<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../bootstrap-combined.min.css" rel="stylesheet" /><script type="text/javascript" src="../../jquery-1.9.1.min.js"></script><script type="text/javascript" src="../../bootstrap.min.js"></script><link href="../../styles.css" rel="stylesheet" /><link rel="icon" href="../../favicon.ico" type="image/x-icon"></link><script type="text/javascript" src="../../nav.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["flash"]};</script><title>BitmapData</title></head><body><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><form class="navbar-search pull-left" id="searchForm"><input id="search" type="text" class="search-query" placeholder="Filter" autocomplete="off"/></form><ul class="nav"><li id="select-platform" class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Platform<b class="caret"></b></a><ul class="dropdown-menu"><li data="all"><a href="#">All Platforms</a></li><li data="flash"><a href="#">flash</a></li></ul></li></ul></div></div><div id="container"><div id="nav"></div><div id="content"><div class="header"><h1><code><span class="directive">class </span><span class="type">flash.display.BitmapData</span><span class="keyword"> implements</span> <a class="type" href="../../flash/display/IBitmapDrawable.html">IBitmapDrawable</a></code></h1></div><div class="body"><p class="availability">Available on all platforms</p><div><table class="related-types toggle" style="margin-top:16px;"><tbody><tr><td colspan="2"><strong>Sub classes</strong></td></tr><tr><td width="12" style="vertical-align:top;"><a href="#" onclick="toggleInherited(this)"><img style="padding-top:4px;" src="../../triangle-closed.png"></img></a></td><td class="toggle-hide"><a href="../../flixel/_FlxSprite/GraphicDefault.html">GraphicDefault</a>, <a href="../../flixel/addons/nape/GraphicNapeDebug.html">GraphicNapeDebug</a>, <a href="../../flixel/input/mouse/_FlxMouse/GraphicCursor.html">GraphicCursor</a>, <a href="../../flixel/system/debug/_FlxDebugger/GraphicDrawDebug.html">GraphicDrawDebug</a>, <a href="../../flixel/system/debug/_FlxDebugger/GraphicFlixel.html">GraphicFlixel</a>, <a href="../../flixel/system/debug/_Stats/GraphicMaximizeButton.html">GraphicMaximizeButton</a>, <a href="../../flixel/system/debug/_Stats/GraphicMinimizeButton.html">GraphicMinimizeButton</a>, <a href="../../flixel/system/debug/_VCR/GraphicOpen.html">GraphicOpen</a>, <a href="../../flixel/system/debug/_VCR/GraphicPause.html">GraphicPause</a>, <a href="../../flixel/system/debug/_VCR/GraphicPlay.html">GraphicPlay</a>, <a href="../../flixel/system/debug/_VCR/GraphicRecordOff.html">GraphicRecordOff</a>, <a href="../../flixel/system/debug/_VCR/GraphicRecordOn.html">GraphicRecordOn</a>, <a href="../../flixel/system/debug/_VCR/GraphicRestart.html">GraphicRestart</a>, <a href="../../flixel/system/debug/_VCR/GraphicStep.html">GraphicStep</a>, <a href="../../flixel/system/debug/_VCR/GraphicStop.html">GraphicStop</a>, <a href="../../flixel/system/debug/_Window/GraphicCloseButton.html">GraphicCloseButton</a>, <a href="../../flixel/system/debug/_Window/GraphicWindowHandle.html">GraphicWindowHandle</a>, <a href="../../flixel/system/debug/GraphicConsole.html">GraphicConsole</a>, <a href="../../flixel/system/debug/GraphicLog.html">GraphicLog</a>, <a href="../../flixel/system/debug/GraphicStats.html">GraphicStats</a>, <a href="../../flixel/system/debug/GraphicWatch.html">GraphicWatch</a>, <a href="../../flixel/system/GraphicLogo.html">GraphicLogo</a>, <a href="../../flixel/tile/GraphicAuto.html">GraphicAuto</a>, <a href="../../flixel/tile/GraphicAutoAlt.html">GraphicAutoAlt</a>, <a href="../../flixel/ui/_FlxAnalog/GraphicBase.html">GraphicBase</a>, <a href="../../flixel/ui/_FlxAnalog/GraphicThumb.html">GraphicThumb</a>, <a href="../../flixel/ui/_FlxTypedButton/GraphicButton.html">GraphicButton</a>, <a href="../../flixel/ui/_FlxVirtualPad/GraphicA.html">GraphicA</a>, <a href="../../flixel/ui/_FlxVirtualPad/GraphicB.html">GraphicB</a>, <a href="../../flixel/ui/_FlxVirtualPad/GraphicC.html">GraphicC</a>, <a href="../../flixel/ui/_FlxVirtualPad/GraphicDown.html">GraphicDown</a>, <a href="../../flixel/ui/_FlxVirtualPad/GraphicLeft.html">GraphicLeft</a>, <a href="../../flixel/ui/_FlxVirtualPad/GraphicRight.html">GraphicRight</a>, <a href="../../flixel/ui/_FlxVirtualPad/GraphicUp.html">GraphicUp</a>, <a href="../../flixel/ui/_FlxVirtualPad/GraphicX.html">GraphicX</a>, <a href="../../flixel/ui/_FlxVirtualPad/GraphicY.html">GraphicY</a></td><td class="toggle-show"><table class="table table-condensed"><tbody><tr><td width="200"><a href="../../flixel/_FlxSprite/GraphicDefault.html">GraphicDefault</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/addons/nape/GraphicNapeDebug.html">GraphicNapeDebug</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/input/mouse/_FlxMouse/GraphicCursor.html">GraphicCursor</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_FlxDebugger/GraphicDrawDebug.html">GraphicDrawDebug</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_FlxDebugger/GraphicFlixel.html">GraphicFlixel</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_Stats/GraphicMaximizeButton.html">GraphicMaximizeButton</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_Stats/GraphicMinimizeButton.html">GraphicMinimizeButton</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_VCR/GraphicOpen.html">GraphicOpen</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_VCR/GraphicPause.html">GraphicPause</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_VCR/GraphicPlay.html">GraphicPlay</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_VCR/GraphicRecordOff.html">GraphicRecordOff</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_VCR/GraphicRecordOn.html">GraphicRecordOn</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_VCR/GraphicRestart.html">GraphicRestart</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_VCR/GraphicStep.html">GraphicStep</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_VCR/GraphicStop.html">GraphicStop</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_Window/GraphicCloseButton.html">GraphicCloseButton</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/_Window/GraphicWindowHandle.html">GraphicWindowHandle</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/GraphicConsole.html">GraphicConsole</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/GraphicLog.html">GraphicLog</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/GraphicStats.html">GraphicStats</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/debug/GraphicWatch.html">GraphicWatch</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/system/GraphicLogo.html">GraphicLogo</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/tile/GraphicAuto.html">GraphicAuto</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/tile/GraphicAutoAlt.html">GraphicAutoAlt</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxAnalog/GraphicBase.html">GraphicBase</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxAnalog/GraphicThumb.html">GraphicThumb</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxTypedButton/GraphicButton.html">GraphicButton</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxVirtualPad/GraphicA.html">GraphicA</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxVirtualPad/GraphicB.html">GraphicB</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxVirtualPad/GraphicC.html">GraphicC</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxVirtualPad/GraphicDown.html">GraphicDown</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxVirtualPad/GraphicLeft.html">GraphicLeft</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxVirtualPad/GraphicRight.html">GraphicRight</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxVirtualPad/GraphicUp.html">GraphicUp</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxVirtualPad/GraphicX.html">GraphicX</a></td><td><p></p></td></tr><tr><td width="200"><a href="../../flixel/ui/_FlxVirtualPad/GraphicY.html">GraphicY</a></td><td><p></p></td></tr></tbody></table></td></tr></tbody></table></div><div class="doc"><p>The BitmapData class lets you work with the data(pixels) of a Bitmap
 * object. You can use the methods of the BitmapData class to create
 * arbitrarily sized transparent or opaque bitmap images and manipulate them
 * in various ways at runtime. You can also access the BitmapData for a bitmap
 * image that you load with the <code>flash.Assets</code> or 
 * <code>flash.display.Loader</code> classes.
 <em>
 * <p>This class lets you separate bitmap rendering operations from the
 * internal display updating routines of flash. By manipulating a
 * BitmapData object directly, you can create complex images without incurring
 * the per-frame overhead of constantly redrawing the content from vector
 * data.</p>
 </em>
 * <p>The methods of the BitmapData class support effects that are not
 * available through the filters available to non-bitmap display objects.</p>
 <em>
 * <p>A BitmapData object contains an array of pixel data. This data can
 * represent either a fully opaque bitmap or a transparent bitmap that
 * contains alpha channel data. Either type of BitmapData object is stored as
 * a buffer of 32-bit integers. Each 32-bit integer determines the properties
 * of a single pixel in the bitmap.</p>
 </em>
 * <p>Each 32-bit integer is a combination of four 8-bit channel values(from
 * 0 to 255) that describe the alpha transparency and the red, green, and blue
 * (ARGB) values of the pixel.(For ARGB values, the most significant byte
 * represents the alpha channel value, followed by red, green, and blue.)</p>
 <em>
 * <p>The four channels(alpha, red, green, and blue) are represented as
 * numbers when you use them with the <code>BitmapData.copyChannel()</code>
 * method or the <code>DisplacementMapFilter.componentX</code> and
 * <code>DisplacementMapFilter.componentY</code> properties, and these numbers
 * are represented by the following constants in the BitmapDataChannel
 * class:</p>
 </em>
 * <ul>
 *   <li><code>BitmapDataChannel.ALPHA</code></li>
 *   <li><code>BitmapDataChannel.RED</code></li>
 *   <li><code>BitmapDataChannel.GREEN</code></li>
 *   <li><code>BitmapDataChannel.BLUE</code></li>
 * </ul>
 <em>
 * <p>You can attach BitmapData objects to a Bitmap object by using the
 * <code>bitmapData</code> property of the Bitmap object.</p>
 </em>
 * <p>You can use a BitmapData object to fill a Graphics object by using the
 * <code>Graphics.beginBitmapFill()</code> method.</p>
 * 
 * <p>You can also use a BitmapData object to perform batch tile rendering
 * using the <code>flash.display.Tilesheet</code> class.</p>
 *
 * <p>In Flash Player 10, the maximum size for a BitmapData object
 * is 8,191 pixels in width or height, and the total number of pixels cannot
 * exceed 16,777,215 pixels.(So, if a BitmapData object is 8,191 pixels wide,
 * it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation 
 * is 2,880 pixels in height and 2,880 in width.</p></p></div><h2>Instance Fields</h2><div class="platform platform-flash"><a name="height"></a><h3><p><code><span class="keyword">var</span> <a href="#height"><span class="identifier">height</span></a>:<a class="type" href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>The height of the bitmap image in pixels.</p></div></div><div class="platform platform-flash"><a name="rect"></a><h3><p><code><span class="keyword">var</span> <a href="#rect"><span class="identifier">rect</span></a>:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a></code></p></h3><div class="doc"><p>The rectangle that defines the size and location of the bitmap image. The
 * top and left of the rectangle are 0; the width and height are equal to the
 * width and height in pixels of the BitmapData object.</p></div></div><div class="platform platform-flash"><a name="transparent"></a><h3><p><code><span class="keyword">var</span> <a href="#transparent"><span class="identifier">transparent</span></a>:<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Defines whether the bitmap image supports per-pixel transparency. You can
 * set this value only when you construct a BitmapData object by passing in
 * <code>true</code> for the <code>transparent</code> parameter of the
 * constructor. Then, after you create a BitmapData object, you can check
 * whether it supports per-pixel transparency by determining if the value of
 * the <code>transparent</code> property is <code>true</code>.</p></div></div><div class="platform platform-flash"><a name="width"></a><h3><p><code><span class="keyword">var</span> <a href="#width"><span class="identifier">width</span></a>:<a class="type" href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>The width of the bitmap image in pixels.</p></div></div><div class="platform platform-flash"><a name="new"></a><h3><p><code><span class="keyword">function</span> <a href="#new"><span class="identifier">new</span></a>(width:<a class="type" href="../../Int.html">Int</a>, height:<a class="type" href="../../Int.html">Int</a>, ?transparent:<a class="type" href="../../Bool.html">Bool</a>, ?fillColor:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Creates a BitmapData object with a specified width and height. If you specify a value for 
 * the <code>fillColor</code> parameter, every pixel in the bitmap is set to that color. 
 * 
 * By default, the bitmap is created as transparent, unless you pass the value <code>false</code>
 * for the transparent parameter. After you create an opaque bitmap, you cannot change it 
 * to a transparent bitmap. Every pixel in an opaque bitmap uses only 24 bits of color channel 
 * information. If you define the bitmap as transparent, every pixel uses 32 bits of color 
 * channel information, including an alpha transparency channel.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>width</td><td><p>The width of the bitmap image in pixels. 
 * </p></td></tr><tr><td>height</td><td><p>The height of the bitmap image in pixels. 
 * </p></td></tr><tr><td>transparent</td><td><p>Specifies whether the bitmap image supports per-pixel transparency. The default value is <code>true</code>(transparent). To create a fully transparent bitmap, set the value of the <code>transparent</code> parameter to <code>true</code> and the value of the <code>fillColor</code> parameter to 0x00000000(or to 0). Setting the <code>transparent</code> property to <code>false</code> can result in minor improvements in rendering performance.
 * </p></td></tr><tr><td>fillColor</td><td><p>A 32-bit ARGB color value that you use to fill the bitmap image area. The default value is 0xFFFFFFFF(solid white).</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="applyFilter"></a><h3><p><code><span class="keyword">function</span> <a href="#applyFilter"><span class="identifier">applyFilter</span></a>(sourceBitmapData:<a class="type" href="../../flash/display/BitmapData.html">BitmapData</a>, sourceRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, destPoint:<a class="type" href="../../flash/geom/Point.html">Point</a>, filter:<a class="type" href="../../flash/filters/BitmapFilter.html">BitmapFilter</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Takes a source image and a filter object and generates the filtered image. 
 * 
 * This method relies on the behavior of built-in filter objects, which determine the 
 * destination rectangle that is affected by an input source rectangle.
 * 
 * After a filter is applied, the resulting image can be larger than the input image. 
 * For example, if you use a BlurFilter class to blur a source rectangle of(50,50,100,100) 
 * and a destination point of(10,10), the area that changes in the destination image is 
 * larger than(10,10,60,60) because of the blurring. This happens internally during the 
 * applyFilter() call.
 * 
 * If the <code>sourceRect</code> parameter of the sourceBitmapData parameter is an 
 * interior region, such as(50,50,100,100) in a 200 x 200 image, the filter uses the source 
 * pixels outside the <code>sourceRect</code> parameter to generate the destination rectangle.
 * 
 * If the BitmapData object and the object specified as the <code>sourceBitmapData</code> 
 * parameter are the same object, the application uses a temporary copy of the object to 
 * perform the filter. For best performance, avoid this situation.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>sourceBitmapData</td><td><p>The input bitmap image to use. The source image can be a different BitmapData object or it can refer to the current BitmapData instance.
 * </p></td></tr><tr><td>sourceRect</td><td><p>A rectangle that defines the area of the source image to use as input.
 * </p></td></tr><tr><td>destPoint</td><td><p>The point within the destination image(the current BitmapData instance) that corresponds to the upper-left corner of the source rectangle. 
 * </p></td></tr><tr><td>filter</td><td><p>The filter object that you use to perform the filtering operation.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="clone"></a><h3><p><code><span class="keyword">function</span> <a href="#clone"><span class="identifier">clone</span></a>():<a class="type" href="../../flash/display/BitmapData.html">BitmapData</a></code></p></h3><div class="doc"><p>Returns a new BitmapData object that is a clone of the original instance with an exact copy of the contained bitmap. 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A new BitmapData object that is identical to the original.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="colorTransform"></a><h3><p><code><span class="keyword">function</span> <a href="#colorTransform"><span class="identifier">colorTransform</span></a>(rect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, colorTransform:<a class="type" href="../../flash/geom/ColorTransform.html">ColorTransform</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Adjusts the color values in a specified area of a bitmap image by using a <code>ColorTransform</code>
 * object. If the rectangle matches the boundaries of the bitmap image, this method transforms the color 
 * values of the entire image. 
 * </p><table class="table table-condensed"><tbody><tr><td>rect</td><td><p>A Rectangle object that defines the area of the image in which the ColorTransform object is applied.
 * </p></td></tr><tr><td>colorTransform</td><td><p>A ColorTransform object that describes the color transformation values to apply.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="compare"></a><h3><p><code><span class="keyword">function</span> <a href="#compare"><span class="identifier">compare</span></a>(otherBitmapData:<a class="type" href="../../flash/display/BitmapData.html">BitmapData</a>):<a class="type" href="../../flash/utils/Object.html">Object</a></code></p></h3><div class="doc"><p>Compares two BitmapData objects. If the two BitmapData objects have the
 * same dimensions(width and height), the method returns a new BitmapData
 * object, in which each pixel is the "difference" between the pixels in the
 * two source objects:
 * <ul>
 *   <li>If two pixels are equal, the difference pixel is 0x00000000. </li>
 *   <li>If two pixels have different RGB values(ignoring the alpha value),
 * the difference pixel is 0xRRGGBB where RR/GG/BB are the individual
 * difference values between red, green, and blue channels(the pixel value
 * in the source object minus the pixel value in the
 * <code>otherBitmapData</code> object). Alpha channel differences are
 * ignored in this case. </li>
 *   <li>If only the alpha channel value is different, the pixel value is
 * 0x<i>ZZ</i>FFFFFF, where <i>ZZ</i> is the difference in the alpha values
 * (the alpha value in the source object minus the alpha value in the
 * <code>otherBitmapData</code> object).</li>
 * </ul>
 *
 * <p>For example, consider the following two BitmapData objects:</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>otherBitmapData</td><td><p>The BitmapData object to compare with the source
<em>                        BitmapData object.
</em> </p></td></tr><tr><td>returns</td><td><p>If the two BitmapData objects have the same dimensions(width and
<em>         height), the method returns a new BitmapData object that has the
</em>         difference between the two objects(see the main discussion). If
<em>         the BitmapData objects are equivalent, the method returns the
</em>         number 0. If the widths of the BitmapData objects are not equal,
<em>         the method returns the number -3. If the heights of the BitmapData
</em>         objects are not equal, the method returns the number -4.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="copyChannel"></a><h3><p><code><span class="keyword">function</span> <a href="#copyChannel"><span class="identifier">copyChannel</span></a>(sourceBitmapData:<a class="type" href="../../flash/display/BitmapData.html">BitmapData</a>, sourceRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, destPoint:<a class="type" href="../../flash/geom/Point.html">Point</a>, sourceChannel:<a class="type" href="../../UInt.html">UInt</a>, destChannel:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Transfers data from one channel of another BitmapData object or the
 * current BitmapData object into a channel of the current BitmapData object.
 * All of the data in the other channels in the destination BitmapData object
 * are preserved.
 <em>
 * <p>The source channel value and destination channel value can be one of
 * following values: </p>
 </em>
 * <ul>
 *   <li><code>BitmapDataChannel.RED</code></li>
 *   <li><code>BitmapDataChannel.GREEN</code></li>
 *   <li><code>BitmapDataChannel.BLUE</code></li>
 *   <li><code>BitmapDataChannel.ALPHA</code></li>
 * </ul>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>sourceBitmapData</td><td><p>The input bitmap image to use. The source image
<em>                         can be a different BitmapData object or it can
</em>                         refer to the current BitmapData object.
* </p></td></tr><tr><td>sourceRect</td><td><p>The source Rectangle object. To copy only channel
 *                         data from a smaller area within the bitmap,
 *                         specify a source rectangle that is smaller than
 *                         the overall size of the BitmapData object.
 * </p></td></tr><tr><td>destPoint</td><td><p>The destination Point object that represents the
 *                         upper-left corner of the rectangular area where
 *                         the new channel data is placed. To copy only
 *                         channel data from one area to a different area in
 *                         the destination image, specify a point other than
 *                        (0,0).
 * </p></td></tr><tr><td>sourceChannel</td><td><p>The source channel. Use a value from the
 *                         BitmapDataChannel class
 *                        (<code>BitmapDataChannel.RED</code>,
 *                         <code>BitmapDataChannel.BLUE</code>,
 *                         <code>BitmapDataChannel.GREEN</code>,
 *                         <code>BitmapDataChannel.ALPHA</code>).
 * </p></td></tr><tr><td>destChannel</td><td><p>The destination channel. Use a value from the
 *                         BitmapDataChannel class
 *                        (<code>BitmapDataChannel.RED</code>,
 *                         <code>BitmapDataChannel.BLUE</code>,
 *                         <code>BitmapDataChannel.GREEN</code>,
 *                         <code>BitmapDataChannel.ALPHA</code>).
 * </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="copyPixels"></a><h3><p><code><span class="keyword">function</span> <a href="#copyPixels"><span class="identifier">copyPixels</span></a>(sourceBitmapData:<a class="type" href="../../flash/display/BitmapData.html">BitmapData</a>, sourceRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, destPoint:<a class="type" href="../../flash/geom/Point.html">Point</a>, ?alphaBitmapData:<a class="type" href="../../flash/display/BitmapData.html">BitmapData</a>, ?alphaPoint:<a class="type" href="../../flash/geom/Point.html">Point</a>, ?mergeAlpha:<a class="type" href="../../Bool.html">Bool</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Provides a fast routine to perform pixel manipulation between images with
 * no stretching, rotation, or color effects. This method copies a
 * rectangular area of a source image to a rectangular area of the same size
 * at the destination point of the destination BitmapData object.
 <em>
 * <p>If you include the <code>alphaBitmap</code> and <code>alphaPoint</code>
 * parameters, you can use a secondary image as an alpha source for the
 * source image. If the source image has alpha data, both sets of alpha data
 * are used to composite pixels from the source image to the destination
 * image. The <code>alphaPoint</code> parameter is the point in the alpha
 * image that corresponds to the upper-left corner of the source rectangle.
 * Any pixels outside the intersection of the source image and alpha image
 * are not copied to the destination image.</p>
 </em>
 * <p>The <code>mergeAlpha</code> property controls whether or not the alpha
 * channel is used when a transparent image is copied onto another
 * transparent image. To copy pixels with the alpha channel data, set the
 * <code>mergeAlpha</code> property to <code>true</code>. By default, the
 * <code>mergeAlpha</code> property is <code>false</code>.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>sourceBitmapData</td><td><p>The input bitmap image from which to copy pixels.
<em>                         The source image can be a different BitmapData
</em>                         instance, or it can refer to the current
<em>                         BitmapData instance.
</em> </p></td></tr><tr><td>sourceRect</td><td><p>A rectangle that defines the area of the source
 *                         image to use as input.
 * </p></td></tr><tr><td>destPoint</td><td><p>The destination point that represents the
 *                         upper-left corner of the rectangular area where
 *                         the new pixels are placed.
 * </p></td></tr><tr><td>alphaBitmapData</td><td><p>A secondary, alpha BitmapData object source.
 * </p></td></tr><tr><td>alphaPoint</td><td><p>The point in the alpha BitmapData object source
 *                         that corresponds to the upper-left corner of the
 *                         <code>sourceRect</code> parameter.
 * </p></td></tr><tr><td>mergeAlpha</td><td><p>To use the alpha channel, set the value to
 *                         <code>true</code>. To copy pixels with no alpha
 *                         channel, set the value to <code>false</code>.
 * </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="copyPixelsToByteArray"></a><h3><p><code><span class="keyword">function</span> <a href="#copyPixelsToByteArray"><span class="identifier">copyPixelsToByteArray</span></a>(rect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, data:<a class="type" href="../../flash/utils/ByteArray.html">ByteArray</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p></p></div></div><div class="platform platform-flash"><a name="dispose"></a><h3><p><code><span class="keyword">function</span> <a href="#dispose"><span class="identifier">dispose</span></a>():<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Frees memory that is used to store the BitmapData object.
 <em>
 * <p>When the <code>dispose()</code> method is called on an image, the width
 * and height of the image are set to 0. All subsequent calls to methods or
 * properties of this BitmapData instance fail, and an exception is thrown.
 * </p>
 </em>
 * <p><code>BitmapData.dispose()</code> releases the memory occupied by the
 * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
 * memory). After using <code>BitmapData.dispose()</code>, the BitmapData
 * object is no longer usable and an exception may be thrown if
 * you call functions on the BitmapData object. However,
 * <code>BitmapData.dispose()</code> does not garbage collect the BitmapData
 * object(approximately 128 bytes); the memory occupied by the actual
 * BitmapData object is released at the time the BitmapData object is
 * collected by the garbage collector.</p></p></div></div><div class="platform platform-flash"><a name="draw"></a><h3><p><code><span class="keyword">function</span> <a href="#draw"><span class="identifier">draw</span></a>(source:<a class="type" href="../../flash/display/IBitmapDrawable.html">IBitmapDrawable</a>, ?matrix:<a class="type" href="../../flash/geom/Matrix.html">Matrix</a>, ?colorTransform:<a class="type" href="../../flash/geom/ColorTransform.html">ColorTransform</a>, ?blendMode:<a class="type" href="../../flash/display/BlendMode.html">BlendMode</a>, ?clipRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, ?smoothing:<a class="type" href="../../Bool.html">Bool</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Draws the <code>source</code> display object onto the bitmap image, using
 * the NME software renderer. You can specify <code>matrix</code>,
 * <code>colorTransform</code>, <code>blendMode</code>, and a destination
 * <code>clipRect</code> parameter to control how the rendering performs.
 * Optionally, you can specify whether the bitmap should be smoothed when
 * scaled(this works only if the source object is a BitmapData object).
 *
 * <p>The source display object does not use any of its applied
 * transformations for this call. It is treated as it exists in the library
 * or file, with no matrix transform, no color transform, and no blend mode.
 * To draw a display object(such as a movie clip) by using its own transform
 * properties, you can copy its <code>transform</code> property object to the
 * <code>transform</code> property of the Bitmap object that uses the
 * BitmapData object.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>source</td><td><p>The display object or BitmapData object to draw to
 *                       the BitmapData object.(The DisplayObject and
 *                       BitmapData classes implement the IBitmapDrawable
 *                       interface.)
 * </p></td></tr><tr><td>matrix</td><td><p>A Matrix object used to scale, rotate, or translate
 *                       the coordinates of the bitmap. If you do not want to
 *                       apply a matrix transformation to the image, set this
 *                       parameter to an identity matrix, created with the
 *                       default <code>new Matrix()</code> constructor, or
 *                       pass a <code>null</code> value.
 * </p></td></tr><tr><td>colorTransform</td><td><p>A ColorTransform object that you use to adjust the
<em>                       color values of the bitmap. If no object is
</em>                       supplied, the bitmap image's colors are not
<em>                       transformed. If you must pass this parameter but you
</em>                       do not want to transform the image, set this
<em>                       parameter to a ColorTransform object created with
</em>                       the default <code>new ColorTransform()</code>
<em>                       constructor.
</em> </p></td></tr><tr><td>blendMode</td><td><p>A string value, from the flash.display.BlendMode
 *                       class, specifying the blend mode to be applied to
 *                       the resulting bitmap.
 * </p></td></tr><tr><td>clipRect</td><td><p>A Rectangle object that defines the area of the
 *                       source object to draw. If you do not supply this
 *                       value, no clipping occurs and the entire source
 *                       object is drawn.
 * </p></td></tr><tr><td>smoothing</td><td><p>A Boolean value that determines whether a BitmapData
 *                       object is smoothed when scaled or rotated, due to a
 *                       scaling or rotation in the <code>matrix</code>
 *                       parameter. The <code>smoothing</code> parameter only
 *                       applies if the <code>source</code> parameter is a
 *                       BitmapData object. With <code>smoothing</code> set
 *                       to <code>false</code>, the rotated or scaled
 *                       BitmapData image can appear pixelated or jagged. For
 *                       example, the following two images use the same
 *                       BitmapData object for the <code>source</code>
 *                       parameter, but the <code>smoothing</code> parameter
 *                       is set to <code>true</code> on the left and
 *                       <code>false</code> on the right:
 *
 *                       <p>Drawing a bitmap with <code>smoothing</code> set
 *                       to <code>true</code> takes longer than doing so with
 *                       <code>smoothing</code> set to
 *                       <code>false</code>.</p>
 * </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="encode"></a><h3><p><code><span class="keyword">function</span> <a href="#encode"><span class="identifier">encode</span></a>(rect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, compressor:<a class="type" href="../../flash/utils/Object.html">Object</a>, ?byteArray:<a class="type" href="../../flash/utils/ByteArray.html">ByteArray</a>):<a class="type" href="../../flash/utils/ByteArray.html">ByteArray</a></code></p></h3><div class="doc"><p>Encodes the current image as a JPG or PNG format ByteArray.
 * 
 * This method is not available to the HTML5 and Flash targets.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>format</td><td><p>The encoding format, either "png" or "jpg".
 * </p></td></tr><tr><td>quality</td><td><p>The encoding quality, when encoding with the JPG format.
* </p></td></tr><tr><td>returns</td><td><p>A ByteArray in the specified encoding format</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="fillRect"></a><h3><p><code><span class="keyword">function</span> <a href="#fillRect"><span class="identifier">fillRect</span></a>(rect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, color:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Fills a rectangular area of pixels with a specified ARGB color.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>rect</td><td><p>The rectangular area to fill.
 * </p></td></tr><tr><td>color</td><td><p>The ARGB color value that fills the area. ARGB colors are
<em>              often specified in hexadecimal format; for example,
</em>              0xFF336699.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="floodFill"></a><h3><p><code><span class="keyword">function</span> <a href="#floodFill"><span class="identifier">floodFill</span></a>(x:<a class="type" href="../../Int.html">Int</a>, y:<a class="type" href="../../Int.html">Int</a>, color:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Performs a flood fill operation on an image starting at an(<i>x</i>,
 * <i>y</i>) coordinate and filling with a certain color. The
 * <code>floodFill()</code> method is similar to the paint bucket tool in
 * various paint programs. The color is an ARGB color that contains alpha
 * information and color information.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>x</td><td><p>The <i>x</i> coordinate of the image.
 * </p></td></tr><tr><td>y</td><td><p>The <i>y</i> coordinate of the image.
 * </p></td></tr><tr><td>color</td><td><p>The ARGB color to use as a fill.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="generateFilterRect"></a><h3><p><code><span class="keyword">function</span> <a href="#generateFilterRect"><span class="identifier">generateFilterRect</span></a>(sourceRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, filter:<a class="type" href="../../flash/filters/BitmapFilter.html">BitmapFilter</a>):<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a></code></p></h3><div class="doc"><p>Determines the destination rectangle that the <code>applyFilter()</code>
 * method call affects, given a BitmapData object, a source rectangle, and a
 * filter object.
 <em>
 * <p>For example, a blur filter normally affects an area larger than the
 * size of the original image. A 100 x 200 pixel image that is being filtered
 * by a default BlurFilter instance, where <code>blurX = blurY = 4</code>
 * generates a destination rectangle of <code>(-2,-2,104,204)</code>. The
 * <code>generateFilterRect()</code> method lets you find out the size of
 * this destination rectangle in advance so that you can size the destination
 * image appropriately before you perform a filter operation.</p>
 </em>
 * <p>Some filters clip their destination rectangle based on the source image
 * size. For example, an inner <code>DropShadow</code> does not generate a
 * larger result than its source image. In this API, the BitmapData object is
 * used as the source bounds and not the source <code>rect</code>
 * parameter.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>sourceRect</td><td><p>A rectangle defining the area of the source image to use
<em>                   as input.
</em> </p></td></tr><tr><td>filter</td><td><p>A filter object that you use to calculate the
 *                   destination rectangle.
 * </p></td></tr><tr><td>returns</td><td><p>A destination rectangle computed by using an image, the
<em>         <code>sourceRect</code> parameter, and a filter.
</em> </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="getColorBoundsRect"></a><h3><p><code><span class="keyword">function</span> <a href="#getColorBoundsRect"><span class="identifier">getColorBoundsRect</span></a>(mask:<a class="type" href="../../UInt.html">UInt</a>, color:<a class="type" href="../../UInt.html">UInt</a>, ?findColor:<a class="type" href="../../Bool.html">Bool</a>):<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a></code></p></h3><div class="doc"><p>Determines a rectangular region that either fully encloses all pixels of a
 * specified color within the bitmap image(if the <code>findColor</code>
 * parameter is set to <code>true</code>) or fully encloses all pixels that
 * do not include the specified color(if the <code>findColor</code>
 * parameter is set to <code>false</code>).
 *
 * <p>For example, if you have a source image and you want to determine the
 * rectangle of the image that contains a nonzero alpha channel, pass
 * <code>{mask: 0xFF000000, color: 0x00000000}</code> as parameters. If the
 * <code>findColor</code> parameter is set to <code>true</code>, the entire
 * image is searched for the bounds of pixels for which <code>(value &amp; mask)
 * == color</code>(where <code>value</code> is the color value of the
 * pixel). If the <code>findColor</code> parameter is set to
 * <code>false</code>, the entire image is searched for the bounds of pixels
 * for which <code>(value &amp; mask) != color</code>(where <code>value</code>
 * is the color value of the pixel). To determine white space around an
 * image, pass <code>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</code> to find the
 * bounds of nonwhite pixels.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>mask</td><td><p>A hexadecimal value, specifying the bits of the ARGB
 *                  color to consider. The color value is combined with this
 *                  hexadecimal value, by using the <code>&amp;</code>(bitwise
 *                  AND) operator.
 * </p></td></tr><tr><td>color</td><td><p>A hexadecimal value, specifying the ARGB color to match
 *                 (if <code>findColor</code> is set to <code>true</code>)
 *                  or <i>not</i> to match(if <code>findColor</code> is set
 *                  to <code>false</code>).
 * </p></td></tr><tr><td>findColor</td><td><p>If the value is set to <code>true</code>, returns the
<em>                  bounds of a color value in an image. If the value is set
</em>                  to <code>false</code>, returns the bounds of where this
<em>                  color doesn't exist in an image.
</em> </p></td></tr><tr><td>returns</td><td><p>The region of the image that is the specified color.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="getPixel"></a><h3><p><code><span class="keyword">function</span> <a href="#getPixel"><span class="identifier">getPixel</span></a>(x:<a class="type" href="../../Int.html">Int</a>, y:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>Returns an integer that represents an RGB pixel value from a BitmapData
 * object at a specific point(<i>x</i>, <i>y</i>). The
 * <code>getPixel()</code> method returns an unmultiplied pixel value. No
 * alpha information is returned.
 *
 * <p>All pixels in a BitmapData object are stored as premultiplied color
 * values. A premultiplied image pixel has the red, green, and blue color
 * channel values already multiplied by the alpha data. For example, if the
 * alpha value is 0, the values for the RGB channels are also 0, independent
 * of their unmultiplied values. This loss of data can cause some problems
 * when you perform operations. All BitmapData methods take and return
 * unmultiplied values. The internal pixel representation is converted from
 * premultiplied to unmultiplied before it is returned as a value. During a
 * set operation, the pixel value is premultiplied before the raw image pixel
 * is set.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>x</td><td><p>The <i>x</i> position of the pixel.
* </p></td></tr><tr><td>y</td><td><p>The <i>y</i> position of the pixel.
* </p></td></tr><tr><td>returns</td><td><p>A number that represents an RGB pixel value. If the(<i>x</i>,
<em>         <i>y</i>) coordinates are outside the bounds of the image, the
</em>         method returns 0.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="getPixel32"></a><h3><p><code><span class="keyword">function</span> <a href="#getPixel32"><span class="identifier">getPixel32</span></a>(x:<a class="type" href="../../Int.html">Int</a>, y:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>Returns an ARGB color value that contains alpha channel data and RGB data.
 * This method is similar to the <code>getPixel()</code> method, which
 * returns an RGB color without alpha channel data.
 *
 * <p>All pixels in a BitmapData object are stored as premultiplied color
 * values. A premultiplied image pixel has the red, green, and blue color
 * channel values already multiplied by the alpha data. For example, if the
 * alpha value is 0, the values for the RGB channels are also 0, independent
 * of their unmultiplied values. This loss of data can cause some problems
 * when you perform operations. All BitmapData methods take and return
 * unmultiplied values. The internal pixel representation is converted from
 * premultiplied to unmultiplied before it is returned as a value. During a
 * set operation, the pixel value is premultiplied before the raw image pixel
 * is set.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>x</td><td><p>The <i>x</i> position of the pixel.
* </p></td></tr><tr><td>y</td><td><p>The <i>y</i> position of the pixel.
* </p></td></tr><tr><td>returns</td><td><p>A number representing an ARGB pixel value. If the(<i>x</i>,
<em>         <i>y</i>) coordinates are outside the bounds of the image, 0 is
</em>         returned.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="getPixels"></a><h3><p><code><span class="keyword">function</span> <a href="#getPixels"><span class="identifier">getPixels</span></a>(rect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>):<a class="type" href="../../flash/utils/ByteArray.html">ByteArray</a></code></p></h3><div class="doc"><p>Generates a byte array from a rectangular region of pixel data. Writes an
 * unsigned integer(a 32-bit unmultiplied pixel value) for each pixel into
 * the byte array.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>rect</td><td><p>A rectangular area in the current BitmapData object.
* </p></td></tr><tr><td>returns</td><td><p>A ByteArray representing the pixels in the given Rectangle.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="getVector"></a><h3><p><code><span class="keyword">function</span> <a href="#getVector"><span class="identifier">getVector</span></a>(rect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>):<a class="type" href="../../flash/Vector.html">Vector</a>&lt;<a class="type" href="../../UInt.html">UInt</a>&gt;</code></p></h3><div class="doc"><p>Generates a vector array from a rectangular region of pixel data. Returns
 * a Vector object of unsigned integers(a 32-bit unmultiplied pixel value)
 * for the specified rectangle.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>rect</td><td><p>A rectangular area in the current BitmapData object.
* </p></td></tr><tr><td>returns</td><td><p>A Vector representing the given Rectangle.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="histogram"></a><h3><p><code><span class="keyword">function</span> <a href="#histogram"><span class="identifier">histogram</span></a>(?hRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>):<a class="type" href="../../flash/Vector.html">Vector</a>&lt;<a class="type" href="../../flash/Vector.html">Vector</a>&lt;<a class="type" href="../../Float.html">Float</a>&gt;&gt;</code></p></h3><div class="doc"><p>Computes a 256-value binary number histogram of a BitmapData object. This
 * method returns a Vector object containing four Vector.<Number> instances
 * (four Vector objects that contain Number objects). The four Vector
 * instances represent the red, green, blue and alpha components in order.
 * Each Vector instance contains 256 values that represent the population
 * count of an individual component value, from 0 to 255.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>hRect</td><td><p>The area of the BitmapData object to use.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="hitTest"></a><h3><p><code><span class="keyword">function</span> <a href="#hitTest"><span class="identifier">hitTest</span></a>(firstPoint:<a class="type" href="../../flash/geom/Point.html">Point</a>, firstAlphaThreshold:<a class="type" href="../../UInt.html">UInt</a>, secondObject:<a class="type" href="../../flash/utils/Object.html">Object</a>, ?secondBitmapDataPoint:<a class="type" href="../../flash/geom/Point.html">Point</a>, ?secondAlphaThreshold:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Performs pixel-level hit detection between one bitmap image and a point,
 * rectangle, or other bitmap image. A hit is defined as an overlap of a
 * point or rectangle over an opaque pixel, or two overlapping opaque pixels.
 * No stretching, rotation, or other transformation of either object is
 * considered when the hit test is performed.
 *
 * <p>If an image is an opaque image, it is considered a fully opaque
 * rectangle for this method. Both images must be transparent images to
 * perform pixel-level hit testing that considers transparency. When you are
 * testing two transparent images, the alpha threshold parameters control
 * what alpha channel values, from 0 to 255, are considered opaque.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>firstPoint</td><td><p>A position of the upper-left corner of the
 *                              BitmapData image in an arbitrary coordinate
 *                              space. The same coordinate space is used in
 *                              defining the <code>secondBitmapPoint</code>
 *                              parameter.
 * </p></td></tr><tr><td>firstAlphaThreshold</td><td><p>The smallest alpha channel value that is
 *                              considered opaque for this hit test.
 * </p></td></tr><tr><td>secondObject</td><td><p>A Rectangle, Point, Bitmap, or BitmapData
 *                              object.
 * </p></td></tr><tr><td>secondBitmapDataPoint</td><td><p>A point that defines a pixel location in the
<em>                              second BitmapData object. Use this parameter
</em>                              only when the value of
<em>                              <code>secondObject</code> is a BitmapData
</em>                              object.
* </p></td></tr><tr><td>secondAlphaThreshold</td><td><p>The smallest alpha channel value that is
 *                              considered opaque in the second BitmapData
 *                              object. Use this parameter only when the
 *                              value of <code>secondObject</code> is a
 *                              BitmapData object and both BitmapData objects
 *                              are transparent.
 * </p></td></tr><tr><td>returns</td><td><p>A value of <code>true</code> if a hit occurs; otherwise,
<em>         <code>false</code>.
</em> </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="lock"></a><h3><p><code><span class="keyword">function</span> <a href="#lock"><span class="identifier">lock</span></a>():<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Locks an image so that any objects that reference the BitmapData object,
 * such as Bitmap objects, are not updated when this BitmapData object
 * changes. To improve performance, use this method along with the
 * <code>unlock()</code> method before and after numerous calls to the
 * <code>setPixel()</code> or <code>setPixel32()</code> method.</p></div></div><div class="platform platform-flash"><a name="merge"></a><h3><p><code><span class="keyword">function</span> <a href="#merge"><span class="identifier">merge</span></a>(sourceBitmapData:<a class="type" href="../../flash/display/BitmapData.html">BitmapData</a>, sourceRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, destPoint:<a class="type" href="../../flash/geom/Point.html">Point</a>, redMultiplier:<a class="type" href="../../UInt.html">UInt</a>, greenMultiplier:<a class="type" href="../../UInt.html">UInt</a>, blueMultiplier:<a class="type" href="../../UInt.html">UInt</a>, alphaMultiplier:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Performs per-channel blending from a source image to a destination image.
 * For each channel and each pixel, a new value is computed based on the
 * channel values of the source and destination pixels. For example, in the
 * red channel, the new value is computed as follows(where
 * <code>redSrc</code> is the red channel value for a pixel in the source
 * image and <code>redDest</code> is the red channel value at the
 * corresponding pixel of the destination image):
 <em>
 * <p> <code> new redDest = [(redSrc * redMultiplier) + (redDest * (256 -
 * redMultiplier))] / 256; </code> </p>
 </em>
 * <p>The <code>redMultiplier</code>, <code>greenMultiplier</code>,
 * <code>blueMultiplier</code>, and <code>alphaMultiplier</code> values are
 * the multipliers used for each color channel. Use a hexadecimal value
 * ranging from <code>0</code> to <code>0x100</code>(256) where
 * <code>0</code> specifies the full value from the destination is used in
 * the result, <code>0x100</code> specifies the full value from the source is
 * used, and numbers in between specify a blend is used(such as
 * <code>0x80</code> for 50%).</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>sourceBitmapData</td><td><p>The input bitmap image to use. The source image
<em>                         can be a different BitmapData object, or it can
</em>                         refer to the current BitmapData object.
* </p></td></tr><tr><td>sourceRect</td><td><p>A rectangle that defines the area of the source
 *                         image to use as input.
 * </p></td></tr><tr><td>destPoint</td><td><p>The point within the destination image(the
 *                         current BitmapData instance) that corresponds to
 *                         the upper-left corner of the source rectangle.
 * </p></td></tr><tr><td>redMultiplier</td><td><p>A hexadecimal uint value by which to multiply the
 *                         red channel value.
 * </p></td></tr><tr><td>greenMultiplier</td><td><p>A hexadecimal uint value by which to multiply the
 *                         green channel value.
 * </p></td></tr><tr><td>blueMultiplier</td><td><p>A hexadecimal uint value by which to multiply the
 *                         blue channel value.
 * </p></td></tr><tr><td>alphaMultiplier</td><td><p>A hexadecimal uint value by which to multiply the
 *                         alpha transparency value.
 * </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="noise"></a><h3><p><code><span class="keyword">function</span> <a href="#noise"><span class="identifier">noise</span></a>(randomSeed:<a class="type" href="../../Int.html">Int</a>, ?low:<a class="type" href="../../UInt.html">UInt</a>, ?high:<a class="type" href="../../UInt.html">UInt</a>, ?channelOptions:<a class="type" href="../../UInt.html">UInt</a>, ?grayScale:<a class="type" href="../../Bool.html">Bool</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Fills an image with pixels representing random noise.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>randomSeed</td><td><p>The random seed number to use. If you keep all other
 *                       parameters the same, you can generate different
 *                       pseudo-random results by varying the random seed
 *                       value. The noise function is a mapping function, not
 *                       a true random-number generation function, so it
 *                       creates the same results each time from the same
 *                       random seed.
 * </p></td></tr><tr><td>low</td><td><p>The lowest value to generate for each channel(0 to
 *                       255).
 * </p></td></tr><tr><td>high</td><td><p>The highest value to generate for each channel(0 to
 *                       255).
 * </p></td></tr><tr><td>channelOptions</td><td><p>A number that can be a combination of any of the
<em>                       four color channel values
</em>                      (<code>BitmapDataChannel.RED</code>,
<em>                       <code>BitmapDataChannel.BLUE</code>,
</em>                       <code>BitmapDataChannel.GREEN</code>, and
<em>                       <code>BitmapDataChannel.ALPHA</code>). You can use
</em>                       the logical OR operator(<code>|</code>) to combine
<em>                       channel values.
</em> </p></td></tr><tr><td>grayScale</td><td><p>A Boolean value. If the value is <code>true</code>,
 *                       a grayscale image is created by setting all of the
 *                       color channels to the same value. The alpha channel
 *                       selection is not affected by setting this parameter
 *                       to <code>true</code>.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="paletteMap"></a><h3><p><code><span class="keyword">function</span> <a href="#paletteMap"><span class="identifier">paletteMap</span></a>(sourceBitmapData:<a class="type" href="../../flash/display/BitmapData.html">BitmapData</a>, sourceRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, destPoint:<a class="type" href="../../flash/geom/Point.html">Point</a>, ?redArray:<a class="type" href="../../Array.html">Array</a>&lt;<a class="type" href="../../Int.html">Int</a>&gt;, ?greenArray:<a class="type" href="../../Array.html">Array</a>&lt;<a class="type" href="../../Int.html">Int</a>&gt;, ?blueArray:<a class="type" href="../../Array.html">Array</a>&lt;<a class="type" href="../../Int.html">Int</a>&gt;, ?alphaArray:<a class="type" href="../../Array.html">Array</a>&lt;<a class="type" href="../../Int.html">Int</a>&gt;):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Remaps the color channel values in an image that has up to four arrays of
 * color palette data, one for each channel.
 <em>
 * <p>Flash runtimes use the following steps to generate the resulting
 * image:</p>
 </em>
 * <ol>
 *   <li>After the red, green, blue, and alpha values are computed, they are
 * added together using standard 32-bit-integer arithmetic. </li>
 *   <li>The red, green, blue, and alpha channel values of each pixel are
 * extracted into separate 0 to 255 values. These values are used to look up
 * new color values in the appropriate array: <code>redArray</code>,
 * <code>greenArray</code>, <code>blueArray</code>, and
 * <code>alphaArray</code>. Each of these four arrays should contain 256
 * values. </li>
 *   <li>After all four of the new channel values are retrieved, they are
 * combined into a standard ARGB value that is applied to the pixel.</li>
 * </ol>
 <em>
 * <p>Cross-channel effects can be supported with this method. Each input
 * array can contain full 32-bit values, and no shifting occurs when the
 * values are added together. This routine does not support per-channel
 * clamping. </p>
 </em>
 * <p>If no array is specified for a channel, the color channel is copied
 * from the source image to the destination image.</p>
 *
 * <p>You can use this method for a variety of effects such as general
 * palette mapping(taking one channel and converting it to a false color
 * image). You can also use this method for a variety of advanced color
 * manipulation algorithms, such as gamma, curves, levels, and
 * quantizing.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>sourceBitmapData</td><td><p>The input bitmap image to use. The source image
<em>                         can be a different BitmapData object, or it can
</em>                         refer to the current BitmapData instance.
* </p></td></tr><tr><td>sourceRect</td><td><p>A rectangle that defines the area of the source
 *                         image to use as input.
 * </p></td></tr><tr><td>destPoint</td><td><p>The point within the destination image(the
 *                         current BitmapData object) that corresponds to the
 *                         upper-left corner of the source rectangle.
 * </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="perlinNoise"></a><h3><p><code><span class="keyword">function</span> <a href="#perlinNoise"><span class="identifier">perlinNoise</span></a>(baseX:<a class="type" href="../../Float.html">Float</a>, baseY:<a class="type" href="../../Float.html">Float</a>, numOctaves:<a class="type" href="../../UInt.html">UInt</a>, randomSeed:<a class="type" href="../../Int.html">Int</a>, stitch:<a class="type" href="../../Bool.html">Bool</a>, fractalNoise:<a class="type" href="../../Bool.html">Bool</a>, ?channelOptions:<a class="type" href="../../UInt.html">UInt</a>, ?grayScale:<a class="type" href="../../Bool.html">Bool</a>, ?offsets:<a class="type" href="../../Array.html">Array</a>&lt;<a class="type" href="../../flash/geom/Point.html">Point</a>&gt;):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Generates a Perlin noise image.
 <em>
 * <p>The Perlin noise generation algorithm interpolates and combines
 * individual random noise functions(called octaves) into a single function
 * that generates more natural-seeming random noise. Like musical octaves,
 * each octave function is twice the frequency of the one before it. Perlin
 * noise has been described as a "fractal sum of noise" because it combines
 * multiple sets of noise data with different levels of detail.</p>
 </em>
 * <p>You can use Perlin noise functions to simulate natural phenomena and
 * landscapes, such as wood grain, clouds, and mountain ranges. In most
 * cases, the output of a Perlin noise function is not displayed directly but
 * is used to enhance other images and give them pseudo-random
 * variations.</p>
 *
 * <p>Simple digital random noise functions often produce images with harsh,
 * contrasting points. This kind of harsh contrast is not often found in
 * nature. The Perlin noise algorithm blends multiple noise functions that
 * operate at different levels of detail. This algorithm results in smaller
 * variations among neighboring pixel values.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>baseX</td><td><p>Frequency to use in the <i>x</i> direction. For
 *                       example, to generate a noise that is sized for a 64
 *                       x 128 image, pass 64 for the <code>baseX</code>
 *                       value.
 * </p></td></tr><tr><td>baseY</td><td><p>Frequency to use in the <i>y</i> direction. For
 *                       example, to generate a noise that is sized for a 64
 *                       x 128 image, pass 128 for the <code>baseY</code>
 *                       value.
 * </p></td></tr><tr><td>numOctaves</td><td><p>Number of octaves or individual noise functions to
 *                       combine to create this noise. Larger numbers of
 *                       octaves create images with greater detail. Larger
 *                       numbers of octaves also require more processing
 *                       time.
 * </p></td></tr><tr><td>randomSeed</td><td><p>The random seed number to use. If you keep all other
 *                       parameters the same, you can generate different
 *                       pseudo-random results by varying the random seed
 *                       value. The Perlin noise function is a mapping
 *                       function, not a true random-number generation
 *                       function, so it creates the same results each time
 *                       from the same random seed.
 * </p></td></tr><tr><td>stitch</td><td><p>A Boolean value. If the value is <code>true</code>,
 *                       the method attempts to smooth the transition edges
 *                       of the image to create seamless textures for tiling
 *                       as a bitmap fill.
 * </p></td></tr><tr><td>fractalNoise</td><td><p>A Boolean value. If the value is <code>true</code>,
 *                       the method generates fractal noise; otherwise, it
 *                       generates turbulence. An image with turbulence has
 *                       visible discontinuities in the gradient that can
 *                       make it better approximate sharper visual effects
 *                       like flames and ocean waves.
 * </p></td></tr><tr><td>channelOptions</td><td><p>A number that can be a combination of any of the
<em>                       four color channel values
</em>                      (<code>BitmapDataChannel.RED</code>,
<em>                       <code>BitmapDataChannel.BLUE</code>,
</em>                       <code>BitmapDataChannel.GREEN</code>, and
<em>                       <code>BitmapDataChannel.ALPHA</code>). You can use
</em>                       the logical OR operator(<code>|</code>) to combine
<em>                       channel values.
</em> </p></td></tr><tr><td>grayScale</td><td><p>A Boolean value. If the value is <code>true</code>,
 *                       a grayscale image is created by setting each of the
 *                       red, green, and blue color channels to identical
 *                       values. The alpha channel value is not affected if
 *                       this value is set to <code>true</code>.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="pixelDissolve"></a><h3><p><code><span class="keyword">function</span> <a href="#pixelDissolve"><span class="identifier">pixelDissolve</span></a>(sourceBitmapData:<a class="type" href="../../flash/display/BitmapData.html">BitmapData</a>, sourceRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, destPoint:<a class="type" href="../../flash/geom/Point.html">Point</a>, ?randomSeed:<a class="type" href="../../Int.html">Int</a>, ?numPixels:<a class="type" href="../../Int.html">Int</a>, ?fillColor:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>Performs a pixel dissolve either from a source image to a destination
 * image or by using the same image. Flash runtimes use a
 * <code>randomSeed</code> value to generate a random pixel dissolve. The
 * return value of the function must be passed in on subsequent calls to
 * continue the pixel dissolve until it is finished.
 <em>
 * <p>If the source image does not equal the destination image, pixels are
 * copied from the source to the destination by using all of the properties.
 * This process allows dissolving from a blank image into a fully populated
 * image.</p>
 </em>
 * <p>If the source and destination images are equal, pixels are filled with
 * the <code>color</code> parameter. This process allows dissolving away from
 * a fully populated image. In this mode, the destination <code>point</code>
 * parameter is ignored.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>sourceBitmapData</td><td><p>The input bitmap image to use. The source image
<em>                         can be a different BitmapData object, or it can
</em>                         refer to the current BitmapData instance.
* </p></td></tr><tr><td>sourceRect</td><td><p>A rectangle that defines the area of the source
 *                         image to use as input.
 * </p></td></tr><tr><td>destPoint</td><td><p>The point within the destination image(the
 *                         current BitmapData instance) that corresponds to
 *                         the upper-left corner of the source rectangle.
 * </p></td></tr><tr><td>randomSeed</td><td><p>The random seed to use to start the pixel
 *                         dissolve.
 * </p></td></tr><tr><td>numPixels</td><td><p>The default is 1/30 of the source area(width x
 *                         height).
 * </p></td></tr><tr><td>fillColor</td><td><p>An ARGB color value that you use to fill pixels
 *                         whose source value equals its destination value.
 * </p></td></tr><tr><td>returns</td><td><p>The new random seed value to use for subsequent calls.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="scroll"></a><h3><p><code><span class="keyword">function</span> <a href="#scroll"><span class="identifier">scroll</span></a>(x:<a class="type" href="../../Int.html">Int</a>, y:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Scrolls an image by a certain(<i>x</i>, <i>y</i>) pixel amount. Edge
 * regions outside the scrolling area are left unchanged.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>x</td><td><p>The amount by which to scroll horizontally.
* </p></td></tr><tr><td>y</td><td><p>The amount by which to scroll vertically.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="setPixel"></a><h3><p><code><span class="keyword">function</span> <a href="#setPixel"><span class="identifier">setPixel</span></a>(x:<a class="type" href="../../Int.html">Int</a>, y:<a class="type" href="../../Int.html">Int</a>, color:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Sets a single pixel of a BitmapData object. The current alpha channel
 * value of the image pixel is preserved during this operation. The value of
 * the RGB color parameter is treated as an unmultiplied color value.
 *
 * <p><b>Note:</b> To increase performance, when you use the
 * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
 * call the <code>lock()</code> method before you call the
 * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
 * the <code>unlock()</code> method when you have made all pixel changes.
 * This process prevents objects that reference this BitmapData instance from
 * updating until you finish making the pixel changes.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>x</td><td><p>The <i>x</i> position of the pixel whose value changes.
 * </p></td></tr><tr><td>y</td><td><p>The <i>y</i> position of the pixel whose value changes.
 * </p></td></tr><tr><td>color</td><td><p>The resulting RGB color for the pixel.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="setPixel32"></a><h3><p><code><span class="keyword">function</span> <a href="#setPixel32"><span class="identifier">setPixel32</span></a>(x:<a class="type" href="../../Int.html">Int</a>, y:<a class="type" href="../../Int.html">Int</a>, color:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Sets the color and alpha transparency values of a single pixel of a
 * BitmapData object. This method is similar to the <code>setPixel()</code>
 * method; the main difference is that the <code>setPixel32()</code> method
 * takes an ARGB color value that contains alpha channel information.
 <em>
 * <p>All pixels in a BitmapData object are stored as premultiplied color
 * values. A premultiplied image pixel has the red, green, and blue color
 * channel values already multiplied by the alpha data. For example, if the
 * alpha value is 0, the values for the RGB channels are also 0, independent
 * of their unmultiplied values. This loss of data can cause some problems
 * when you perform operations. All BitmapData methods take and return
 * unmultiplied values. The internal pixel representation is converted from
 * premultiplied to unmultiplied before it is returned as a value. During a
 * set operation, the pixel value is premultiplied before the raw image pixel
 * is set.</p>
 </em>
 * <p><b>Note:</b> To increase performance, when you use the
 * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
 * call the <code>lock()</code> method before you call the
 * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
 * the <code>unlock()</code> method when you have made all pixel changes.
 * This process prevents objects that reference this BitmapData instance from
 * updating until you finish making the pixel changes.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>x</td><td><p>The <i>x</i> position of the pixel whose value changes.
 * </p></td></tr><tr><td>y</td><td><p>The <i>y</i> position of the pixel whose value changes.
 * </p></td></tr><tr><td>color</td><td><p>The resulting ARGB color for the pixel. If the bitmap is
<em>              opaque(not transparent), the alpha transparency portion of
</em>              this color value is ignored.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="setPixels"></a><h3><p><code><span class="keyword">function</span> <a href="#setPixels"><span class="identifier">setPixels</span></a>(rect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, inputByteArray:<a class="type" href="../../flash/utils/ByteArray.html">ByteArray</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Converts a byte array into a rectangular region of pixel data. For each
 * pixel, the <code>ByteArray.readUnsignedInt()</code> method is called and
 * the return value is written into the pixel. If the byte array ends before
 * the full rectangle is written, the function returns. The data in the byte
 * array is expected to be 32-bit ARGB pixel values. No seeking is performed
 * on the byte array before or after the pixels are read.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>rect</td><td><p>Specifies the rectangular region of the BitmapData
 *                       object.
 * </p></td></tr><tr><td>inputByteArray</td><td><p>A ByteArray object that consists of 32-bit
<em>                       unmultiplied pixel values to be used in the
</em>                       rectangular region.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="setVector"></a><h3><p><code><span class="keyword">function</span> <a href="#setVector"><span class="identifier">setVector</span></a>(rect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, inputVector:<a class="type" href="../../flash/Vector.html">Vector</a>&lt;<a class="type" href="../../UInt.html">UInt</a>&gt;):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Converts a Vector into a rectangular region of pixel data. For each pixel,
 * a Vector element is read and written into the BitmapData pixel. The data
 * in the Vector is expected to be 32-bit ARGB pixel values.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>rect</td><td><p>Specifies the rectangular region of the BitmapData object.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="threshold"></a><h3><p><code><span class="keyword">function</span> <a href="#threshold"><span class="identifier">threshold</span></a>(sourceBitmapData:<a class="type" href="../../flash/display/BitmapData.html">BitmapData</a>, sourceRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>, destPoint:<a class="type" href="../../flash/geom/Point.html">Point</a>, operation:<a class="type" href="../../String.html">String</a>, threshold:<a class="type" href="../../UInt.html">UInt</a>, ?color:<a class="type" href="../../UInt.html">UInt</a>, ?mask:<a class="type" href="../../UInt.html">UInt</a>, ?copySource:<a class="type" href="../../Bool.html">Bool</a>):<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>Tests pixel values in an image against a specified threshold and sets
 * pixels that pass the test to new color values. Using the
 * <code>threshold()</code> method, you can isolate and replace color ranges
 * in an image and perform other logical operations on image pixels.
 <em>
 * <p>The <code>threshold()</code> method's test logic is as follows:</p>
 </em>
 * <ol>
 *   <li>If <code>((pixelValue &amp; mask) operation(threshold &amp; mask))</code>,
 * then set the pixel to <code>color</code>;</li>
 *   <li>Otherwise, if <code>copySource == true</code>, then set the pixel to
 * corresponding pixel value from <code>sourceBitmap</code>.</li>
 * </ol>
 *
 * <p>The <code>operation</code> parameter specifies the comparison operator
 * to use for the threshold test. For example, by using "==" as the
 * <code>operation</code> parameter, you can isolate a specific color value
 * in an image. Or by using <code>{operation: "&lt;", mask: 0xFF000000,
 * threshold: 0x7F000000, color: 0x00000000}</code>, you can set all
 * destination pixels to be fully transparent when the source image pixel's
 * alpha is less than 0x7F. You can use this technique for animated
 * transitions and other effects.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>sourceBitmapData</td><td><p>The input bitmap image to use. The source image
<em>                         can be a different BitmapData object or it can
</em>                         refer to the current BitmapData instance.
* </p></td></tr><tr><td>sourceRect</td><td><p>A rectangle that defines the area of the source
 *                         image to use as input.
 * </p></td></tr><tr><td>destPoint</td><td><p>The point within the destination image(the
 *                         current BitmapData instance) that corresponds to
 *                         the upper-left corner of the source rectangle.
 * </p></td></tr><tr><td>operation</td><td><p>One of the following comparison operators, passed
 *                         as a String: "&lt;", "&lt;=", ">", ">=", "==", "!="
 * </p></td></tr><tr><td>threshold</td><td><p>The value that each pixel is tested against to see
 *                         if it meets or exceeds the threshhold.
 * </p></td></tr><tr><td>color</td><td><p>The color value that a pixel is set to if the
 *                         threshold test succeeds. The default value is
 *                         0x00000000.
 * </p></td></tr><tr><td>mask</td><td><p>The mask to use to isolate a color component.
 * </p></td></tr><tr><td>copySource</td><td><p>If the value is <code>true</code>, pixel values
 *                         from the source image are copied to the
 *                         destination when the threshold test fails. If the
 *                         value is <code>false</code>, the source image is
 *                         not copied when the threshold test fails.
 * </p></td></tr><tr><td>returns</td><td><p>The number of pixels that were changed.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="unlock"></a><h3><p><code><span class="keyword">function</span> <a href="#unlock"><span class="identifier">unlock</span></a>(?changeRect:<a class="type" href="../../flash/geom/Rectangle.html">Rectangle</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Unlocks an image so that any objects that reference the BitmapData object,
 * such as Bitmap objects, are updated when this BitmapData object changes.
 * To improve performance, use this method along with the <code>lock()</code>
 * method before and after numerous calls to the <code>setPixel()</code> or
 * <code>setPixel32()</code> method.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>changeRect</td><td><p>The area of the BitmapData object that has changed. If
<em>                   you do not specify a value for this parameter, the
</em>                   entire area of the BitmapData object is considered
*                   changed.</p></td></tr></tbody></table></div></div></div></div></div></body></html>
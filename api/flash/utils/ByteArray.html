<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../bootstrap-combined.min.css" rel="stylesheet" /><script type="text/javascript" src="../../jquery-1.9.1.min.js"></script><script type="text/javascript" src="../../bootstrap.min.js"></script><link href="../../styles.css" rel="stylesheet" /><link rel="icon" href="../../favicon.ico" type="image/x-icon"></link><script type="text/javascript" src="../../nav.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["flash"]};</script><title>ByteArray</title></head><body><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><form class="navbar-search pull-left" id="searchForm"><input id="search" type="text" class="search-query" placeholder="Filter" autocomplete="off"/></form><ul class="nav"><li id="select-platform" class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Platform<b class="caret"></b></a><ul class="dropdown-menu"><li data="all"><a href="#">All Platforms</a></li><li data="flash"><a href="#">flash</a></li></ul></li></ul></div></div><div id="container"><div id="nav"></div><div id="content"><div class="header"><h1><code><span class="directive">class </span><span class="type">flash.utils.ByteArray</span><span class="keyword"> implements</span> <a class="type" href="../../flash/utils/IDataInput.html">IDataInput</a></code></h1></div><div class="body"><p class="availability">Available on all platforms</p><div class="doc"><p>The ByteArray class provides methods and properties to optimize reading,
 * writing, and working with binary data.
 <em>
 * <p><i>Note:</i> The ByteArray class is for advanced developers who need to
 * access data on the byte level.</p>
 </em>
 * <p>In-memory data is a packed array(the most compact representation for
 * the data type) of bytes, but an instance of the ByteArray class can be
 * manipulated with the standard <code>[]</code>(array access) operators. It
 * also can be read and written to as an in-memory file, using methods similar
 * to those in the URLStream and Socket classes.</p>
 <em>
 * <p>In addition, zlib compression and decompression are supported, as well
 * as Action Message Format(AMF) object serialization.</p>
 </em>
 * <p>Possible uses of the ByteArray class include the following:
 * <ul>
 *   <li>Creating a custom protocol to connect to a server.</li>
 *   <li>Writing your own URLEncoder/URLDecoder.</li>
 *   <li>Writing your own AMF/Remoting packet.</li>
 *   <li>Optimizing the size of your data by using data types.</li>
 *   <li>Working with binary data loaded from a file in Adobe<sup>®</sup>
 * AIR<sup>®</sup>.</li>
 * </ul>
 * </p></p></div><h2>Class Fields</h2><div class="platform platform-flash"><a name="defaultObjectEncoding"></a><h3><p><code><span class="keyword">static </span><span class="keyword">var</span> <a href="#defaultObjectEncoding"><span class="identifier">defaultObjectEncoding</span></a>:<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>Denotes the default object encoding for the ByteArray class to use for a
 * new ByteArray instance. When you create a new ByteArray instance, the
 * encoding on that instance starts with the value of
 * <code>defaultObjectEncoding</code>. The <code>defaultObjectEncoding</code>
 * property is initialized to <code>ObjectEncoding.AMF3</code>.
 *
 * <p>When an object is written to or read from binary data, the
 * <code>objectEncoding</code> value is used to determine whether the
 * ActionScript 3.0, ActionScript2.0, or ActionScript 1.0 format should be
 * used. The value is a constant from the ObjectEncoding class.</p></p></div></div><h2>Instance Fields</h2><div class="platform platform-flash"><a name="bytesAvailable"></a><h3><p><code><span class="keyword">var</span> <a href="#bytesAvailable"><span class="identifier">bytesAvailable</span></a>:<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>The number of bytes of data available for reading from the current
 * position in the byte array to the end of the array.
 *
 * <p>Use the <code>bytesAvailable</code> property in conjunction with the
 * read methods each time you access a ByteArray object to ensure that you
 * are reading valid data.</p></p></div></div><div class="platform platform-flash"><a name="endian"></a><h3><p><code><span class="keyword">var</span> <a href="#endian"><span class="identifier">endian</span></a>:<a class="type" href="../../flash/utils/Endian.html">Endian</a></code></p></h3><div class="doc"><p>Changes or reads the byte order for the data; either
 * <code>Endian.BIG<em>ENDIAN</code> or <code>Endian.LITTLE</em>ENDIAN</code>.</p></div></div><div class="platform platform-flash"><a name="length"></a><h3><p><code><span class="keyword">var</span> <a href="#length"><span class="identifier">length</span></a>:<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>The length of the ByteArray object, in bytes.
 <em>
 * <p>If the length is set to a value that is larger than the current length,
 * the right side of the byte array is filled with zeros.</p>
 </em>
 * <p>If the length is set to a value that is smaller than the current
 * length, the byte array is truncated.</p></p></div></div><div class="platform platform-flash"><a name="objectEncoding"></a><h3><p><code><span class="keyword">var</span> <a href="#objectEncoding"><span class="identifier">objectEncoding</span></a>:<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>Used to determine whether the ActionScript 3.0, ActionScript 2.0, or
 * ActionScript 1.0 format should be used when writing to, or reading from, a
 * ByteArray instance. The value is a constant from the ObjectEncoding class.</p></div></div><div class="platform platform-flash"><a name="position"></a><h3><p><code><span class="keyword">var</span> <a href="#position"><span class="identifier">position</span></a>:<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>Moves, or returns the current position, in bytes, of the file pointer into
 * the ByteArray object. This is the point at which the next call to a read
 * method starts reading or a write method starts writing.</p></div></div><div class="platform platform-flash"><a name="shareable"></a><h3><p><code><span class="keyword">var</span> <a href="#shareable"><span class="identifier">shareable</span></a>:<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p></p></div></div><div class="platform platform-flash"><a name="new"></a><h3><p><code><span class="keyword">function</span> <a href="#new"><span class="identifier">new</span></a>():<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Creates a ByteArray instance representing a packed array of bytes, so that
 * you can use the methods and properties in this class to optimize your data
 * storage and stream.</p></div></div><div class="platform platform-flash"><a name="atomicCompareAndSwapIntAt"></a><h3><p><code><span class="keyword">function</span> <a href="#atomicCompareAndSwapIntAt"><span class="identifier">atomicCompareAndSwapIntAt</span></a>(byteIndex:<a class="type" href="../../Int.html">Int</a>, expectedValue:<a class="type" href="../../Int.html">Int</a>, newValue:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../Int.html">Int</a></code></p></h3><div class="doc"><p></p></div></div><div class="platform platform-flash"><a name="atomicCompareAndSwapLength"></a><h3><p><code><span class="keyword">function</span> <a href="#atomicCompareAndSwapLength"><span class="identifier">atomicCompareAndSwapLength</span></a>(expectedLength:<a class="type" href="../../Int.html">Int</a>, newLength:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../Int.html">Int</a></code></p></h3><div class="doc"><p></p></div></div><div class="platform platform-flash"><a name="clear"></a><h3><p><code><span class="keyword">function</span> <a href="#clear"><span class="identifier">clear</span></a>():<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Clears the contents of the byte array and resets the <code>length</code>
 * and <code>position</code> properties to 0. Calling this method explicitly
 * frees up the memory used by the ByteArray instance.</p></div></div><div class="platform platform-flash"><a name="compress"></a><h3><p><code><span class="keyword">function</span> <a href="#compress"><span class="identifier">compress</span></a>(?algorithm:<a class="type" href="../../flash/utils/CompressionAlgorithm.html">CompressionAlgorithm</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Compresses the byte array. The entire byte array is compressed. For
 * content running in Adobe AIR, you can specify a compression algorithm by
 * passing a value(defined in the CompressionAlgorithm class) as the
 * <code>algorithm</code> parameter. Flash Player supports only the default
 * algorithm, zlib.
 <em>
 * <p>After the call, the <code>length</code> property of the ByteArray is
 * set to the new length. The <code>position</code> property is set to the
 * end of the byte array.</p>
 </em>
 * <p>The zlib compressed data format is described at &lt;a
 * href="http://www.ietf.org/rfc/rfc1950.txt"
 * scope="external">http://www.ietf.org/rfc/rfc1950.txt</a>.</p>
 <em>
 * <p>The deflate compression algorithm is described at &lt;a
 * href="http://www.ietf.org/rfc/rfc1951.txt"
 * scope="external">http://www.ietf.org/rfc/rfc1951.txt</a>.</p>
 </em>
 * <p>The deflate compression algorithm is used in several compression
 * formats, such as zlib, gzip, some zip implementations, and others. When
 * data is compressed using one of those compression formats, in addition to
 * storing the compressed version of the original data, the compression
 * format data(for example, the .zip file) includes metadata information.
 * Some examples of the types of metadata included in various file formats
 * are file name, file modification date/time, original file size, optional
 * comments, checksum data, and more.</p>
 <em>
 * <p>For example, when a ByteArray is compressed using the zlib algorithm,
 * the resulting ByteArray is structured in a specific format. Certain bytes
 * contain metadata about the compressed data, while other bytes contain the
 * actual compressed version of the original ByteArray data. As defined by
 * the zlib compressed data format specification, those bytes(that is, the
 * portion containing the compressed version of the original data) are
 * compressed using the deflate algorithm. Consequently those bytes are
 * identical to the result of calling <code>compress(&lt;ph
 * outputclass="javascript">air.CompressionAlgorithm.DEFLATE)</code> on the
 * original ByteArray. However, the result from <code>compress(&lt;ph
 * outputclass="javascript">air.CompressionAlgorithm.ZLIB)</code> includes
 * the extra metadata, while the
 * <code>compress(CompressionAlgorithm.DEFLATE)</code> result includes only
 * the compressed version of the original ByteArray data and nothing
 * else.</p>
 </em>
 * <p>In order to use the deflate format to compress a ByteArray instance's
 * data in a specific format such as gzip or zip, you cannot simply call
 * <code>compress(CompressionAlgorithm.DEFLATE)</code>. You must create a
 * ByteArray structured according to the compression format's specification,
 * including the appropriate metadata as well as the compressed data obtained
 * using the deflate format. Likewise, in order to decode data compressed in
 * a format such as gzip or zip, you can't simply call
 * <code>uncompress(CompressionAlgorithm.DEFLATE)</code> on that data. First,
 * you must separate the metadata from the compressed data, and you can then
 * use the deflate format to decompress the compressed data.</p></p></div></div><div class="platform platform-flash"><a name="deflate"></a><h3><p><code><span class="keyword">function</span> <a href="#deflate"><span class="identifier">deflate</span></a>():<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Compresses the byte array using the deflate compression algorithm. The
 * entire byte array is compressed.
 <em>
 * <p>After the call, the <code>length</code> property of the ByteArray is
 * set to the new length. The <code>position</code> property is set to the
 * end of the byte array.</p>
 </em>
 * <p>The deflate compression algorithm is described at &lt;a
 * href="http://www.ietf.org/rfc/rfc1951.txt"
 * scope="external">http://www.ietf.org/rfc/rfc1951.txt</a>.</p>
 *
 * <p>In order to use the deflate format to compress a ByteArray instance's
 * data in a specific format such as gzip or zip, you cannot simply call
 * <code>deflate()</code>. You must create a ByteArray structured according
 * to the compression format's specification, including the appropriate
 * metadata as well as the compressed data obtained using the deflate format.
 * Likewise, in order to decode data compressed in a format such as gzip or
 * zip, you can't simply call <code>inflate()</code> on that data. First, you
 * must separate the metadata from the compressed data, and you can then use
 * the deflate format to decompress the compressed data.</p></p></div></div><div class="platform platform-flash"><a name="inflate"></a><h3><p><code><span class="keyword">function</span> <a href="#inflate"><span class="identifier">inflate</span></a>():<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Decompresses the byte array using the deflate compression algorithm. The
 * byte array must have been compressed using the same algorithm.
 <em>
 * <p>After the call, the <code>length</code> property of the ByteArray is
 * set to the new length. The <code>position</code> property is set to 0.</p>
 </em>
 * <p>The deflate compression algorithm is described at &lt;a
 * href="http://www.ietf.org/rfc/rfc1951.txt"
 * scope="external">http://www.ietf.org/rfc/rfc1951.txt</a>.</p>
 *
 * <p>In order to decode data compressed in a format that uses the deflate
 * compression algorithm, such as data in gzip or zip format, it will not
 * work to simply call <code>inflate()</code> on a ByteArray containing the
 * compression formation data. First, you must separate the metadata that is
 * included as part of the compressed data format from the actual compressed
 * data. For more information, see the <code>compress()</code> method
 * description.</p>
 * 
 * </p></div></div><div class="platform platform-flash"><a name="readBoolean"></a><h3><p><code><span class="keyword">function</span> <a href="#readBoolean"><span class="identifier">readBoolean</span></a>():<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Reads a Boolean value from the byte stream. A single byte is read, and
 * <code>true</code> is returned if the byte is nonzero, <code>false</code>
 * otherwise.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>Returns <code>true</code> if the byte is nonzero,
<em>         <code>false</code> otherwise.
</em> </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readByte"></a><h3><p><code><span class="keyword">function</span> <a href="#readByte"><span class="identifier">readByte</span></a>():<a class="type" href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>Reads a signed byte from the byte stream.
 *
 * <p>The returned value is in the range -128 to 127.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>An integer between -128 and 127.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readBytes"></a><h3><p><code><span class="keyword">function</span> <a href="#readBytes"><span class="identifier">readBytes</span></a>(bytes:<a class="type" href="../../flash/utils/ByteArray.html">ByteArray</a>, ?offset:<a class="type" href="../../UInt.html">UInt</a>, ?length:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Reads the number of data bytes, specified by the <code>length</code>
 * parameter, from the byte stream. The bytes are read into the ByteArray
 * object specified by the <code>bytes</code> parameter, and the bytes are
 * written into the destination ByteArray starting at the position specified
 * by <code>offset</code>.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>bytes</td><td><p>The ByteArray object to read data into.
 * </p></td></tr><tr><td>offset</td><td><p>The offset(position) in <code>bytes</code> at which the
<em>               read data should be written.
</em> </p></td></tr><tr><td>length</td><td><p>The number of bytes to read. The default value of 0 causes
<em>               all available data to be read.
</em> </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readDouble"></a><h3><p><code><span class="keyword">function</span> <a href="#readDouble"><span class="identifier">readDouble</span></a>():<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>Reads an IEEE 754 double-precision(64-bit) floating-point number from the
 * byte stream.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A double-precision(64-bit) floating-point number.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readFloat"></a><h3><p><code><span class="keyword">function</span> <a href="#readFloat"><span class="identifier">readFloat</span></a>():<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>Reads an IEEE 754 single-precision(32-bit) floating-point number from the
 * byte stream.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A single-precision(32-bit) floating-point number.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readInt"></a><h3><p><code><span class="keyword">function</span> <a href="#readInt"><span class="identifier">readInt</span></a>():<a class="type" href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>Reads a signed 32-bit integer from the byte stream.
 *
 * <p>The returned value is in the range -2147483648 to 2147483647.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A 32-bit signed integer between -2147483648 and 2147483647.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readMultiByte"></a><h3><p><code><span class="keyword">function</span> <a href="#readMultiByte"><span class="identifier">readMultiByte</span></a>(length:<a class="type" href="../../UInt.html">UInt</a>, charSet:<a class="type" href="../../String.html">String</a>):<a class="type" href="../../String.html">String</a></code></p></h3><div class="doc"><p>Reads a multibyte string of specified length from the byte stream using
 * the specified character set.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>length</td><td><p>The number of bytes from the byte stream to read.
 * </p></td></tr><tr><td>charSet</td><td><p>The string denoting the character set to use to interpret
<em>                the bytes. Possible character set strings include
</em>                <code>"shift-jis"</code>, <code>"cn-gb"</code>,
<em>                <code>"iso-8859-1"</code>, and others. For a complete list,
</em>                see <a href="../../charset-codes.html">Supported Character
<em>                Sets</a>.
</em>
<em>                <p><b>Note:</b> If the value for the <code>charSet</code>
</em>                parameter is not recognized by the current system, the
<em>                application uses the system's default code page as the
</em>                character set. For example, a value for the
<em>                <code>charSet</code> parameter, as in
</em>                <code>myTest.readMultiByte(22, "iso-8859-01")</code> that
<em>                uses <code>01</code> instead of <code>1</code> might work
</em>                on your development system, but not on another system. On
<em>                the other system, the application will use the system's
</em>                default code page.</p>
* </p></td></tr><tr><td>returns</td><td><p>UTF-8 encoded string.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readObject"></a><h3><p><code><span class="keyword">function</span> <a href="#readObject"><span class="identifier">readObject</span></a>():<a class="type" href="../../Dynamic.html">Dynamic</a></code></p></h3><div class="doc"><p>Reads an object from the byte array, encoded in AMF serialized format.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>The deserialized object.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readShort"></a><h3><p><code><span class="keyword">function</span> <a href="#readShort"><span class="identifier">readShort</span></a>():<a class="type" href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>Reads a signed 16-bit integer from the byte stream.
 *
 * <p>The returned value is in the range -32768 to 32767.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A 16-bit signed integer between -32768 and 32767.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readUTF"></a><h3><p><code><span class="keyword">function</span> <a href="#readUTF"><span class="identifier">readUTF</span></a>():<a class="type" href="../../String.html">String</a></code></p></h3><div class="doc"><p>Reads a UTF-8 string from the byte stream. The string is assumed to be
 * prefixed with an unsigned short indicating the length in bytes.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>UTF-8 encoded string.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readUTFBytes"></a><h3><p><code><span class="keyword">function</span> <a href="#readUTFBytes"><span class="identifier">readUTFBytes</span></a>(length:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../String.html">String</a></code></p></h3><div class="doc"><p>Reads a sequence of UTF-8 bytes specified by the <code>length</code>
 * parameter from the byte stream and returns a string.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>length</td><td><p>An unsigned short indicating the length of the UTF-8 bytes.
* </p></td></tr><tr><td>returns</td><td><p>A string composed of the UTF-8 bytes of the specified length.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readUnsignedByte"></a><h3><p><code><span class="keyword">function</span> <a href="#readUnsignedByte"><span class="identifier">readUnsignedByte</span></a>():<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>Reads an unsigned byte from the byte stream.
 *
 * <p>The returned value is in the range 0 to 255. </p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A 32-bit unsigned integer between 0 and 255.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readUnsignedInt"></a><h3><p><code><span class="keyword">function</span> <a href="#readUnsignedInt"><span class="identifier">readUnsignedInt</span></a>():<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>Reads an unsigned 32-bit integer from the byte stream.
 *
 * <p>The returned value is in the range 0 to 4294967295. </p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A 32-bit unsigned integer between 0 and 4294967295.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="readUnsignedShort"></a><h3><p><code><span class="keyword">function</span> <a href="#readUnsignedShort"><span class="identifier">readUnsignedShort</span></a>():<a class="type" href="../../UInt.html">UInt</a></code></p></h3><div class="doc"><p>Reads an unsigned 16-bit integer from the byte stream.
 *
 * <p>The returned value is in the range 0 to 65535. </p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A 16-bit unsigned integer between 0 and 65535.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="toString"></a><h3><p><code><span class="keyword">function</span> <a href="#toString"><span class="identifier">toString</span></a>():<a class="type" href="../../String.html">String</a></code></p></h3><div class="doc"><p>Converts the byte array to a string. If the data in the array begins with
 * a Unicode byte order mark, the application will honor that mark when
 * converting to a string. If <code>System.useCodePage</code> is set to
 * <code>true</code>, the application will treat the data in the array as
 * being in the current system code page when converting.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>The string representation of the byte array.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="uncompress"></a><h3><p><code><span class="keyword">function</span> <a href="#uncompress"><span class="identifier">uncompress</span></a>(?algorithm:<a class="type" href="../../flash/utils/CompressionAlgorithm.html">CompressionAlgorithm</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Decompresses the byte array. For content running in Adobe AIR, you can
 * specify a compression algorithm by passing a value(defined in the
 * CompressionAlgorithm class) as the <code>algorithm</code> parameter. The
 * byte array must have been compressed using the same algorithm. Flash
 * Player supports only the default algorithm, zlib.
 <em>
 * <p>After the call, the <code>length</code> property of the ByteArray is
 * set to the new length. The <code>position</code> property is set to 0.</p>
 </em>
 * <p>The zlib compressed data format is described at &lt;a
 * href="http://www.ietf.org/rfc/rfc1950.txt"
 * scope="external">http://www.ietf.org/rfc/rfc1950.txt</a>.</p>
 <em>
 * <p>The deflate compression algorithm is described at &lt;a
 * href="http://www.ietf.org/rfc/rfc1951.txt"
 * scope="external">http://www.ietf.org/rfc/rfc1951.txt</a>.</p>
 </em>
 * <p>In order to decode data compressed in a format that uses the deflate
 * compression algorithm, such as data in gzip or zip format, it will not
 * work to call <code>uncompress(CompressionAlgorithm.DEFLATE)</code> on a
 * ByteArray containing the compression formation data. First, you must
 * separate the metadata that is included as part of the compressed data
 * format from the actual compressed data. For more information, see the
 * <code>compress()</code> method description.</p>
 * 
 * </p></div></div><div class="platform platform-flash"><a name="writeBoolean"></a><h3><p><code><span class="keyword">function</span> <a href="#writeBoolean"><span class="identifier">writeBoolean</span></a>(value:<a class="type" href="../../Bool.html">Bool</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes a Boolean value. A single byte is written according to the
 * <code>value</code> parameter, either 1 if <code>true</code> or 0 if
 * <code>false</code>.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>value</td><td><p>A Boolean value determining which byte is written. If the
<em>              parameter is <code>true</code>, the method writes a 1; if
</em>              <code>false</code>, the method writes a 0.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeByte"></a><h3><p><code><span class="keyword">function</span> <a href="#writeByte"><span class="identifier">writeByte</span></a>(value:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes a byte to the byte stream.
 *
 * <p>The low 8 bits of the parameter are used. The high 24 bits are ignored.
 * </p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>value</td><td><p>A 32-bit integer. The low 8 bits are written to the byte
*              stream.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeBytes"></a><h3><p><code><span class="keyword">function</span> <a href="#writeBytes"><span class="identifier">writeBytes</span></a>(bytes:<a class="type" href="../../flash/utils/ByteArray.html">ByteArray</a>, ?offset:<a class="type" href="../../UInt.html">UInt</a>, ?length:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes a sequence of <code>length</code> bytes from the specified byte
 * array, <code>bytes</code>, starting <code>offset</code>(zero-based index)
 * bytes into the byte stream.
 <em>
 * <p>If the <code>length</code> parameter is omitted, the default length of
 * 0 is used; the method writes the entire buffer starting at
 * <code>offset</code>. If the <code>offset</code> parameter is also omitted,
 * the entire buffer is written. </p>
 </em>
 * <p>If <code>offset</code> or <code>length</code> is out of range, they are
 * clamped to the beginning and end of the <code>bytes</code> array.</p>
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>bytes</td><td><p>The ByteArray object.
 * </p></td></tr><tr><td>offset</td><td><p>A zero-based index indicating the position into the array to
<em>               begin writing.
</em> </p></td></tr><tr><td>length</td><td><p>An unsigned integer indicating how far into the buffer to
*               write.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeDouble"></a><h3><p><code><span class="keyword">function</span> <a href="#writeDouble"><span class="identifier">writeDouble</span></a>(value:<a class="type" href="../../Float.html">Float</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes an IEEE 754 double-precision(64-bit) floating-point number to the
 * byte stream.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>value</td><td><p>A double-precision(64-bit) floating-point number.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeFloat"></a><h3><p><code><span class="keyword">function</span> <a href="#writeFloat"><span class="identifier">writeFloat</span></a>(value:<a class="type" href="../../Float.html">Float</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes an IEEE 754 single-precision(32-bit) floating-point number to the
 * byte stream.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>value</td><td><p>A single-precision(32-bit) floating-point number.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeInt"></a><h3><p><code><span class="keyword">function</span> <a href="#writeInt"><span class="identifier">writeInt</span></a>(value:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes a 32-bit signed integer to the byte stream.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>value</td><td><p>An integer to write to the byte stream.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeMultiByte"></a><h3><p><code><span class="keyword">function</span> <a href="#writeMultiByte"><span class="identifier">writeMultiByte</span></a>(value:<a class="type" href="../../String.html">String</a>, charSet:<a class="type" href="../../String.html">String</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes a multibyte string to the byte stream using the specified character
 * set.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>value</td><td><p>The string value to be written.
 * </p></td></tr><tr><td>charSet</td><td><p>The string denoting the character set to use. Possible
<em>                character set strings include <code>"shift-jis"</code>,
</em>                <code>"cn-gb"</code>, <code>"iso-8859-1"</code>, and
<em>                others. For a complete list, see &lt;a
</em>                href="../../charset-codes.html">Supported Character
*                Sets</a>.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeObject"></a><h3><p><code><span class="keyword">function</span> <a href="#writeObject"><span class="identifier">writeObject</span></a>(object:<a class="type" href="../../Dynamic.html">Dynamic</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes an object into the byte array in AMF serialized format.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>object</td><td><p>The object to serialize.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeShort"></a><h3><p><code><span class="keyword">function</span> <a href="#writeShort"><span class="identifier">writeShort</span></a>(value:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes a 16-bit integer to the byte stream. The low 16 bits of the
 * parameter are used. The high 16 bits are ignored.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>value</td><td><p>32-bit integer, whose low 16 bits are written to the byte
*              stream.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeUTF"></a><h3><p><code><span class="keyword">function</span> <a href="#writeUTF"><span class="identifier">writeUTF</span></a>(value:<a class="type" href="../../String.html">String</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes a UTF-8 string to the byte stream. The length of the UTF-8 string
 * in bytes is written first, as a 16-bit integer, followed by the bytes
 * representing the characters of the string.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>value</td><td><p>The string value to be written.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeUTFBytes"></a><h3><p><code><span class="keyword">function</span> <a href="#writeUTFBytes"><span class="identifier">writeUTFBytes</span></a>(value:<a class="type" href="../../String.html">String</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes a UTF-8 string to the byte stream. Similar to the
 * <code>writeUTF()</code> method, but <code>writeUTFBytes()</code> does not
 * prefix the string with a 16-bit length word.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>value</td><td><p>The string value to be written.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="writeUnsignedInt"></a><h3><p><code><span class="keyword">function</span> <a href="#writeUnsignedInt"><span class="identifier">writeUnsignedInt</span></a>(value:<a class="type" href="../../UInt.html">UInt</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Writes a 32-bit unsigned integer to the byte stream.
 * 
 * </p><table class="table table-condensed"><tbody><tr><td>value</td><td><p>An unsigned integer to write to the byte stream.</p></td></tr></tbody></table></div></div></div></div></div></body></html>
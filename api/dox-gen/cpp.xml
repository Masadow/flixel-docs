<haxe>
	<class path="Array" params="T" file="C:\HaxeToolkit\haxe\std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.sort.MergeSort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurense of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurense of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.</haxe_doc>
	</class>
	<abstract path="Class" params="T" file="C:\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/Date.hx">
		<now public="1" set="method" line="50" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<new1 set="method" line="53" static="1"><f a="t">
	<d/>
	<c path="Date"/>
</f></new1>
		<fromTime public="1" set="method" line="57" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="63" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:
		
		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`
		
		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<mSeconds><x path="Float"/></mSeconds>
		<getTime public="1" set="method" line="30">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" set="method" line="34">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method" line="36">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method" line="38">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method" line="40">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method" line="42">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method" line="44">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method" line="46">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<toString public="1" set="method" line="48">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method" line="26">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.
		
		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.
		
		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by
	
	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.
	
	There is some extra functions available in the `DateTools` class.
	
	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="cpp.Lib" params="" file="C:\HaxeToolkit\haxe\std/cpp/Lib.hx">
		<load public="1" set="method" line="29" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</load>
		<getProcAddress public="1" get="inline" set="null" line="40" static="1">
			<f a="lib:prim">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</getProcAddress>
		<loadLazy public="1" set="method" line="48" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Tries to load, and always returns a valid function, but the function may throw
		if called.</haxe_doc>
		</loadLazy>
		<rethrow public="1" set="method" line="64" static="1"><f a="inExp">
	<d/>
	<x path="Void"/>
</f></rethrow>
		<stringReference public="1" set="method" line="66" static="1"><f a="inExp">
	<d/>
	<x path="Void"/>
</f></stringReference>
		<print public="1" set="method" line="71" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print the specified value on the default output.</haxe_doc>
		</print>
		<haxeToNeko public="1" set="method" line="79" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic</haxe_doc>
		</haxeToNeko>
		<nekoToHaxe public="1" set="method" line="87" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic</haxe_doc>
		</nekoToHaxe>
		<println public="1" set="method" line="93" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print the specified value on the default output followed by a newline character.</haxe_doc>
		</println>
	</class>
	<class path="EReg" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/EReg.hx">
		<regexp_new_options line="174" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></regexp_new_options>
		<regexp_match line="175" static="1"><f a=":::">
	<d/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></regexp_match>
		<regexp_matched line="176" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<d/>
</f></regexp_matched>
		<regexp_matched_pos line="177" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<a>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
	</a>
</f></regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><x path="Bool"/></global>
		<match public="1" set="method" line="36">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.
		
		This method modifies the internal state.
		
		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="45">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.
		
		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.
		
		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.
		
		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="50">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the left of the last matched substring.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, only the
		substring to the left of the leftmost match is returned.
		
		The result does not include the matched part.</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="55">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the right of the last matched substring.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, only the
		substring to the right of the leftmost match is returned.
		
		The result does not include the matched part.</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="61">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="65">
			<f a="s:pos:?len" v="::-1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.
		
		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.match(s.substr(pos,len))` can be used instead.
		
		This method modifies the internal state.
		
		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<split public="1" set="method" line="74">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits String `s` at all substrings `this` EReg matches.
		
		If a match is found at the start of `s`, the result contains a leading
		empty String "" entry.
		
		If a match is found at the end of `s`, the result contains a trailing
		empty String "" entry.
		
		If two matching substrings appear next to each other, the result
		contains the empty String "" between them.
		
		By default, this method splits `s` into two parts at the first matched
		substring. If the global g modifier is in place, `s` is split at each
		matched substring.
		
		If `s` is null, the result is unspecified.</haxe_doc>
		</split>
		<replace public="1" set="method" line="98">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.
		
		If `this` EReg does not match any substring, the result is `s`.
		
		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.
		
		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.
		
		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="149">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Calls the function `f` for the substring of `s` which `this` EReg matches
		and replaces that substring with the result of `f` call.

		The `f` function takes `this` EReg object as its first argument and should
		return a replacement string for the substring matched.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `s` or `f` are null, the result is unspecified.</haxe_doc>
		</map>
		<new public="1" set="method" line="28">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.
		
		This is equivalent to the shorthand syntax `~/r/opt`
		
		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.
	
	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.
	
	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier
	
	EReg instances maintain an internal state, which is affected by several of
	its methods.
	
	A detailed explanation of the supported operations is available at
	http://haxe.org/doc/cross/regexp</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="Enum" params="T" file="C:\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is `EnumValue`.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="IntIterator" params="" file="C:\HaxeToolkit\haxe\std/IntIterator.hx">
		<min><x path="Int"/></min>
		<max><x path="Int"/></max>
		<hasNext public="1" set="method" line="52">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="61">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.
		
		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<new public="1" set="method" line="44">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).
		
		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.
	
	It is usually not used explicitly, but through it's special syntax:
	`min...max`
		
	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="C:\HaxeToolkit\haxe\std/Lambda.hx">
		<array public="1" params="A" set="method" line="42" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="54" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a List form Iterable `it`.

		If `it` is a List, this function returns a copy of it.</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="68" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new List by applying function `f` to all elements of `it`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="82" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<x path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to map, but also passes the index of each element to `f`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="98" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.

		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.

		If no such element is found, the result is false.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="115" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains an element for which `f` is true.

		This function returns true as soon as an element is found for which a
		call to `f` returns true.

		If no such element is found, the result is false.

		If `f` is null, the result is unspecified.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="134" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is true for all elements of `it`.

		This function returns false as soon as an element is found for which a
		call to `f` returns false.

		If no such element is found, the result is true.

		In particular, this function always returns true if `it` is empty.

		If `f` is null, the result is unspecified.</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="146" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls `f` on all elements of `it`, in order.

		If `f` is null, the result is unspecified.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="159" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<x path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Returns a List containing those elements of `it` for which `f` returned
		true.

		If `it` is empty, the result is the empty List even if `f` is null.

		Otherwise if `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="179" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional fold on Iterable `it`, using function `f` with start argument
		`first`.

		If `it` has no elements, the result is `first`.

		Otherwise the first element of `it` is passed to `f` alongside `first`.
		The result of that call is then passed to `f` with the next element of
		`it`, and so on until `it` has no more elements.

		If `it` or `f` are null, the result is unspecified.</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="191" static="1">
			<f a="it:?pred" v=":null">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of elements in `it` for which `pred` is true, or the
		total number of elements in `it` if `pred` is null.

		This function traverses all elements.</haxe_doc>
		</count>
		<empty public="1" params="T" set="method" line="206" static="1">
			<f a="it">
				<t path="Iterable"><c path="empty.T"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if Iterable `it` does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="217" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element `v` within Iterable `it`.

		This function uses operator `==` to check for equality.

		If `v` does not exist in `it`, the result is -1.</haxe_doc>
		</indexOf>
		<find public="1" params="T" set="method" line="237" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="find.T"/></t>
				<f a="">
					<c path="find.T"/>
					<x path="Bool"/>
				</f>
				<t path="Null"><c path="find.T"/></t>
			</f>
			<haxe_doc>Returns the first element of `it` for which `f` is true.

		This function returns as soon as an element is found for which a call to
		`f` returns true.

		If no such element is found, the result is null.

		If `f` is null, the result is unspecified.</haxe_doc>
		</find>
		<concat public="1" params="T" set="method" line="250" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a new List containing all elements of Iterable `a` followed by
		all elements of Iterable `b`.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</concat>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="List" params="T" file="C:\HaxeToolkit\haxe\std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="49">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.
		
		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.
		
		`this.length` increases by 1.</haxe_doc>
		</push>
		<first public="1" set="method" line="81">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.
		
		This function does not modify `this` List.</haxe_doc>
		</first>
		<last public="1" set="method" line="90">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of `this` List, or null if no elements exist.
		
		This function does not modify `this` List.</haxe_doc>
		</last>
		<pop public="1" set="method" line="100">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.
		
		The element is removed from `this` List.</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="114">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if `this` List is empty.</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="124">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.
		
		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="138">
			<f a="v">
				<c path="List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `v` in `this` List.
		
		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.
		
		Otherwise, false is returned.</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="161">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="203">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` List.
		
		The result is enclosed in { } with the individual elements being
		separated by a comma.</haxe_doc>
		</toString>
		<join public="1" set="method" line="224">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` List, with `sep` separating
		each element.</haxe_doc>
		</join>
		<filter public="1" set="method" line="243">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<x path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with `f`. The returned list will contain all
		elements for which `f(x) == true`.</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="259">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted by the
		function `f`.</haxe_doc>
		</map>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
	</class>
	<abstract path="Map" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="Map.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="Map.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="Map.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="Map.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.
		
	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.
	
	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.
	
	Maps can also be created with `key1 => value1, key2 => value2` syntax.
	
	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"><e>K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Map.hx" private="1" module="Map">
	<_new public="1" set="method" static="1">
		<f a=""><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a new Map.
		
		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:
		
		1. if K is a `String`, `haxe.ds.StringMap` is used
		2. if K is an `Int`, `haxe.ds.IntMap` is used
		3. if K is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if K is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if K is any other type, it causes a compile-time error
			
		(Cpp) Map does not use weak keys on ObjectMap by default.</haxe_doc>
	</_new>
	<set public="1" get="inline" set="null" line="70" static="1">
		<f a="this:key:value">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<c path="Map.V"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Maps `key` to `value`.
		
		If `key` already has a mapping, the previous value disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</set>
	<get public="1" get="inline" set="null" line="87" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<t path="Null"><c path="Map.V"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
		<haxe_doc>Returns the current mapping of `key`.
		
		If no such mapping exists, null is returned.
		
		Note that a check like `map.get(key) == null` can hold for two reasons:
		
		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`
		
		If it is important to distinguish these cases, `exists()` should be
		used.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</get>
	<exists public="1" get="inline" set="null" line="94" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns true if `key` has a mapping, false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</exists>
	<remove public="1" get="inline" set="null" line="102" static="1">
		<f a="this:key">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
	</remove>
	<keys public="1" get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<t path="Iterator"><c path="Map.K"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns an Iterator over the keys of `this` Map.
		
		The order of keys is undefined.</haxe_doc>
	</keys>
	<iterator public="1" get="inline" set="null" line="118" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<t path="Iterator"><c path="Map.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns an Iterator over the values of `this` Map.
		
		The order of values is undefined.</haxe_doc>
	</iterator>
	<toString public="1" get="inline" set="null" line="127" static="1">
		<f a="this">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a String representation of `this` Map.
		
		The exact representation depends on the platform and key-type.</haxe_doc>
	</toString>
	<arrayWrite public="1" get="inline" set="null" line="131" static="1">
		<f a="this:k:v">
			<c path="IMap">
				<c path="Map.K"/>
				<c path="Map.V"/>
			</c>
			<c path="Map.K"/>
			<c path="Map.V"/>
			<c path="Map.V"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</arrayWrite>
	<toStringMap get="inline" set="null" line="136" static="1">
		<f a="t">
			<c path="IMap">
				<c path="String"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toStringMap>
	<toIntMap get="inline" set="null" line="140" static="1">
		<f a="t">
			<c path="IMap">
				<x path="Int"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toIntMap>
	<toEnumValueMapMap params="K" get="inline" set="null" line="144" static="1">
		<f a="t">
			<c path="IMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.EnumValueMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="Map.V"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toEnumValueMapMap>
	<toObjectMap params="K" get="inline" set="null" line="148" static="1">
		<f a="t">
			<c path="IMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.ObjectMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toObjectMap>
	<fromStringMap params="V" get="inline" set="null" line="152" static="1">
		<f a="map">
			<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
			<x path="Map">
				<c path="String"/>
				<c path="fromStringMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromStringMap>
	<fromIntMap params="V" get="inline" set="null" line="156" static="1">
		<f a="map">
			<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
			<x path="Map">
				<x path="Int"/>
				<c path="fromIntMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromIntMap>
	<fromObjectMap params="K:V" get="inline" set="null" line="160" static="1">
		<f a="map">
			<c path="haxe.ds.ObjectMap">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</c>
			<x path="Map">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromObjectMap>
</class></impl>
	</abstract>
	<class path="_Map.Map_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Map.hx" private="1" module="Map">
		<_new public="1" set="method" static="1">
			<f a=""><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a new Map.
		
		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:
		
		1. if K is a `String`, `haxe.ds.StringMap` is used
		2. if K is an `Int`, `haxe.ds.IntMap` is used
		3. if K is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if K is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if K is any other type, it causes a compile-time error
			
		(Cpp) Map does not use weak keys on ObjectMap by default.</haxe_doc>
		</_new>
		<set public="1" get="inline" set="null" line="70" static="1">
			<f a="this:key:value">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<c path="Map.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Maps `key` to `value`.
		
		If `key` already has a mapping, the previous value disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="87" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<t path="Null"><c path="Map.V"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
			<haxe_doc>Returns the current mapping of `key`.
		
		If no such mapping exists, null is returned.
		
		Note that a check like `map.get(key) == null` can hold for two reasons:
		
		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`
		
		If it is important to distinguish these cases, `exists()` should be
		used.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="94" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns true if `key` has a mapping, false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="102" static="1">
			<f a="this:key">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<t path="Iterator"><c path="Map.K"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns an Iterator over the keys of `this` Map.
		
		The order of keys is undefined.</haxe_doc>
		</keys>
		<iterator public="1" get="inline" set="null" line="118" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<t path="Iterator"><c path="Map.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns an Iterator over the values of `this` Map.
		
		The order of values is undefined.</haxe_doc>
		</iterator>
		<toString public="1" get="inline" set="null" line="127" static="1">
			<f a="this">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a String representation of `this` Map.
		
		The exact representation depends on the platform and key-type.</haxe_doc>
		</toString>
		<arrayWrite public="1" get="inline" set="null" line="131" static="1">
			<f a="this:k:v">
				<c path="IMap">
					<c path="Map.K"/>
					<c path="Map.V"/>
				</c>
				<c path="Map.K"/>
				<c path="Map.V"/>
				<c path="Map.V"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</arrayWrite>
		<toStringMap get="inline" set="null" line="136" static="1">
			<f a="t">
				<c path="IMap">
					<c path="String"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toStringMap>
		<toIntMap get="inline" set="null" line="140" static="1">
			<f a="t">
				<c path="IMap">
					<x path="Int"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toIntMap>
		<toEnumValueMapMap params="K" get="inline" set="null" line="144" static="1">
			<f a="t">
				<c path="IMap">
					<c path="toEnumValueMapMap.K"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.EnumValueMap">
					<c path="toEnumValueMapMap.K"/>
					<c path="Map.V"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toEnumValueMapMap>
		<toObjectMap params="K" get="inline" set="null" line="148" static="1">
			<f a="t">
				<c path="IMap">
					<c path="toObjectMap.K"/>
					<c path="Map.V"/>
				</c>
				<c path="haxe.ds.ObjectMap">
					<c path="toObjectMap.K"/>
					<c path="Map.V"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toObjectMap>
		<fromStringMap params="V" get="inline" set="null" line="152" static="1">
			<f a="map">
				<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
				<x path="Map">
					<c path="String"/>
					<c path="fromStringMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromStringMap>
		<fromIntMap params="V" get="inline" set="null" line="156" static="1">
			<f a="map">
				<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
				<x path="Map">
					<x path="Int"/>
					<c path="fromIntMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromIntMap>
		<fromObjectMap params="K:V" get="inline" set="null" line="160" static="1">
			<f a="map">
				<c path="haxe.ds.ObjectMap">
					<c path="fromObjectMap.K"/>
					<c path="fromObjectMap.V"/>
				</c>
				<x path="Map">
					<c path="fromObjectMap.K"/>
					<c path="fromObjectMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromObjectMap>
	</class>
	<class path="IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx" module="Map" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<t path="Null"><c path="IMap.V"/></t>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="IMap.K"/>
	<c path="IMap.V"/>
	<x path="Void"/>
</f></set>
		<exists public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<remove public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="IMap.K"/></t></f></keys>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="IMap.V"/></t></f></iterator>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
	</class>
	<typedef path="_Map.Hashable" params="" file="C:\HaxeToolkit\haxe\std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="C:\HaxeToolkit\haxe\std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with NEGATIVE_INFINITY as an operand may result in
		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with NaN as an operand will result in NaN.

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.

		In order to test if a value is NaN, you should use Math.isNaN() function.

		(Php) In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, see:
			https://bugs.php.net/bug.php?id=42143</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is
		POSITIVE_INFINITY.

		If `v` is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are NaN, the result is NaN.

		If `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.

		If `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are NaN, the result is NaN.

		If `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.

		If `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of `v`.

		The unit of `v` is radians.

		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of `v`.

		The unit of `v` is radians.

		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<asin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<atan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.

		If `v` is NEGATIVE_INFINITY, the result is 0.0.

		If `v` is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.

		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.

		If `v` is 0.0, the result is NEGATIVE_INFINITY.

		This is the inverse operation of exp, i.e. log(exp(v)) == v always
		holds.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.

		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.

		If `v` is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest Int value.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.

		TODO: need spec</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest Int value that is not greater than `v`.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.

		TODO: need spec</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest Int value that is not less than `v`.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.

		TODO: need spec</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result is
		false.

		Otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is NaN, the result is true.

		Otherwise the result is false. In particular, both POSITIVE_INFINITY and
		NEGATIVE_INFINITY are not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta><m n=":include"><e>"hxMath"</e></m></meta>
	</class>
	<class path="Reflect" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/Reflect.hx">
		<hasField public="1" set="method" line="24" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.
		
		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.
		
		If `o` is not an object or has no field named `field`, the result is
		null.
		
		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.
		
		If `field` is null, the result is unspecified.
		
		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="32" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.
		
		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.
		
		If `o` or `field` are null, the result is unspecified.
		
		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.
		
		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" get="inline" set="null" line="41" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.
		
		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.
		
		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" line="46" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="53" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.
		
		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="60" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.
		
		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="64" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.
		
		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.
		
		This function is only defined if `a` and `b` are of the same type.
		
		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.
		
		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:
		
		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified
		
		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="68" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.
		
		If `f1` or `f2` are not functions, the result is unspecified.
		
		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="76" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.
		
		The result is true if `v` is one of the following:
			
		- class instance
		- structure
		- Class<T>
		- Enum<T>
			
		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="83" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.
		
		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.
		
		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" line="87" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.
		
		This method is only guaranteed to work on anonymous structures.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="92" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Copies the fields of structure `o`.
		
		This is only guaranteed to work on anonymous structures.
		
		If `o` is null, the result is unspecified.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="104" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="Std" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/Std.hx">
		<is public="1" set="method" line="23" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<instance public="1" params="T:S" set="method" line="27" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Checks if object `value` is an instance of class `c`.
		
		Compiles only if the class specified by `c` can be assigned to the type
		of `value`.
		
		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the class specified by `c`, `value` is
		returned. Otherwise null is returned.
		
		This method is not guaranteed to work with interfaces or core types such
		as String, Array and Date.
		
		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</instance>
		<string public="1" set="method" line="31" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="35" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="39" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is null.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="43" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a NaN value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="47" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="Void" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.
	
	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.
	
	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.
	
	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.
	
	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.
		
		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="C:\HaxeToolkit\haxe\std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.
		
		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.
		
		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.
		
		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.
		
		If `this` String is the empty String "", the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.
		
		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.
		
		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.
		
		If `delimiter` is null, the result is unspecified.
		
		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.
		
		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.
		
		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.
		
		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to `endIndex`.
		
		If `startIndex` or `endIndex` are negative, 0 is used instead.
		
		If `startIndex` exceeds `endIndex`, they are swapped.
		
		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.
		
		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/StringBuf.hx">
		<b><c path="Array"><c path="String"/></c></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<get_length set="method" line="33"><f a=""><x path="Int"/></f></get_length>
		<add public="1" params="T" set="method" line="40">
			<f a="x">
				<c path="add.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.
		
		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).
		
		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="44">
			<f a="s:pos:?len" v="::null">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends a substring of `s` to `this` StringBuf.
		
		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.add(s.substr(pos,len))` can be used instead.
		
		If `s` or `pos` are null, the result is unspecified.
		
		If `len` is omitted or null, the substring ranges from `pos` to the end
		of `s`.</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="48">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character identified by `c` to `this` StringBuf.
		
		If `c` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="52">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.
		
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.
		
		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.
	
	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.
	
	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="StringTools" params="" file="C:\HaxeToolkit\haxe\std/StringTools.hx">
		<urlEncode public="1" get="inline" set="null" line="36" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" get="inline" set="null" line="61" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="97" static="1">
			<f a="s:?quotes" v=":null">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:
			
		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;
		
		If `quotes` is true, the following characters are also replaced:
		
		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="116" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Unescapes HTML special characters of the string `s`.

		This is the inverse operation to htmlEscape, i.e. the following always
		holds: htmlUnescape(htmlEscape(s)) == s

		The replacements follow:
			
		- `&amp;` becomes `&`
		- `&lt;` becomes `<`
		- `&gt;` becomes `>`
		- `&quot;` becomes `"`
		- `&#039;` becomes `'`]]></haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="127" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is null, the result is unspecified.

		If `start` is the empty String "", the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="144" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is null, the result is unspecified.

		If `end` is the empty String "", the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="165" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String "", or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="179" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="204" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="226" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for ltrim(rtrim(s)).</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="248" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String "" or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<rpad public="1" set="method" line="270" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Appends `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String "" or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</rpad>
		<replace public="1" set="method" line="291" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String "", `by` is inserted after each character
		of `s`. If `by` is also the empty String "", `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="313" static="1">
			<f a="n:?digits" v=":null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its length equals `digits`.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="342" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the character code at position `index` of String `s`.

		This method is faster than String.charCodeAt() on most platforms.
		However, unlike String.charCodeAt(), the result is unspecified if
		`index` is negative or exceeds `s.length`.

		This operation is not guaranteed to work if `s` contains the \0
		character.</haxe_doc>
		</fastCodeAt>
		<isEof public="1" get="inline" set="null" line="369" static="1">
			<f a="c">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</isEof>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="Sys" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/Sys.hx">
		<print public="1" set="method" line="24" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="28" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<stdin public="1" set="method" line="33" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See [getChar] for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" line="37" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" line="41" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<getChar public="1" set="method" line="45" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting [echo] to true will also display it on the output.</haxe_doc>
		</getChar>
		<args public="1" set="method" line="49" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the commandline.</haxe_doc>
		</args>
		<getEnv public="1" set="method" line="53" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" line="60" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<sleep public="1" set="method" line="64" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" line="68" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect [DateTools.format] date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" line="72" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="76" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="80" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<escapeArgument set="method" line="84" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" set="method" line="98" static="1">
			<f a="cmd:?args" v=":null">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Run the given command with the list of arguments. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).
		Read the [sys.io.Process] api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" line="107" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" line="111" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" line="115" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" line="119" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<environment public="1" set="method" line="123" static="1">
			<f a=""><c path="haxe.ds.StringMap"><c path="String"/></c></f>
			<haxe_doc>Returns the whole environement variables.</haxe_doc>
		</environment>
		<get_env line="134" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></get_env>
		<put_env line="135" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></put_env>
		<_sleep line="136" static="1"><f a="">
	<x path="Float"/>
	<unknown/>
</f></_sleep>
		<set_time_locale line="137" static="1"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></set_time_locale>
		<get_cwd line="138" static="1"><f a=""><c path="String"/></f></get_cwd>
		<set_cwd line="139" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></set_cwd>
		<sys_string line="140" static="1"><f a=""><c path="String"/></f></sys_string>
		<sys_command line="141" static="1"><f a="">
	<c path="String"/>
	<x path="Int"/>
</f></sys_command>
		<sys_exit line="142" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></sys_exit>
		<sys_time line="143" static="1"><f a=""><x path="Float"/></f></sys_time>
		<sys_cpu_time line="144" static="1"><f a=""><x path="Float"/></f></sys_cpu_time>
		<sys_exe_path line="145" static="1"><f a=""><c path="String"/></f></sys_exe_path>
		<sys_env line="146" static="1"><f a=""><c path="Array"><c path="String"/></c></f></sys_env>
		<file_stdin line="148" static="1"><f a=""><unknown/></f></file_stdin>
		<file_stdout line="149" static="1"><f a=""><unknown/></f></file_stdout>
		<file_stderr line="150" static="1"><f a=""><unknown/></f></file_stderr>
		<getch line="152" static="1"><f a="">
	<x path="Bool"/>
	<x path="Int"/>
</f></getch>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<enum path="ValueType" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
	</enum>
	<class path="Type" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="35" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.
		
		If `o` is null or of a different type, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="46" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.
		
		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.
		
		If `o` is null, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="52" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.
		
		If `c` has no super class, null is returned.
		
		If `c` is null, the result is unspecified.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="56" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.
		
		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `c` has no package, the class name is returned.
		
		If `c` is null, the result is unspecified.
		
		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="62" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.
		
		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `e` has no package, the enum name is returned.
		
		If `e` is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="66" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.
		
		If `name` is the path of an existing class, that class is returned.
		
		Otherwise null is returned.
		
		If `name` is null or the path to a different type, the result is
		unspecified.
		
		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="73" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.
		
		If `name` is the path of an existing enum, that enum is returned.
		
		Otherwise null is returned.
		
		If `name` is null the result is unspecified.
		
		If `name` is the path to a different type, null is returned.
		
		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="80" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.
		
		This function guarantees that the class constructor is called.
		
		Default values of constructors arguments are not guaranteed to be
		taken into account.
		
		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.
		
		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="86" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.
		
		This function guarantees that the class constructor is not called.
		
		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="90" static="1">
			<f a="e:constr:?params" v="::null">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="94" static="1">
			<f a="e:index:?params" v="::null">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="100" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`.
		
		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.
		
		The order of the fields in the returned Array is unspecified.
		
		If `c` is null, the result is unspecified.
		
		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="104" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.
		
		This does not include static fields of parent classes.
		
		The order of the fields in the returned Array is unspecified.
		
		If `c` is null, the result is unspecified.
		
		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="108" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If `c` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="112" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.
		
		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="128" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="132" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.
		
		The result String does not contain any constructor arguments.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="136" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.
		
		If `e` has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="141" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.
		
		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="145" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.
	
	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<enum path="XmlType" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/Xml.hx" module="Xml"><meta><m n=":flatEnum"/></meta></enum>
	<class path="Xml" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Document>
		<_parse line="44" static="1"><f a=":">
	<c path="String"/>
	<a>
		<xml><f a="name:att">
	<c path="String"/>
	<d><c path="String"/></d>
	<x path="Void"/>
</f></xml>
		<pcdata><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></pcdata>
		<done><f a=""><x path="Void"/></f></done>
		<doctype><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></doctype>
		<cur><c path="Xml"/></cur>
		<comment><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></comment>
		<cdata><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></cdata>
	</a>
	<unknown/>
</f></_parse>
		<parse public="1" set="method" line="46" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parse a String into an Xml object.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="110" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="119" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="126" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="133" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="140" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="147" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="154" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<_nodeName><c path="String"/></_nodeName>
		<_nodeValue><c path="String"/></_nodeValue>
		<_attributes><d><c path="String"/></d></_attributes>
		<_children><c path="Array"><c path="Xml"/></c></_children>
		<_parent><c path="Xml"/></_parent>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<get_nodeName set="method" line="168"><f a=""><c path="String"/></f></get_nodeName>
		<set_nodeName set="method" line="174"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeName>
		<get_nodeValue set="method" line="180"><f a=""><c path="String"/></f></get_nodeValue>
		<set_nodeValue set="method" line="186"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_nodeValue>
		<parent public="1" get="accessor" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.</haxe_doc>
		</parent>
		<get_parent set="method" line="193"><f a=""><c path="Xml"/></f></get_parent>
		<get public="1" set="method" line="197">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="203">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<remove public="1" set="method" line="212">
			<f a="att">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an attribute for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="219">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="225">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an [Iterator] on all the attribute names.</haxe_doc>
		</attributes>
		<iterator public="1" set="method" line="231">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="238">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="271">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method" line="305">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node.</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method" line="311">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="322">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="331">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method" line="339">
			<f a="x:pos">
				<c path="Xml"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts a child at the given position among the other childs.</haxe_doc>
		</insertChild>
		<toString public="1" set="method" line="348">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<toStringRec set="method" line="354"><f a="s">
	<c path="StringBuf"/>
	<x path="Void"/>
</f></toStringRec>
		<new set="method" line="41"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="cpp.rtti.FieldNumericIntegerLookup" params="" file="C:\HaxeToolkit\haxe\std/cpp/rtti/FieldNumericIntegerLookup.hx" interface="1"><haxe_doc>If you implement this interface, then the backend will generate code that
	allows fast numeric access to fields by integer id.  This should speed up the CFFI.</haxe_doc></class>
	<class path="cpp.vm.Gc" params="" file="C:\HaxeToolkit\haxe\std/cpp/vm/Gc.hx">
		<MEM_INFO_USAGE public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></MEM_INFO_USAGE>
		<MEM_INFO_RESERVED public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></MEM_INFO_RESERVED>
		<MEM_INFO_CURRENT public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></MEM_INFO_CURRENT>
		<MEM_INFO_LARGE public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></MEM_INFO_LARGE>
		<enable public="1" set="method" line="31" static="1"><f a="inEnable">
	<x path="Bool"/>
	<x path="Void"/>
</f></enable>
		<run public="1" set="method" line="36" static="1"><f a="major">
	<x path="Bool"/>
	<x path="Void"/>
</f></run>
		<compact public="1" set="method" line="41" static="1"><f a=""><x path="Void"/></f></compact>
		<memInfo public="1" set="method" line="53" static="1"><f a="inWhatInfo">
	<x path="Int"/>
	<x path="Int"/>
</f></memInfo>
		<memUsage public="1" set="method" line="58" static="1"><f a=""><x path="Int"/></f></memUsage>
		<trace public="1" set="method" line="63" static="1"><f a="sought:?printInstances" v=":true">
	<x path="Class"><d/></x>
	<x path="Bool"/>
	<x path="Int"/>
</f></trace>
		<versionCheck public="1" set="method" line="68" static="1"><f a=""><x path="Bool"/></f></versionCheck>
		<doNotKill public="1" set="method" line="70" static="1"><f a="inObject">
	<d/>
	<x path="Void"/>
</f></doNotKill>
		<getNextZombie public="1" set="method" line="75" static="1"><f a=""><d/></f></getNextZombie>
		<safePoint public="1" set="method" line="80" static="1"><f a=""><x path="Void"/></f></safePoint>
		<enterGCFreeZone public="1" set="method" line="85" static="1"><f a=""><x path="Void"/></f></enterGCFreeZone>
		<exitGCFreeZone public="1" set="method" line="90" static="1"><f a=""><x path="Void"/></f></exitGCFreeZone>
	</class>
	<class path="cpp.vm.Mutex" params="" file="C:\HaxeToolkit\haxe\std/cpp/vm/Mutex.hx">
		<m><d/></m>
		<acquire public="1" set="method" line="30"><f a=""><x path="Void"/></f></acquire>
		<tryAcquire public="1" set="method" line="33"><f a=""><x path="Bool"/></f></tryAcquire>
		<release public="1" set="method" line="36"><f a=""><x path="Void"/></f></release>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="cpp.vm.ThreadHandle" params="" file="C:\HaxeToolkit\haxe\std/cpp/vm/Thread.hx" module="cpp.vm.Thread"><d/></typedef>
	<class path="cpp.vm.Thread" params="" file="C:\HaxeToolkit\haxe\std/cpp/vm/Thread.hx">
		<current public="1" set="method" line="45" static="1">
			<f a=""><c path="cpp.vm.Thread"/></f>
			<haxe_doc>Returns the current thread.</haxe_doc>
		</current>
		<create public="1" set="method" line="52" static="1">
			<f a="callb">
				<f a=""><x path="Void"/></f>
				<c path="cpp.vm.Thread"/>
			</f>
			<haxe_doc>Creates a new thread that will execute the [callb] function, then exit.</haxe_doc>
		</create>
		<readMessage public="1" set="method" line="61" static="1">
			<f a="block">
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>Reads a message from the thread queue. If [block] is true, the function
		blocks until a message is available. If [block] is false, the function
		returns [null] if no message is available.</haxe_doc>
		</readMessage>
		<handle public="1" set="null"><t path="cpp.vm.ThreadHandle"/></handle>
		<sendMessage public="1" set="method" line="37">
			<f a="msg">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Send a message to the thread queue. This message can be readed by using [readMessage].</haxe_doc>
		</sendMessage>
		<__compare set="method" line="65"><f a="t">
	<a><handle set="null"><t path="cpp.vm.ThreadHandle"/></handle></a>
	<x path="Int"/>
</f></__compare>
		<new set="method" line="30"><f a="h">
	<t path="cpp.vm.ThreadHandle"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="cpp.zip.Compress" params="" file="C:\HaxeToolkit\haxe\std/cpp/zip/Compress.hx"><c path="haxe.zip.Compress"/></typedef>
	<typedef path="cpp.zip.Flush" params="" file="C:\HaxeToolkit\haxe\std/cpp/zip/Flush.hx"><e path="haxe.zip.FlushMode"/></typedef>
	<typedef path="cpp.zip.Uncompress" params="" file="C:\HaxeToolkit\haxe\std/cpp/zip/Uncompress.hx"><c path="haxe.zip.Uncompress"/></typedef>
	<class path="sys.io.Process" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/sys/io/Process.hx">
		<_run line="123" static="1"><f a=":">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<unknown/>
</f></_run>
		<_exit line="124" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></_exit>
		<_pid line="125" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></_pid>
		<_close line="126" static="1"><f a="">
	<d/>
	<unknown/>
</f></_close>
		<p><d/></p>
		<stdout public="1" set="null"><c path="haxe.io.Input"/></stdout>
		<stderr public="1" set="null"><c path="haxe.io.Input"/></stderr>
		<stdin public="1" set="null"><c path="haxe.io.Output"/></stdin>
		<getPid public="1" set="method" line="107"><f a=""><x path="Int"/></f></getPid>
		<exitCode public="1" set="method" line="111"><f a=""><x path="Int"/></f></exitCode>
		<close public="1" set="method" line="115"><f a=""><x path="Void"/></f></close>
		<kill public="1" set="method" line="119"><f a=""><x path="Void"/></f></kill>
		<new public="1" set="method" line="100"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.io.Output" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Output.hx">
		<LN2 line="31" static="1"><x path="Float"/></LN2>
		<_float_bytes line="329" static="1"><f a=":">
	<x path="Float"/>
	<x path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_float_bytes>
		<_double_bytes line="330" static="1"><f a=":">
	<x path="Float"/>
	<x path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_double_bytes>
		<bigEndian public="1" set="accessor"><x path="Bool"/></bigEndian>
		<writeByte public="1" set="method" line="38"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="42"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="65"><f a=""><x path="Void"/></f></flush>
		<close public="1" set="method" line="68"><f a=""><x path="Void"/></f></close>
		<set_bigEndian set="method" line="71"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<write public="1" set="method" line="78"><f a="s">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></write>
		<writeFullBytes public="1" set="method" line="89"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeFullBytes>
		<writeFloat public="1" set="method" line="97"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method" line="151"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeInt8 public="1" set="method" line="228"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt8>
		<writeInt16 public="1" set="method" line="234"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt16>
		<writeUInt16 public="1" set="method" line="239"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUInt16>
		<writeInt24 public="1" set="method" line="250"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt24>
		<writeUInt24 public="1" set="method" line="255"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUInt24>
		<writeInt32 public="1" set="method" line="268"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt32>
		<prepare public="1" set="method" line="288">
			<f a="nbytes">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeInput public="1" set="method" line="291"><f a="i:?bufsize" v=":null">
	<c path="haxe.io.Input"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeInput>
		<writeString public="1" set="method" line="313"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
	</class>
	<class path="sys.io._Process.Stdin" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Output"/>
		<_stdin_write line="53" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stdin_write>
		<_stdin_close line="54" static="1"><f a="">
	<d/>
	<unknown/>
</f></_stdin_close>
		<p><d/></p>
		<buf><c path="haxe.io.Bytes"/></buf>
		<close public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></close>
		<writeByte public="1" set="method" line="39" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="44" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<new public="1" set="method" line="29"><f a="p">
	<unknown/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="267" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="292" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="341" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<fastGet public="1" get="inline" set="null" line="359" static="1">
			<f a="b:pos">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read the most efficiently possible the n-th byte of the data.
		Behavior when reading outside of the available data is unspecified.</haxe_doc>
		</fastGet>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="34"><f a="pos">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="50"><f a="pos:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<blit public="1" set="method" line="68"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<fill public="1" set="method" line="99"><f a="pos:len:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fill>
		<sub public="1" set="method" line="116"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="142"><f a="other">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></compare>
		<readString public="1" set="method" line="180"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="228"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method" line="249"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="263"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="29"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Input" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Input.hx">
		<_float_of_bytes line="343" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></_float_of_bytes>
		<_double_of_bytes line="344" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></_double_of_bytes>
		<bigEndian public="1" set="accessor"><x path="Bool"/></bigEndian>
		<readByte public="1" set="method" line="37"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="46"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="67"><f a=""><x path="Void"/></f></close>
		<set_bigEndian set="method" line="70"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<readAll public="1" set="method" line="77"><f a="?bufsize" v="null">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" set="method" line="99"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readFullBytes>
		<read public="1" set="method" line="107"><f a="nbytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" set="method" line="119"><f a="end">
	<x path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" set="method" line="127"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" set="method" line="144"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="198"><f a=""><x path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="271"><f a=""><x path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="278"><f a=""><x path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="287"><f a=""><x path="Int"/></f></readUInt16>
		<readInt24 public="1" set="method" line="293"><f a=""><x path="Int"/></f></readInt24>
		<readUInt24 public="1" set="method" line="303"><f a=""><x path="Int"/></f></readUInt24>
		<readInt32 public="1" set="method" line="310"><f a=""><x path="Int"/></f></readInt32>
		<readString public="1" set="method" line="326"><f a="len">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
	</class>
	<class path="sys.io._Process.Stdout" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Input"/>
		<_stdout_read line="87" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stdout_read>
		<_stderr_read line="88" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stderr_read>
		<p><d/></p>
		<out><x path="Bool"/></out>
		<buf><c path="haxe.io.Bytes"/></buf>
		<readByte public="1" set="method" line="70" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="76" override="1"><f a="str:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="64"><f a="p:out">
	<unknown/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.Lib" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/Lib.hx">
		<FULLSCREEN public="1" line="20" static="1"><x path="Int"/></FULLSCREEN>
		<BORDERLESS public="1" line="21" static="1"><x path="Int"/></BORDERLESS>
		<RESIZABLE public="1" line="22" static="1"><x path="Int"/></RESIZABLE>
		<HARDWARE public="1" line="23" static="1"><x path="Int"/></HARDWARE>
		<VSYNC public="1" line="24" static="1"><x path="Int"/></VSYNC>
		<HW_AA public="1" line="25" static="1"><x path="Int"/></HW_AA>
		<HW_AA_HIRES public="1" line="26" static="1"><x path="Int"/></HW_AA_HIRES>
		<ALLOW_SHADERS public="1" line="27" static="1"><x path="Int"/></ALLOW_SHADERS>
		<REQUIRE_SHADERS public="1" line="28" static="1"><x path="Int"/></REQUIRE_SHADERS>
		<DEPTH_BUFFER public="1" line="29" static="1"><x path="Int"/></DEPTH_BUFFER>
		<STENCIL_BUFFER public="1" line="30" static="1"><x path="Int"/></STENCIL_BUFFER>
		<company public="1" set="null" static="1"><c path="String"/></company>
		<current public="1" get="accessor" set="null" static="1"><c path="flash.display.MovieClip"/></current>
		<file public="1" set="null" static="1"><c path="String"/></file>
		<initHeight public="1" set="null" static="1"><x path="Int"/></initHeight>
		<initWidth public="1" set="null" static="1"><x path="Int"/></initWidth>
		<packageName public="1" set="null" static="1"><c path="String"/></packageName>
		<silentRecreate public="1" line="38" static="1"><x path="Bool"/></silentRecreate>
		<stage public="1" get="accessor" set="null" static="1"><c path="flash.display.Stage"/></stage>
		<version public="1" set="null" static="1"><c path="String"/></version>
		<__current line="42" static="1">
			<c path="flash.display.MovieClip"/>
			<meta><m n=":noCompletion"/></meta>
		</__current>
		<__isInit line="43" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__isInit>
		<__loadedNekoAPI static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__loadedNekoAPI>
		<__mainFrame line="45" static="1">
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__mainFrame>
		<__moduleNames line="46" static="1">
			<x path="Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__moduleNames>
		<__stage line="47" static="1">
			<c path="flash.display.Stage"/>
			<meta><m n=":noCompletion"/></meta>
		</__stage>
		<as public="1" params="T" get="inline" set="null" line="50" static="1"><f a="v:c">
	<d/>
	<x path="Class"><c path="as.T"/></x>
	<t path="Null"><c path="as.T"/></t>
</f></as>
		<attach public="1" set="method" line="57" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<close public="1" set="method" line="64" static="1"><f a=""><x path="Void"/></f></close>
		<create public="1" set="method" line="73" static="1"><f a="onLoaded:width:height:?frameRate:?color:?flags:?title:?icon:?stageClass" v=":::60.0f:16777215:15:'OpenFL':null:null">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="flash.display.BitmapData"/>
	<x path="Class"><c path="flash.display.Stage"/></x>
	<x path="Void"/>
</f></create>
		<createManagedStage public="1" set="method" line="125" static="1"><f a="width:height:?flags" v="::0">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl.display.ManagedStage"/>
</f></createManagedStage>
		<findHaxeLib set="method" line="138" static="1"><f a="library">
	<c path="String"/>
	<c path="String"/>
</f></findHaxeLib>
		<load public="1" set="method" line="179" static="1"><f a="library:method:?args" v="::0">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<loaderTrace set="method" line="254" static="1"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></loaderTrace>
		<rethrow public="1" set="method" line="272" static="1"><f a="error">
	<d/>
	<x path="Void"/>
</f></rethrow>
		<sysName set="method" line="311" static="1"><f a=""><c path="String"/></f></sysName>
		<tryLoad set="method" line="323" static="1"><f a="name:library:func:args">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></tryLoad>
		<exit public="1" set="method" line="382" static="1"><f a=""><x path="Void"/></f></exit>
		<forceClose public="1" set="method" line="403" static="1"><f a=""><x path="Void"/></f></forceClose>
		<getTimer public="1" set="method" line="411" static="1"><f a=""><x path="Int"/></f></getTimer>
		<getURL public="1" set="method" line="418" static="1"><f a="url:?target" v=":null">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<x path="Void"/>
</f></getURL>
		<pause public="1" set="method" line="425" static="1"><f a=""><x path="Void"/></f></pause>
		<postUICallback public="1" set="method" line="432" static="1"><f a="inCallback">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></postUICallback>
		<resume public="1" set="method" line="443" static="1"><f a=""><x path="Void"/></f></resume>
		<setIcon public="1" set="method" line="450" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></setIcon>
		<setPackage public="1" set="method" line="458" static="1"><f a="company:file:packageName:version">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setPackage>
		<__setCurrentStage public="1" set="method" line="470" static="1">
			<f a="stage">
				<c path="flash.display.Stage"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setCurrentStage>
		<trace public="1" set="method" line="477" static="1"><f a="arg">
	<d/>
	<x path="Void"/>
</f></trace>
		<get_current set="method" line="491" static="1"><f a=""><c path="flash.display.MovieClip"/></f></get_current>
		<get_stage set="method" line="510" static="1"><f a=""><c path="flash.display.Stage"/></f></get_stage>
		<lime_set_package line="533" static="1"><f a=":::">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></lime_set_package>
		<lime_get_frame_stage line="534" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_get_frame_stage>
		<lime_get_url line="535" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></lime_get_url>
		<lime_pause_animation line="536" static="1"><f a=""><unknown/></f></lime_pause_animation>
		<lime_resume_animation line="537" static="1"><f a=""><unknown/></f></lime_resume_animation>
	</class>
	<class path="flash.Memory" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/Memory.hx">
		<gcRef static="1"><c path="flash.utils.ByteArray"/></gcRef>
		<len static="1"><x path="Int"/></len>
		<select public="1" set="method" line="20" static="1"><f a="bytes">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></select>
		<getByte public="1" set="method" line="136" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Int"/>
</f></getByte>
		<getDouble public="1" set="method" line="144" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getFloat public="1" set="method" line="152" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat>
		<getI32 public="1" set="method" line="160" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Int"/>
</f></getI32>
		<getUI16 public="1" set="method" line="168" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Int"/>
</f></getUI16>
		<setByte public="1" set="method" line="176" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setByte>
		<setDouble public="1" set="method" line="184" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setDouble>
		<setFloat public="1" set="method" line="192" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setI16 public="1" set="method" line="200" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setI16>
		<setI32 public="1" set="method" line="208" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setI32>
	</class>
	<abstract path="flash.Vector" params="T" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/Vector.hx">
		<from><icast><c path="Array"><c path="flash.Vector.T"/></c></icast></from>
		<this><c path="Array"><c path="flash.Vector.T"/></c></this>
		<to><icast><c path="Array"><c path="flash.Vector.T"/></c></icast></to>
		<meta><m n=":arrayAccess"/></meta>
		<impl><class path="flash._Vector.Vector_Impl_" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/Vector.hx" private="1" module="flash.Vector">
	<length public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<fixed public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</fixed>
	<_new public="1" set="method" line="11" static="1">
		<f a="?length:?fixed" v="null:null">
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="flash.Vector.T"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<concat public="1" set="method" line="18" static="1">
		<f a="this:?a" v=":null">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<c path="Array"><c path="flash.Vector.T"/></c>
			<x path="flash.Vector"><c path="flash.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</concat>
	<copy public="1" set="method" line="25" static="1">
		<f a="this">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<x path="flash.Vector"><c path="flash.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</copy>
	<iterator public="1" params="T" set="method" line="32" static="1">
		<f a="this">
			<c path="Array"><c path="iterator.T"/></c>
			<t path="Iterator"><c path="iterator.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<join public="1" set="method" line="39" static="1">
		<f a="this:sep">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</join>
	<pop public="1" get="inline" set="null" line="46" static="1">
		<f a="this">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<t path="Null"><c path="flash.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</pop>
	<push public="1" get="inline" set="null" line="53" static="1">
		<f a="this:x">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<c path="flash.Vector.T"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<reverse public="1" set="method" line="60" static="1">
		<f a="this">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</reverse>
	<shift public="1" get="inline" set="null" line="67" static="1">
		<f a="this">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<t path="Null"><c path="flash.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</shift>
	<unshift public="1" get="inline" set="null" line="74" static="1">
		<f a="this:x">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<c path="flash.Vector.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</unshift>
	<slice public="1" set="method" line="81" static="1">
		<f a="this:?pos:?end" v=":null:null">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="flash.Vector"><c path="flash.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</slice>
	<sort public="1" set="method" line="88" static="1">
		<f a="this:f">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<f a=":">
				<c path="flash.Vector.T"/>
				<c path="flash.Vector.T"/>
				<x path="Int"/>
			</f>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</sort>
	<splice public="1" set="method" line="95" static="1">
		<f a="this:pos:len">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="flash.Vector"><c path="flash.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</splice>
	<toString public="1" set="method" line="102" static="1">
		<f a="this">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<indexOf public="1" set="method" line="109" static="1">
		<f a="this:x:?from" v="::0">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<c path="flash.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</indexOf>
	<lastIndexOf public="1" set="method" line="126" static="1">
		<f a="this:x:?from" v="::0">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<c path="flash.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</lastIndexOf>
	<ofArray public="1" params="T" get="inline" set="null" line="142" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="flash.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
	<convert public="1" params="T:U" get="inline" set="null" line="149" static="1"><f a="v">
	<c path="Array"><c path="convert.T"/></c>
	<x path="flash.Vector"><c path="convert.U"/></x>
</f></convert>
	<get_length get="inline" set="null" line="163" static="1">
		<f a="this">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<set_length get="inline" set="null" line="170" static="1">
		<f a="this:value">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_length>
	<get_fixed get="inline" set="null" line="177" static="1">
		<f a="this">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_fixed>
	<set_fixed get="inline" set="null" line="184" static="1">
		<f a="this:value">
			<c path="Array"><c path="flash.Vector.T"/></c>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_fixed>
</class></impl>
	</abstract>
	<class path="flash._Vector.Vector_Impl_" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/Vector.hx" private="1" module="flash.Vector">
		<length public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<fixed public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</fixed>
		<_new public="1" set="method" line="11" static="1">
			<f a="?length:?fixed" v="null:null">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="flash.Vector.T"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<concat public="1" set="method" line="18" static="1">
			<f a="this:?a" v=":null">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<c path="Array"><c path="flash.Vector.T"/></c>
				<x path="flash.Vector"><c path="flash.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</concat>
		<copy public="1" set="method" line="25" static="1">
			<f a="this">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<x path="flash.Vector"><c path="flash.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</copy>
		<iterator public="1" params="T" set="method" line="32" static="1">
			<f a="this">
				<c path="Array"><c path="iterator.T"/></c>
				<t path="Iterator"><c path="iterator.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<join public="1" set="method" line="39" static="1">
			<f a="this:sep">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</join>
		<pop public="1" get="inline" set="null" line="46" static="1">
			<f a="this">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<t path="Null"><c path="flash.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</pop>
		<push public="1" get="inline" set="null" line="53" static="1">
			<f a="this:x">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<c path="flash.Vector.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<reverse public="1" set="method" line="60" static="1">
			<f a="this">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
		<shift public="1" get="inline" set="null" line="67" static="1">
			<f a="this">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<t path="Null"><c path="flash.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</shift>
		<unshift public="1" get="inline" set="null" line="74" static="1">
			<f a="this:x">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<c path="flash.Vector.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</unshift>
		<slice public="1" set="method" line="81" static="1">
			<f a="this:?pos:?end" v=":null:null">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="flash.Vector"><c path="flash.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</slice>
		<sort public="1" set="method" line="88" static="1">
			<f a="this:f">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<f a=":">
					<c path="flash.Vector.T"/>
					<c path="flash.Vector.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</sort>
		<splice public="1" set="method" line="95" static="1">
			<f a="this:pos:len">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="flash.Vector"><c path="flash.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</splice>
		<toString public="1" set="method" line="102" static="1">
			<f a="this">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<indexOf public="1" set="method" line="109" static="1">
			<f a="this:x:?from" v="::0">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<c path="flash.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</indexOf>
		<lastIndexOf public="1" set="method" line="126" static="1">
			<f a="this:x:?from" v="::0">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<c path="flash.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</lastIndexOf>
		<ofArray public="1" params="T" get="inline" set="null" line="142" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="flash.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="149" static="1"><f a="v">
	<c path="Array"><c path="convert.T"/></c>
	<x path="flash.Vector"><c path="convert.U"/></x>
</f></convert>
		<get_length get="inline" set="null" line="163" static="1">
			<f a="this">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<set_length get="inline" set="null" line="170" static="1">
			<f a="this:value">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_length>
		<get_fixed get="inline" set="null" line="177" static="1">
			<f a="this">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_fixed>
		<set_fixed get="inline" set="null" line="184" static="1">
			<f a="this:value">
				<c path="Array"><c path="flash.Vector.T"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_fixed>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/IEventDispatcher.hx" interface="1">
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<t path="flash.events.Function"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<t path="flash.events.Function"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/EventDispatcher.hx">
		<implements path="flash.events.IEventDispatcher"/>
		<__sortEvents get="inline" set="null" line="212" static="1">
			<f a="a:b">
				<c path="flash.events.Listener"/>
				<c path="flash.events.Listener"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__sortEvents>
		<__eventMap>
			<t path="flash.events.EventMap"/>
			<meta><m n=":noCompletion"/></meta>
		</__eventMap>
		<__target>
			<c path="flash.events.IEventDispatcher"/>
			<meta><m n=":noCompletion"/></meta>
		</__target>
		<addEventListener public="1" set="method" line="24"><f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
	<c path="String"/>
	<t path="flash.events.Function"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method" line="54"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method" line="123"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method" line="148"><f a="type:listener:?capture" v="::false">
	<c path="String"/>
	<t path="flash.events.Function"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<toString public="1" set="method" line="178"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method" line="185"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<__dispatchCompleteEvent public="1" set="method" line="198">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__dispatchCompleteEvent>
		<__dispatchIOErrorEvent public="1" set="method" line="205">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__dispatchIOErrorEvent>
		<new public="1" set="method" line="16"><f a="?target" v="null">
	<c path="flash.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/IBitmapDrawable.hx" interface="1"><__drawToSurface public="1" set="method">
	<f a="surface:matrix:colorTransform:blendMode:clipRect:smoothing">
		<d/>
		<c path="flash.geom.Matrix"/>
		<c path="flash.geom.ColorTransform"/>
		<c path="String"/>
		<c path="flash.geom.Rectangle"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":noCompletion"/></meta>
</__drawToSurface></class>
	<class path="flash.display.DisplayObject" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/DisplayObject.hx">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<lime_create_display_object line="768" static="1"><f a=""><unknown/></f></lime_create_display_object>
		<lime_display_object_get_graphics line="769" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_display_object_get_graphics>
		<lime_display_object_draw_to_surface line="770" static="1"><f a=":::::">
	<d/>
	<d/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<c path="String"/>
	<c path="flash.geom.Rectangle"/>
	<unknown/>
</f></lime_display_object_draw_to_surface>
		<lime_display_object_get_id line="771" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_display_object_get_id>
		<lime_display_object_get_x line="772" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_x>
		<lime_display_object_set_x line="773" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_display_object_set_x>
		<lime_display_object_get_y line="774" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_y>
		<lime_display_object_set_y line="775" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_display_object_set_y>
		<lime_display_object_get_z line="776" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_z>
		<lime_display_object_set_z line="777" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_display_object_set_z>
		<lime_display_object_get_scale_x line="778" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_scale_x>
		<lime_display_object_set_scale_x line="779" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_display_object_set_scale_x>
		<lime_display_object_get_scale_y line="780" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_scale_y>
		<lime_display_object_set_scale_y line="781" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_display_object_set_scale_y>
		<lime_display_object_get_mouse_x line="782" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_mouse_x>
		<lime_display_object_get_mouse_y line="783" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_mouse_y>
		<lime_display_object_get_rotation line="784" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_rotation>
		<lime_display_object_set_rotation line="785" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_display_object_set_rotation>
		<lime_display_object_get_bg line="786" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_display_object_get_bg>
		<lime_display_object_set_bg line="787" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_display_object_set_bg>
		<lime_display_object_get_name line="788" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_display_object_get_name>
		<lime_display_object_set_name line="789" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></lime_display_object_set_name>
		<lime_display_object_get_width line="790" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_width>
		<lime_display_object_set_width line="791" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_display_object_set_width>
		<lime_display_object_get_height line="792" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_height>
		<lime_display_object_set_height line="793" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_display_object_set_height>
		<lime_display_object_get_alpha line="794" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_display_object_get_alpha>
		<lime_display_object_set_alpha line="795" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_display_object_set_alpha>
		<lime_display_object_get_blend_mode line="796" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_display_object_get_blend_mode>
		<lime_display_object_set_blend_mode line="797" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_display_object_set_blend_mode>
		<lime_display_object_get_cache_as_bitmap line="798" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_display_object_get_cache_as_bitmap>
		<lime_display_object_set_cache_as_bitmap line="799" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_display_object_set_cache_as_bitmap>
		<lime_display_object_get_pedantic_bitmap_caching line="800" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_display_object_get_pedantic_bitmap_caching>
		<lime_display_object_set_pedantic_bitmap_caching line="801" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_display_object_set_pedantic_bitmap_caching>
		<lime_display_object_get_pixel_snapping line="802" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_display_object_get_pixel_snapping>
		<lime_display_object_set_pixel_snapping line="803" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_display_object_set_pixel_snapping>
		<lime_display_object_get_visible line="804" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_display_object_get_visible>
		<lime_display_object_set_visible line="805" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_display_object_set_visible>
		<lime_display_object_set_filters line="806" static="1"><f a=":">
	<d/>
	<c path="Array"><d/></c>
	<unknown/>
</f></lime_display_object_set_filters>
		<lime_display_object_global_to_local line="807" static="1"><f a=":">
	<d/>
	<c path="flash.geom.Point"/>
	<unknown/>
</f></lime_display_object_global_to_local>
		<lime_display_object_local_to_global line="808" static="1"><f a=":">
	<d/>
	<c path="flash.geom.Point"/>
	<unknown/>
</f></lime_display_object_local_to_global>
		<lime_display_object_set_scale9_grid line="809" static="1"><f a=":">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<unknown/>
</f></lime_display_object_set_scale9_grid>
		<lime_display_object_set_scroll_rect line="810" static="1"><f a=":">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<unknown/>
</f></lime_display_object_set_scroll_rect>
		<lime_display_object_set_mask line="811" static="1"><f a=":">
	<d/>
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_display_object_set_mask>
		<lime_display_object_set_matrix line="812" static="1"><f a=":">
	<d/>
	<c path="flash.geom.Matrix"/>
	<unknown/>
</f></lime_display_object_set_matrix>
		<lime_display_object_get_matrix line="813" static="1"><f a="::">
	<d/>
	<c path="flash.geom.Matrix"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_display_object_get_matrix>
		<lime_display_object_get_color_transform line="814" static="1"><f a="::">
	<d/>
	<c path="flash.geom.ColorTransform"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_display_object_get_color_transform>
		<lime_display_object_set_color_transform line="815" static="1"><f a=":">
	<d/>
	<c path="flash.geom.ColorTransform"/>
	<unknown/>
</f></lime_display_object_set_color_transform>
		<lime_display_object_get_pixel_bounds line="816" static="1"><f a=":">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<unknown/>
</f></lime_display_object_get_pixel_bounds>
		<lime_display_object_get_bounds line="817" static="1"><f a=":::">
	<d/>
	<d/>
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_display_object_get_bounds>
		<lime_display_object_hit_test_point line="818" static="1"><f a="::::">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></lime_display_object_hit_test_point>
		<alpha public="1" get="accessor" set="accessor"><x path="Float"/></alpha>
		<blendMode public="1" get="accessor" set="accessor"><e path="flash.display.BlendMode"/></blendMode>
		<cacheAsBitmap public="1" get="accessor" set="accessor"><x path="Bool"/></cacheAsBitmap>
		<filters public="1" get="accessor" set="accessor"><c path="Array"><d/></c></filters>
		<graphics public="1" get="accessor" set="null"><c path="flash.display.Graphics"/></graphics>
		<height public="1" get="accessor" set="accessor"><x path="Float"/></height>
		<loaderInfo public="1"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<mask public="1" set="accessor"><c path="flash.display.DisplayObject"/></mask>
		<mouseX public="1" get="accessor" set="null"><x path="Float"/></mouseX>
		<mouseY public="1" get="accessor" set="null"><x path="Float"/></mouseY>
		<name public="1" get="accessor" set="accessor"><c path="String"/></name>
		<opaqueBackground public="1" get="accessor" set="accessor"><t path="Null"><x path="Int"/></t></opaqueBackground>
		<parent public="1" get="accessor" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<pedanticBitmapCaching public="1" get="accessor" set="accessor"><x path="Bool"/></pedanticBitmapCaching>
		<pixelSnapping public="1" get="accessor" set="accessor"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<rotation public="1" get="accessor" set="accessor"><x path="Float"/></rotation>
		<scale9Grid public="1" get="accessor" set="accessor"><c path="flash.geom.Rectangle"/></scale9Grid>
		<scaleX public="1" get="accessor" set="accessor"><x path="Float"/></scaleX>
		<scaleY public="1" get="accessor" set="accessor"><x path="Float"/></scaleY>
		<scrollRect public="1" get="accessor" set="accessor"><c path="flash.geom.Rectangle"/></scrollRect>
		<stage public="1" get="accessor" set="null"><c path="flash.display.Stage"/></stage>
		<transform public="1" get="accessor" set="accessor"><c path="flash.geom.Transform"/></transform>
		<visible public="1" get="accessor" set="accessor"><x path="Bool"/></visible>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<z public="1" get="accessor" set="accessor"><x path="Float"/></z>
		<__handle public="1">
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<__filters>
			<c path="Array"><d/></c>
			<meta><m n=":noCompletion"/></meta>
		</__filters>
		<__graphicsCache>
			<c path="flash.display.Graphics"/>
			<meta><m n=":noCompletion"/></meta>
		</__graphicsCache>
		<__id>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__id>
		<__parent>
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":noCompletion"/></meta>
		</__parent>
		<__scale9Grid>
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__scale9Grid>
		<__scrollRect>
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__scrollRect>
		<dispatchEvent public="1" set="method" line="68" override="1"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<getBounds public="1" set="method" line="86"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method" line="95"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1" set="method" line="104"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<hitTestObject public="1" set="method" line="113"><f a="object">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method" line="140"><f a="x:y:?shapeFlag" v="::false">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></hitTestPoint>
		<localToGlobal public="1" set="method" line="147"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<toString public="1" set="method" line="156" override="1"><f a=""><c path="String"/></f></toString>
		<__asInteractiveObject set="method" line="163">
			<f a=""><c path="flash.display.InteractiveObject"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__asInteractiveObject>
		<__broadcast public="1" set="method" line="170">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__broadcast>
		<__contains public="1" set="method" line="177">
			<f a="child">
				<c path="flash.display.DisplayObject"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__contains>
		<__dispatchEvent public="1" set="method" line="184">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__dispatchEvent>
		<__drawToSurface public="1" set="method" line="198">
			<f a="surface:matrix:colorTransform:blendMode:clipRect:smoothing">
				<d/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<c path="String"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__drawToSurface>
		<__findByID set="method" line="205">
			<f a="id">
				<x path="Int"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__findByID>
		<__fireEvent set="method" line="218">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fireEvent>
		<__getColorTransform public="1" set="method" line="281">
			<f a=""><c path="flash.geom.ColorTransform"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getColorTransform>
		<__getConcatenatedColorTransform public="1" set="method" line="290">
			<f a=""><c path="flash.geom.ColorTransform"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getConcatenatedColorTransform>
		<__getConcatenatedMatrix public="1" set="method" line="299">
			<f a=""><c path="flash.geom.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getConcatenatedMatrix>
		<__getInteractiveObjectStack public="1" set="method" line="308">
			<f a="stack">
				<c path="Array"><c path="flash.display.InteractiveObject"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getInteractiveObjectStack>
		<__getMatrix public="1" set="method" line="327">
			<f a=""><c path="flash.geom.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getMatrix>
		<__getObjectsUnderPoint public="1" set="method" line="336">
			<f a="point:result">
				<c path="flash.geom.Point"/>
				<c path="Array"><c path="flash.display.DisplayObject"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getObjectsUnderPoint>
		<__getPixelBounds public="1" set="method" line="347">
			<f a=""><c path="flash.geom.Rectangle"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getPixelBounds>
		<__onAdded set="method" line="356">
			<f a="object:isOnStage">
				<c path="flash.display.DisplayObject"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onAdded>
		<__onRemoved set="method" line="377">
			<f a="object:wasOnStage">
				<c path="flash.display.DisplayObject"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onRemoved>
		<__setColorTransform public="1" set="method" line="398">
			<f a="colorTransform">
				<c path="flash.geom.ColorTransform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setColorTransform>
		<__setMatrix public="1" set="method" line="405">
			<f a="matrix">
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setMatrix>
		<__setParent public="1" set="method" line="412">
			<f a="parent">
				<c path="flash.display.DisplayObjectContainer"/>
				<c path="flash.display.DisplayObjectContainer"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setParent>
		<get_alpha set="method" line="455"><f a=""><x path="Float"/></f></get_alpha>
		<set_alpha set="method" line="456"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<get_opaqueBackground set="method" line="464"><f a=""><t path="Null"><x path="Int"/></t></f></get_opaqueBackground>
		<set_opaqueBackground set="method" line="479"><f a="value">
	<t path="Null"><x path="Int"/></t>
	<t path="Null"><x path="Int"/></t>
</f></set_opaqueBackground>
		<get_blendMode set="method" line="496"><f a=""><e path="flash.display.BlendMode"/></f></get_blendMode>
		<set_blendMode set="method" line="504"><f a="value">
	<e path="flash.display.BlendMode"/>
	<e path="flash.display.BlendMode"/>
</f></set_blendMode>
		<get_cacheAsBitmap set="method" line="512"><f a=""><x path="Bool"/></f></get_cacheAsBitmap>
		<set_cacheAsBitmap set="method" line="513"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_cacheAsBitmap>
		<get_pedanticBitmapCaching set="method" line="521"><f a=""><x path="Bool"/></f></get_pedanticBitmapCaching>
		<set_pedanticBitmapCaching set="method" line="522"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pedanticBitmapCaching>
		<get_pixelSnapping set="method" line="530"><f a=""><e path="flash.display.PixelSnapping"/></f></get_pixelSnapping>
		<set_pixelSnapping set="method" line="538"><f a="value">
	<e path="flash.display.PixelSnapping"/>
	<e path="flash.display.PixelSnapping"/>
</f></set_pixelSnapping>
		<get_filters set="method" line="555"><f a=""><c path="Array"><d/></c></f></get_filters>
		<set_filters set="method" line="571"><f a="value">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_filters>
		<get_graphics set="method" line="599"><f a=""><c path="flash.display.Graphics"/></f></get_graphics>
		<get_height set="method" line="612"><f a=""><x path="Float"/></f></get_height>
		<set_height set="method" line="613"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<set_mask set="method" line="621"><f a="value">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></set_mask>
		<get_mouseX set="method" line="630"><f a=""><x path="Float"/></f></get_mouseX>
		<get_mouseY set="method" line="631"><f a=""><x path="Float"/></f></get_mouseY>
		<get_name set="method" line="634"><f a=""><c path="String"/></f></get_name>
		<set_name set="method" line="635"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<get_parent set="method" line="643"><f a=""><c path="flash.display.DisplayObjectContainer"/></f></get_parent>
		<get_rotation set="method" line="646"><f a=""><x path="Float"/></f></get_rotation>
		<set_rotation set="method" line="647"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<get_scale9Grid set="method" line="655"><f a=""><c path="flash.geom.Rectangle"/></f></get_scale9Grid>
		<set_scale9Grid set="method" line="656"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_scale9Grid>
		<get_scaleX set="method" line="665"><f a=""><x path="Float"/></f></get_scaleX>
		<set_scaleX set="method" line="666"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<get_scaleY set="method" line="674"><f a=""><x path="Float"/></f></get_scaleY>
		<set_scaleY set="method" line="675"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<get_scrollRect set="method" line="683"><f a=""><c path="flash.geom.Rectangle"/></f></get_scrollRect>
		<set_scrollRect set="method" line="684"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_scrollRect>
		<get_stage set="method" line="693"><f a=""><c path="flash.display.Stage"/></f></get_stage>
		<get_transform set="method" line="706"><f a=""><c path="flash.geom.Transform"/></f></get_transform>
		<set_transform set="method" line="707"><f a="value">
	<c path="flash.geom.Transform"/>
	<c path="flash.geom.Transform"/>
</f></set_transform>
		<get_visible set="method" line="716"><f a=""><x path="Bool"/></f></get_visible>
		<set_visible set="method" line="717"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<get_width set="method" line="725"><f a=""><x path="Float"/></f></get_width>
		<set_width set="method" line="726"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<get_x set="method" line="734"><f a=""><x path="Float"/></f></get_x>
		<set_x set="method" line="735"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_y set="method" line="743"><f a=""><x path="Float"/></f></get_y>
		<set_y set="method" line="744"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_z set="method" line="752"><f a=""><x path="Float"/></f></get_z>
		<set_z set="method" line="753"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<new public="1" set="method" line="56"><f a="handle:type">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.Bitmap" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/Bitmap.hx">
		<extends path="flash.display.DisplayObject"/>
		<bitmapData public="1" set="accessor"><c path="flash.display.BitmapData"/></bitmapData>
		<smoothing public="1" set="accessor"><x path="Bool"/></smoothing>
		<__rebuild set="method" line="35">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__rebuild>
		<set_bitmapData set="method" line="62"><f a="value">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
</f></set_bitmapData>
		<set_smoothing set="method" line="72"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_smoothing>
		<new public="1" set="method" line="15"><f a="?bitmapData:?pixelSnapping:?smoothing" v="null:null:false">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.BitmapData" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/BitmapData.hx">
		<implements path="flash.display.IBitmapDrawable"/>
		<CLEAR public="1" get="inline" set="null" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":deprecated"/></meta>
		</CLEAR>
		<BLACK public="1" get="inline" set="null" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":deprecated"/></meta>
		</BLACK>
		<WHITE public="1" get="inline" set="null" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":deprecated"/></meta>
		</WHITE>
		<RED public="1" get="inline" set="null" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":deprecated"/></meta>
		</RED>
		<GREEN public="1" get="inline" set="null" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":deprecated"/></meta>
		</GREEN>
		<BLUE public="1" get="inline" set="null" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":deprecated"/></meta>
		</BLUE>
		<PNG public="1" get="inline" set="null" line="24" static="1">
			<c path="String"/>
			<meta><m n=":deprecated"/></meta>
		</PNG>
		<JPG public="1" get="inline" set="null" line="25" static="1">
			<c path="String"/>
			<meta><m n=":deprecated"/></meta>
		</JPG>
		<TRANSPARENT public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></TRANSPARENT>
		<HARDWARE public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></HARDWARE>
		<FORMAT_8888 public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></FORMAT_8888>
		<FORMAT_4444 public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></FORMAT_4444>
		<FORMAT_565 public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></FORMAT_565>
		<createColor public="1" get="inline" set="null" line="113" static="1">
			<f a="rgb:?alpha" v=":255">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":deprecated"/></meta>
		</createColor>
		<extractAlpha public="1" get="inline" set="null" line="170" static="1">
			<f a="argb">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":deprecated"/></meta>
		</extractAlpha>
		<extractColor public="1" get="inline" set="null" line="177" static="1">
			<f a="argb">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":deprecated"/></meta>
		</extractColor>
		<getRGBAPixels public="1" get="inline" set="null" line="246" static="1"><f a="bitmapData">
	<c path="flash.display.BitmapData"/>
	<c path="flash.utils.ByteArray"/>
</f></getRGBAPixels>
		<load public="1" set="method" line="293" static="1"><f a="filename:?format" v=":0">
	<c path="String"/>
	<x path="Int"/>
	<c path="flash.display.BitmapData"/>
</f></load>
		<loadFromBytes public="1" set="method" line="302" static="1"><f a="bytes:?rawAlpha" v=":null">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<c path="flash.display.BitmapData"/>
</f></loadFromBytes>
		<loadFromHaxeBytes public="1" set="method" line="311" static="1"><f a="bytes:?rawAlpha" v=":null">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
	<c path="flash.display.BitmapData"/>
</f></loadFromHaxeBytes>
		<sameValue get="inline" set="null" line="381" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
		</sameValue>
		<__flipPixel get="inline" set="null" line="628" static="1">
			<f a="pixel">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__flipPixel>
		<__ucompare public="1" set="method" line="642" static="1">
			<f a="n1:n2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__ucompare>
		<lime_bitmap_data_create line="718" static="1"><f a=":::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_bitmap_data_create>
		<lime_bitmap_data_load line="719" static="1"><f a=":">
	<c path="String"/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_load>
		<lime_bitmap_data_from_bytes line="720" static="1"><f a=":">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<unknown/>
</f></lime_bitmap_data_from_bytes>
		<lime_bitmap_data_clear line="721" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_clear>
		<lime_bitmap_data_clone line="722" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_bitmap_data_clone>
		<lime_bitmap_data_apply_filter line="723" static="1"><f a="::::">
	<d/>
	<d/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<unknown/>
</f></lime_bitmap_data_apply_filter>
		<lime_bitmap_data_color_transform line="724" static="1"><f a="::">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<unknown/>
</f></lime_bitmap_data_color_transform>
		<lime_bitmap_data_copy line="725" static="1"><f a="::::">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<d/>
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_bitmap_data_copy>
		<lime_bitmap_data_copy_channel line="726" static="1"><f a=":::::">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<d/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_copy_channel>
		<lime_bitmap_data_fill line="727" static="1"><f a=":::">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_fill>
		<lime_bitmap_data_get_pixels line="728" static="1"><f a=":">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></lime_bitmap_data_get_pixels>
		<lime_bitmap_data_get_pixel line="729" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lime_bitmap_data_get_pixel>
		<lime_bitmap_data_get_pixel32 line="730" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lime_bitmap_data_get_pixel32>
		<lime_bitmap_data_get_pixel_rgba line="731" static="1"><unknown/></lime_bitmap_data_get_pixel_rgba>
		<lime_bitmap_data_get_array line="733" static="1"><f a="::">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></lime_bitmap_data_get_array>
		<lime_bitmap_data_get_color_bounds_rect line="735" static="1"><f a="::::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<unknown/>
</f></lime_bitmap_data_get_color_bounds_rect>
		<lime_bitmap_data_scroll line="736" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_scroll>
		<lime_bitmap_data_set_pixel line="737" static="1"><f a=":::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_set_pixel>
		<lime_bitmap_data_set_pixel32 line="738" static="1"><f a=":::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_set_pixel32>
		<lime_bitmap_data_set_pixel_rgba line="739" static="1"><unknown/></lime_bitmap_data_set_pixel_rgba>
		<lime_bitmap_data_set_bytes line="740" static="1"><f a=":::">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_set_bytes>
		<lime_bitmap_data_set_format line="741" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_set_format>
		<lime_bitmap_data_set_array line="743" static="1"><f a="::">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></lime_bitmap_data_set_array>
		<lime_bitmap_data_create_hardware_surface line="744" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_bitmap_data_create_hardware_surface>
		<lime_bitmap_data_destroy_hardware_surface line="745" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_bitmap_data_destroy_hardware_surface>
		<lime_bitmap_data_dispose line="747" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_bitmap_data_dispose>
		<lime_bitmap_data_generate_filter_rect line="748" static="1"><f a="::">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
	<unknown/>
</f></lime_bitmap_data_generate_filter_rect>
		<lime_render_surface_to_surface line="749" static="1"><f a="::::::">
	<d/>
	<d/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<c path="String"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_render_surface_to_surface>
		<lime_bitmap_data_height line="750" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_bitmap_data_height>
		<lime_bitmap_data_width line="751" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_bitmap_data_width>
		<lime_bitmap_data_get_transparent line="752" static="1"><unknown/></lime_bitmap_data_get_transparent>
		<lime_bitmap_data_set_flags line="753" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_set_flags>
		<lime_bitmap_data_encode line="754" static="1"><f a="::">
	<d/>
	<c path="String"/>
	<x path="Float"/>
	<c path="flash.utils.ByteArray"/>
</f></lime_bitmap_data_encode>
		<lime_bitmap_data_dump_bits line="755" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_bitmap_data_dump_bits>
		<lime_bitmap_data_flood_fill line="756" static="1"><f a=":::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_bitmap_data_flood_fill>
		<lime_bitmap_data_noise line="757" static="1"><f a=":::::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_bitmap_data_noise>
		<lime_bitmap_data_unmultiply_alpha line="758" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_bitmap_data_unmultiply_alpha>
		<lime_bitmap_data_multiply_alpha line="759" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_bitmap_data_multiply_alpha>
		<lime_bitmap_data_get_prem_alpha line="760" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_bitmap_data_get_prem_alpha>
		<lime_bitmap_data_set_prem_alpha line="761" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_bitmap_data_set_prem_alpha>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<premultipliedAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></premultipliedAlpha>
		<rect public="1" get="accessor" set="null"><c path="flash.geom.Rectangle"/></rect>
		<transparent public="1" get="accessor" set="null"><x path="Bool"/></transparent>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<__handle public="1">
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<__transparent>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__transparent>
		<applyFilter public="1" set="method" line="69"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<clear public="1" set="method" line="76"><f a="color">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clone public="1" set="method" line="83"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method" line="92"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<copyChannel public="1" set="method" line="99"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="106"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha" v=":::null:null:false">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></copyPixels>
		<createHardwareSurface public="1" set="method" line="121"><f a=""><x path="Void"/></f></createHardwareSurface>
		<destroyHardwareSurface public="1" set="method" line="128"><f a=""><x path="Void"/></f></destroyHardwareSurface>
		<dispose public="1" set="method" line="136"><f a=""><x path="Void"/></f></dispose>
		<draw public="1" set="method" line="149"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing" v=":null:null:null:null:false">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw>
		<dumpBits public="1" set="method" line="156"><f a=""><x path="Void"/></f></dumpBits>
		<encode public="1" set="method" line="163"><f a="format:?quality" v=":0.9f">
	<c path="String"/>
	<x path="Float"/>
	<c path="flash.utils.ByteArray"/>
</f></encode>
		<fillRect public="1" set="method" line="184"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillRect>
		<fillRectEx public="1" set="method" line="191"><f a="rect:color:?alpha" v="::255">
	<c path="flash.geom.Rectangle"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillRectEx>
		<floodFill public="1" set="method" line="198"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method" line="205"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1" set="method" line="214"><f a="mask:color:?findColor" v="::true">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<getPixel public="1" set="method" line="223"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="230"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="237"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getVector public="1" set="method" line="272"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="Array"><x path="Int"/></c>
</f></getVector>
		<lock public="1" set="method" line="318"><f a=""><x path="Void"/></f></lock>
		<multiplyAlpha public="1" set="method" line="325"><f a=""><x path="Void"/></f></multiplyAlpha>
		<noise public="1" set="method" line="332"><f a="randomSeed:?low:?high:?channelOptions:?grayScale" v=":0:255:7:false">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></noise>
		<paletteMap public="1" set="method" line="339"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray" v=":::null:null:null:null">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method" line="373"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets" v="::::::7:false:null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<x path="Void"/>
</f></perlinNoise>
		<scroll public="1" set="method" line="388"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setFlags public="1" set="method" line="395"><f a="flags">
	<x path="Int"/>
	<x path="Void"/>
</f></setFlags>
		<setFormat public="1" set="method" line="403"><f a="format">
	<x path="Int"/>
	<x path="Void"/>
</f></setFormat>
		<setPixel public="1" set="method" line="410"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="417"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="424"><f a="rect:pixels">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setVector public="1" set="method" line="434"><f a="rect:pixels">
	<c path="flash.geom.Rectangle"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></setVector>
		<threshold public="1" set="method" line="456"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource" v=":::::0:-1:false">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></threshold>
		<unlock public="1" set="method" line="607"><f a="?changeRect" v="null">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></unlock>
		<unmultiplyAlpha public="1" set="method" line="614"><f a=""><x path="Void"/></f></unmultiplyAlpha>
		<__drawToSurface public="1" set="method" line="621">
			<f a="surface:matrix:colorTransform:blendMode:clipRect:smoothing">
				<d/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<c path="String"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__drawToSurface>
		<__loadFromBytes get="inline" set="null" line="635">
			<f a="bytes:?rawAlpha" v=":null">
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__loadFromBytes>
		<get_premultipliedAlpha set="method" line="703"><f a=""><x path="Bool"/></f></get_premultipliedAlpha>
		<set_premultipliedAlpha set="method" line="704"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_premultipliedAlpha>
		<get_rect set="method" line="705"><f a=""><c path="flash.geom.Rectangle"/></f></get_rect>
		<get_width set="method" line="706"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="707"><f a=""><x path="Int"/></f></get_height>
		<get_transparent set="method" line="708"><f a=""><x path="Bool"/></f></get_transparent>
		<new public="1" set="method" line="42"><f a="width:height:?transparent:?fillColor:?gpuMode" v="::true:-1:null">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":autoBuild"><e>'???'</e></m></meta>
	</class>
	<class path="flash.display.OptimizedPerlin" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/BitmapData.hx" module="flash.display.BitmapData">
		<P line="769" static="1"><c path="Array"><x path="Int"/></c></P>
		<octaves><x path="Int"/></octaves>
		<aOctFreq><c path="Array"><x path="Float"/></c></aOctFreq>
		<aOctPers><c path="Array"><x path="Float"/></c></aOctPers>
		<fPersMax><x path="Float"/></fPersMax>
		<iXoffset><x path="Float"/></iXoffset>
		<iYoffset><x path="Float"/></iYoffset>
		<iZoffset><x path="Float"/></iZoffset>
		<baseFactor><x path="Float"/></baseFactor>
		<fill public="1" set="method" line="848"><f a="bitmap:_x:_y:_z:?_" v="::::null">
	<c path="flash.display.BitmapData"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
	<x path="Void"/>
</f></fill>
		<octFreqPers set="method" line="962"><f a="fPersistence">
	<x path="Float"/>
	<x path="Void"/>
</f></octFreqPers>
		<seedOffset set="method" line="985"><f a="iSeed">
	<x path="Int"/>
	<x path="Void"/>
</f></seedOffset>
		<new public="1" set="method" line="838"><f a="?seed:?numOctaves:?falloff" v="123:4:0.5f">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.BitmapDataChannel" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/BitmapDataChannel.hx">
		<ALPHA public="1" get="inline" set="null" line="6" static="1"><x path="Int"/></ALPHA>
		<BLUE public="1" get="inline" set="null" line="7" static="1"><x path="Int"/></BLUE>
		<GREEN public="1" get="inline" set="null" line="8" static="1"><x path="Int"/></GREEN>
		<RED public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></RED>
	</class>
	<enum path="flash.display.BlendMode" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/BlendMode.hx">
		<NORMAL/>
		<LAYER/>
		<MULTIPLY/>
		<SCREEN/>
		<LIGHTEN/>
		<DARKEN/>
		<DIFFERENCE/>
		<ADD/>
		<SUBTRACT/>
		<INVERT/>
		<ALPHA/>
		<ERASE/>
		<OVERLAY/>
		<HARDLIGHT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/CapsStyle.hx">
		<ROUND/>
		<NONE/>
		<SQUARE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.display.InteractiveObject" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/InteractiveObject.hx">
		<extends path="flash.display.DisplayObject"/>
		<lime_display_object_set_mouse_enabled line="103" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_display_object_set_mouse_enabled>
		<lime_display_object_set_needs_soft_keyboard line="104" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_display_object_set_needs_soft_keyboard>
		<lime_display_object_get_needs_soft_keyboard line="105" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_display_object_get_needs_soft_keyboard>
		<lime_display_object_set_moves_for_soft_keyboard line="106" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_display_object_set_moves_for_soft_keyboard>
		<lime_display_object_get_moves_for_soft_keyboard line="107" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_display_object_get_moves_for_soft_keyboard>
		<lime_display_object_dismiss_soft_keyboard line="108" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_display_object_dismiss_soft_keyboard>
		<lime_display_object_request_soft_keyboard line="109" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_display_object_request_soft_keyboard>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<mouseEnabled public="1" get="accessor" set="accessor"><x path="Bool"/></mouseEnabled>
		<moveForSoftKeyboard public="1" get="accessor" set="accessor"><x path="Bool"/></moveForSoftKeyboard>
		<needsSoftKeyboard public="1" get="accessor" set="accessor"><x path="Bool"/></needsSoftKeyboard>
		<__mouseEnabled>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__mouseEnabled>
		<__dismissSoftKeyboard public="1" set="method" line="28"><f a=""><x path="Bool"/></f></__dismissSoftKeyboard>
		<requestSoftKeyboard public="1" set="method" line="35"><f a=""><x path="Bool"/></f></requestSoftKeyboard>
		<__asInteractiveObject set="method" line="42" override="1">
			<f a=""><c path="flash.display.InteractiveObject"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__asInteractiveObject>
		<get_mouseEnabled set="method" line="56"><f a=""><x path="Bool"/></f></get_mouseEnabled>
		<set_mouseEnabled set="method" line="57"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseEnabled>
		<set_moveForSoftKeyboard set="method" line="66"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_moveForSoftKeyboard>
		<get_moveForSoftKeyboard set="method" line="74"><f a=""><x path="Bool"/></f></get_moveForSoftKeyboard>
		<set_needsSoftKeyboard set="method" line="81"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_needsSoftKeyboard>
		<get_needsSoftKeyboard set="method" line="89"><f a=""><x path="Bool"/></f></get_needsSoftKeyboard>
		<new public="1" set="method" line="18"><f a="handle:type">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/DisplayObjectContainer.hx">
		<extends path="flash.display.InteractiveObject"/>
		<lime_create_display_object_container line="537" static="1"><f a=""><unknown/></f></lime_create_display_object_container>
		<lime_doc_add_child line="538" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></lime_doc_add_child>
		<lime_doc_remove_child line="539" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_doc_remove_child>
		<lime_doc_set_child_index line="540" static="1"><f a="::">
	<d/>
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_doc_set_child_index>
		<lime_doc_get_mouse_children line="541" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_doc_get_mouse_children>
		<lime_doc_set_mouse_children line="542" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_doc_set_mouse_children>
		<lime_doc_swap_children line="543" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_doc_swap_children>
		<mouseChildren public="1" get="accessor" set="accessor"><x path="Bool"/></mouseChildren>
		<numChildren public="1" get="accessor" set="null"><x path="Int"/></numChildren>
		<tabChildren public="1" get="accessor" set="accessor"><x path="Bool"/></tabChildren>
		<__children>
			<c path="Array"><c path="flash.display.DisplayObject"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__children>
		<addChild public="1" set="method" line="29"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method" line="37"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method" line="46"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method" line="53"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method" line="60"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method" line="74"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method" line="91"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method" line="98"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<removeChild public="1" set="method" line="126"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method" line="142"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChildren public="1" set="method" line="157"><f a="?beginIndex:?endIndex" v="0:2147483647">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></removeChildren>
		<setChildIndex public="1" set="method" line="192"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<swapChildren public="1" set="method" line="199"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method" line="215"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<__addChild get="inline" set="null" line="222">
			<f a="child">
				<c path="flash.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__addChild>
		<__broadcast public="1" set="method" line="245" override="1">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__broadcast>
		<__contains public="1" set="method" line="285" override="1">
			<f a="child">
				<c path="flash.display.DisplayObject"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__contains>
		<__findByID set="method" line="314" override="1">
			<f a="id">
				<x path="Int"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__findByID>
		<__getChildIndex set="method" line="341">
			<f a="child">
				<c path="flash.display.DisplayObject"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getChildIndex>
		<__getObjectsUnderPoint public="1" set="method" line="358" override="1">
			<f a="point:result">
				<c path="flash.geom.Point"/>
				<c path="Array"><c path="flash.display.DisplayObject"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getObjectsUnderPoint>
		<__onAdded set="method" line="371" override="1">
			<f a="object:isOnStage">
				<c path="flash.display.DisplayObject"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onAdded>
		<__onRemoved set="method" line="384" override="1">
			<f a="object:wasOnStage">
				<c path="flash.display.DisplayObject"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onRemoved>
		<__removeChildFromArray public="1" set="method" line="397">
			<f a="child">
				<c path="flash.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__removeChildFromArray>
		<__setChildIndex get="inline" set="null" line="411">
			<f a="child:index">
				<c path="flash.display.DisplayObject"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setChildIndex>
		<__swapChildrenAt get="inline" set="null" line="489">
			<f a="index1:index2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__swapChildrenAt>
		<get_mouseChildren set="method" line="516"><f a=""><x path="Bool"/></f></get_mouseChildren>
		<set_mouseChildren set="method" line="517"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseChildren>
		<get_numChildren set="method" line="525"><f a=""><x path="Int"/></f></get_numChildren>
		<get_tabChildren set="method" line="526"><f a=""><x path="Bool"/></f></get_tabChildren>
		<set_tabChildren set="method" line="527"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tabChildren>
		<new set="method" line="21"><f a="handle:type">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.FrameLabel" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/FrameLabel.hx">
		<extends path="flash.events.EventDispatcher"/>
		<frame public="1" get="accessor" set="null"><x path="Int"/></frame>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<__frame>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__frame>
		<__name>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__name>
		<get_frame set="method" line="34"><f a=""><x path="Int"/></f></get_frame>
		<get_name set="method" line="35"><f a=""><c path="String"/></f></get_name>
		<new public="1" set="method" line="17"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.GradientType" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/Graphics.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></TILE_TRANS_2x2>
		<TILE_SMOOTH get="inline" set="null" line="17" static="1"><x path="Int"/></TILE_SMOOTH>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></TILE_BLEND_ADD>
		<RGBA public="1" get="inline" set="null" line="216" static="1">
			<f a="rgb:?alpha" v=":255">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":deprecated"/>
			</meta>
		</RGBA>
		<lime_gfx_clear line="230" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gfx_clear>
		<lime_gfx_begin_fill line="231" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_begin_fill>
		<lime_gfx_begin_bitmap_fill line="232" static="1"><f a="::::">
	<d/>
	<d/>
	<c path="flash.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_gfx_begin_bitmap_fill>
		<lime_gfx_line_bitmap_fill line="233" static="1"><f a="::::">
	<d/>
	<d/>
	<c path="flash.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_gfx_line_bitmap_fill>
		<lime_gfx_begin_gradient_fill line="234" static="1"><f a="::::::::">
	<d/>
	<x path="Int"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_begin_gradient_fill>
		<lime_gfx_line_gradient_fill line="235" static="1"><f a="::::::::">
	<d/>
	<x path="Int"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_line_gradient_fill>
		<lime_gfx_end_fill line="236" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gfx_end_fill>
		<lime_gfx_line_style line="237" static="1"><f a="::::::::">
	<d/>
	<t path="Null"><x path="Float"/></t>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_line_style>
		<lime_gfx_move_to line="238" static="1"><f a="::">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_move_to>
		<lime_gfx_line_to line="239" static="1"><f a="::">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_line_to>
		<lime_gfx_curve_to line="240" static="1"><f a="::::">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_curve_to>
		<lime_gfx_arc_to line="241" static="1"><f a="::::">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_arc_to>
		<lime_gfx_draw_ellipse line="242" static="1"><f a="::::">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_draw_ellipse>
		<lime_gfx_draw_data line="243" static="1"><f a=":">
	<d/>
	<c path="Array"><d/></c>
	<unknown/>
</f></lime_gfx_draw_data>
		<lime_gfx_draw_datum line="244" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></lime_gfx_draw_datum>
		<lime_gfx_draw_rect line="245" static="1"><f a="::::">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_draw_rect>
		<lime_gfx_draw_path line="246" static="1"><f a=":::">
	<d/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Float"/></c>
	<x path="Bool"/>
	<unknown/>
</f></lime_gfx_draw_path>
		<lime_gfx_draw_tiles line="247" static="1"><f a="::::">
	<d/>
	<d/>
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gfx_draw_tiles>
		<lime_gfx_draw_points line="248" static="1"><f a=":::::">
	<d/>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gfx_draw_points>
		<lime_gfx_draw_round_rect line="249" static="1"><f a="::::::">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="Null"><x path="Float"/></t>
	<unknown/>
</f></lime_gfx_draw_round_rect>
		<lime_gfx_draw_triangles line="250" static="1"><f a="::::::">
	<d/>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<unknown/>
</f></lime_gfx_draw_triangles>
		<__handle>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<arcTo public="1" set="method" line="31"><f a="controlX:controlY:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></arcTo>
		<beginBitmapFill public="1" set="method" line="38"><f a="bitmap:?matrix:?repeat:?smooth" v=":null:true:false">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></beginBitmapFill>
		<beginFill public="1" set="method" line="45"><f a="color:?alpha" v=":1.0f">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginFill>
		<beginGradientFill public="1" set="method" line="52"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v="::::null:null:null:0.0f">
	<e path="flash.display.GradientType"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginGradientFill>
		<clear public="1" set="method" line="66"><f a=""><x path="Void"/></f></clear>
		<curveTo public="1" set="method" line="73"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method" line="80"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method" line="87"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method" line="94"><f a="graphicsData">
	<c path="Array"><c path="flash.display.IGraphicsData"/></c>
	<x path="Void"/>
</f></drawGraphicsData>
		<drawGraphicsDatum public="1" set="method" line="109"><f a="graphicsDatum">
	<c path="flash.display.IGraphicsData"/>
	<x path="Void"/>
</f></drawGraphicsDatum>
		<drawPoints public="1" set="method" line="116"><f a="xy:?pointRGBA:?defaultRGBA:?size" v=":null:-1:-1.0f">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawPoints>
		<drawRect public="1" set="method" line="123"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method" line="130"><f a="x:y:width:height:radiusX:?radiusY" v=":::::null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRect>
		<drawPath public="1" set="method" line="137"><f a="commands:data:?winding" v="::'evenOdd'">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></drawPath>
		<drawTiles public="1" set="method" line="144"><f a="sheet:data:?smooth:?flags:?count" v="::false:0:-1">
	<c path="openfl.display.Tilesheet"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawTiles>
		<drawTriangles public="1" set="method" line="159"><f a="vertices:?indices:?uvtData:?culling:?colors:?blendMode" v=":null:null:null:null:0">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Float"/></c>
	<e path="flash.display.TriangleCulling"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></drawTriangles>
		<endFill public="1" set="method" line="167"><f a=""><x path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method" line="174"><f a="bitmap:?matrix:?repeat:?smooth" v=":null:true:false">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></lineBitmapStyle>
		<lineGradientStyle public="1" set="method" line="181"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v="::::null:null:null:0.0f">
	<e path="flash.display.GradientType"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineGradientStyle>
		<lineStyle public="1" set="method" line="195"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit" v="null:0:1.0f:false:null:null:null:3">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineStyle>
		<lineTo public="1" set="method" line="202"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="209"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<new public="1" set="method" line="24"><f a="handle">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.GraphicsPathWinding" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/GraphicsPathWinding.hx">
		<EVEN_ODD public="1" get="inline" set="null" line="6" static="1"><c path="String"/></EVEN_ODD>
		<NON_ZERO public="1" get="inline" set="null" line="7" static="1"><c path="String"/></NON_ZERO>
	</class>
	<class path="flash.display.IGraphicsData" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/IGraphicsData.hx">
		<__handle public="1">
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<new public="1" set="method" line="10"><f a="handle">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.InterpolationMethod" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/LineScaleMode.hx">
		<NORMAL/>
		<NONE/>
		<VERTICAL/>
		<HORIZONTAL/>
		<OPENGL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.display.Sprite" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/Sprite.hx">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<startDrag public="1" set="method" line="21"><f a="?lockCenter:?bounds" v="false:null">
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></startDrag>
		<stopDrag public="1" set="method" line="32"><f a=""><x path="Void"/></f></stopDrag>
		<__getType set="method" line="43"><f a=""><c path="String"/></f></__getType>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.Loader" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/Loader.hx">
		<extends path="flash.display.Sprite"/>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<__image>
			<c path="flash.display.BitmapData"/>
			<meta><m n=":noCompletion"/></meta>
		</__image>
		<load public="1" set="method" line="36"><f a="request:?context" v=":null">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></load>
		<loadBytes public="1" set="method" line="43"><f a="bytes:?context" v=":null">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></loadBytes>
		<unload public="1" set="method" line="60"><f a=""><x path="Void"/></f></unload>
		<__onComplete set="method" line="90">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onComplete>
		<contentLoaderInfo_onData set="method" line="130"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></contentLoaderInfo_onData>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.URLLoader" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/net/URLLoader.hx">
		<extends path="flash.events.EventDispatcher"/>
		<activeLoaders line="23" static="1">
			<c path="List"><c path="flash.net.URLLoader"/></c>
			<meta><m n=":noCompletion"/></meta>
		</activeLoaders>
		<urlInvalid get="inline" set="null" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</urlInvalid>
		<urlInit get="inline" set="null" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</urlInit>
		<urlLoading get="inline" set="null" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</urlLoading>
		<urlComplete get="inline" set="null" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</urlComplete>
		<urlError get="inline" set="null" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</urlError>
		<hasActive public="1" set="method" line="89" static="1"><f a=""><x path="Bool"/></f></hasActive>
		<initialize public="1" set="method" line="96" static="1"><f a="caCertFilePath">
	<c path="String"/>
	<x path="Void"/>
</f></initialize>
		<__loadPending public="1" set="method" line="254" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__loadPending>
		<__pollData public="1" set="method" line="261" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__pollData>
		<lime_curl_create line="292" static="1"><f a="">
	<c path="flash.net.URLRequest"/>
	<unknown/>
</f></lime_curl_create>
		<lime_curl_process_loaders line="293" static="1"><f a=""><unknown/></f></lime_curl_process_loaders>
		<lime_curl_update_loader line="294" static="1"><f a=":">
	<d/>
	<c path="flash.net.URLLoader"/>
	<unknown/>
</f></lime_curl_update_loader>
		<lime_curl_get_code line="295" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_curl_get_code>
		<lime_curl_get_error_message line="296" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_curl_get_error_message>
		<lime_curl_get_data line="297" static="1"><f a="">
	<d/>
	<c path="flash.utils.ByteArray"/>
</f></lime_curl_get_data>
		<lime_curl_get_cookies line="298" static="1"><f a="">
	<d/>
	<c path="Array"><c path="String"/></c>
</f></lime_curl_get_cookies>
		<lime_curl_get_headers line="299" static="1"><f a="">
	<d/>
	<c path="Array"><c path="String"/></c>
</f></lime_curl_get_headers>
		<lime_curl_initialize line="300" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></lime_curl_initialize>
		<bytesLoaded public="1" set="null"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<data public="1"><d/></data>
		<dataFormat public="1"><e path="flash.net.URLLoaderDataFormat"/></dataFormat>
		<state>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</state>
		<__handle>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<__onComplete public="1">
			<f a="">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onComplete>
		<close public="1" set="method" line="54"><f a=""><x path="Void"/></f></close>
		<dispatchHTTPStatus set="method" line="61"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></dispatchHTTPStatus>
		<getCookies public="1" set="method" line="82"><f a=""><c path="Array"><c path="String"/></c></f></getCookies>
		<load public="1" set="method" line="103"><f a="request">
	<c path="flash.net.URLRequest"/>
	<x path="Void"/>
</f></load>
		<onError set="method" line="157"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></onError>
		<update set="method" line="165"><f a=""><x path="Void"/></f></update>
		<__dataComplete set="method" line="229">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__dataComplete>
		<new public="1" set="method" line="35"><f a="?request" v="null">
	<c path="flash.net.URLRequest"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/LoaderInfo.hx">
		<extends path="flash.net.URLLoader"/>
		<create public="1" set="method" line="51" static="1"><f a="loader">
	<c path="flash.display.Loader"/>
	<c path="flash.display.LoaderInfo"/>
</f></create>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" get="accessor" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<childAllowsParent public="1" set="null"><x path="Bool"/></childAllowsParent>
		<content public="1"><c path="flash.display.DisplayObject"/></content>
		<contentType public="1"><c path="String"/></contentType>
		<frameRate public="1" set="null"><x path="Float"/></frameRate>
		<height public="1" set="null"><x path="Int"/></height>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><x path="Bool"/></parentAllowsChild>
		<sameDomain public="1" set="null"><x path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><x path="Int"/></width>
		<uncaughtErrorEvents public="1" set="null"><c path="flash.events.UncaughtErrorEvents"/></uncaughtErrorEvents>
		<__pendingURL>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__pendingURL>
		<load public="1" set="method" line="68" override="1"><f a="request">
	<c path="flash.net.URLRequest"/>
	<x path="Void"/>
</f></load>
		<this_onComplete set="method" line="99"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></this_onComplete>
		<get_bytes set="method" line="113"><f a=""><c path="flash.utils.ByteArray"/></f></get_bytes>
		<new set="method" line="37"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/MovieClip.hx">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" get="accessor" set="null"><x path="Int"/></currentFrame>
		<currentFrameLabel public="1" get="accessor" set="null"><c path="String"/></currentFrameLabel>
		<currentLabel public="1" get="accessor" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" get="accessor" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<enabled public="1"><x path="Bool"/></enabled>
		<framesLoaded public="1" get="accessor" set="null"><x path="Int"/></framesLoaded>
		<totalFrames public="1" get="accessor" set="null"><x path="Int"/></totalFrames>
		<__currentFrame>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__currentFrame>
		<__currentFrameLabel>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__currentFrameLabel>
		<__currentLabel>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__currentLabel>
		<__currentLabels>
			<c path="Array"><c path="flash.display.FrameLabel"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__currentLabels>
		<__totalFrames>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__totalFrames>
		<gotoAndPlay public="1" set="method" line="35"><f a="frame:?scene" v=":null">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method" line="42"><f a="frame:?scene" v=":null">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method" line="49"><f a=""><x path="Void"/></f></nextFrame>
		<__getType set="method" line="56" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getType>
		<play public="1" set="method" line="63"><f a=""><x path="Void"/></f></play>
		<prevFrame public="1" set="method" line="70"><f a=""><x path="Void"/></f></prevFrame>
		<stop public="1" set="method" line="77"><f a=""><x path="Void"/></f></stop>
		<get_currentFrame set="method" line="91"><f a=""><x path="Int"/></f></get_currentFrame>
		<get_currentFrameLabel set="method" line="92"><f a=""><c path="String"/></f></get_currentFrameLabel>
		<get_currentLabel set="method" line="93"><f a=""><c path="String"/></f></get_currentLabel>
		<get_currentLabels set="method" line="94"><f a=""><c path="Array"><c path="flash.display.FrameLabel"/></c></f></get_currentLabels>
		<get_framesLoaded set="method" line="95"><f a=""><x path="Int"/></f></get_framesLoaded>
		<get_totalFrames set="method" line="96"><f a=""><x path="Int"/></f></get_totalFrames>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.display.PixelSnapping" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.display.Shape" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/Shape.hx">
		<extends path="flash.display.DisplayObject"/>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/SpreadMethod.hx">
		<PAD/>
		<REPEAT/>
		<REFLECT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.events.Event" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/Event.hx">
		<ACTIVATE public="1" line="7" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" line="8" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" line="9" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" line="10" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" line="11" static="1"><c path="String"/></CHANGE>
		<CLOSE public="1" line="12" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" line="13" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" line="14" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" line="15" static="1"><c path="String"/></CONTEXT3D_CREATE>
		<DEACTIVATE public="1" line="16" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" line="17" static="1"><c path="String"/></ENTER_FRAME>
		<ID3 public="1" line="18" static="1"><c path="String"/></ID3>
		<INIT public="1" line="19" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" line="20" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" line="21" static="1"><c path="String"/></OPEN>
		<REMOVED public="1" line="22" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" line="23" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" line="24" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" line="25" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" line="26" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" line="27" static="1"><c path="String"/></SELECT>
		<SOUND_COMPLETE public="1" line="28" static="1"><c path="String"/></SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" line="29" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" line="30" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" line="31" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<UNLOAD public="1" line="32" static="1"><c path="String"/></UNLOAD>
		<bubbles public="1" get="accessor" set="null"><x path="Bool"/></bubbles>
		<cancelable public="1" get="accessor" set="null"><x path="Bool"/></cancelable>
		<currentTarget public="1" get="accessor" set="accessor"><d/></currentTarget>
		<eventPhase public="1" get="accessor" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<target public="1" get="accessor" set="accessor"><d/></target>
		<type public="1" get="accessor" set="null"><c path="String"/></type>
		<__bubbles>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__bubbles>
		<__cancelable>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__cancelable>
		<__currentTarget>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__currentTarget>
		<__eventPhase>
			<e path="flash.events.EventPhase"/>
			<meta><m n=":noCompletion"/></meta>
		</__eventPhase>
		<__isCancelled>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__isCancelled>
		<__isCancelledNow>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__isCancelledNow>
		<__target>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__target>
		<__type>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__type>
		<clone public="1" set="method" line="65"><f a=""><c path="flash.events.Event"/></f></clone>
		<stopImmediatePropagation public="1" set="method" line="72"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method" line="84"><f a=""><x path="Void"/></f></stopPropagation>
		<toString public="1" set="method" line="95"><f a=""><c path="String"/></f></toString>
		<__getIsCancelled public="1" set="method" line="102">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getIsCancelled>
		<__getIsCancelledNow public="1" set="method" line="109">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getIsCancelledNow>
		<__setPhase public="1" set="method" line="116">
			<f a="value">
				<e path="flash.events.EventPhase"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setPhase>
		<get_bubbles set="method" line="130"><f a=""><x path="Bool"/></f></get_bubbles>
		<get_cancelable set="method" line="131"><f a=""><x path="Bool"/></f></get_cancelable>
		<get_currentTarget set="method" line="132"><f a=""><d/></f></get_currentTarget>
		<set_currentTarget set="method" line="133"><f a="value">
	<d/>
	<d/>
</f></set_currentTarget>
		<get_eventPhase set="method" line="134"><f a=""><e path="flash.events.EventPhase"/></f></get_eventPhase>
		<get_target set="method" line="135"><f a=""><d/></f></get_target>
		<set_target set="method" line="136"><f a="value">
	<d/>
	<d/>
</f></set_target>
		<get_type set="method" line="137"><f a=""><c path="String"/></f></get_type>
		<new public="1" set="method" line="51"><f a="type:?bubbles:?cancelable" v=":false:false">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.MouseEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/MouseEvent.hx">
		<extends path="flash.events.Event"/>
		<DOUBLE_CLICK public="1" line="11" static="1"><c path="String"/></DOUBLE_CLICK>
		<CLICK public="1" line="12" static="1"><c path="String"/></CLICK>
		<MIDDLE_CLICK public="1" line="13" static="1"><c path="String"/></MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" line="14" static="1"><c path="String"/></MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" line="15" static="1"><c path="String"/></MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" line="16" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" line="17" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" line="18" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" line="19" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" line="20" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" line="21" static="1"><c path="String"/></MOUSE_WHEEL>
		<RIGHT_CLICK public="1" line="22" static="1"><c path="String"/></RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" line="23" static="1"><c path="String"/></RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" line="24" static="1"><c path="String"/></RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" line="25" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" line="26" static="1"><c path="String"/></ROLL_OVER>
		<efLeftDown line="41" static="1"><x path="Int"/></efLeftDown>
		<efShiftDown line="42" static="1"><x path="Int"/></efShiftDown>
		<efCtrlDown line="43" static="1"><x path="Int"/></efCtrlDown>
		<efAltDown line="44" static="1"><x path="Int"/></efAltDown>
		<efCommandDown line="45" static="1"><x path="Int"/></efCommandDown>
		<__create public="1" set="method" line="86" static="1">
			<f a="type:event:local:target">
				<c path="String"/>
				<d/>
				<c path="flash.geom.Point"/>
				<c path="flash.display.InteractiveObject"/>
				<c path="flash.events.MouseEvent"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__create>
		<altKey public="1"><x path="Bool"/></altKey>
		<buttonDown public="1"><x path="Bool"/></buttonDown>
		<clickCount public="1"><x path="Int"/></clickCount>
		<commandKey public="1"><x path="Bool"/></commandKey>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<delta public="1"><x path="Int"/></delta>
		<localX public="1"><x path="Float"/></localX>
		<localY public="1"><x path="Float"/></localY>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<stageX public="1"><x path="Float"/></stageX>
		<stageY public="1"><x path="Float"/></stageY>
		<clone public="1" set="method" line="65" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="72" override="1"><f a=""><c path="String"/></f></toString>
		<updateAfterEvent public="1" set="method" line="79"><f a=""><x path="Void"/></f></updateAfterEvent>
		<__createSimilar public="1" set="method" line="98">
			<f a="type:?related:?target" v=":null:null">
				<c path="String"/>
				<c path="flash.display.InteractiveObject"/>
				<c path="flash.display.InteractiveObject"/>
				<c path="flash.events.MouseEvent"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__createSimilar>
		<new public="1" set="method" line="47"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta:?commandKey:?clickCount" v=":true:false:0:0:null:false:false:false:false:0:false:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.TouchEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/TouchEvent.hx">
		<extends path="flash.events.MouseEvent"/>
		<TOUCH_BEGIN public="1" line="11" static="1"><c path="String"/></TOUCH_BEGIN>
		<TOUCH_END public="1" line="12" static="1"><c path="String"/></TOUCH_END>
		<TOUCH_MOVE public="1" line="13" static="1"><c path="String"/></TOUCH_MOVE>
		<TOUCH_OUT public="1" line="14" static="1"><c path="String"/></TOUCH_OUT>
		<TOUCH_OVER public="1" line="15" static="1"><c path="String"/></TOUCH_OVER>
		<TOUCH_ROLL_OUT public="1" line="16" static="1"><c path="String"/></TOUCH_ROLL_OUT>
		<TOUCH_ROLL_OVER public="1" line="17" static="1"><c path="String"/></TOUCH_ROLL_OVER>
		<TOUCH_TAP public="1" line="18" static="1"><c path="String"/></TOUCH_TAP>
		<__create public="1" set="method" line="38" static="1">
			<f a="type:event:local:target:sizeX:sizeY">
				<c path="String"/>
				<d/>
				<c path="flash.geom.Point"/>
				<c path="flash.display.InteractiveObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flash.events.TouchEvent"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__create>
		<isPrimaryTouchPoint public="1"><x path="Bool"/></isPrimaryTouchPoint>
		<sizeX public="1"><x path="Float"/></sizeX>
		<sizeY public="1"><x path="Float"/></sizeY>
		<touchPointID public="1"><x path="Int"/></touchPointID>
		<__createSimilar public="1" set="method" line="50" override="1">
			<f a="type:?related:?target" v=":null:null">
				<c path="String"/>
				<c path="flash.display.InteractiveObject"/>
				<c path="flash.display.InteractiveObject"/>
				<c path="flash.events.MouseEvent"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__createSimilar>
		<new public="1" set="method" line="26"><f a="type:?bubbles:?cancelable:?localX:?localY:?sizeX:?sizeY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta:?commandKey:?clickCount" v=":true:false:0:0:1:1:null:false:false:false:false:0:false:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.Stage" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/Stage.hx">
		<extends path="flash.display.DisplayObjectContainer"/>
		<__earlyWakeup public="1" line="29" static="1">
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__earlyWakeup>
		<__exiting public="1" line="30" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__exiting>
		<OrientationPortrait public="1" line="32" static="1"><x path="Int"/></OrientationPortrait>
		<OrientationPortraitUpsideDown public="1" line="33" static="1"><x path="Int"/></OrientationPortraitUpsideDown>
		<OrientationLandscapeRight public="1" line="34" static="1"><x path="Int"/></OrientationLandscapeRight>
		<OrientationLandscapeLeft public="1" line="35" static="1"><x path="Int"/></OrientationLandscapeLeft>
		<OrientationFaceUp public="1" line="36" static="1"><x path="Int"/></OrientationFaceUp>
		<OrientationFaceDown public="1" line="37" static="1"><x path="Int"/></OrientationFaceDown>
		<efLeftDown line="58" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</efLeftDown>
		<efShiftDown line="59" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</efShiftDown>
		<efCtrlDown line="60" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</efCtrlDown>
		<efAltDown line="61" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</efAltDown>
		<efCommandDown line="62" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</efCommandDown>
		<efLocationRight line="63" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</efLocationRight>
		<efNoNativeClick line="64" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</efNoNativeClick>
		<sClickEvents line="65" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</sClickEvents>
		<sDownEvents line="66" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</sDownEvents>
		<sUpEvents line="67" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</sUpEvents>
		<__mouseChanges line="69" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__mouseChanges>
		<__touchChanges line="70" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__touchChanges>
		<getOrientation public="1" set="dynamic" line="123" static="1"><f a=""><x path="Int"/></f></getOrientation>
		<getNormalOrientation public="1" set="dynamic" line="130" static="1"><f a=""><x path="Int"/></f></getNormalOrientation>
		<setFixedOrientation public="1" set="method" line="166" static="1"><f a="orientation">
	<x path="Int"/>
	<x path="Void"/>
</f></setFixedOrientation>
		<shouldRotateInterface public="1" set="dynamic" line="174" static="1"><f a="orientation">
	<x path="Int"/>
	<x path="Bool"/>
</f></shouldRotateInterface>
		<lime_set_stage_handler line="1321" static="1"><f a=":::">
	<d/>
	<f a="event">
		<d/>
		<d/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_set_stage_handler>
		<lime_render_stage line="1322" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_render_stage>
		<lime_stage_get_autos3d line="1323" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_stage_get_autos3d>
		<lime_stage_set_autos3d line="1324" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_stage_set_autos3d>
		<lime_stage_get_focus_id line="1325" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_stage_get_focus_id>
		<lime_stage_set_focus line="1326" static="1"><f a="::">
	<d/>
	<unknown/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_focus>
		<lime_stage_get_focus_rect line="1327" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_stage_get_focus_rect>
		<lime_stage_set_focus_rect line="1328" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_stage_set_focus_rect>
		<lime_stage_is_opengl line="1329" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_stage_is_opengl>
		<lime_stage_get_stage_width line="1330" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_stage_get_stage_width>
		<lime_stage_get_stage_height line="1331" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_stage_get_stage_height>
		<lime_stage_get_dpi_scale line="1332" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_stage_get_dpi_scale>
		<lime_stage_get_scale_mode line="1333" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_stage_get_scale_mode>
		<lime_stage_set_scale_mode line="1334" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_scale_mode>
		<lime_stage_get_align line="1335" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_stage_get_align>
		<lime_stage_set_align line="1336" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_align>
		<lime_stage_get_quality line="1337" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_stage_get_quality>
		<lime_stage_set_quality line="1338" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_quality>
		<lime_stage_get_display_state line="1339" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_stage_get_display_state>
		<lime_stage_set_display_state line="1340" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_display_state>
		<lime_stage_set_next_wake line="1341" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_stage_set_next_wake>
		<lime_stage_request_render line="1342" static="1"><unknown/></lime_stage_request_render>
		<lime_stage_resize_window line="1343" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_resize_window>
		<lime_stage_set_resolution line="1344" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_resolution>
		<lime_stage_set_screenmode line="1345" static="1"><f a="::::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_screenmode>
		<lime_stage_set_fullscreen line="1346" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_stage_set_fullscreen>
		<lime_stage_show_cursor line="1347" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_stage_show_cursor>
		<lime_stage_set_fixed_orientation line="1348" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_fixed_orientation>
		<lime_stage_get_orientation line="1349" static="1"><f a=""><x path="Int"/></f></lime_stage_get_orientation>
		<lime_stage_get_normal_orientation line="1350" static="1"><f a=""><x path="Int"/></f></lime_stage_get_normal_orientation>
		<autos3d public="1" get="accessor" set="accessor"><x path="Bool"/></autos3d>
		<active public="1" set="null"><x path="Bool"/></active>
		<align public="1" get="accessor" set="accessor"><e path="flash.display.StageAlign"/></align>
		<color public="1" get="accessor" set="accessor"><x path="Int"/></color>
		<displayState public="1" get="accessor" set="accessor"><e path="flash.display.StageDisplayState"/></displayState>
		<dpiScale public="1" get="accessor" set="null"><x path="Float"/></dpiScale>
		<focus public="1" get="accessor" set="accessor"><c path="flash.display.InteractiveObject"/></focus>
		<frameRate public="1" set="accessor"><x path="Float"/></frameRate>
		<isOpenGL public="1" get="accessor" set="null"><x path="Bool"/></isOpenGL>
		<onKey public="1"><f a=":::">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onKey>
		<onQuit public="1"><f a=""><x path="Void"/></f></onQuit>
		<pauseWhenDeactivated public="1"><x path="Bool"/></pauseWhenDeactivated>
		<quality public="1" get="accessor" set="accessor"><e path="flash.display.StageQuality"/></quality>
		<renderRequest public="1"><f a=""><x path="Void"/></f></renderRequest>
		<scaleMode public="1" get="accessor" set="accessor"><e path="flash.display.StageScaleMode"/></scaleMode>
		<stageFocusRect public="1" get="accessor" set="accessor"><x path="Bool"/></stageFocusRect>
		<stageHeight public="1" get="accessor" set="null"><x path="Int"/></stageHeight>
		<stageWidth public="1" get="accessor" set="null"><x path="Int"/></stageWidth>
		<__joyAxisData>
			<x path="Map">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__joyAxisData>
		<__dragBounds>
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__dragBounds>
		<__dragObject>
			<c path="flash.display.Sprite"/>
			<meta><m n=":noCompletion"/></meta>
		</__dragObject>
		<__dragOffsetX>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__dragOffsetX>
		<__dragOffsetY>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__dragOffsetY>
		<__focusOverObjects>
			<c path="Array"><c path="flash.display.InteractiveObject"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__focusOverObjects>
		<__framePeriod>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__framePeriod>
		<__invalid>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__invalid>
		<__lastClickTime>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__lastClickTime>
		<__lastDown>
			<c path="Array"><c path="flash.display.InteractiveObject"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__lastDown>
		<__lastRender>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__lastRender>
		<__mouseOverObjects>
			<c path="Array"><c path="flash.display.InteractiveObject"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__mouseOverObjects>
		<__nextRender>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__nextRender>
		<__touchInfo>
			<x path="Map">
				<x path="Int"/>
				<c path="flash.display.TouchInfo"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__touchInfo>
		<invalidate public="1" set="method" line="137"><f a=""><x path="Void"/></f></invalidate>
		<resize public="1" set="method" line="144"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setResolution public="1" set="method" line="151"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setResolution>
		<setScreenMode public="1" set="method" line="156"><f a="mode">
	<c path="flash.system.ScreenMode"/>
	<x path="Void"/>
</f></setScreenMode>
		<setFullscreen public="1" set="method" line="161"><f a="full">
	<x path="Bool"/>
	<x path="Void"/>
</f></setFullscreen>
		<showCursor public="1" set="method" line="181"><f a="show">
	<x path="Bool"/>
	<x path="Void"/>
</f></showCursor>
		<__checkFocusInOuts set="method" line="188">
			<f a="event:stack">
				<d/>
				<c path="Array"><c path="flash.display.InteractiveObject"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__checkFocusInOuts>
		<__checkInOuts set="method" line="220">
			<f a="event:stack:?touchInfo" v="::null">
				<c path="flash.events.MouseEvent"/>
				<c path="Array"><c path="flash.display.InteractiveObject"/></c>
				<c path="flash.display.TouchInfo"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__checkInOuts>
		<__checkRender set="method" line="290">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__checkRender>
		<__doProcessStageEvent set="method" line="337">
			<f a="event">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__doProcessStageEvent>
		<__processStageEvent set="method" line="521">
			<f a="event">
				<d/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__processStageEvent>
		<__drag set="method" line="529">
			<f a="mouse">
				<c path="flash.geom.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__drag>
		<__nextFrameDue set="method" line="571">
			<f a="otherTimers">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__nextFrameDue>
		<__onChange set="method" line="595">
			<f a="event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onChange>
		<__onFocus set="method" line="608">
			<f a="event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onFocus>
		<__onJoystick set="method" line="640">
			<f a="event:type">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onJoystick>
		<__onKey set="method" line="759">
			<f a="event:type">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onKey>
		<__onMouse set="method" line="808">
			<f a="event:type:fromMouse">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onMouse>
		<__onRenderContext set="method" line="925">
			<f a="active">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onRenderContext>
		<__onResize set="method" line="933">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onResize>
		<__onSysWM set="method" line="941">
			<f a="event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onSysWM>
		<__onTouch set="method" line="949">
			<f a="event:type:touchInfo">
				<d/>
				<c path="String"/>
				<c path="flash.display.TouchInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onTouch>
		<__pollTimers public="1" set="method" line="984">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__pollTimers>
		<__render public="1" set="method" line="1000">
			<f a="sendEnterFrame">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__render>
		<__setActive public="1" set="method" line="1026">
			<f a="value">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setActive>
		<__startDrag public="1" set="method" line="1076">
			<f a="sprite:lockCenter:bounds">
				<c path="flash.display.Sprite"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__startDrag>
		<__stopDrag public="1" set="method" line="1109">
			<f a="sprite">
				<c path="flash.display.Sprite"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__stopDrag>
		<__updateNextWake public="1" set="method" line="1117">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__updateNextWake>
		<get_align set="method" line="1147"><f a=""><e path="flash.display.StageAlign"/></f></get_align>
		<set_align set="method" line="1155"><f a="value">
	<e path="flash.display.StageAlign"/>
	<e path="flash.display.StageAlign"/>
</f></set_align>
		<get_color set="method" line="1163"><f a=""><x path="Int"/></f></get_color>
		<set_color set="method" line="1170"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<get_displayState set="method" line="1177"><f a=""><e path="flash.display.StageDisplayState"/></f></get_displayState>
		<set_displayState set="method" line="1185"><f a="value">
	<e path="flash.display.StageDisplayState"/>
	<e path="flash.display.StageDisplayState"/>
</f></set_displayState>
		<get_dpiScale set="method" line="1193"><f a=""><x path="Float"/></f></get_dpiScale>
		<get_focus set="method" line="1200"><f a=""><c path="flash.display.InteractiveObject"/></f></get_focus>
		<set_focus set="method" line="1209"><f a="value">
	<c path="flash.display.InteractiveObject"/>
	<c path="flash.display.InteractiveObject"/>
</f></set_focus>
		<set_frameRate set="method" line="1226"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameRate>
		<get_isOpenGL set="method" line="1236"><f a=""><x path="Bool"/></f></get_isOpenGL>
		<get_quality set="method" line="1243"><f a=""><e path="flash.display.StageQuality"/></f></get_quality>
		<set_quality set="method" line="1251"><f a="value">
	<e path="flash.display.StageQuality"/>
	<e path="flash.display.StageQuality"/>
</f></set_quality>
		<get_scaleMode set="method" line="1259"><f a=""><e path="flash.display.StageScaleMode"/></f></get_scaleMode>
		<set_scaleMode set="method" line="1267"><f a="value">
	<e path="flash.display.StageScaleMode"/>
	<e path="flash.display.StageScaleMode"/>
</f></set_scaleMode>
		<get_stage set="method" line="1275" override="1"><f a=""><c path="flash.display.Stage"/></f></get_stage>
		<get_stageFocusRect set="method" line="1282"><f a=""><x path="Bool"/></f></get_stageFocusRect>
		<set_stageFocusRect set="method" line="1283"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_stageFocusRect>
		<get_autos3d set="method" line="1291"><f a=""><x path="Bool"/></f></get_autos3d>
		<set_autos3d set="method" line="1292"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autos3d>
		<get_stageHeight set="method" line="1300"><f a=""><x path="Int"/></f></get_stageHeight>
		<get_stageWidth set="method" line="1307"><f a=""><x path="Int"/></f></get_stageWidth>
		<new public="1" set="method" line="91"><f a="handle:width:height">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.TouchInfo" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/Stage.hx" module="flash.display.Stage">
		<touchOverObjects public="1"><c path="Array"><c path="flash.display.InteractiveObject"/></c></touchOverObjects>
		<new public="1" set="method" line="1362"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.display.StageAlign" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN/>
		<FULL_SCREEN_INTERACTIVE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/StageQuality.hx">
		<LOW/>
		<MEDIUM/>
		<HIGH/>
		<BEST/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.errors.Error" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/errors/Error.hx">
		<errorID public="1"><x path="Int"/></errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace set="method" line="20"><f a=""><c path="String"/></f></getStackTrace>
		<toString public="1" set="method" line="27"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="12"><f a="?message:?id" v="null:0">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.errors.ArgumentError" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/errors/ArgumentError.hx">
		<extends path="flash.errors.Error"/>
		<new public="1" set="method" line="4"><f a="?message:?id">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.errors.EOFError" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/errors/EOFError.hx">
		<extends path="flash.errors.Error"/>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.errors.RangeError" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/errors/RangeError.hx">
		<extends path="flash.errors.Error"/>
		<new public="1" set="method" line="7"><f a="?message" v="''">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.TextEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/TextEvent.hx">
		<extends path="flash.events.Event"/>
		<LINK public="1" line="7" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" line="8" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1" set="null"><c path="String"/></text>
		<clone public="1" set="method" line="22" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="29" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="13"><f a="type:?bubbles:?cancelable:?text" v=":false:false:''">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/ErrorEvent.hx">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" line="7" static="1"><c path="String"/></ERROR>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<clone public="1" set="method" line="20" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="27" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="12"><f a="type:?bubbles:?cancelable:?text:?id" v=":false:false:'':0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.Listener" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/EventDispatcher.hx" module="flash.events.EventDispatcher">
		<__id line="253" static="1"><x path="Int"/></__id>
		<id public="1"><x path="Int"/></id>
		<listener public="1"><c path="openfl.utils.WeakRef"><t path="flash.events.Function"/></c></listener>
		<priority public="1"><x path="Int"/></priority>
		<useCapture public="1"><x path="Bool"/></useCapture>
		<dispatchEvent public="1" set="method" line="266"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></dispatchEvent>
		<is public="1" set="method" line="273"><f a="listener:useCapture">
	<t path="flash.events.Function"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></is>
		<new public="1" set="method" line="256"><f a="listener:useCapture:priority">
	<c path="openfl.utils.WeakRef"><t path="flash.events.Function"/></c>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="flash.events.ListenerList" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/EventDispatcher.hx" module="flash.events.EventDispatcher"><c path="Array"><c path="flash.events.Listener"/></c></typedef>
	<typedef path="flash.events.EventMap" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/EventDispatcher.hx" module="flash.events.EventDispatcher"><c path="haxe.ds.StringMap"><t path="flash.events.ListenerList"/></c></typedef>
	<enum path="flash.events.EventPhase" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<AT_TARGET/>
		<BUBBLING_PHASE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.events.FocusEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/FocusEvent.hx">
		<extends path="flash.events.Event"/>
		<FOCUS_IN public="1" line="10" static="1"><c path="String"/></FOCUS_IN>
		<FOCUS_OUT public="1" line="11" static="1"><c path="String"/></FOCUS_OUT>
		<KEY_FOCUS_CHANGE public="1" line="12" static="1"><c path="String"/></KEY_FOCUS_CHANGE>
		<MOUSE_FOCUS_CHANGE public="1" line="13" static="1"><c path="String"/></MOUSE_FOCUS_CHANGE>
		<keyCode public="1" set="null"><x path="Int"/></keyCode>
		<relatedObject public="1" set="null"><c path="flash.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1" set="null"><x path="Bool"/></shiftKey>
		<clone public="1" set="method" line="31" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="38" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="20"><f a="type:?bubbles:?cancelable:?relatedObject:?shiftKey:?keyCode:?direction" v=":true:false:null:false:0:'none'">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="flash.display.InteractiveObject"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.HTTPStatusEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/HTTPStatusEvent.hx">
		<extends path="flash.events.Event"/>
		<HTTP_STATUS public="1" line="7" static="1"><c path="String"/></HTTP_STATUS>
		<status public="1"><x path="Int"/></status>
		<responseHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></responseHeaders>
		<clone public="1" set="method" line="21" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="28" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="12"><f a="type:?bubbles:?cancelable:?status" v=":false:false:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="flash.events.Function" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/IEventDispatcher.hx" module="flash.events.IEventDispatcher"><f a="">
	<d/>
	<x path="Void"/>
</f></typedef>
	<class path="flash.events.IOErrorEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/IOErrorEvent.hx">
		<extends path="flash.events.ErrorEvent"/>
		<IO_ERROR public="1" line="7" static="1"><c path="String"/></IO_ERROR>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="24" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="10"><f a="type:?bubbles:?cancelable:?text:?id" v=":true:false:'':0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/KeyboardEvent.hx">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" line="7" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" line="8" static="1"><c path="String"/></KEY_UP>
		<altKey public="1"><x path="Bool"/></altKey>
		<charCode public="1"><x path="Int"/></charCode>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<controlKey public="1"><x path="Bool"/></controlKey>
		<commandKey public="1"><x path="Bool"/></commandKey>
		<keyCode public="1"><x path="Int"/></keyCode>
		<keyLocation public="1"><x path="Int"/></keyLocation>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<clone public="1" set="method" line="36" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="43" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="19"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue:?controlKeyValue:?commandKeyValue" v=":false:false:0:0:0:false:false:false:false:false">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ProgressEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/ProgressEvent.hx">
		<extends path="flash.events.Event"/>
		<PROGRESS public="1" get="inline" set="null" line="7" static="1"><c path="String"/></PROGRESS>
		<SOCKET_DATA public="1" get="inline" set="null" line="8" static="1"><c path="String"/></SOCKET_DATA>
		<bytesLoaded public="1" set="null"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<clone public="1" set="method" line="24" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="31" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="14"><f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal" v=":false:false:0:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.SampleDataEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/SampleDataEvent.hx">
		<extends path="flash.events.Event"/>
		<SAMPLE_DATA public="1" line="10" static="1"><c path="String"/></SAMPLE_DATA>
		<data public="1"><c path="flash.utils.ByteArray"/></data>
		<position public="1"><x path="Float"/></position>
		<clone public="1" set="method" line="27" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="34" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="16"><f a="type:?bubbles:?cancelable" v=":false:false">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.UncaughtErrorEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/UncaughtErrorEvent.hx">
		<extends path="flash.events.ErrorEvent"/>
		<UNCAUGHT_ERROR public="1" line="4" static="1"><c path="String"/></UNCAUGHT_ERROR>
		<error public="1"><d/></error>
		<clone public="1" set="method" line="16" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="23" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="type:?bubbles:?cancelable:?error_in" v=":true:true:null">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/events/UncaughtErrorEvents.hx">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method" line="3"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.filesystem.File" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/filesystem/File.hx">
		<applicationDirectory public="1" get="accessor" set="null" static="1"><c path="flash.filesystem.File"/></applicationDirectory>
		<applicationStorageDirectory public="1" get="accessor" set="null" static="1"><c path="flash.filesystem.File"/></applicationStorageDirectory>
		<desktopDirectory public="1" get="accessor" set="null" static="1"><c path="flash.filesystem.File"/></desktopDirectory>
		<documentsDirectory public="1" get="accessor" set="null" static="1"><c path="flash.filesystem.File"/></documentsDirectory>
		<userDirectory public="1" get="accessor" set="null" static="1"><c path="flash.filesystem.File"/></userDirectory>
		<APP get="inline" set="null" line="20" static="1"><x path="Int"/></APP>
		<STORAGE get="inline" set="null" line="21" static="1"><x path="Int"/></STORAGE>
		<DESKTOP get="inline" set="null" line="22" static="1"><x path="Int"/></DESKTOP>
		<DOCS get="inline" set="null" line="23" static="1"><x path="Int"/></DOCS>
		<USER get="inline" set="null" line="24" static="1"><x path="Int"/></USER>
		<get_applicationDirectory set="method" line="45" static="1"><f a=""><c path="flash.filesystem.File"/></f></get_applicationDirectory>
		<get_applicationStorageDirectory set="method" line="46" static="1"><f a=""><c path="flash.filesystem.File"/></f></get_applicationStorageDirectory>
		<get_desktopDirectory set="method" line="47" static="1"><f a=""><c path="flash.filesystem.File"/></f></get_desktopDirectory>
		<get_documentsDirectory set="method" line="48" static="1"><f a=""><c path="flash.filesystem.File"/></f></get_documentsDirectory>
		<get_userDirectory set="method" line="49" static="1"><f a=""><c path="flash.filesystem.File"/></f></get_userDirectory>
		<lime_filesystem_get_special_dir line="100" static="1"><f a="">
	<x path="Int"/>
	<c path="String"/>
</f></lime_filesystem_get_special_dir>
		<nativePath public="1" set="accessor"><c path="String"/></nativePath>
		<url public="1" set="accessor"><c path="String"/></url>
		<set_nativePath set="method" line="52"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_nativePath>
		<set_url set="method" line="60"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_url>
		<new public="1" set="method" line="30"><f a="?path" v="null">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/filters/BitmapFilter.hx">
		<type><c path="String"/></type>
		<clone public="1" set="method" line="17"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method" line="10"><f a="type">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.filters.GlowFilter" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/filters/GlowFilter.hx">
		<extends path="flash.filters.BitmapFilter"/>
		<alpha public="1"><x path="Float"/></alpha>
		<blurX public="1"><x path="Float"/></blurX>
		<blurY public="1"><x path="Float"/></blurY>
		<color public="1"><x path="Int"/></color>
		<inner public="1"><x path="Bool"/></inner>
		<knockout public="1"><x path="Bool"/></knockout>
		<quality public="1"><x path="Int"/></quality>
		<strength public="1"><x path="Float"/></strength>
		<angle><x path="Float"/></angle>
		<distance><x path="Float"/></distance>
		<hideObject public="1"><x path="Bool"/></hideObject>
		<clone public="1" set="method" line="40" override="1"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method" line="21"><f a="?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout" v="0:1.0f:4.0f:4.0f:1.0f:1:false:false">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/geom/ColorTransform.hx">
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<color public="1" get="accessor" set="accessor"><x path="Int"/></color>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<redOffset public="1"><x path="Float"/></redOffset>
		<concat public="1" set="method" line="32"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<get_color set="method" line="49"><f a=""><x path="Int"/></f></get_color>
		<set_color set="method" line="56"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<new public="1" set="method" line="18"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset" v="1.0f:1.0f:1.0f:1.0f:0.0f:0.0f:0.0f:0.0f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/geom/Matrix.hx">
		<implements path="cpp.rtti.FieldNumericIntegerLookup"/>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<clone public="1" set="method" line="27"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1" set="method" line="34"><f a="m">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<copyColumnFrom public="1" set="method" line="52"><f a="column:vector3D">
	<x path="Int"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1" set="method" line="78"><f a="column:vector3D">
	<x path="Int"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1" set="method" line="107"><f a="other">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></copyFrom>
		<copyRowFrom public="1" set="method" line="119"><f a="row:vector3D">
	<x path="Int"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1" set="method" line="145"><f a="row:vector3D">
	<x path="Int"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowTo>
		<createBox public="1" set="method" line="172"><f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createBox>
		<createGradientBox public="1" set="method" line="183"><f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createGradientBox>
		<deltaTransformPoint public="1" set="method" line="209"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method" line="216"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method" line="228"><f a=""><c path="flash.geom.Matrix"/></f></invert>
		<mult public="1" set="method" line="258"><f a="m">
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.Matrix"/>
</f></mult>
		<rotate public="1" set="method" line="275"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method" line="295"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setRotation public="1" set="method" line="309"><f a="angle:?scale" v=":1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRotation>
		<setTo public="1" set="method" line="319"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<toString public="1" set="method" line="331"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method" line="338"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method" line="345"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<new public="1" set="method" line="15"><f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/geom/Matrix3D.hx">
		<create2D public="1" set="method" line="191" static="1"><f a="x:y:?scale:?rotation" v="::1:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></create2D>
		<createABCD public="1" set="method" line="207" static="1"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></createABCD>
		<createOrtho public="1" set="method" line="219" static="1"><f a="x0:x1:y0:y1:zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></createOrtho>
		<getAxisRotation public="1" set="method" line="306" static="1"><f a="x:y:z:degrees">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></getAxisRotation>
		<interpolate public="1" set="method" line="360" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<determinant public="1" get="accessor" set="null"><x path="Float"/></determinant>
		<position public="1" get="accessor" set="accessor"><c path="flash.geom.Vector3D"/></position>
		<rawData public="1"><x path="flash.Vector"><x path="Float"/></x></rawData>
		<append public="1" set="method" line="30"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<appendRotation public="1" set="method" line="64"><f a="degrees:axis:?pivotPoint" v="::null">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<appendScale public="1" set="method" line="80"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendTranslation public="1" set="method" line="87"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<clone public="1" set="method" line="96"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<copyColumnFrom public="1" set="method" line="103"><f a="column:vector3D">
	<x path="Int"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1" set="method" line="119"><f a="column:vector3D">
	<x path="Int"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1" set="method" line="135"><f a="other">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></copyFrom>
		<copyRowFrom public="1" set="method" line="146"><f a="row:vector3D">
	<x path="Int"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1" set="method" line="163"><f a="row:vector3D">
	<x path="Int"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowTo>
		<copyToMatrix3D public="1" set="method" line="180"><f a="other">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></copyToMatrix3D>
		<decompose public="1" set="method" line="235"><f a=""><x path="flash.Vector"><c path="flash.geom.Vector3D"/></x></f></decompose>
		<deltaTransformVector public="1" set="method" line="293"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<identity public="1" set="method" line="338"><f a=""><x path="Void"/></f></identity>
		<interpolateTo public="1" set="method" line="375"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<invert public="1" set="method" line="386"><f a=""><x path="Bool"/></f></invert>
		<pointAt public="1" set="method" line="423"><f a="pos:?at:?up" v=":null:null">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<prepend public="1" set="method" line="490"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<prependRotation public="1" set="method" line="524"><f a="degrees:axis:?pivotPoint" v="::null">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prependScale public="1" set="method" line="540"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependTranslation public="1" set="method" line="547"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method" line="556"><f a="components">
	<x path="flash.Vector"><c path="flash.geom.Vector3D"/></x>
	<x path="Bool"/>
</f></recompose>
		<transformVector public="1" set="method" line="579"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method" line="592"><f a="vin:vout">
	<x path="flash.Vector"><x path="Float"/></x>
	<x path="flash.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></transformVectors>
		<transpose public="1" set="method" line="612"><f a=""><x path="Void"/></f></transpose>
		<get_determinant set="method" line="638"><f a=""><x path="Float"/></f></get_determinant>
		<get_position set="method" line="650"><f a=""><c path="flash.geom.Vector3D"/></f></get_position>
		<set_position public="1" set="method" line="657"><f a="value">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></set_position>
		<new public="1" set="method" line="15"><f a="?v" v="null">
	<x path="flash.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Point" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/geom/Point.hx">
		<distance public="1" set="method" line="42" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" line="58" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" line="90" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method" line="20"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1" set="method" line="27"><f a=""><c path="flash.geom.Point"/></f></clone>
		<copyFrom public="1" set="method" line="34"><f a="sourcePoint">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></copyFrom>
		<equals public="1" set="method" line="51"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<normalize public="1" set="method" line="65"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method" line="82"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setTo public="1" set="method" line="97"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<subtract public="1" set="method" line="105"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1" set="method" line="112"><f a=""><c path="String"/></f></toString>
		<get_length set="method" line="126"><f a=""><x path="Float"/></f></get_length>
		<new public="1" set="method" line="12"><f a="?x:?y" v="0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/geom/Rectangle.hx">
		<bottom public="1" get="accessor" set="accessor"><x path="Float"/></bottom>
		<bottomRight public="1" get="accessor" set="accessor"><c path="flash.geom.Point"/></bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1" get="accessor" set="accessor"><x path="Float"/></left>
		<right public="1" get="accessor" set="accessor"><x path="Float"/></right>
		<size public="1" get="accessor" set="accessor"><c path="flash.geom.Point"/></size>
		<top public="1" get="accessor" set="accessor"><x path="Float"/></top>
		<topLeft public="1" get="accessor" set="accessor"><c path="flash.geom.Point"/></topLeft>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method" line="30"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1" set="method" line="37"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method" line="44"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method" line="51"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<copyFrom public="1" set="method" line="66"><f a="sourceRect">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></copyFrom>
		<equals public="1" set="method" line="76"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<extendBounds public="1" set="method" line="83"><f a="r">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></extendBounds>
		<inflate public="1" set="method" line="116"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method" line="126"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method" line="133"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method" line="156"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method" line="173"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method" line="180"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method" line="188"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method" line="196"><f a=""><x path="Void"/></f></setEmpty>
		<setTo public="1" set="method" line="206"><f a="xa:ya:widtha:heighta">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<toString public="1" set="method" line="216"><f a=""><c path="String"/></f></toString>
		<transform public="1" set="method" line="223"><f a="m">
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.Rectangle"/>
</f></transform>
		<union public="1" set="method" line="256"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<get_bottom set="method" line="274"><f a=""><x path="Float"/></f></get_bottom>
		<set_bottom set="method" line="275"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bottom>
		<get_bottomRight set="method" line="276"><f a=""><c path="flash.geom.Point"/></f></get_bottomRight>
		<set_bottomRight set="method" line="277"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_bottomRight>
		<get_left set="method" line="278"><f a=""><x path="Float"/></f></get_left>
		<set_left set="method" line="279"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_left>
		<get_right set="method" line="280"><f a=""><x path="Float"/></f></get_right>
		<set_right set="method" line="281"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_right>
		<get_size set="method" line="282"><f a=""><c path="flash.geom.Point"/></f></get_size>
		<set_size set="method" line="283"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_size>
		<get_top set="method" line="284"><f a=""><x path="Float"/></f></get_top>
		<set_top set="method" line="285"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_top>
		<get_topLeft set="method" line="286"><f a=""><c path="flash.geom.Point"/></f></get_topLeft>
		<set_topLeft set="method" line="287"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_topLeft>
		<new public="1" set="method" line="20"><f a="?x:?y:?width:?height" v="0:0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/geom/Transform.hx">
		<colorTransform public="1" get="accessor" set="accessor"><c path="flash.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" get="accessor" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" get="accessor" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1" get="accessor" set="accessor"><c path="flash.geom.Matrix"/></matrix>
		<pixelBounds public="1" get="accessor" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<__parent>
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":noCompletion"/></meta>
		</__parent>
		<get_colorTransform set="method" line="33"><f a=""><c path="flash.geom.ColorTransform"/></f></get_colorTransform>
		<set_colorTransform set="method" line="34"><f a="value">
	<c path="flash.geom.ColorTransform"/>
	<c path="flash.geom.ColorTransform"/>
</f></set_colorTransform>
		<get_concatenatedColorTransform set="method" line="35"><f a=""><c path="flash.geom.ColorTransform"/></f></get_concatenatedColorTransform>
		<get_concatenatedMatrix set="method" line="36"><f a=""><c path="flash.geom.Matrix"/></f></get_concatenatedMatrix>
		<get_matrix set="method" line="37"><f a=""><c path="flash.geom.Matrix"/></f></get_matrix>
		<set_matrix set="method" line="38"><f a="value">
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.Matrix"/>
</f></set_matrix>
		<get_pixelBounds set="method" line="39"><f a=""><c path="flash.geom.Rectangle"/></f></get_pixelBounds>
		<new public="1" set="method" line="19"><f a="parent">
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/geom/Vector3D.hx">
		<X_AXIS public="1" get="accessor" set="null" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" get="accessor" set="null" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" get="accessor" set="null" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" get="inline" set="null" line="36" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" get="inline" set="null" line="79" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<get_X_AXIS get="inline" set="null" line="196" static="1"><f a=""><c path="flash.geom.Vector3D"/></f></get_X_AXIS>
		<get_Y_AXIS get="inline" set="null" line="197" static="1"><f a=""><c path="flash.geom.Vector3D"/></f></get_Y_AXIS>
		<get_Z_AXIS get="inline" set="null" line="198" static="1"><f a=""><c path="flash.geom.Vector3D"/></f></get_Z_AXIS>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<lengthSquared public="1" get="accessor" set="null"><x path="Float"/></lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" get="inline" set="null" line="29"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<clone public="1" get="inline" set="null" line="47"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<copyFrom public="1" get="inline" set="null" line="54"><f a="sourceVector3D">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></copyFrom>
		<crossProduct public="1" get="inline" set="null" line="63"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" get="inline" set="null" line="70"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" get="inline" set="null" line="90"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" get="inline" set="null" line="97"><f a="toCompare:?allFour" v=":false">
	<c path="flash.geom.Vector3D"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></equals>
		<incrementBy public="1" get="inline" set="null" line="104"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" get="inline" set="null" line="113"><f a="toCompare:tolerance:?allFour" v="::false">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></nearEquals>
		<negate public="1" get="inline" set="null" line="120"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" get="inline" set="null" line="129"><f a=""><x path="Float"/></f></normalize>
		<project public="1" get="inline" set="null" line="146"><f a=""><x path="Void"/></f></project>
		<setTo public="1" get="inline" set="null" line="155"><f a="xa:ya:za">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<scaleBy public="1" get="inline" set="null" line="164"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<subtract public="1" get="inline" set="null" line="173"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<toString public="1" get="inline" set="null" line="180"><f a=""><c path="String"/></f></toString>
		<get_length get="inline" set="null" line="194"><f a=""><x path="Float"/></f></get_length>
		<get_lengthSquared get="inline" set="null" line="195"><f a=""><x path="Float"/></f></get_lengthSquared>
		<new public="1" set="method" line="19"><f a="?x:?y:?z:?w" v="0:0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.ID3Info" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/media/ID3Info.hx">
		<album public="1"><c path="String"/></album>
		<artist public="1"><c path="String"/></artist>
		<comment public="1"><c path="String"/></comment>
		<genre public="1"><c path="String"/></genre>
		<songName public="1"><c path="String"/></songName>
		<track public="1"><c path="String"/></track>
		<year public="1"><c path="String"/></year>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.Sound" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/media/Sound.hx">
		<extends path="flash.events.EventDispatcher"/>
		<lime_sound_from_file line="312" static="1"><f a=":">
	<c path="String"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_sound_from_file>
		<lime_sound_from_data line="313" static="1"><f a="::">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_sound_from_data>
		<lime_sound_get_id3 line="314" static="1"><f a=":">
	<d/>
	<c path="flash.media.ID3Info"/>
	<unknown/>
</f></lime_sound_get_id3>
		<lime_sound_get_length line="315" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_sound_get_length>
		<lime_sound_close line="316" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_sound_close>
		<lime_sound_get_status line="317" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_sound_get_status>
		<lime_sound_channel_create_dynamic line="318" static="1"><f a=":">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.media.SoundTransform"/>
	<unknown/>
</f></lime_sound_channel_create_dynamic>
		<bytesLoaded public="1" set="null"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<id3 public="1" get="accessor" set="null"><c path="flash.media.ID3Info"/></id3>
		<isBuffering public="1" get="accessor" set="null"><x path="Bool"/></isBuffering>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<url public="1" set="null"><c path="String"/></url>
		<__audioType public="1">
			<e path="flash.media.InternalAudioType"/>
			<meta><m n=":noCompletion"/></meta>
		</__audioType>
		<__handle public="1">
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<__loading>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__loading>
		<__dynamicSound>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__dynamicSound>
		<addEventListener public="1" set="method" line="53" override="1"><f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
	<c path="String"/>
	<t path="flash.events.Function"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<close public="1" set="method" line="73"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="87"><f a="stream:?context:?forcePlayAsMusic" v=":null:false">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></load>
		<loadCompressedDataFromByteArray public="1" set="method" line="111"><f a="bytes:length:?forcePlayAsMusic" v="::false">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" set="method" line="127"><f a="bytes:samples:?format:?stereo:?sampleRate" v="::'float':true:44100.0f">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></loadPCMFromByteArray>
		<play public="1" set="method" line="175"><f a="?startTime:?loops:?soundTransform" v="0:0:null">
	<x path="Float"/>
	<x path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundChannel"/>
</f></play>
		<__checkLoading set="method" line="224">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__checkLoading>
		<__onError set="method" line="251">
			<f a="msg">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onError>
		<get_id3 set="method" line="267"><f a=""><c path="flash.media.ID3Info"/></f></get_id3>
		<get_isBuffering set="method" line="284"><f a=""><x path="Bool"/></f></get_isBuffering>
		<get_length set="method" line="292"><f a=""><x path="Float"/></f></get_length>
		<new public="1" set="method" line="33"><f a="?stream:?context:?forcePlayAsMusic" v="null:null:false">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":autoBuild"><e>'???'</e></m></meta>
	</class>
	<enum path="flash.media.InternalAudioType" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/media/Sound.hx" module="flash.media.Sound">
		<MUSIC/>
		<SOUND/>
		<UNKNOWN/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":noCompletion"/>
		</meta>
	</enum>
	<class path="flash.media.SoundChannel" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/media/SoundChannel.hx">
		<extends path="flash.events.EventDispatcher"/>
		<__dynamicSoundCount public="1" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__dynamicSoundCount>
		<__incompleteList line="30" static="1">
			<c path="Array"><c path="flash.media.SoundChannel"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__incompleteList>
		<__audioState static="1">
			<c path="flash.media.AudioThreadState"/>
			<meta><m n=":noCompletion"/></meta>
		</__audioState>
		<__audioThreadIsIdle line="41" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__audioThreadIsIdle>
		<__audioThreadRunning line="42" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__audioThreadRunning>
		<createDynamic public="1" set="method" line="76" static="1"><f a="handle:soundTransform:dataProvider">
	<d/>
	<c path="flash.media.SoundTransform"/>
	<c path="flash.events.EventDispatcher"/>
	<c path="flash.media.SoundChannel"/>
</f></createDynamic>
		<__checkCompleteBackgroundThread set="method" line="177" static="1"><f a=""><x path="Void"/></f></__checkCompleteBackgroundThread>
		<__completePending public="1" set="method" line="203" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__completePending>
		<__pollComplete public="1" set="method" line="210" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__pollComplete>
		<lime_sound_channel_is_complete line="295" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_sound_channel_is_complete>
		<lime_sound_channel_get_left line="296" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_sound_channel_get_left>
		<lime_sound_channel_get_right line="297" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_sound_channel_get_right>
		<lime_sound_channel_get_position line="298" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_sound_channel_get_position>
		<lime_sound_channel_set_position line="299" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
</f></lime_sound_channel_set_position>
		<lime_sound_channel_get_data_position line="300" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_sound_channel_get_data_position>
		<lime_sound_channel_stop line="301" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_sound_channel_stop>
		<lime_sound_channel_create line="302" static="1"><f a=":::">
	<d/>
	<x path="Float"/>
	<x path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<unknown/>
</f></lime_sound_channel_create>
		<lime_sound_channel_set_transform line="303" static="1"><f a=":">
	<d/>
	<c path="flash.media.SoundTransform"/>
	<unknown/>
</f></lime_sound_channel_set_transform>
		<lime_sound_channel_needs_data line="304" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_sound_channel_needs_data>
		<lime_sound_channel_add_data line="305" static="1"><f a=":">
	<d/>
	<c path="flash.utils.ByteArray"/>
	<unknown/>
</f></lime_sound_channel_add_data>
		<leftPeak public="1" get="accessor" set="null"><x path="Float"/></leftPeak>
		<rightPeak public="1" get="accessor" set="null"><x path="Float"/></rightPeak>
		<position public="1" get="accessor" set="accessor"><x path="Float"/></position>
		<soundTransform public="1" get="accessor" set="accessor"><c path="flash.media.SoundTransform"/></soundTransform>
		<__dataProvider public="1">
			<c path="flash.events.EventDispatcher"/>
			<meta><m n=":noCompletion"/></meta>
		</__dataProvider>
		<__handle>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<__soundInstance public="1">
			<c path="flash.media.Sound"/>
			<meta><m n=":noCompletion"/></meta>
		</__soundInstance>
		<__transform>
			<c path="flash.media.SoundTransform"/>
			<meta><m n=":noCompletion"/></meta>
		</__transform>
		<__thread_completed public="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__thread_completed>
		<__addedToThread>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__addedToThread>
		<stop public="1" set="method" line="91"><f a=""><x path="Void"/></f></stop>
		<__checkComplete set="method" line="111">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__checkComplete>
		<__runCheckComplete public="1" set="method" line="227">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__runCheckComplete>
		<get_leftPeak set="method" line="259"><f a=""><x path="Float"/></f></get_leftPeak>
		<get_rightPeak set="method" line="260"><f a=""><x path="Float"/></f></get_rightPeak>
		<get_position set="method" line="261"><f a=""><x path="Float"/></f></get_position>
		<set_position set="method" line="262"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<get_soundTransform set="method" line="265"><f a=""><c path="flash.media.SoundTransform"/></f></get_soundTransform>
		<set_soundTransform set="method" line="278"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<new public="1" set="method" line="51"><f a="handle:startTime:loops:soundTransform">
	<d/>
	<x path="Float"/>
	<x path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AudioThreadState" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/media/SoundChannel.hx" module="flash.media.SoundChannel">
		<audioThread public="1"><c path="cpp.vm.Thread"/></audioThread>
		<channelList public="1"><c path="Array"><c path="flash.media.SoundChannel"/></c></channelList>
		<mainThread public="1"><c path="cpp.vm.Thread"/></mainThread>
		<mutex public="1"><c path="cpp.vm.Mutex"/></mutex>
		<add public="1" set="method" line="330"><f a="channel">
	<c path="flash.media.SoundChannel"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="342"><f a="channel">
	<c path="flash.media.SoundChannel"/>
	<x path="Void"/>
</f></remove>
		<updateComplete public="1" set="method" line="371"><f a=""><x path="Void"/></f></updateComplete>
		<new public="1" set="method" line="322"><f a=""><x path="Void"/></f></new>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="flash.media.SoundLoaderContext" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/media/SoundLoaderContext.hx"><new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new></class>
	<class path="flash.media.SoundTransform" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/media/SoundTransform.hx">
		<pan public="1"><x path="Float"/></pan>
		<volume public="1"><x path="Float"/></volume>
		<clone public="1" set="method" line="19"><f a=""><c path="flash.media.SoundTransform"/></f></clone>
		<new public="1" set="method" line="11"><f a="?volume:?pan" v="1.0f:0.0f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.SharedObject" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/net/SharedObject.hx">
		<extends path="flash.events.EventDispatcher"/>
		<mkdir public="1" set="method" line="66" static="1"><f a="directory">
	<c path="String"/>
	<x path="Void"/>
</f></mkdir>
		<getFilePath set="method" line="151" static="1"><f a="name:localPath">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getFilePath>
		<getLocal public="1" set="method" line="160" static="1"><f a="name:?localPath:?secure" v=":null:false">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getLocal>
		<resolveClass set="method" line="210" static="1"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<data public="1" set="null"><d/></data>
		<localPath><c path="String"/></localPath>
		<name><c path="String"/></name>
		<clear public="1" set="method" line="36"><f a=""><x path="Void"/></f></clear>
		<close public="1" set="method" line="57"><f a=""><x path="Void"/></f></close>
		<flush public="1" set="method" line="121"><f a="?minDiskSpace" v="0">
	<x path="Int"/>
	<e path="flash.net.SharedObjectFlushStatus"/>
</f></flush>
		<setProperty public="1" set="method" line="223"><f a="propertyName:?value" v=":null">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></setProperty>
		<new set="method" line="25"><f a="name:localPath:data">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.net.SharedObjectFlushStatus" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/net/SharedObjectFlushStatus.hx">
		<FLUSHED/>
		<PENDING/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.net.URLLoaderDataFormat" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/net/URLLoaderDataFormat.hx">
		<BINARY/>
		<TEXT/>
		<VARIABLES/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.net.URLRequest" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/net/URLRequest.hx">
		<AUTH_BASIC public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></AUTH_BASIC>
		<AUTH_DIGEST public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></AUTH_DIGEST>
		<AUTH_GSSNEGOTIATE public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></AUTH_GSSNEGOTIATE>
		<AUTH_NTLM public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></AUTH_NTLM>
		<AUTH_DIGEST_IE public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></AUTH_DIGEST_IE>
		<AUTH_DIGEST_ANY public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></AUTH_DIGEST_ANY>
		<authType public="1"><x path="Int"/></authType>
		<contentType public="1"><c path="String"/></contentType>
		<cookieString public="1"><c path="String"/></cookieString>
		<credentials public="1"><c path="String"/></credentials>
		<data public="1"><d/></data>
		<followRedirects public="1"><x path="Bool"/></followRedirects>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<verbose public="1"><x path="Bool"/></verbose>
		<__bytes public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":noCompletion"/></meta>
		</__bytes>
		<basicAuth public="1" set="method" line="52"><f a="user:password">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></basicAuth>
		<digestAuth public="1" set="method" line="60"><f a="user:password">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></digestAuth>
		<__prepare public="1" set="method" line="68">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__prepare>
		<new public="1" set="method" line="31"><f a="?url" v="null">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/net/URLRequestHeader.hx">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method" line="11"><f a="?name:?value" v="null:null">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.URLRequestMethod" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/net/URLRequestMethod.hx">
		<DELETE public="1" get="inline" set="null" line="7" static="1"><c path="String"/></DELETE>
		<GET public="1" get="inline" set="null" line="8" static="1"><c path="String"/></GET>
		<HEAD public="1" get="inline" set="null" line="9" static="1"><c path="String"/></HEAD>
		<OPTIONS public="1" get="inline" set="null" line="10" static="1"><c path="String"/></OPTIONS>
		<POST public="1" get="inline" set="null" line="11" static="1"><c path="String"/></POST>
		<PUT public="1" get="inline" set="null" line="12" static="1"><c path="String"/></PUT>
	</class>
	<class path="flash.net.URLVariables" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/net/URLVariables.hx">
		<decode public="1" set="method" line="18"><f a="data">
	<c path="String"/>
	<x path="Void"/>
</f></decode>
		<toString public="1" set="method" line="49"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="7"><f a="?encoded" v="null">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/system/ApplicationDomain.hx">
		<currentDomain public="1" set="null" line="7" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method" line="27"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<hasDefinition public="1" set="method" line="34"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method" line="12"><f a="?parentDomain" v="null">
	<c path="flash.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.system.LoaderContext" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/system/LoaderContext.hx">
		<allowCodeImport public="1"><x path="Bool"/></allowCodeImport>
		<allowLoadBytesCodeExecution public="1"><x path="Bool"/></allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method" line="14"><f a="?checkPolicyFile:?applicationDomain:?securityDomain" v="false:null:null">
	<x path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.system.PixelFormat" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/system/PixelFormat.hx">
		<UNKNOWN/>
		<INDEX1LSB/>
		<INDEX1MSB/>
		<INDEX4LSB/>
		<INDEX4MSB/>
		<INDEX8/>
		<RGB332/>
		<RGB444/>
		<RGB555/>
		<BGR555/>
		<ARGB4444/>
		<RGBA4444/>
		<ABGR4444/>
		<BGRA4444/>
		<ARGB1555/>
		<RGBA5551/>
		<ABGR1555/>
		<BGRA5551/>
		<RGB565/>
		<BGR565/>
		<RGB24/>
		<BGR24/>
		<RGB888/>
		<RGBX8888/>
		<BGR888/>
		<BGRX8888/>
		<ARGB8888/>
		<RGBA8888/>
		<ABGR8888/>
		<BGRA8888/>
		<ARGB2101010/>
		<YV12/>
		<IYUV/>
		<YUY2/>
		<UYVY/>
		<YVYU/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.system.ScreenMode" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/system/ScreenMode.hx">
		<format public="1"><e path="flash.system.PixelFormat"/></format>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<refreshRate public="1"><x path="Int"/></refreshRate>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/system/SecurityDomain.hx">
		<currentDomain public="1" set="null" line="7" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<new set="method" line="10"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.system.System" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/system/System.hx">
		<deviceID public="1" get="accessor" set="null" static="1"><c path="String"/></deviceID>
		<totalMemory public="1" get="accessor" set="null" static="1"><x path="Int"/></totalMemory>
		<exit public="1" set="method" line="14" static="1"><f a="?code" v="0">
	<x path="Int"/>
	<x path="Void"/>
</f></exit>
		<gc public="1" set="method" line="21" static="1"><f a=""><x path="Void"/></f></gc>
		<get_deviceID set="method" line="43" static="1"><f a=""><c path="String"/></f></get_deviceID>
		<get_totalMemory set="method" line="46" static="1"><f a=""><x path="Int"/></f></get_totalMemory>
		<lime_get_unique_device_identifier line="68" static="1"><f a=""><c path="String"/></f></lime_get_unique_device_identifier>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/AntiAliasType.hx">
		<ADVANCED/>
		<NORMAL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.text.Font" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/Font.hx">
		<__registeredFonts line="18" static="1">
			<c path="Array"><c path="flash.text.Font"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__registeredFonts>
		<__deviceFonts static="1">
			<c path="Array"><c path="flash.text.Font"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__deviceFonts>
		<enumerateFonts public="1" set="method" line="74" static="1"><f a="?enumerateDeviceFonts" v="false">
	<x path="Bool"/>
	<c path="Array"><c path="flash.text.Font"/></c>
</f></enumerateFonts>
		<load public="1" set="method" line="97" static="1"><f a="filename">
	<c path="String"/>
	<t path="flash.text.NativeFontData"/>
</f></load>
		<loadBytes public="1" set="method" line="105" static="1"><f a="bytes">
	<c path="flash.utils.ByteArray"/>
	<t path="flash.text.NativeFontData"/>
</f></loadBytes>
		<registerFont public="1" set="method" line="113" static="1"><f a="font">
	<x path="Class"><c path="flash.text.Font"/></x>
	<x path="Void"/>
</f></registerFont>
		<freetype_import_font line="146" static="1"><f a=":::">
	<c path="String"/>
	<unknown/>
	<x path="Int"/>
	<c path="flash.utils.ByteArray"/>
	<t path="flash.text.NativeFontData"/>
</f></freetype_import_font>
		<lime_font_register_font line="147" static="1"><f a=":">
	<c path="String"/>
	<c path="flash.utils.ByteArray"/>
	<unknown/>
</f></lime_font_register_font>
		<lime_font_iterate_device_fonts line="148" static="1"><f a="">
	<f a="name:style">
		<c path="String"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<unknown/>
</f></lime_font_iterate_device_fonts>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<fontStyle public="1" set="null"><e path="flash.text.FontStyle"/></fontStyle>
		<fontType public="1" set="null"><e path="flash.text.FontType"/></fontType>
		<toString public="1" set="method" line="132"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="22"><f a="?filename:?style:?type" v="'':null:null">
	<c path="String"/>
	<e path="flash.text.FontStyle"/>
	<e path="flash.text.FontType"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":autoBuild"><e>'???'</e></m></meta>
	</class>
	<typedef path="flash.text.NativeFontData" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/Font.hx" module="flash.text.Font"><a>
	<style_name><c path="String"/></style_name>
	<num_glyphs><x path="Int"/></num_glyphs>
	<kerning><c path="Array"><t path="flash.text.NativeKerningData"/></c></kerning>
	<is_italic><x path="Bool"/></is_italic>
	<is_fixed_width><x path="Bool"/></is_fixed_width>
	<is_bold><x path="Bool"/></is_bold>
	<height><x path="Int"/></height>
	<has_kerning><x path="Bool"/></has_kerning>
	<has_glyph_names><x path="Bool"/></has_glyph_names>
	<glyphs><c path="Array"><t path="flash.text.NativeGlyphData"/></c></glyphs>
	<family_name><c path="String"/></family_name>
	<em_size><x path="Int"/></em_size>
	<descend><x path="Int"/></descend>
	<ascend><x path="Int"/></ascend>
</a></typedef>
	<typedef path="flash.text.NativeGlyphData" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/Font.hx" module="flash.text.Font"><a>
	<points><c path="Array"><x path="Int"/></c></points>
	<min_y><x path="Int"/></min_y>
	<min_x><x path="Int"/></min_x>
	<max_y><x path="Int"/></max_y>
	<max_x><x path="Int"/></max_x>
	<char_code><x path="Int"/></char_code>
	<advance><x path="Int"/></advance>
</a></typedef>
	<typedef path="flash.text.NativeKerningData" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/Font.hx" module="flash.text.Font"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<right_glyph><x path="Int"/></right_glyph>
	<left_glyph><x path="Int"/></left_glyph>
</a></typedef>
	<enum path="flash.text.FontStyle" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/FontStyle.hx">
		<BOLD/>
		<BOLD_ITALIC/>
		<ITALIC/>
		<REGULAR/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.FontType" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/FontType.hx">
		<DEVICE/>
		<EMBEDDED/>
		<EMBEDDED_CFF/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/GridFitType.hx">
		<NONE/>
		<PIXEL/>
		<SUBPIXEL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.text.TextField" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/TextField.hx">
		<extends path="flash.display.InteractiveObject"/>
		<lime_text_field_create line="168" static="1"><f a=""><unknown/></f></lime_text_field_create>
		<lime_text_field_get_text line="169" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_text_field_get_text>
		<lime_text_field_set_text line="170" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></lime_text_field_set_text>
		<lime_text_field_get_html_text line="171" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_text_field_get_html_text>
		<lime_text_field_set_html_text line="172" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></lime_text_field_set_html_text>
		<lime_text_field_get_text_color line="173" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_text_color>
		<lime_text_field_set_text_color line="174" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_text_field_set_text_color>
		<lime_text_field_get_selectable line="175" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_text_field_get_selectable>
		<lime_text_field_set_selectable line="176" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_text_field_set_selectable>
		<lime_text_field_get_display_as_password line="177" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_text_field_get_display_as_password>
		<lime_text_field_set_display_as_password line="178" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_text_field_set_display_as_password>
		<lime_text_field_get_def_text_format line="179" static="1"><f a=":">
	<d/>
	<c path="flash.text.TextFormat"/>
	<unknown/>
</f></lime_text_field_get_def_text_format>
		<lime_text_field_set_def_text_format line="180" static="1"><f a=":">
	<d/>
	<c path="flash.text.TextFormat"/>
	<unknown/>
</f></lime_text_field_set_def_text_format>
		<lime_text_field_get_auto_size line="181" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_auto_size>
		<lime_text_field_set_auto_size line="182" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_text_field_set_auto_size>
		<lime_text_field_get_type line="183" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_text_field_get_type>
		<lime_text_field_set_type line="184" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_text_field_set_type>
		<lime_text_field_get_multiline line="185" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_text_field_get_multiline>
		<lime_text_field_set_multiline line="186" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_text_field_set_multiline>
		<lime_text_field_get_word_wrap line="187" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_text_field_get_word_wrap>
		<lime_text_field_set_word_wrap line="188" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_text_field_set_word_wrap>
		<lime_text_field_get_border line="189" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_text_field_get_border>
		<lime_text_field_set_border line="190" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_text_field_set_border>
		<lime_text_field_get_border_color line="191" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_border_color>
		<lime_text_field_set_border_color line="192" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_text_field_set_border_color>
		<lime_text_field_get_background line="193" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_text_field_get_background>
		<lime_text_field_set_background line="194" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_text_field_set_background>
		<lime_text_field_get_background_color line="195" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_background_color>
		<lime_text_field_set_background_color line="196" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_text_field_set_background_color>
		<lime_text_field_get_text_width line="197" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_text_field_get_text_width>
		<lime_text_field_get_text_height line="198" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_text_field_get_text_height>
		<lime_text_field_get_text_format line="199" static="1"><f a=":::">
	<d/>
	<c path="flash.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_text_field_get_text_format>
		<lime_text_field_set_text_format line="200" static="1"><f a=":::">
	<d/>
	<c path="flash.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_text_field_set_text_format>
		<lime_text_field_get_max_scroll_v line="201" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_max_scroll_v>
		<lime_text_field_get_max_scroll_h line="202" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_max_scroll_h>
		<lime_text_field_get_bottom_scroll_v line="203" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_bottom_scroll_v>
		<lime_text_field_get_scroll_h line="204" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_scroll_h>
		<lime_text_field_set_scroll_h line="205" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_text_field_set_scroll_h>
		<lime_text_field_get_scroll_v line="206" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_scroll_v>
		<lime_text_field_set_scroll_v line="207" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_text_field_set_scroll_v>
		<lime_text_field_get_num_lines line="208" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_num_lines>
		<lime_text_field_get_max_chars line="209" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_text_field_get_max_chars>
		<lime_text_field_set_max_chars line="210" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_text_field_set_max_chars>
		<lime_text_field_get_line_text line="211" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<c path="String"/>
</f></lime_text_field_get_line_text>
		<lime_text_field_get_line_metrics line="212" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
	<unknown/>
</f></lime_text_field_get_line_metrics>
		<lime_text_field_get_line_offset line="213" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></lime_text_field_get_line_offset>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1" get="accessor" set="accessor"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<background public="1" get="accessor" set="accessor"><x path="Bool"/></background>
		<backgroundColor public="1" get="accessor" set="accessor"><x path="Int"/></backgroundColor>
		<border public="1" get="accessor" set="accessor"><x path="Bool"/></border>
		<borderColor public="1" get="accessor" set="accessor"><x path="Int"/></borderColor>
		<bottomScrollV public="1" get="accessor" set="null"><x path="Int"/></bottomScrollV>
		<defaultTextFormat public="1" get="accessor" set="accessor"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1" get="accessor" set="accessor"><x path="Bool"/></displayAsPassword>
		<embedFonts public="1" get="accessor" set="accessor"><x path="Bool"/></embedFonts>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<htmlText public="1" get="accessor" set="accessor"><c path="String"/></htmlText>
		<maxChars public="1" get="accessor" set="accessor"><x path="Int"/></maxChars>
		<maxScrollH public="1" get="accessor" set="null"><x path="Int"/></maxScrollH>
		<maxScrollV public="1" get="accessor" set="null"><x path="Int"/></maxScrollV>
		<multiline public="1" get="accessor" set="accessor"><x path="Bool"/></multiline>
		<numLines public="1" get="accessor" set="null"><x path="Int"/></numLines>
		<scrollH public="1" get="accessor" set="accessor"><x path="Int"/></scrollH>
		<scrollV public="1" get="accessor" set="accessor"><x path="Int"/></scrollV>
		<selectable public="1" get="accessor" set="accessor"><x path="Bool"/></selectable>
		<sharpness public="1"><x path="Float"/></sharpness>
		<text public="1" get="accessor" set="accessor"><c path="String"/></text>
		<textColor public="1" get="accessor" set="accessor"><x path="Int"/></textColor>
		<textHeight public="1" get="accessor" set="null"><x path="Float"/></textHeight>
		<textWidth public="1" get="accessor" set="null"><x path="Float"/></textWidth>
		<type public="1" get="accessor" set="accessor"><e path="flash.text.TextFieldType"/></type>
		<wordWrap public="1" get="accessor" set="accessor"><x path="Bool"/></wordWrap>
		<appendText public="1" set="method" line="50"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<getLineOffset public="1" set="method" line="57"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method" line="64"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineMetrics public="1" set="method" line="71"><f a="lineIndex">
	<x path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getTextFormat public="1" set="method" line="80"><f a="?beginIndex:?endIndex" v="-1:-1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<replaceText public="1" set="method" line="89"><f a="beginIndex:endIndex:newText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method" line="96"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method" line="103"><f a="format:?beginIndex:?endIndex" v=":-1:-1">
	<c path="flash.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setTextFormat>
		<get_autoSize set="method" line="117"><f a=""><e path="flash.text.TextFieldAutoSize"/></f></get_autoSize>
		<set_autoSize set="method" line="118"><f a="value">
	<e path="flash.text.TextFieldAutoSize"/>
	<e path="flash.text.TextFieldAutoSize"/>
</f></set_autoSize>
		<get_background set="method" line="119"><f a=""><x path="Bool"/></f></get_background>
		<set_background set="method" line="120"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_background>
		<get_backgroundColor set="method" line="121"><f a=""><x path="Int"/></f></get_backgroundColor>
		<set_backgroundColor set="method" line="122"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_backgroundColor>
		<get_border set="method" line="123"><f a=""><x path="Bool"/></f></get_border>
		<set_border set="method" line="124"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_border>
		<get_borderColor set="method" line="125"><f a=""><x path="Int"/></f></get_borderColor>
		<set_borderColor set="method" line="126"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderColor>
		<get_bottomScrollV set="method" line="127"><f a=""><x path="Int"/></f></get_bottomScrollV>
		<get_defaultTextFormat set="method" line="128"><f a=""><c path="flash.text.TextFormat"/></f></get_defaultTextFormat>
		<set_defaultTextFormat set="method" line="129"><f a="value">
	<c path="flash.text.TextFormat"/>
	<c path="flash.text.TextFormat"/>
</f></set_defaultTextFormat>
		<get_displayAsPassword set="method" line="130"><f a=""><x path="Bool"/></f></get_displayAsPassword>
		<set_displayAsPassword set="method" line="131"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_displayAsPassword>
		<get_embedFonts set="method" line="132"><f a=""><x path="Bool"/></f></get_embedFonts>
		<set_embedFonts set="method" line="133"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_embedFonts>
		<get_htmlText set="method" line="134"><f a=""><c path="String"/></f></get_htmlText>
		<set_htmlText set="method" line="135"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_htmlText>
		<get_maxChars set="method" line="136"><f a=""><x path="Int"/></f></get_maxChars>
		<set_maxChars set="method" line="137"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxChars>
		<get_maxScrollH set="method" line="138"><f a=""><x path="Int"/></f></get_maxScrollH>
		<get_maxScrollV set="method" line="139"><f a=""><x path="Int"/></f></get_maxScrollV>
		<get_multiline set="method" line="140"><f a=""><x path="Bool"/></f></get_multiline>
		<set_multiline set="method" line="141"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_multiline>
		<get_numLines set="method" line="142"><f a=""><x path="Int"/></f></get_numLines>
		<get_scrollH set="method" line="143"><f a=""><x path="Int"/></f></get_scrollH>
		<set_scrollH set="method" line="144"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollH>
		<get_scrollV set="method" line="145"><f a=""><x path="Int"/></f></get_scrollV>
		<set_scrollV set="method" line="146"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollV>
		<get_selectable set="method" line="147"><f a=""><x path="Bool"/></f></get_selectable>
		<set_selectable set="method" line="148"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_selectable>
		<get_text set="method" line="149"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="150"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<get_textColor set="method" line="151"><f a=""><x path="Int"/></f></get_textColor>
		<set_textColor set="method" line="152"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_textColor>
		<get_textWidth set="method" line="153"><f a=""><x path="Float"/></f></get_textWidth>
		<get_textHeight set="method" line="154"><f a=""><x path="Float"/></f></get_textHeight>
		<get_type set="method" line="155"><f a=""><e path="flash.text.TextFieldType"/></f></get_type>
		<set_type set="method" line="156"><f a="value">
	<e path="flash.text.TextFieldType"/>
	<e path="flash.text.TextFieldType"/>
</f></set_type>
		<get_wordWrap set="method" line="157"><f a=""><x path="Bool"/></f></get_wordWrap>
		<set_wordWrap set="method" line="158"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wordWrap>
		<new public="1" set="method" line="40"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/TextFieldAutoSize.hx">
		<CENTER/>
		<LEFT/>
		<NONE/>
		<RIGHT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/TextFieldType.hx">
		<DYNAMIC/>
		<INPUT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/TextFormat.hx">
		<align public="1"><c path="String"/></align>
		<blockIndent public="1"><t path="Null"><x path="Float"/></t></blockIndent>
		<bold public="1"><t path="Null"><x path="Bool"/></t></bold>
		<bullet public="1"><t path="Null"><x path="Bool"/></t></bullet>
		<color public="1"><t path="Null"><x path="Int"/></t></color>
		<display public="1"><c path="String"/></display>
		<font public="1"><c path="String"/></font>
		<indent public="1"><t path="Null"><x path="Float"/></t></indent>
		<italic public="1"><t path="Null"><x path="Bool"/></t></italic>
		<kerning public="1"><t path="Null"><x path="Float"/></t></kerning>
		<leading public="1"><t path="Null"><x path="Float"/></t></leading>
		<leftMargin public="1"><t path="Null"><x path="Float"/></t></leftMargin>
		<letterSpacing public="1"><t path="Null"><x path="Float"/></t></letterSpacing>
		<rightMargin public="1"><t path="Null"><x path="Float"/></t></rightMargin>
		<size public="1"><t path="Null"><x path="Float"/></t></size>
		<tabStops public="1"><c path="Array"><x path="Int"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><t path="Null"><x path="Bool"/></t></underline>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method" line="28"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading" v="null:null:null:null:null:null:null:null:null:null:null:null:null">
	<c path="String"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextFormatAlign" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/TextFormatAlign.hx">
		<LEFT public="1" line="6" static="1"><c path="String"/></LEFT>
		<RIGHT public="1" line="7" static="1"><c path="String"/></RIGHT>
		<CENTER public="1" line="8" static="1"><c path="String"/></CENTER>
		<JUSTIFY public="1" line="9" static="1"><c path="String"/></JUSTIFY>
	</class>
	<class path="flash.text.TextLineMetrics" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/text/TextLineMetrics.hx">
		<ascent public="1"><x path="Float"/></ascent>
		<descent public="1"><x path="Float"/></descent>
		<height public="1"><x path="Float"/></height>
		<leading public="1"><x path="Float"/></leading>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method" line="15"><f a="?x:?width:?height:?ascent:?descent:?leading" v="0:0:0:0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.ui.Keyboard" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/ui/Keyboard.hx">
		<A public="1" get="inline" set="null" line="7" static="1"><x path="Int"/></A>
		<B public="1" get="inline" set="null" line="8" static="1"><x path="Int"/></B>
		<C public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></C>
		<D public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></D>
		<E public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></E>
		<F public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></F>
		<G public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></G>
		<H public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></H>
		<I public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></I>
		<J public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></J>
		<K public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></K>
		<L public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></L>
		<M public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></M>
		<N public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></N>
		<O public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></O>
		<P public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></P>
		<Q public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></Q>
		<R public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></R>
		<S public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></S>
		<T public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></T>
		<U public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></U>
		<V public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></V>
		<W public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></W>
		<X public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></X>
		<Y public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></Y>
		<Z public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></Z>
		<ALTERNATE public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></ALTERNATE>
		<BACKQUOTE public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></BACKQUOTE>
		<BACKSLASH public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></BACKSLASH>
		<BACKSPACE public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></BACKSPACE>
		<CAPS_LOCK public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></CAPS_LOCK>
		<COMMA public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></COMMA>
		<COMMAND public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></COMMAND>
		<CONTROL public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></CONTROL>
		<DELETE public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></DELETE>
		<DOWN public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></DOWN>
		<END public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></END>
		<ENTER public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></ENTER>
		<EQUAL public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></EQUAL>
		<ESCAPE public="1" get="inline" set="null" line="47" static="1"><x path="Int"/></ESCAPE>
		<F1 public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></F1>
		<F2 public="1" get="inline" set="null" line="49" static="1"><x path="Int"/></F2>
		<F3 public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></F3>
		<F4 public="1" get="inline" set="null" line="51" static="1"><x path="Int"/></F4>
		<F5 public="1" get="inline" set="null" line="52" static="1"><x path="Int"/></F5>
		<F6 public="1" get="inline" set="null" line="53" static="1"><x path="Int"/></F6>
		<F7 public="1" get="inline" set="null" line="54" static="1"><x path="Int"/></F7>
		<F8 public="1" get="inline" set="null" line="55" static="1"><x path="Int"/></F8>
		<F9 public="1" get="inline" set="null" line="56" static="1"><x path="Int"/></F9>
		<F10 public="1" get="inline" set="null" line="57" static="1"><x path="Int"/></F10>
		<F11 public="1" get="inline" set="null" line="58" static="1"><x path="Int"/></F11>
		<F12 public="1" get="inline" set="null" line="59" static="1"><x path="Int"/></F12>
		<F13 public="1" get="inline" set="null" line="60" static="1"><x path="Int"/></F13>
		<F14 public="1" get="inline" set="null" line="61" static="1"><x path="Int"/></F14>
		<F15 public="1" get="inline" set="null" line="62" static="1"><x path="Int"/></F15>
		<HOME public="1" get="inline" set="null" line="63" static="1"><x path="Int"/></HOME>
		<INSERT public="1" get="inline" set="null" line="64" static="1"><x path="Int"/></INSERT>
		<LEFT public="1" get="inline" set="null" line="65" static="1"><x path="Int"/></LEFT>
		<LEFTBRACKET public="1" get="inline" set="null" line="66" static="1"><x path="Int"/></LEFTBRACKET>
		<MINUS public="1" get="inline" set="null" line="67" static="1"><x path="Int"/></MINUS>
		<NUMBER_0 public="1" get="inline" set="null" line="68" static="1"><x path="Int"/></NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" line="69" static="1"><x path="Int"/></NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" line="70" static="1"><x path="Int"/></NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" line="71" static="1"><x path="Int"/></NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" line="72" static="1"><x path="Int"/></NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" line="73" static="1"><x path="Int"/></NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" line="74" static="1"><x path="Int"/></NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" line="75" static="1"><x path="Int"/></NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" line="76" static="1"><x path="Int"/></NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" line="77" static="1"><x path="Int"/></NUMBER_9>
		<NUMPAD public="1" get="inline" set="null" line="78" static="1"><x path="Int"/></NUMPAD>
		<NUMPAD_0 public="1" get="inline" set="null" line="79" static="1"><x path="Int"/></NUMPAD_0>
		<NUMPAD_1 public="1" get="inline" set="null" line="80" static="1"><x path="Int"/></NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" line="81" static="1"><x path="Int"/></NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" line="82" static="1"><x path="Int"/></NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" line="83" static="1"><x path="Int"/></NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" line="84" static="1"><x path="Int"/></NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" line="85" static="1"><x path="Int"/></NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" line="86" static="1"><x path="Int"/></NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" line="87" static="1"><x path="Int"/></NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" line="88" static="1"><x path="Int"/></NUMPAD_9>
		<NUMPAD_ADD public="1" get="inline" set="null" line="89" static="1"><x path="Int"/></NUMPAD_ADD>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" line="90" static="1"><x path="Int"/></NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" line="91" static="1"><x path="Int"/></NUMPAD_DIVIDE>
		<NUMPAD_ENTER public="1" get="inline" set="null" line="92" static="1"><x path="Int"/></NUMPAD_ENTER>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" line="93" static="1"><x path="Int"/></NUMPAD_MULTIPLY>
		<NUMPAD_SUBTRACT public="1" get="inline" set="null" line="94" static="1"><x path="Int"/></NUMPAD_SUBTRACT>
		<PAGE_DOWN public="1" get="inline" set="null" line="95" static="1"><x path="Int"/></PAGE_DOWN>
		<PAGE_UP public="1" get="inline" set="null" line="96" static="1"><x path="Int"/></PAGE_UP>
		<PERIOD public="1" get="inline" set="null" line="97" static="1"><x path="Int"/></PERIOD>
		<QUOTE public="1" get="inline" set="null" line="98" static="1"><x path="Int"/></QUOTE>
		<RIGHT public="1" get="inline" set="null" line="99" static="1"><x path="Int"/></RIGHT>
		<RIGHTBRACKET public="1" get="inline" set="null" line="100" static="1"><x path="Int"/></RIGHTBRACKET>
		<SEMICOLON public="1" get="inline" set="null" line="101" static="1"><x path="Int"/></SEMICOLON>
		<SHIFT public="1" get="inline" set="null" line="102" static="1"><x path="Int"/></SHIFT>
		<SLASH public="1" get="inline" set="null" line="103" static="1"><x path="Int"/></SLASH>
		<SPACE public="1" get="inline" set="null" line="104" static="1"><x path="Int"/></SPACE>
		<TAB public="1" get="inline" set="null" line="105" static="1"><x path="Int"/></TAB>
		<UP public="1" get="inline" set="null" line="106" static="1"><x path="Int"/></UP>
	</class>
	<class path="flash.ui.Mouse" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/ui/Mouse.hx">
		<hide public="1" set="method" line="10" static="1"><f a=""><x path="Void"/></f></hide>
		<show public="1" set="method" line="21" static="1"><f a=""><x path="Void"/></f></show>
	</class>
	<class path="flash.ui.Multitouch" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/ui/Multitouch.hx">
		<inputMode public="1" get="accessor" set="accessor" static="1"><e path="flash.ui.MultitouchInputMode"/></inputMode>
		<maxTouchPoints public="1" set="null" static="1"><x path="Int"/></maxTouchPoints>
		<supportedGestures public="1" set="null" static="1"><c path="Array"><c path="String"/></c></supportedGestures>
		<supportsGestureEvents public="1" set="null" static="1"><x path="Bool"/></supportsGestureEvents>
		<supportsTouchEvents public="1" get="accessor" set="null" static="1"><x path="Bool"/></supportsTouchEvents>
		<get_inputMode set="method" line="34" static="1"><f a=""><e path="flash.ui.MultitouchInputMode"/></f></get_inputMode>
		<set_inputMode set="method" line="49" static="1"><f a="value">
	<e path="flash.ui.MultitouchInputMode"/>
	<e path="flash.ui.MultitouchInputMode"/>
</f></set_inputMode>
		<get_supportsTouchEvents set="method" line="63" static="1"><f a=""><x path="Bool"/></f></get_supportsTouchEvents>
		<lime_stage_get_multitouch_supported line="73" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_stage_get_multitouch_supported>
		<lime_stage_get_multitouch_active line="74" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_stage_get_multitouch_active>
		<lime_stage_set_multitouch_active line="75" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_stage_set_multitouch_active>
	</class>
	<enum path="flash.ui.MultitouchInputMode" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/ui/MultitouchInputMode.hx">
		<NONE/>
		<TOUCH_POINT/>
		<GESTURE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.utils.IDataOutput" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/utils/IDataOutput.hx" interface="1">
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
	</class>
	<class path="openfl.utils.IMemoryRange" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/utils/IMemoryRange.hx" interface="1">
		<getByteBuffer public="1" set="method"><f a=""><c path="flash.utils.ByteArray"/></f></getByteBuffer>
		<getStart public="1" set="method"><f a=""><x path="Int"/></f></getStart>
		<getLength public="1" set="method"><f a=""><x path="Int"/></f></getLength>
	</class>
	<class path="flash.utils.IDataInput" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/utils/IDataInput.hx" interface="1">
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="data:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
	</class>
	<class path="flash.utils.ByteArray" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/utils/ByteArray.hx">
		<extends path="haxe.io.Bytes"/>
		<implements path="flash.utils.IDataOutput"/>
		<implements path="openfl.utils.IMemoryRange"/>
		<implements path="flash.utils.IDataInput"/>
		<fromBytes public="1" set="method" line="179" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="flash.utils.ByteArray"/>
</f></fromBytes>
		<readFile public="1" set="method" line="298" static="1"><f a="path">
	<c path="String"/>
	<c path="flash.utils.ByteArray"/>
</f></readFile>
		<_double_bytes line="777" static="1"><f a=":">
	<x path="Float"/>
	<x path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_double_bytes>
		<_double_of_bytes line="778" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></_double_of_bytes>
		<_float_bytes line="779" static="1"><f a=":">
	<x path="Float"/>
	<x path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_float_bytes>
		<_float_of_bytes line="780" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></_float_of_bytes>
		<lime_byte_array_overwrite_file line="782" static="1"><f a=":">
	<c path="String"/>
	<c path="flash.utils.ByteArray"/>
	<unknown/>
</f></lime_byte_array_overwrite_file>
		<lime_byte_array_read_file line="783" static="1"><f a="">
	<c path="String"/>
	<c path="flash.utils.ByteArray"/>
</f></lime_byte_array_read_file>
		<lime_byte_array_get_native_pointer line="785" static="1"><f a="">
	<c path="flash.utils.ByteArray"/>
	<unknown/>
</f></lime_byte_array_get_native_pointer>
		<lime_lzma_encode line="786" static="1"><f a="">
	<t path="haxe.io.BytesData"/>
	<t path="haxe.io.BytesData"/>
</f></lime_lzma_encode>
		<lime_lzma_decode line="787" static="1"><f a="">
	<t path="haxe.io.BytesData"/>
	<t path="haxe.io.BytesData"/>
</f></lime_lzma_decode>
		<bigEndian public="1"><x path="Bool"/></bigEndian>
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<position public="1"><x path="Int"/></position>
		<byteLength public="1" get="accessor" set="null"><x path="Int"/></byteLength>
		<asString public="1" set="method" line="69"><f a=""><c path="String"/></f></asString>
		<checkData public="1" set="method" line="76"><f a="length">
	<x path="Int"/>
	<x path="Void"/>
</f></checkData>
		<clear public="1" set="method" line="87"><f a=""><x path="Void"/></f></clear>
		<compress public="1" set="method" line="95"><f a="?algorithm" v="null">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<deflate public="1" set="method" line="143"><f a=""><x path="Void"/></f></deflate>
		<ensureElem set="method" line="150"><f a="size:updateLength">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></ensureElem>
		<getByteBuffer public="1" set="method" line="188"><f a=""><c path="flash.utils.ByteArray"/></f></getByteBuffer>
		<getLength public="1" set="method" line="195"><f a=""><x path="Int"/></f></getLength>
		<getNativePointer public="1" set="method" line="202"><f a=""><d/></f></getNativePointer>
		<getStart public="1" set="method" line="209"><f a=""><x path="Int"/></f></getStart>
		<inflate public="1" set="method" line="216"><f a=""><x path="Void"/></f></inflate>
		<readBoolean public="1" get="inline" set="null" line="223"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" get="inline" set="null" line="230"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="238"><f a="data:?offset:?length" v=":0:0">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method" line="276"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="307"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method" line="327"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" get="inline" set="null" line="339"><f a="length:charSet">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<writeMultiByte public="1" get="inline" set="null" line="345"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<readShort public="1" set="method" line="349"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" get="inline" set="null" line="361"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method" line="368"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method" line="380"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method" line="390"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method" line="398"><f a="length">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<setLength public="1" set="method" line="424"><f a="length">
	<x path="Int"/>
	<x path="Void"/>
</f></setLength>
		<slice public="1" set="method" line="437"><f a="begin:?end" v=":null">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.utils.ByteArray"/>
</f></slice>
		<uncompress public="1" set="method" line="485"><f a="?algorithm" v="null">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<write_uncheck get="inline" set="null" line="529"><f a="byte">
	<x path="Int"/>
	<x path="Void"/>
</f></write_uncheck>
		<writeBoolean public="1" set="method" line="540"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeObject public="1" set="method" line="545"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeByte public="1" get="inline" set="null" line="550"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="563"><f a="bytes:?offset:?length" v=":0:0">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method" line="574"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFile public="1" set="method" line="589"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></writeFile>
		<writeFloat public="1" set="method" line="598"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method" line="611"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeShort public="1" set="method" line="634"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUnsignedInt public="1" set="method" line="653"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTF public="1" set="method" line="660"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method" line="674"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<__fromBytes get="inline" set="null" line="687">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromBytes>
		<__get public="1" get="inline" set="null" line="699">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="738">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<__throwEOFi set="method" line="749">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__throwEOFi>
		<get_bytesAvailable set="method" line="764"><f a=""><x path="Int"/></f></get_bytesAvailable>
		<get_byteLength set="method" line="765"><f a=""><x path="Int"/></f></get_byteLength>
		<get_endian set="method" line="766"><f a=""><c path="String"/></f></get_endian>
		<set_endian set="method" line="767"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_endian>
		<new public="1" set="method" line="37"><f a="?size" v="0">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":autoBuild"><e>'???'</e></m></meta>
	</class>
	<enum path="flash.utils.CompressionAlgorithm" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/utils/CompressionAlgorithm.hx">
		<DEFLATE/>
		<ZLIB/>
		<LZMA/>
		<GZIP/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flash.utils.Endian" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/flash/utils/Endian.hx">
		<BIG_ENDIAN public="1" get="inline" set="null" line="6" static="1"><c path="String"/></BIG_ENDIAN>
		<LITTLE_ENDIAN public="1" get="inline" set="null" line="7" static="1"><c path="String"/></LITTLE_ENDIAN>
	</class>
	<class path="flixel.interfaces.IFlxDestroyable" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/interfaces/IFlxDestroyable.hx" interface="1">
		<destroy public="1" set="method"><f a=""><x path="Void"/></f></destroy>
		<haxe_doc>* Mainly used for FlxDestroyUtil.destroy().</haxe_doc>
	</class>
	<class path="flixel.FlxBasic" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/FlxBasic.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<_ACTIVECOUNT public="1" line="19" static="1">
			<x path="Int"/>
			<haxe_doc>* Static counters for performance tracking.</haxe_doc>
		</_ACTIVECOUNT>
		<_VISIBLECOUNT public="1" line="20" static="1"><x path="Int"/></_VISIBLECOUNT>
		<ID public="1">
			<x path="Int"/>
			<haxe_doc>* IDs seem like they could be pretty useful, huh?
	 * They're not actually used for anything yet though.</haxe_doc>
		</ID>
		<active public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Controls whether update() is automatically called by FlxState/FlxGroup.</haxe_doc>
		</active>
		<visible public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Controls whether draw() is automatically called by FlxState/FlxGroup.</haxe_doc>
		</visible>
		<alive public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Useful state for many game objects - "dead" (!alive) vs alive. kill() and
	 * revive() both flip this switch (along with exists, but you can override that).</haxe_doc>
		</alive>
		<exists public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* This flag indicates whether this objects has been destroyed or not. 
	 * Cannot be set, use destroy() and revive().</haxe_doc>
		</exists>
		<collisionType public="1" set="null">
			<x path="flixel.system.FlxCollisionType"/>
			<haxe_doc>* Enum that informs the collision system which type of object this is (to avoid expensive type casting).</haxe_doc>
		</collisionType>
		<destroy public="1" set="method" line="57">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* WARNING: This will remove this object entirely. Use kill() if you want to disable it temporarily only and revive() it later.
	 * Override this function to null out variables manually or call destroy() on class members if necessary. Don't forget to call super.destroy()!</haxe_doc>
		</destroy>
		<kill public="1" set="method" line="66">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handy function for "killing" game objects. Use reset() to revive them. Default behavior is to flag them as nonexistent AND dead. However, if you want the 
	 * "corpse" to remain in the game, like to animate an effect or whatever, you should override this, setting only alive to false, and leaving exists true.</haxe_doc>
		</kill>
		<revive public="1" set="method" line="76">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handy function for bringing game objects "back to life". Just sets alive and exists back to true.
	 * In practice, this function is most often called by FlxObject.reset().</haxe_doc>
		</revive>
		<update public="1" set="method" line="86">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this function to update your class's position and appearance.
	 * This is where most of your game rules and behavioral code will go.</haxe_doc>
		</update>
		<draw public="1" set="method" line="97">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this function to control how the object is drawn.
	 * Overriding draw() is rarely necessary, but can be very useful.</haxe_doc>
		</draw>
		<set_visible set="method" line="104"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_active set="method" line="109"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_active>
		<set_exists set="method" line="114"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_exists>
		<set_alive set="method" line="119"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_alive>
		<toString public="1" set="method" line="124"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="51"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This is a useful "generic" Flixel object. Both FlxObject and 
 * FlxGroup extend this class. Has no size, position or graphical data.</haxe_doc>
	</class>
	<class path="flixel.FlxCamera" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/FlxCamera.hx">
		<extends path="flixel.FlxBasic"/>
		<STYLE_LOCKON public="1" get="inline" set="null" line="33" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera has no deadzone, just tracks the focus object directly.</haxe_doc>
		</STYLE_LOCKON>
		<STYLE_PLATFORMER public="1" get="inline" set="null" line="37" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera deadzone is narrow but tall.</haxe_doc>
		</STYLE_PLATFORMER>
		<STYLE_TOPDOWN public="1" get="inline" set="null" line="41" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera deadzone is a medium-size square around the focus object.</haxe_doc>
		</STYLE_TOPDOWN>
		<STYLE_TOPDOWN_TIGHT public="1" get="inline" set="null" line="45" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera deadzone is a small square around the focus object.</haxe_doc>
		</STYLE_TOPDOWN_TIGHT>
		<STYLE_SCREEN_BY_SCREEN public="1" get="inline" set="null" line="49" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera will move screenwise.</haxe_doc>
		</STYLE_SCREEN_BY_SCREEN>
		<STYLE_NO_DEAD_ZONE public="1" get="inline" set="null" line="53" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera has no deadzone, just tracks the focus object directly and centers it.</haxe_doc>
		</STYLE_NO_DEAD_ZONE>
		<SHAKE_BOTH_AXES public="1" get="inline" set="null" line="57" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "shake" effect preset: shake camera on both the X and Y axes.</haxe_doc>
		</SHAKE_BOTH_AXES>
		<SHAKE_HORIZONTAL_ONLY public="1" get="inline" set="null" line="61" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "shake" effect preset: shake camera on the X axis only.</haxe_doc>
		</SHAKE_HORIZONTAL_ONLY>
		<SHAKE_VERTICAL_ONLY public="1" get="inline" set="null" line="65" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "shake" effect preset: shake camera on the Y axis only.</haxe_doc>
		</SHAKE_VERTICAL_ONLY>
		<defaultZoom public="1" static="1">
			<x path="Float"/>
			<haxe_doc>* While you can alter the zoom of each camera after the fact,
	 * this variable determines what value the camera will start at when created.</haxe_doc>
		</defaultZoom>
		<defaultCameras public="1" static="1">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<haxe_doc>* Which cameras a FlxBasic uses to be drawn on when nothing else has been specified. 
	 * By default, this is just a reference to FlxG.cameras.list / all cameras, but it can be very useful to change.</haxe_doc>
		</defaultCameras>
		<_storageHead static="1">
			<c path="flixel.system.layer.DrawStackItem"/>
			<haxe_doc>* Draw stack items that can be reused</haxe_doc>
		</_storageHead>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X position of this camera's display.  Zoom does NOT affect this number.
	 * Measured in pixels from the left side of the flash window.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y position of this camera's display.  Zoom does NOT affect this number.
	 * Measured in pixels from the top of the flash window.</haxe_doc>
		</y>
		<style public="1">
			<x path="Int"/>
			<haxe_doc>* Tells the camera to use this following style.</haxe_doc>
		</style>
		<target public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Tells the camera to follow this FlxObject object around.</haxe_doc>
		</target>
		<followLerp public="1">
			<x path="Float"/>
			<haxe_doc>* Used to smoothly track the camera as it follows.</haxe_doc>
		</followLerp>
		<deadzone public="1">
			<c path="flixel.util.FlxRect"/>
			<haxe_doc>* You can assign a "dead zone" to the camera in order to better control its movement. The camera will always keep the focus object inside the dead zone, unless it is bumping up against 
	 * the bounds rectangle's edges. The deadzone's coordinates are measured from the camera's upper left corner in game pixels. For rapid prototyping, you can use the preset deadzones (e.g. STYLE_PLATFORMER) with follow().</haxe_doc>
		</deadzone>
		<bounds public="1">
			<c path="flixel.util.FlxRect"/>
			<haxe_doc>* The edges of the camera's range, i.e. where to stop scrolling.
	 * Measured in game pixels and world coordinates.</haxe_doc>
		</bounds>
		<scroll public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Stores the basic parallax scrolling values.</haxe_doc>
		</scroll>
		<bgColor public="1">
			<x path="Int"/>
			<haxe_doc>* The natural background color of the camera. Defaults to FlxG.cameras.bgColor.
	 * NOTE: can be transparent for crazy FX (only works on flash)!</haxe_doc>
		</bgColor>
		<useBgAlphaBlending public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to use alpha blending for camera's background fill or not. 
	 * Useful for flash target (and works only on this target). Default value is false.</haxe_doc>
		</useBgAlphaBlending>
		<flashSprite public="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* Used to render buffer to screen space. NOTE: We don't recommend modifying this directly unless you are fairly experienced. 
	 * Uses include 3D projection, advanced display list modification, and more.</haxe_doc>
		</flashSprite>
		<width public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* How wide the camera display is, in game pixels.</haxe_doc>
		</width>
		<height public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* How tall the camera display is, in game pixels.</haxe_doc>
		</height>
		<zoom public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The zoom level of this camera. 1 = 1:1, 2 = 2x zoom, etc.
	 * Indicates how far the camera is zoomed in.</haxe_doc>
		</zoom>
		<alpha public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The alpha value of this camera display (a Number between 0.0 and 1.0).</haxe_doc>
		</alpha>
		<angle public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The angle of the camera display (in degrees). Currently yields weird display results,
	 * since cameras aren't nested in an extra display object yet.</haxe_doc>
		</angle>
		<color public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The color tint of the camera display.
	 * (Internal, help with color transforming the flash bitmap.)</haxe_doc>
		</color>
		<antialiasing public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the camera display is smooth and filtered, or chunky and pixelated.
	 * Default behavior is chunky-style.</haxe_doc>
		</antialiasing>
		<followLead public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Used to force the camera to look ahead of the target.</haxe_doc>
		</followLead>
		<_flashRect>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashRect>
		<_flashPoint>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashPoint>
		<_flashOffset>
			<c path="flixel.util.FlxPoint"/>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashOffset>
		<_fxFlashColor>
			<x path="Int"/>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashColor>
		<_fxFlashDuration>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashDuration>
		<_fxFlashComplete>
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashComplete>
		<_fxFlashAlpha>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashAlpha>
		<_fxFadeColor>
			<x path="Int"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeColor>
		<_lastTargetPosition>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Used to calculate the following target current velocity.</haxe_doc>
		</_lastTargetPosition>
		<_scrollTarget>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Helper to calculate follow target current scroll.</haxe_doc>
		</_scrollTarget>
		<_fxFadeDuration>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeDuration>
		<_fxFadeIn>
			<x path="Bool"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeIn>
		<_fxFadeComplete>
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeComplete>
		<_fxFadeAlpha>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeAlpha>
		<_fxShakeIntensity>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeIntensity>
		<_fxShakeDuration>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeDuration>
		<_fxShakeComplete>
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeComplete>
		<_fxShakeOffset>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeOffset>
		<_fxShakeDirection>
			<x path="Int"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeDirection>
		<_point>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Internal, to help avoid costly allocations.</haxe_doc>
		</_point>
		<canvas public="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* Sprite for drawing (instead of _flashBitmap in flash)</haxe_doc>
		</canvas>
		<debugLayer public="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* Sprite for visual effects (flash and fade) and drawDebug information 
	 * (bounding boxes are drawn on it) for non-flash targets</haxe_doc>
		</debugLayer>
		<_currentStackItem>
			<c path="flixel.system.layer.DrawStackItem"/>
			<haxe_doc>* Currently used draw stack item</haxe_doc>
		</_currentStackItem>
		<_headOfDrawStack>
			<c path="flixel.system.layer.DrawStackItem"/>
			<haxe_doc>* Pointer to head of stack with draw items</haxe_doc>
		</_headOfDrawStack>
		<getDrawStackItem public="1" set="method" line="309">
			<f a="ObjGraphics:ObjColored:ObjBlending:?ObjAntialiasing" v=":::false">
				<c path="flixel.util.loaders.CachedGraphics"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.system.layer.DrawStackItem"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getDrawStackItem>
		<clearDrawStack set="method" line="358">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</clearDrawStack>
		<render set="method" line="384">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</render>
		<destroy public="1" set="method" line="498" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="545" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the camera scroll as well as special effects like screen-shake or fades.</haxe_doc>
		</update>
		<updateFollow set="method" line="565"><f a=""><x path="Void"/></f></updateFollow>
		<updateFlash set="method" line="649"><f a=""><x path="Void"/></f></updateFlash>
		<updateFade set="method" line="662"><f a=""><x path="Void"/></f></updateFade>
		<updateShake set="method" line="693"><f a=""><x path="Void"/></f></updateShake>
		<follow public="1" set="method" line="736">
			<f a="Target:?Style:?Offset:?Lerp" v=":0:null:0">
				<c path="flixel.FlxObject"/>
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Tells this camera object what FlxObject to track.
	 * 
	 * @param	Target		The object you want the camera to track.  Set to null to not follow anything.
	 * @param	Style		Leverage one of the existing "deadzone" presets.  If you use a custom deadzone, ignore this parameter and manually specify the deadzone after calling follow().
	 * @param	Offset		Offset the follow deadzone by a certain amount. Only applicable for STYLE_PLATFORMER and STYLE_LOCKON styles.
	 * @param	Lerp		How much lag the camera should have (can help smooth out the camera movement).</haxe_doc>
		</follow>
		<focusOn public="1" get="inline" set="null" line="783">
			<f a="point">
				<c path="flixel.util.FlxPoint"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the camera focus to this location instantly.
	 * 
	 * @param	Point		Where you want the camera to focus.</haxe_doc>
		</focusOn>
		<flash public="1" set="method" line="796">
			<f a="?Color:?Duration:?OnComplete:?Force" v="-1:1:null:false">
				<x path="Int"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The screen is filled with this color and gradually returns to normal.
	 * 
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the flash to fade.
	 * @param	OnComplete	A function you want to run when the flash finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</flash>
		<fade public="1" set="method" line="821">
			<f a="?Color:?Duration:?FadeIn:?OnComplete:?Force" v="-16777216:1:false:null:false">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The screen is gradually filled with this color.
	 * 
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the fade to finish.
	 * @param   FadeIn      True fades from a color, false fades to it.
	 * @param	OnComplete	A function you want to run when the fade finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</fade>
		<shake public="1" set="method" line="856">
			<f a="?Intensity:?Duration:?OnComplete:?Force:?Direction" v="0.05f:0.5f:null:true:0">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A simple screen-shake effect.
	 * 
	 * @param	Intensity	Percentage of screen size representing the maximum distance that the screen can move while shaking.
	 * @param	Duration	The length in seconds that the shaking effect should last.
	 * @param	OnComplete	A function you want to run when the shake effect finishes.
	 * @param	Force		Force the effect to reset (default = true, unlike flash() and fade()!).
	 * @param	Direction	Whether to shake on both axes, just up and down, or just side to side (use class constants SHAKE_BOTH_AXES, SHAKE_VERTICAL_ONLY, or SHAKE_HORIZONTAL_ONLY).</haxe_doc>
		</shake>
		<stopFX public="1" set="method" line="872">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just turns off all the camera effects instantly.</haxe_doc>
		</stopFX>
		<copyFrom public="1" set="method" line="887">
			<f a="Camera">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.FlxCamera"/>
			</f>
			<haxe_doc>* Copy the bounds, focus object, and deadzone info from an existing camera.
	 * 
	 * @param	Camera	The camera you want to copy from.
	 * @return	A reference to this FlxCamera object.</haxe_doc>
		</copyFrom>
		<fill public="1" set="method" line="927">
			<f a="Color:?BlendAlpha:?FxAlpha:?graphics" v=":true:1.0f:null">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="flash.display.Graphics"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fill the camera with the specified color.
	 * 
	 * @param	Color		The color to fill with in 0xAARRGGBB hex format.
	 * @param	BlendAlpha	Whether to blend the alpha value or just wipe the previous contents.  Default is true.</haxe_doc>
		</fill>
		<drawFX set="method" line="960">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Internal helper function, handles the actual drawing of all the special effects.</haxe_doc>
		</drawFX>
		<setSize public="1" get="inline" set="null" line="1024">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shortcut for setting both width and Height.
	 * 
	 * @param	Width	The new sprite width.
	 * @param	Height	The new sprite height.</haxe_doc>
		</setSize>
		<setPosition public="1" get="inline" set="null" line="1037">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function to set the coordinates of this camera.
	 * Handy since it only requires one line of code.
	 * 
	 * @param	X	The new x position
	 * @param	Y	The new y position</haxe_doc>
		</setPosition>
		<setBounds public="1" set="method" line="1052">
			<f a="?X:?Y:?Width:?Height:?UpdateWorld" v="0:0:0:0:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Specify the boundaries of the level or where the camera is allowed to move.
	 * 
	 * @param	X				The smallest X value of your level (usually 0).
	 * @param	Y				The smallest Y value of your level (usually 0).
	 * @param	Width			The largest X value of your level (usually the level width).
	 * @param	Height			The largest Y value of your level (usually the level height).
	 * @param	UpdateWorld		Whether the global quad-tree's dimensions should be updated to match (default: false).</haxe_doc>
		</setBounds>
		<setScale public="1" set="method" line="1066"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setScale>
		<getScale public="1" get="inline" set="null" line="1080">
			<f a=""><c path="flixel.util.FlxPoint"/></f>
			<haxe_doc>* The scale of the camera object, irrespective of zoom.
	 * Currently yields weird display results, since cameras aren't nested in an extra display object yet.</haxe_doc>
		</getScale>
		<set_width set="method" line="1085"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<set_height set="method" line="1115"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<set_zoom set="method" line="1145"><f a="Zoom">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zoom>
		<set_alpha set="method" line="1159"><f a="Alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_angle set="method" line="1170"><f a="Angle">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<set_color set="method" line="1177"><f a="Color">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<set_antialiasing set="method" line="1200"><f a="Antialiasing">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_antialiasing>
		<new public="1" set="method" line="418">
			<f a="?X:?Y:?Width:?Height:?Zoom" v="0:0:0:0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiates a new camera at the specified location, with the specified size and zoom level.
	 * 
	 * @param 	X			X location of the camera's display in pixels. Uses native, 1:1 resolution, ignores zoom.
	 * @param 	Y			Y location of the camera's display in pixels. Uses native, 1:1 resolution, ignores zoom.
	 * @param 	Width		The width of the camera display in pixels.
	 * @param 	Height		The height of the camera display in pixels.
	 * @param 	Zoom		The initial zoom level of the camera.  A zoom level of 2 will make all pixels display at 2x resolution.</haxe_doc>
		</new>
		<haxe_doc>* The camera class is used to display the game's visuals in the Flash player.
 * By default one camera is created automatically, that is the same size as the Flash player.
 * You can add more cameras or even replace the main camera using utilities in FlxG.</haxe_doc>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.system.FlxVersion" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxVersion.hx">
		<major public="1" set="null"><x path="Int"/></major>
		<minor public="1" set="null"><x path="Int"/></minor>
		<patch public="1" set="null"><x path="Int"/></patch>
		<patchVersion public="1" set="null"><c path="String"/></patchVersion>
		<toString public="1" set="method" line="26">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Formats the version in the format "HaxeFlixel MAJOR.MINOR.PATCH-PATCH_VERSION", 
	 * e.g. HaxeFlixel 3.0.4</haxe_doc>
		</toString>
		<new public="1" set="method" line="14"><f a="Major:Minor:Patch:?PatchVersion" v=":::''">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Helper object for semantic versioning.
 * @see   http://semver.org/</haxe_doc>
	</class>
	<class path="flixel.interfaces.IFlxPooled" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/interfaces/IFlxPooled.hx" interface="1">
		<extends path="flixel.interfaces.IFlxDestroyable"/>
		<put public="1" set="method"><f a=""><x path="Void"/></f></put>
		<_inPool><x path="Bool"/></_inPool>
	</class>
	<class path="flixel.util.FlxPool_flixel_util_FlxPoint" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxPool.hx">
		<_pool><c path="Array"><c path="flixel.util.FlxPoint"/></c></_pool>
		<_class><x path="Class"><c path="flixel.util.FlxPoint"/></x></_class>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<get public="1" set="method" line="23"><f a=""><c path="flixel.util.FlxPoint"/></f></get>
		<put public="1" set="method" line="33"><f a="obj">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></put>
		<putUnsafe public="1" set="method" line="43"><f a="obj">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></putUnsafe>
		<preAllocate public="1" set="method" line="52"><f a="numObjects">
	<x path="Int"/>
	<x path="Void"/>
</f></preAllocate>
		<clear public="1" set="method" line="60"><f a=""><c path="Array"><c path="flixel.util.FlxPoint"/></c></f></clear>
		<get_length get="inline" set="null" line="67"><f a=""><x path="Int"/></f></get_length>
		<new public="1" set="method" line="17"><f a="classObj">
	<x path="Class"><c path="flixel.util.FlxPoint"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.util.FlxPoint" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxPoint.hx">
		<implements path="flixel.interfaces.IFlxPooled"/>
		<_pool line="13" static="1"><c path="flixel.util.FlxPool_flixel_util_FlxPoint"/></_pool>
		<get public="1" get="inline" set="null" line="23" static="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Recycle or create a new FlxPoint. 
	 * Be sure to put() them back into the pool after you're done with them!
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @return	This point.</haxe_doc>
		</get>
		<weak public="1" get="inline" set="null" line="38" static="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Recycle or create a new FlxPoint which will automatically be released 
	 * to the pool when passed into a flixel function.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @return	This point.</haxe_doc>
		</weak>
		<x public="1" set="accessor"><x path="Float"/></x>
		<y public="1" set="accessor"><x path="Float"/></y>
		<_weak><x path="Bool"/></_weak>
		<_inPool><x path="Bool"/></_inPool>
		<put public="1" set="method" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this FlxPoint to the recycling pool.</haxe_doc>
		</put>
		<putWeak public="1" get="inline" set="null" line="71">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this FlxPoint to the recycling pool if it's a weak reference (allocated via weak()).</haxe_doc>
		</putWeak>
		<set public="1" set="method" line="86">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Set the coordinates of this point.
	 * 
	 * @param	X	The X-coordinate of the point in space.
	 * @param	Y	The Y-coordinate of the point in space.
	 * @return	This point.</haxe_doc>
		</set>
		<add public="1" get="inline" set="null" line="100">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Adds the to the coordinates of this point.
	 * 
	 * @param	X	Amount to add to x
	 * @param	Y	Amount to add to y
	 * @return	This point.</haxe_doc>
		</add>
		<addPoint public="1" set="method" line="113">
			<f a="point">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Adds the coordinates of another point to the coordinates of this point.
	 * 
	 * @param	point	The point to add to this point
	 * @return	This point.</haxe_doc>
		</addPoint>
		<subtract public="1" get="inline" set="null" line="128">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Adds the to the coordinates of this point.
	 * 
	 * @param	X	Amount to subtract from x
	 * @param	Y	Amount to subtract from y
	 * @return	This point.</haxe_doc>
		</subtract>
		<subtractPoint public="1" set="method" line="141">
			<f a="point">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Adds the coordinates of another point to the coordinates of this point.
	 * 
	 * @param	point	The point to subtract from this point
	 * @return	This point.</haxe_doc>
		</subtractPoint>
		<copyFrom public="1" get="inline" set="null" line="155">
			<f a="point">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from the specified point.
	 * 
	 * @param	point	Any FlxPoint.
	 * @return	A reference to itself.</haxe_doc>
		</copyFrom>
		<copyTo public="1" set="method" line="168">
			<f a="?point" v="null">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from this point to the specified point.
	 * 
	 * @param	Point	Any FlxPoint.
	 * @return	A reference to the altered point parameter.</haxe_doc>
		</copyTo>
		<copyFromFlash public="1" get="inline" set="null" line="185">
			<f a="FlashPoint">
				<c path="flash.geom.Point"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from the specified Flash point.
	 * 
	 * @param	Point	Any Point.
	 * @return	A reference to itself.</haxe_doc>
		</copyFromFlash>
		<copyToFlash public="1" get="inline" set="null" line="198">
			<f a="FlashPoint">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from this point to the specified Flash point.
	 * 
	 * @param	Point	Any Point.
	 * @return	A reference to the altered point parameter.</haxe_doc>
		</copyToFlash>
		<inCoords public="1" get="inline" set="null" line="214">
			<f a="RectX:RectY:RectWidth:RectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this point is within the given rectangular block
	 * 
	 * @param	RectX		The X value of the region to test within
	 * @param	RectY		The Y value of the region to test within
	 * @param	RectWidth	The width of the region to test within
	 * @param	RectHeight	The height of the region to test within
	 * @return	True if the point is within the region, otherwise false</haxe_doc>
		</inCoords>
		<inFlxRect public="1" get="inline" set="null" line="225">
			<f a="Rect">
				<c path="flixel.util.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this point is within the given rectangular block
	 * 
	 * @param	Rect	The FlxRect to test within
	 * @return	True if pointX/pointY is within the FlxRect, otherwise false</haxe_doc>
		</inFlxRect>
		<distanceTo public="1" get="inline" set="null" line="236">
			<f a="AnotherPoint">
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate the distance to another point.
	 * 
	 * @param 	AnotherPoint	A FlxPoint object to calculate the distance to.
	 * @return	The distance between the two points as a Float.</haxe_doc>
		</distanceTo>
		<floor public="1" get="inline" set="null" line="244">
			<f a=""><c path="flixel.util.FlxPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.floor()</haxe_doc>
		</floor>
		<ceil public="1" get="inline" set="null" line="254">
			<f a=""><c path="flixel.util.FlxPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.ceil()</haxe_doc>
		</ceil>
		<destroy public="1" set="method" line="264">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Necessary for IFlxDestroyable.</haxe_doc>
		</destroy>
		<toString public="1" get="inline" set="null" line="269">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name. Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<set_x set="method" line="279">
			<f a="Value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Necessary for FlxPointHelper in FlxSpriteGroup.</haxe_doc>
		</set_x>
		<set_y set="method" line="287">
			<f a="Value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Necessary for FlxPointHelper in FlxSpriteGroup.</haxe_doc>
		</set_y>
		<new public="1" set="method" line="51"><f a="?X:?Y" v="0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Stores a 2D floating point coordinate.</haxe_doc>
	</class>
	<class path="flixel.system.scaleModes.BaseScaleMode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/scaleModes/BaseScaleMode.hx">
		<zoom line="15" static="1"><c path="flixel.util.FlxPoint"/></zoom>
		<deviceSize public="1" set="null"><c path="flixel.util.FlxPoint"/></deviceSize>
		<gameSize public="1" set="null"><c path="flixel.util.FlxPoint"/></gameSize>
		<scale public="1" set="null"><c path="flixel.util.FlxPoint"/></scale>
		<offset public="1" set="null"><c path="flixel.util.FlxPoint"/></offset>
		<onMeasure public="1" set="method" line="25"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMeasure>
		<updateGameSize set="method" line="34"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateGameSize>
		<updateDeviceSize set="method" line="39"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateDeviceSize>
		<updateScaleOffset set="method" line="44"><f a=""><x path="Void"/></f></updateScaleOffset>
		<updateGameScale set="method" line="64"><f a=""><x path="Void"/></f></updateGameScale>
		<updateGamePosition set="method" line="72"><f a=""><x path="Void"/></f></updateGamePosition>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.system.scaleModes.RatioScaleMode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/scaleModes/RatioScaleMode.hx">
		<extends path="flixel.system.scaleModes.BaseScaleMode"/>
		<updateGameSize set="method" line="7" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateGameSize>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.frontEnds.BitmapFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/BitmapFrontEnd.hx">
		<_cache><x path="Map">
	<c path="String"/>
	<c path="flixel.util.loaders.CachedGraphics"/>
</x></_cache>
		<whitePixel public="1" get="accessor" set="null"><c path="flixel.util.loaders.CachedGraphics"/></whitePixel>
		<_whitePixel><c path="flixel.util.loaders.CachedGraphics"/></_whitePixel>
		<get_whitePixel set="method" line="29"><f a=""><c path="flixel.util.loaders.CachedGraphics"/></f></get_whitePixel>
		<onContext public="1" set="method" line="41"><f a=""><x path="Void"/></f></onContext>
		<dumpCache public="1" set="method" line="63">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dumps bits of all cached graphics. This restores memory, but you can't read / write pixels on those graphics anymore.
	 * You can call onContext() method for each CachedGraphic object which will restore it again.</haxe_doc>
		</dumpCache>
		<checkCache public="1" get="inline" set="null" line="88">
			<f a="Key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check the local bitmap cache to see if a bitmap with this key has been loaded already.
	 * 
	 * @param	Key		The string key identifying the bitmap.
	 * @return	Whether or not this file can be found in the cache.</haxe_doc>
		</checkCache>
		<create public="1" set="method" line="103">
			<f a="Width:Height:Color:?Unique:?Key" v=":::false:null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.util.loaders.CachedGraphics"/>
			</f>
			<haxe_doc>* Generates a new BitmapData object (a colored square) and caches it.
	 * 
	 * @param	Width	How wide the square should be.
	 * @param	Height	How high the square should be.
	 * @param	Color	What color the square should be (0xAARRGGBB)
	 * @param	Unique	Ensures that the bitmap data uses a new slot in the cache.
	 * @param	Key		Force the cache to use a specific Key to index the bitmap.
	 * @return	The BitmapData we just created.</haxe_doc>
		</create>
		<add public="1" get="inline" set="null" line="130">
			<f a="Graphic:?Unique:?Key" v=":false:null">
				<d/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.util.loaders.CachedGraphics"/>
			</f>
			<haxe_doc>* Loads a bitmap from a file, clones it if necessary and caches it.
	 * 
	 * @param	Graphic		The image file that you want to load.
	 * @param	Unique		Ensures that the bitmap data uses a new slot in the cache.
	 * @param	Key			Force the cache to use a specific Key to index the bitmap.
	 * @return	The CachedGraphics we just created.</haxe_doc>
		</add>
		<addWithSpaces public="1" set="method" line="148">
			<f a="Graphic:FrameWidth:FrameHeight:?SpacingX:?SpacingY:?Unique:?Key" v=":::1:1:false:null">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.util.loaders.CachedGraphics"/>
			</f>
			<haxe_doc>* Loads a bitmap from a file, inserts spaces between frames and caches it.
	 * Could be useful for native targets to remove possible glitches.
	 * 
	 * @param	Graphic			The image file that you want to load.
	 * @param	FrameWidth		The width of frames in image
	 * @param	FrameHeight		The height of frames in image
	 * @param	SpacingX		Horizontal spaces to insert between frames in image
	 * @param	SpacingY		Vertical spaces to insert between frames in image
	 * @param	Unique			Ensures that the bitmap data uses a new slot in the cache.
	 * @param	Key				Force the cache to use a specific Key to index the bitmap.
	 * @return	The CachedGraphics we just created.</haxe_doc>
		</addWithSpaces>
		<get public="1" set="method" line="322">
			<f a="key">
				<c path="String"/>
				<c path="flixel.util.loaders.CachedGraphics"/>
			</f>
			<haxe_doc>* Gets cached graphics object from this storage by specified key. 
	 * @param	key	Key for CachedGraphics object (it's name)
	 * @return	CachedGraphics with the key name, or null if there is no such object</haxe_doc>
		</get>
		<getCacheKeyFor public="1" set="method" line="333">
			<f a="bmd">
				<c path="flash.display.BitmapData"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets key from bitmap cache for specified bitmapdata
	 * 
	 * @param	bmd	bitmapdata to find in cache
	 * @return	bitmapdata's key or null if there isn't such bitmapdata in cache</haxe_doc>
		</getCacheKeyFor>
		<getUniqueKey public="1" set="method" line="352">
			<f a="?baseKey" v="'pixels'">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets unique key for bitmap cache
	 * 
	 * @param	baseKey	key's prefix
	 * @return	unique key</haxe_doc>
		</getUniqueKey>
		<remove public="1" set="method" line="367"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></remove>
		<clearCache public="1" set="method" line="383">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dumps the cache's image references.</haxe_doc>
		</clearCache>
		<inOpenFlAssets public="1" set="method" line="404"><f a="bitmap">
	<c path="flash.display.BitmapData"/>
	<x path="Bool"/>
</f></inOpenFlAssets>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal storage system to prevent graphics from being used repeatedly in memory.</haxe_doc>
	</class>
	<class path="flixel.system.frontEnds.CameraFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/CameraFrontEnd.hx">
		<add_flixel_FlxCamera public="1" get="inline" set="null" line="41">
			<f a="NewCamera">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.FlxCamera"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</add_flixel_FlxCamera>
		<list public="1" set="null">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<haxe_doc>* An array listing FlxCamera objects that are used to draw stuff.
	 * By default flixel creates one camera the size of the screen.</haxe_doc>
		</list>
		<bgColor public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The current (global, applies to all cameras) bgColor.</haxe_doc>
		</bgColor>
		<useBufferLocking public="1">
			<x path="Bool"/>
			<haxe_doc>* Allows you to possibly slightly optimize the rendering process IF
	 * you are not doing any pre-processing in your game state's draw() call.</haxe_doc>
		</useBufferLocking>
		<_cameraRect>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Internal helper variable for clearing the cameras each frame.</haxe_doc>
		</_cameraRect>
		<add public="1" params="T" get="inline" set="null" line="41">
			<f a="NewCamera">
				<c path="add.T"/>
				<c path="add.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Add a new camera object to the game.
	 * Handy for PiP, split-screen, etc.
	 * 
	 * @param	NewCamera	The camera you want to add.
	 * @return	This FlxCamera instance.</haxe_doc>
		</add>
		<remove public="1" set="method" line="57">
			<f a="Camera:?Destroy" v=":true">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a camera from the game.
	 * 
	 * @param   Camera    The camera you want to remove.
	 * @param   Destroy   Whether to call destroy() on the camera, default value is true.</haxe_doc>
		</remove>
		<reset public="1" set="method" line="92">
			<f a="?NewCamera" v="null">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Dumps all the current cameras and resets to just one camera.
	 * Handy for doing split-screen especially.
	 * 
	 * @param	NewCamera	Optional; specify a specific camera object to be the new main camera.</haxe_doc>
		</reset>
		<flash public="1" set="method" line="121">
			<f a="?Color:?Duration:?OnComplete:?Force" v="-1:1:null:false">
				<x path="Int"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* All screens are filled with this color and gradually return to normal.
	 * 
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the flash to fade.
	 * @param	OnComplete	A function you want to run when the flash finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</flash>
		<fade public="1" set="method" line="138">
			<f a="?Color:?Duration:?FadeIn:?OnComplete:?Force" v="-16777216:1:false:null:false">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The screen is gradually filled with this color.
	 * 
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the fade to finish.
	 * @param 	FadeIn 		True fades from a color, false fades to it.
	 * @param	OnComplete	A function you want to run when the fade finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</fade>
		<shake public="1" set="method" line="155">
			<f a="?Intensity:?Duration:?OnComplete:?Force:?Direction" v="0.05f:0.5f:null:true:0">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A simple screen-shake effect.
	 * 
	 * @param	Intensity	Percentage of screen size representing the maximum distance that the screen can move while shaking.
	 * @param	Duration	The length in seconds that the shaking effect should last.
	 * @param	OnComplete	A function you want to run when the shake effect finishes.
	 * @param	Force		Force the effect to reset (default = true, unlike flash() and fade()!).
	 * @param	Direction	Whether to shake on both axes, just up and down, or just side to side (use class constants SHAKE_BOTH_AXES, SHAKE_VERTICAL_ONLY, or SHAKE_HORIZONTAL_ONLY).  Default value is SHAKE_BOTH_AXES (0).</haxe_doc>
		</shake>
		<lock get="inline" set="null" line="174">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game object to lock all the camera buffers and clear them for the next draw pass.</haxe_doc>
		</lock>
		<render get="inline" set="null" line="211"><f a=""><x path="Void"/></f></render>
		<unlock get="inline" set="null" line="226">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game object to draw the special FX and unlock all the camera buffers.</haxe_doc>
		</unlock>
		<update get="inline" set="null" line="251">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game object to update the cameras and their tracking/special effects logic.</haxe_doc>
		</update>
		<get_bgColor set="method" line="269"><f a=""><x path="Int"/></f></get_bgColor>
		<set_bgColor set="method" line="274"><f a="Color">
	<x path="Int"/>
	<x path="Int"/>
</f></set_bgColor>
		<new set="method" line="164">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</new>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.system.frontEnds.ConsoleFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/ConsoleFrontEnd.hx">
		<autoPause public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the console should auto-pause or not when it's focused. Only works for flash atm.</haxe_doc>
		</autoPause>
		<registerFunction public="1" get="inline" set="null" line="18">
			<f a="FunctionAlias:Function">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new function to use for the call command.
	 * 
	 * @param 	FunctionAlias		The name with which you want to access the function.
	 * @param 	Function			The function to register.</haxe_doc>
		</registerFunction>
		<registerObject public="1" get="inline" set="null" line="31">
			<f a="ObjectAlias:AnyObject">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new object to use for the set command.
	 * 
	 * @param 	ObjectAlias		The name with which you want to access the object.
	 * @param 	AnyObject		The object to register.</haxe_doc>
		</registerObject>
		<addCommand public="1" get="inline" set="null" line="48">
			<f a="Aliases:ProcessFunction:?Help:?ParamHelp:?NumParams:?ParamCutoff" v="::null:null:0:-1">
				<c path="Array"><c path="String"/></c>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a custom command to the console on the debugging screen.
	 * 
	 * @param 	Aliases			An array of accepted aliases for this command.
	 * @param 	ProcessFunction	Function to be called with params when the command is entered.
	 * @param	Help			The description of this command shown in the help command.
	 * @param	ParamHelp		The description of this command's processFunction's params.
	 * @param 	NumParams		The amount of parameters a function has. Require to prevent crashes on Neko.
	 * @param	ParamCutoff		At which parameter to put all remaining params into an array</haxe_doc>
		</addCommand>
		<new set="method" line="59">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Just needed to create an instance.</haxe_doc>
		</new>
	</class>
	<class path="flixel.system.frontEnds.DebuggerFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/DebuggerFrontEnd.hx">
		<precision public="1">
			<x path="Int"/>
			<haxe_doc>* The amount of decimals FlxPoints / FlxRects are rounded to in log / watch / trace.</haxe_doc>
		</precision>
		<toggleKeys public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* The key codes used to toggle the debugger (see FlxG.keys for the keys available).
	 * Default keys: ` and \. Set to null to deactivate.</haxe_doc>
		</toggleKeys>
		<drawDebug public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether to draw the hitboxes of FlxObjects.</haxe_doc>
		</drawDebug>
		<drawDebugChanged public="1" set="null">
			<t path="flixel.util.FlxSignal"/>
			<haxe_doc>* Dispatched when drawDebug is changed.</haxe_doc>
		</drawDebugChanged>
		<visible public="1" set="accessor"><x path="Bool"/></visible>
		<setLayout public="1" get="inline" set="null" line="44">
			<f a="Layout">
				<e path="flixel.system.debug.DebuggerLayout"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the way the debugger's windows are laid out.
	 * 
	 * @param	Layout	The layout codes can be found in FlxDebugger, for example FlxDebugger.MICRO</haxe_doc>
		</setLayout>
		<resetLayout public="1" get="inline" set="null" line="54">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just resets the debugger windows to whatever the last selected layout was (STANDARD by default).</haxe_doc>
		</resetLayout>
		<addButton public="1" set="method" line="71">
			<f a="Alignment:Icon:UpHandler:?ToggleMode:?UpdateLayout" v=":::false:true">
				<e path="flixel.system.debug.ButtonAlignment"/>
				<c path="flash.display.BitmapData"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.system.ui.FlxSystemButton"/>
			</f>
			<haxe_doc>* Create and add a new debugger button.
	 * 
	 * @param   Position       Either LEFT, MIDDLE or RIGHT.
	 * @param   Icon           The icon to use for the button
	 * @param   UpHandler      The function to be called when the button is pressed.
	 * @param   ToggleMode     Whether this is a toggle button or not.
	 * @param   UpdateLayout   Whether to update the button layout.
	 * @return  The added button.</haxe_doc>
		</addButton>
		<track public="1" set="method" line="87">
			<f a="Object:?WindowTitle" v=":null">
				<d/>
				<c path="String"/>
				<c path="flixel.system.debug.Window"/>
			</f>
			<haxe_doc>* Creates a new tracker window, if there exists a tracking profile for the class of the object.
	 * By default, flixel classes like FlxBasics, FlxRect and FlxPoint are supported.
	 * 
	 * @param	Object	The object to track
	 * @param	WindowTitle	Title for the tracker window, uses the Object's class name by default</haxe_doc>
		</track>
		<addTrackerProfile public="1" get="inline" set="null" line="117">
			<f a="Profile">
				<c path="flixel.system.debug.TrackerProfile"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new TrackerProfile for track(). This also overrides existing profiles.
	 * 
	 * @param	Profile	The TrackerProfile</haxe_doc>
		</addTrackerProfile>
		<removeButton public="1" set="method" line="130">
			<f a="Button:?UpdateLayout" v=":true">
				<c path="flixel.system.ui.FlxSystemButton"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes and destroys a button from the debugger.
	 * 
	 * @param	Button			The FlxSystemButton instance to remove.
	 * @param	UpdateLayout	Whether to update the button layout.</haxe_doc>
		</removeButton>
		<set_drawDebug get="inline" set="null" line="146"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_drawDebug>
		<set_visible get="inline" set="null" line="156"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<new set="method" line="138">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</new>
	</class>
	<class path="flixel.util._FlxSignal.FlxTypedSignal_Impl_" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<dispatch public="1" get="accessor" set="null" static="1">
			<c path="flixel.util.FlxTypedSignal.T"/>
			<meta><m n=":impl"/></meta>
		</dispatch>
		<_new public="1" set="method" static="1">
			<f a=""><c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c></f>
			<meta><m n=":impl"/></meta>
		</_new>
		<add public="1" get="inline" set="null" line="19" static="1">
			<f a="this:listener">
				<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<c path="flixel.util.FlxTypedSignal.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</add>
		<addOnce public="1" get="inline" set="null" line="24" static="1">
			<f a="this:listener">
				<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<c path="flixel.util.FlxTypedSignal.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</addOnce>
		<remove public="1" get="inline" set="null" line="29" static="1">
			<f a="this:listener">
				<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<c path="flixel.util.FlxTypedSignal.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</remove>
		<has public="1" get="inline" set="null" line="34" static="1">
			<f a="this:listener">
				<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<c path="flixel.util.FlxTypedSignal.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</has>
		<removeAll public="1" get="inline" set="null" line="39" static="1">
			<f a="this">
				<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</removeAll>
		<get_dispatch get="inline" set="null" line="44" static="1">
			<f a="this">
				<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<c path="flixel.util.FlxTypedSignal.T"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_dispatch>
		<toSignal0 get="inline" set="null" line="50" static="1">
			<f a="signal">
				<c path="flixel.interfaces.IFlxSignal"><f a=""><x path="Void"/></f></c>
				<c path="flixel.util._FlxSignal.FlxSignal0"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toSignal0>
		<toSignal1 params="T1" get="inline" set="null" line="56" static="1">
			<f a="signal">
				<c path="flixel.interfaces.IFlxSignal"><f a="">
	<c path="toSignal1.T1"/>
	<x path="Void"/>
</f></c>
				<c path="flixel.util._FlxSignal.FlxSignal1"><c path="toSignal1.T1"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toSignal1>
		<toSignal2 params="T1:T2" get="inline" set="null" line="62" static="1">
			<f a="signal">
				<c path="flixel.interfaces.IFlxSignal"><f a=":">
	<c path="toSignal2.T1"/>
	<c path="toSignal2.T2"/>
	<x path="Void"/>
</f></c>
				<c path="flixel.util._FlxSignal.FlxSignal2">
					<c path="toSignal2.T1"/>
					<c path="toSignal2.T2"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toSignal2>
		<toSignal3 params="T1:T2:T3" get="inline" set="null" line="68" static="1">
			<f a="signal">
				<c path="flixel.interfaces.IFlxSignal"><f a="::">
	<c path="toSignal3.T1"/>
	<c path="toSignal3.T2"/>
	<c path="toSignal3.T3"/>
	<x path="Void"/>
</f></c>
				<c path="flixel.util._FlxSignal.FlxSignal3">
					<c path="toSignal3.T1"/>
					<c path="toSignal3.T2"/>
					<c path="toSignal3.T3"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toSignal3>
		<toSignal4 params="T1:T2:T3:T4" get="inline" set="null" line="74" static="1">
			<f a="signal">
				<c path="flixel.interfaces.IFlxSignal"><f a=":::">
	<c path="toSignal4.T1"/>
	<c path="toSignal4.T2"/>
	<c path="toSignal4.T3"/>
	<c path="toSignal4.T4"/>
	<x path="Void"/>
</f></c>
				<c path="flixel.util._FlxSignal.FlxSignal4">
					<c path="toSignal4.T1"/>
					<c path="toSignal4.T2"/>
					<c path="toSignal4.T3"/>
					<c path="toSignal4.T4"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toSignal4>
	</class>
	<class path="flixel.system.frontEnds.InputFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/InputFrontEnd.hx">
		<replace_flixel_input_mouse_FlxMouse public="1" set="method" line="72">
			<f a="Old:New">
				<c path="flixel.input.mouse.FlxMouse"/>
				<c path="flixel.input.mouse.FlxMouse"/>
				<c path="flixel.input.mouse.FlxMouse"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</replace_flixel_input_mouse_FlxMouse>
		<add_flixel_input_gamepad_FlxGamepadManager public="1" set="method" line="25">
			<f a="Input">
				<c path="flixel.input.gamepad.FlxGamepadManager"/>
				<c path="flixel.input.gamepad.FlxGamepadManager"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</add_flixel_input_gamepad_FlxGamepadManager>
		<add_flixel_input_touch_FlxTouchManager public="1" set="method" line="25">
			<f a="Input">
				<c path="flixel.input.touch.FlxTouchManager"/>
				<c path="flixel.input.touch.FlxTouchManager"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</add_flixel_input_touch_FlxTouchManager>
		<add_flixel_input_mouse_FlxMouse public="1" set="method" line="25">
			<f a="Input">
				<c path="flixel.input.mouse.FlxMouse"/>
				<c path="flixel.input.mouse.FlxMouse"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</add_flixel_input_mouse_FlxMouse>
		<add_flixel_input_keyboard_FlxKeyboard public="1" set="method" line="25">
			<f a="Input">
				<c path="flixel.input.keyboard.FlxKeyboard"/>
				<c path="flixel.input.keyboard.FlxKeyboard"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</add_flixel_input_keyboard_FlxKeyboard>
		<list public="1" set="null">
			<c path="Array"><c path="flixel.interfaces.IFlxInput"/></c>
			<haxe_doc>* A read-only list of all inputs.</haxe_doc>
		</list>
		<add public="1" params="T" set="method" line="25">
			<f a="Input">
				<c path="add.T"/>
				<c path="add.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Add an input to the system
	 * 
	 * @param	Input 	The input to add
	 * @return	The input</haxe_doc>
		</add>
		<remove public="1" params="T" set="method" line="48">
			<f a="Input">
				<c path="remove.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Removes an input from the system
	 * 
	 * @param	Input	The input to remove
	 * @return	Bool indicating whether it was removed or not</haxe_doc>
		</remove>
		<replace public="1" params="T" set="method" line="72">
			<f a="Old:New">
				<c path="replace.T"/>
				<c path="replace.T"/>
				<c path="replace.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Replace an existing input in the system with a new one
	 * 
	 * @param	Old 	The old input to replace
	 * @param	New 	The new input to put in its place
	 * @return	If successful returns New. Otherwise returns null.</haxe_doc>
		</replace>
		<reset public="1" set="method" line="95">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the inputs.</haxe_doc>
		</reset>
		<update get="inline" set="null" line="111">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the inputs</haxe_doc>
		</update>
		<onFocus get="inline" set="null" line="122">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the inputs from FlxGame Focus</haxe_doc>
		</onFocus>
		<onFocusLost get="inline" set="null" line="133">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the inputs from FlxGame FocusLost</haxe_doc>
		</onFocusLost>
		<destroy get="inline" set="null" line="144">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<new set="method" line="103"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
		</meta>
	</class>
	<class path="flixel.system.frontEnds.LogFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/LogFrontEnd.hx">
		<redirectTraces public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether everything you trace() is being redirected into the log window.</haxe_doc>
		</redirectTraces>
		<_standardTraceFunction><d/></_standardTraceFunction>
		<add public="1" get="inline" set="null" line="18"><f a="Data">
	<d/>
	<x path="Void"/>
</f></add>
		<warn public="1" get="inline" set="null" line="25"><f a="Data">
	<d/>
	<x path="Void"/>
</f></warn>
		<error public="1" get="inline" set="null" line="32"><f a="Data">
	<d/>
	<x path="Void"/>
</f></error>
		<notice public="1" get="inline" set="null" line="39"><f a="Data">
	<d/>
	<x path="Void"/>
</f></notice>
		<advanced public="1" set="method" line="53">
			<f a="Data:?Style:?FireOnce" v=":null:false">
				<d/>
				<c path="flixel.system.debug.LogStyle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add an advanced log message to the debugger by also specifying a LogStyle. Backend to FlxG.log.add(), FlxG.log.warn(), FlxG.log.error() and FlxG.log.notice().
	 * 
	 * @param	Data  		Any Data to log.
	 * @param  	Style   	The LogStyle to use, for example LogStyle.WARNING. You can also create your own by importing the LogStyle class.
	 * @param  	FireOnce   	Whether you only want to log the Data in case it hasn't been added already</haxe_doc>
		</advanced>
		<clear public="1" get="inline" set="null" line="97">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears the log output.</haxe_doc>
		</clear>
		<set_redirectTraces get="inline" set="null" line="110"><f a="Redirect">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_redirectTraces>
		<processTraceData set="method" line="122">
			<f a="Data:?Info" v=":null">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function used as a interface between trace() and add().
	 * 
	 * @param	Data	The data that has been traced
	 * @param	Inf		Information about the position at which trace() was called</haxe_doc>
		</processTraceData>
		<new set="method" line="105">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</new>
	</class>
	<class path="haxe.Log" params="" file="C:\HaxeToolkit\haxe\std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos" v=":null">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
	</class>
	<class path="flixel.system.frontEnds.PluginFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/PluginFrontEnd.hx">
		<add_flixel_plugin_MouseEventManager public="1" set="method" line="27">
			<f a="Plugin">
				<c path="flixel.plugin.MouseEventManager"/>
				<c path="flixel.plugin.MouseEventManager"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</add_flixel_plugin_MouseEventManager>
		<add_flixel_plugin_TweenManager public="1" set="method" line="27">
			<f a="Plugin">
				<c path="flixel.plugin.TweenManager"/>
				<c path="flixel.plugin.TweenManager"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</add_flixel_plugin_TweenManager>
		<add_flixel_plugin_TimerManager public="1" set="method" line="27">
			<f a="Plugin">
				<c path="flixel.plugin.TimerManager"/>
				<c path="flixel.plugin.TimerManager"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</add_flixel_plugin_TimerManager>
		<add_flixel_plugin_PathManager public="1" set="method" line="27">
			<f a="Plugin">
				<c path="flixel.plugin.PathManager"/>
				<c path="flixel.plugin.PathManager"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</add_flixel_plugin_PathManager>
		<list public="1" set="null">
			<c path="Array"><c path="flixel.plugin.FlxPlugin"/></c>
			<haxe_doc>* An array container for plugins.</haxe_doc>
		</list>
		<add public="1" params="T" set="method" line="27">
			<f a="Plugin">
				<c path="add.T"/>
				<c path="add.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Adds a new plugin to the global plugin array.
	 * 
	 * @param	Plugin	Any object that extends FlxPlugin. Useful for managers and other things. See flixel.plugin for some examples!
	 * @return	The same FlxPlugin-based plugin you passed in.</haxe_doc>
		</add>
		<get public="1" set="method" line="49">
			<f a="ClassType">
				<x path="Class"><c path="flixel.plugin.FlxPlugin"/></x>
				<c path="flixel.plugin.FlxPlugin"/>
			</f>
			<haxe_doc>* Retrieves a plugin based on its class name from the global plugin array.
	 * 
	 * @param	ClassType	The class name of the plugin you want to retrieve. See the FlxPath or FlxTimer constructors for example usage.
	 * @return	The plugin object, or null if no matching plugin was found.</haxe_doc>
		</get>
		<remove public="1" set="method" line="68">
			<f a="Plugin">
				<c path="flixel.plugin.FlxPlugin"/>
				<c path="flixel.plugin.FlxPlugin"/>
			</f>
			<haxe_doc>* Removes an instance of a plugin from the global plugin array.
	 * 
	 * @param	Plugin	The plugin instance you want to remove.
	 * @return	The same FlxPlugin-based plugin you passed in.</haxe_doc>
		</remove>
		<removeType public="1" set="method" line="92">
			<f a="ClassType">
				<x path="Class"><c path="flixel.plugin.FlxPlugin"/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Removes all instances of a plugin from the global plugin array.
	 * 
	 * @param	ClassType	The class name of the plugin type you want removed from the array.
	 * @return	Whether or not at least one instance of this plugin type was removed.</haxe_doc>
		</removeType>
		<update get="inline" set="null" line="128">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Used by the game object to call update() on all the plugins.</haxe_doc>
		</update>
		<draw get="inline" set="null" line="142">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Used by the game object to call draw() on all the plugins.</haxe_doc>
		</draw>
		<onStateSwitch get="inline" set="null" line="156">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Used by the game object to call onStateSwitch() on all the plugins.</haxe_doc>
		</onStateSwitch>
		<onResize get="inline" set="null" line="172">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used by the game object to call onResize() on all the plugins.
	 * @param 	Width	The new window width
	 * @param 	Height	The new window Height</haxe_doc>
		</onResize>
		<new set="method" line="116">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Sets up two plugins: DebugPathDisplay 
	 * in debugging mode and TimerManager</haxe_doc>
		</new>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.util.FlxPath" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxPath.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<manager public="1" static="1">
			<c path="flixel.plugin.PathManager"/>
			<haxe_doc>* The PathManager instance.</haxe_doc>
		</manager>
		<FORWARD public="1" get="inline" set="null" line="28" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then stop.</haxe_doc>
		</FORWARD>
		<BACKWARD public="1" get="inline" set="null" line="32" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then stop.</haxe_doc>
		</BACKWARD>
		<LOOP_FORWARD public="1" get="inline" set="null" line="36" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then directly back to the start, and start over.</haxe_doc>
		</LOOP_FORWARD>
		<LOOP_BACKWARD public="1" get="inline" set="null" line="40" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then directly back to the end, and start over.</haxe_doc>
		</LOOP_BACKWARD>
		<YOYO public="1" get="inline" set="null" line="44" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then turn around and go back to the start, over and over.</haxe_doc>
		</YOYO>
		<HORIZONTAL_ONLY public="1" get="inline" set="null" line="48" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: ignores any vertical component to the path data, only follows side to side.</haxe_doc>
		</HORIZONTAL_ONLY>
		<VERTICAL_ONLY public="1" get="inline" set="null" line="52" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: ignores any horizontal component to the path data, only follows up and down.</haxe_doc>
		</VERTICAL_ONLY>
		<_point line="57" static="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Internal helper for keeping new variable instantiations under control.</haxe_doc>
		</_point>
		<nodes public="1">
			<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			<haxe_doc>* The list of FlxPoints that make up the path data.</haxe_doc>
		</nodes>
		<object public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Object which will follow this path</haxe_doc>
		</object>
		<speed public="1">
			<x path="Float"/>
			<haxe_doc>* The speed at which the object is moving on the path.
	 * When an object completes a non-looping path circuit,
	 * the pathSpeed will be zeroed out, but the path reference
	 * will NOT be nulled out.  So pathSpeed is a good way
	 * to check if this object is currently following a path or not.</haxe_doc>
		</speed>
		<angle public="1">
			<x path="Float"/>
			<haxe_doc>* The angle in degrees between this object and the next node, where 0 is directly upward, and 90 is to the right.</haxe_doc>
		</angle>
		<autoCenter public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the object should auto-center the path or at its origin.</haxe_doc>
		</autoCenter>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc>* Pauses or checks the pause state of the path.</haxe_doc>
		</active>
		<onComplete public="1"><f a="">
	<c path="flixel.util.FlxPath"/>
	<x path="Void"/>
</f></onComplete>
		<debugColor public="1">
			<x path="Int"/>
			<haxe_doc>* Specify a debug display color for the path. Default is white.</haxe_doc>
		</debugColor>
		<debugScrollX public="1">
			<x path="Float"/>
			<haxe_doc>* Specify a debug display scroll factor for the path.  Default is (1,1).
	 * NOTE: does not affect world movement!  Object scroll factors take care of that.</haxe_doc>
		</debugScrollX>
		<debugScrollY public="1"><x path="Float"/></debugScrollY>
		<ignoreDrawDebug public="1">
			<x path="Bool"/>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when FlxG.debugger.drawDebug is true.</haxe_doc>
		</ignoreDrawDebug>
		<finished public="1" set="null"><x path="Bool"/></finished>
		<_nodeIndex>
			<x path="Int"/>
			<haxe_doc>* Internal helper, tracks which node of the path this object is moving toward.</haxe_doc>
		</_nodeIndex>
		<_mode>
			<x path="Int"/>
			<haxe_doc>* Internal tracker for path behavior flags (like looping, horizontal only, etc).</haxe_doc>
		</_mode>
		<_inc>
			<x path="Int"/>
			<haxe_doc>* Internal helper for node navigation, specifically yo-yo and backwards movement.</haxe_doc>
		</_inc>
		<_autoRotate>
			<x path="Bool"/>
			<haxe_doc>* Internal flag for whether the object's angle should be adjusted to the path angle during path follow behavior.</haxe_doc>
		</_autoRotate>
		<reset public="1" set="method" line="141"><f a=""><c path="flixel.util.FlxPath"/></f></reset>
		<start public="1" set="method" line="153"><f a="Object:Nodes:?Speed:?Mode:?AutoRotate" v="::100:0:false">
	<c path="flixel.FlxObject"/>
	<c path="Array"><c path="flixel.util.FlxPoint"/></c>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="flixel.util.FlxPath"/>
</f></start>
		<restart public="1" set="method" line="164"><f a=""><c path="flixel.util.FlxPath"/></f></restart>
		<setNode public="1" set="method" line="199">
			<f a="NodeIndex">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the path node this object is currently at.
	 * 
	 * @param  NodeIndex    The index of the new node out of path.nodes.</haxe_doc>
		</setNode>
		<update public="1" set="method" line="216">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for moving the object along the path.
	 * Generally this function is called automatically by preUpdate().
	 * The first half of the function decides if the object can advance to the next node in the path,
	 * while the second half handles actually picking a velocity toward the next node.</haxe_doc>
		</update>
		<advancePath set="method" line="328">
			<f a="?Snap" v="true">
				<x path="Bool"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Internal function that decides what node in the path to aim for next based on the behavior flags.
	 * 
	 * @return	The node (a FlxPoint object) we are aiming for next.</haxe_doc>
		</advancePath>
		<cancel public="1" set="method" line="431">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops path movement and removes this path it from the path manager.</haxe_doc>
		</cancel>
		<destroy public="1" set="method" line="449">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<add public="1" set="method" line="467">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc>* Add a new node to the end of the path at the specified location.
	 * 
	 * @param	X	X position of the new path point in world coordinates.
	 * @param	Y	Y position of the new path point in world coordinates.</haxe_doc>
		</add>
		<addAt public="1" set="method" line="480">
			<f a="X:Y:Index">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc>* Add a new node to the path at the specified location and index within the path.
	 * 
	 * @param	X		X position of the new path point in world coordinates.
	 * @param	Y		Y position of the new path point in world coordinates.
	 * @param	Index	Where within the list of path nodes to insert this new point.</haxe_doc>
		</addAt>
		<addPoint public="1" set="method" line="499">
			<f a="Node:?AsReference" v=":false">
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc>* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * FlxPoint object to the path.  This allows you to do neat things, like dynamic paths.
	 * 
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.</haxe_doc>
		</addPoint>
		<addPointAt public="1" set="method" line="521">
			<f a="Node:Index:?AsReference" v="::false">
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc>* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * FlxPoint object to the path.  This allows you to do neat things, like dynamic paths.
	 * 
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	Index			Where within the list of path nodes to insert this new point.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.</haxe_doc>
		</addPointAt>
		<remove public="1" set="method" line="546">
			<f a="Node">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Remove a node from the path.
	 * NOTE: only works with points added by reference or with references from nodes itself!
	 * 
	 * @param	Node	The point object you want to remove from the path.
	 * @return	The node that was excised.  Returns null if the node was not found.</haxe_doc>
		</remove>
		<removeAt public="1" set="method" line="565">
			<f a="Index">
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Remove a node from the path using the specified position in the list of path nodes.
	 * 
	 * @param	Index	Where within the list of path nodes you want to remove a node.
	 * @return	The node that was excised.  Returns null if there were no nodes in the path.</haxe_doc>
		</removeAt>
		<head public="1" set="method" line="583">
			<f a=""><c path="flixel.util.FlxPoint"/></f>
			<haxe_doc>* Get the first node in the list.
	 * 
	 * @return	The first node in the path.</haxe_doc>
		</head>
		<tail public="1" set="method" line="597">
			<f a=""><c path="flixel.util.FlxPoint"/></f>
			<haxe_doc>* Get the last node in the list.
	 * 
	 * @return	The last node in the path.</haxe_doc>
		</tail>
		<drawDebug public="1" set="method" line="615">
			<f a="?Camera" v="null">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* While this doesn't override FlxBasic.drawDebug(), the behavior is very similar.
	 * Based on this path data, it draws a simple lines-and-boxes representation of the path
	 * if the drawDebug mode was toggled in the debugger overlay. You can use debugColor
	 * and debugScrollFactor to control the path's appearance.
	 * 
	 * @param	Camera		The camera object the path will draw to.</haxe_doc>
		</drawDebug>
		<new public="1" set="method" line="133">
			<f a="?Object:?Nodes:?Speed:?Mode:?AutoRotate" v="null:null:100:0:false">
				<c path="flixel.FlxObject"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxPath (and calls start() right away if Object != null).</haxe_doc>
		</new>
		<haxe_doc>* This is a simple path data container.  Basically a list of points that
 * a FlxObject can follow.  Also has code for drawing debug visuals.
 * FlxTilemap.findPath() returns a path object, but you can
 * also just make your own, using the add() functions below
 * or by creating your own array of points.</haxe_doc>
	</class>
	<class path="flixel.plugin.FlxPlugin" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/plugin/FlxPlugin.hx">
		<extends path="flixel.FlxBasic"/>
		<onStateSwitch public="1" set="method" line="16">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called whenever the state is switched or reset 
	 * (FlxG.switchState() and FlxG.resetState()).</haxe_doc>
		</onStateSwitch>
		<onResize public="1" set="method" line="23">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function is called whenever the window size has been changed.
	 * @param 	Width	The new window width
	 * @param 	Height	The new window Height</haxe_doc>
		</onResize>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A base class for all flixel plugins that use the flixel plugin system (see FlxG.plugins).
 * Plugins are basically FlxBasics, but they provide some additional features, like 
 * notifications for certain events like switchting the state or resizing the window.</haxe_doc>
	</class>
	<class path="flixel.plugin.PathManager" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/plugin/PathManager.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<_paths><c path="Array"><c path="flixel.util.FlxPath"/></c></_paths>
		<destroy public="1" set="method" line="27" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="35" override="1"><f a=""><x path="Void"/></f></update>
		<draw public="1" set="method" line="51" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by FlxG.plugins.draw() after the game state has been drawn.
	 * Cycles through cameras and calls drawDebug() on each one.</haxe_doc>
		</draw>
		<add public="1" set="method" line="73">
			<f a="Path">
				<c path="flixel.util.FlxPath"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a path to the path debug display manager.
	 * Usually called automatically by FlxPath's constructor.
	 * 
	 * @param	Path	The FlxPath you want to add to the manager.</haxe_doc>
		</add>
		<remove public="1" set="method" line="87">
			<f a="Path:?ReturnInPool" v=":true">
				<c path="flixel.util.FlxPath"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a path from the path debug display manager.
	 * Usually called automatically by FlxPath's destroy() function.
	 * 
	 * @param	Path	The FlxPath you want to remove from the manager.</haxe_doc>
		</remove>
		<clear public="1" get="inline" set="null" line="95">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all the paths from the path debug display manager.</haxe_doc>
		</clear>
		<onStateSwitch public="1" get="inline" set="null" line="100" override="1"><f a=""><x path="Void"/></f></onStateSwitch>
		<new public="1" set="method" line="15">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiates a new debug path display manager.</haxe_doc>
		</new>
	</class>
	<class path="flixel.util.FlxTimer" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxTimer.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<manager public="1" static="1">
			<c path="flixel.plugin.TimerManager"/>
			<haxe_doc>* The TimerManager instance.</haxe_doc>
		</manager>
		<time public="1">
			<x path="Float"/>
			<haxe_doc>* How much time the timer was set for.</haxe_doc>
		</time>
		<loops public="1">
			<x path="Int"/>
			<haxe_doc>* How many loops the timer was set for. 0 means "looping forever".</haxe_doc>
		</loops>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc>* Pauses or checks the pause state of the timer.</haxe_doc>
		</active>
		<finished public="1">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the timer is finished.</haxe_doc>
		</finished>
		<complete public="1">
			<f a="">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Function that gets called when timer completes.
	 * Callback should be formed "onTimer(Timer:FlxTimer);"</haxe_doc>
		</complete>
		<timeLeft public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Read-only: check how much time is left on the timer.</haxe_doc>
		</timeLeft>
		<elapsedTime public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Read-only: The amount of milliseconds that have elapsed since the timer was started</haxe_doc>
		</elapsedTime>
		<loopsLeft public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Read-only: check how many loops are left on the timer.</haxe_doc>
		</loopsLeft>
		<elapsedLoops public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Read-only: how many loops that have elapsed since the timer was started.</haxe_doc>
		</elapsedLoops>
		<progress public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Read-only: how far along the timer is, on a scale of 0.0 to 1.0.</haxe_doc>
		</progress>
		<_timeCounter>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for the actual timer counting up.</haxe_doc>
		</_timeCounter>
		<_loopsCounter>
			<x path="Int"/>
			<haxe_doc>* Internal tracker for the loops counting up.</haxe_doc>
		</_loopsCounter>
		<destroy public="1" set="method" line="90">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<start public="1" set="method" line="103">
			<f a="?Time:?Callback:?Loops" v="1:null:1">
				<x path="Float"/>
				<f a="">
					<c path="flixel.util.FlxTimer"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<c path="flixel.util.FlxTimer"/>
			</f>
			<haxe_doc>* Starts the timer and adds the timer to the timer manager.
	 * 
	 * @param	Time		How many seconds it takes for the timer to go off.
	 * @param	Callback	Optional, triggered whenever the time runs out, once for each loop. Callback should be formed "onTimer(Timer:FlxTimer);"
	 * @param	Loops		How many times the timer should go off. 0 means "looping forever".
	 * @return	A reference to itself (handy for chaining or whatever).</haxe_doc>
		</start>
		<reset public="1" set="method" line="130">
			<f a="?NewTime" v="-1">
				<x path="Float"/>
				<c path="flixel.util.FlxTimer"/>
			</f>
			<haxe_doc>* Restart the timer using the new duration
	 * @param	NewDuration	The duration of this timer in ms.</haxe_doc>
		</reset>
		<cancel public="1" set="method" line="143">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the timer and removes it from the timer manager.</haxe_doc>
		</cancel>
		<update public="1" set="method" line="158">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the timer manager plugin to update the timer.
	 * If time runs out, the loop counter is advanced, the timer reset, and the callback called if it exists.
	 * If the timer runs out of loops, then the timer calls stop().
	 * However, callbacks are called AFTER stop() is called.</haxe_doc>
		</update>
		<get_timeLeft get="inline" set="null" line="179"><f a=""><x path="Float"/></f></get_timeLeft>
		<get_elapsedTime get="inline" set="null" line="184"><f a=""><x path="Float"/></f></get_elapsedTime>
		<get_loopsLeft get="inline" set="null" line="189"><f a=""><x path="Int"/></f></get_loopsLeft>
		<get_elapsedLoops get="inline" set="null" line="194"><f a=""><x path="Int"/></f></get_elapsedLoops>
		<get_progress get="inline" set="null" line="199"><f a=""><x path="Float"/></f></get_progress>
		<new public="1" set="method" line="79">
			<f a="?Time:?Callback:?Loops" v="null:null:1">
				<x path="Float"/>
				<f a="">
					<c path="flixel.util.FlxTimer"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new timer (and calls start() right away if Time != null).
	 * 
	 * @param	Time		How many seconds it takes for the timer to go off.
	 * @param	Callback	Optional, triggered whenever the time runs out, once for each loop. Callback should be formed "onTimer(Timer:FlxTimer);"
	 * @param	Loops		How many times the timer should go off. 0 means "looping forever".</haxe_doc>
		</new>
		<haxe_doc>* A simple timer class, leveraging the new plugins system.
 * Can be used with callbacks or by polling the finished flag.
 * Not intended to be added to a game state or group; the timer manager
 * is responsible for actually calling update(), not the user.</haxe_doc>
	</class>
	<class path="flixel.plugin.TimerManager" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/plugin/TimerManager.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<_timers><c path="Array"><c path="flixel.util.FlxTimer"/></c></_timers>
		<destroy public="1" set="method" line="30" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="41" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by FlxG.plugins.update() before the game state has been updated.
	 * Cycles through timers and calls update() on each one.</haxe_doc>
		</update>
		<add set="method" line="59">
			<f a="Timer">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Add a new timer to the timer manager.
	 * Called when FlxTimer is started.
	 * 
	 * @param	Timer	The FlxTimer you want to add to the manager.</haxe_doc>
		</add>
		<remove set="method" line="72">
			<f a="Timer">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Remove a timer from the timer manager.
	 * Called automatically by FlxTimer's stop() function.
	 * 
	 * @param	Timer	The FlxTimer you want to remove from the manager.
	 * @param	ReturnInPool Whether to reset and put Timer into internal _pool.</haxe_doc>
		</remove>
		<clear public="1" get="inline" set="null" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all the timers from the timer manager.</haxe_doc>
		</clear>
		<onStateSwitch public="1" get="inline" set="null" line="85" override="1"><f a=""><x path="Void"/></f></onStateSwitch>
		<new public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiates a new timer manager.</haxe_doc>
		</new>
		<haxe_doc>* A simple manager for tracking and updating game timer objects.</haxe_doc>
	</class>
	<class path="flixel.tweens.FlxTween" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/FlxTween.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<PERSIST public="1" get="inline" set="null" line="27" static="1">
			<x path="Int"/>
			<haxe_doc>* Persistent Tween type, will stop when it finishes.</haxe_doc>
		</PERSIST>
		<LOOPING public="1" get="inline" set="null" line="31" static="1">
			<x path="Int"/>
			<haxe_doc>* Looping Tween type, will restart immediately when it finishes.</haxe_doc>
		</LOOPING>
		<PINGPONG public="1" get="inline" set="null" line="35" static="1">
			<x path="Int"/>
			<haxe_doc>* "To and from" Tween type, will play tween hither and thither</haxe_doc>
		</PINGPONG>
		<ONESHOT public="1" get="inline" set="null" line="39" static="1">
			<x path="Int"/>
			<haxe_doc>* Oneshot Tween type, will stop and remove itself from its core container when it finishes.</haxe_doc>
		</ONESHOT>
		<BACKWARD public="1" get="inline" set="null" line="43" static="1">
			<x path="Int"/>
			<haxe_doc>* Backward Tween type, will play tween in reverse direction</haxe_doc>
		</BACKWARD>
		<manager public="1" static="1">
			<c path="flixel.plugin.TweenManager"/>
			<haxe_doc>* The tweening plugin that handles all the tweens.</haxe_doc>
		</manager>
		<tween public="1" set="method" line="64" static="1">
			<f a="Object:Values:?Duration:?Options" v="::1:null">
				<d/>
				<d/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.VarTween"/>
			</f>
			<haxe_doc>* Tweens numeric public properties of an Object. Shorthand for creating a VarTween, starting it and adding it to the TweenManager.
	 * Example: FlxTween.tween(Object, { x: 500, y: 350 }, 2.0, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object		The object containing the properties to tween.
	 * @param	Values		An object containing key/value pairs of properties and target values.
	 * @param	Duration	Duration of the tween in seconds.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 *  					startDelay	Seconds to wait until starting this tween, 0 by default.
	 * 						loopDelay	Seconds to wait between loops of this tween, 0 by default.
	 * @return	The added VarTween object.</haxe_doc>
		</tween>
		<num public="1" set="method" line="92" static="1">
			<f a="FromValue:ToValue:?Duration:?Options:?TweenFunction" v="::1:null:null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<c path="flixel.tweens.misc.NumTween"/>
			</f>
			<haxe_doc>* Tweens some numeric value. Shorthand for creating a NumTween, starting it and adding it to the TweenManager. Using it in 
	 * conjunction with a TweenFunction requires more setup, but is faster than VarTween because it doesn't use Reflection.
	 * 
	 * Example: 
	 *    private function tweenFunction(s:FlxSprite, v:Float) { s.alpha = v; }
	 *    FlxTween.num(1, 0, 2.0, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT }, tweenFunction.bind(mySprite));
	 * 
	 * @param	FromValue	Start value.
	 * @param	ToValue		End value.
	 * @param	Duration	Duration of the tween.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 *  					startDelay	Seconds to wait until starting this tween, 0 by default.
	 * 						loopDelay	Seconds to wait between loops of this tween, 0 by default.
	 * @param	TweenFunction	A function to be called when the tweened value updates.  It is recommended not to use an anonoymous 
	 *							function if you are maximizing performance, as those will be compiled to Dynamics on cpp.
	 * @return	The added NumTween object.</haxe_doc>
		</num>
		<angle public="1" set="method" line="115" static="1">
			<f a="?Sprite:FromAngle:ToAngle:?Duration:?Options" v="null:::1:null">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.AngleTween"/>
			</f>
			<haxe_doc>* Tweens numeric value which represents angle. Shorthand for creating a AngleTween object, starting it and adding it to the TweenManager.
	 * Example: FlxTween.angle(Sprite, -90, 90, 2.0, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Sprite		Optional Sprite whose angle should be tweened.
	 * @param	FromAngle	Start angle.
	 * @param	ToAngle		End angle.
	 * @param	Duration	Duration of the tween.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 *  					startDelay	Seconds to wait until starting this tween, 0 by default.
	 * 						loopDelay	Seconds to wait between loops of this tween, 0 by default.
	 * @return	The added AngleTween object.</haxe_doc>
		</angle>
		<color public="1" set="method" line="140" static="1">
			<f a="?Sprite:?Duration:FromColor:ToColor:?FromAlpha:?ToAlpha:?Options" v="null:1:::1:1:null">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.ColorTween"/>
			</f>
			<haxe_doc>* Tweens numeric value which represents color. Shorthand for creating a ColorTween object, starting it and adding it to a TweenPlugin.
	 * Example: FlxTween.color(Sprite, 2.0, 0x000000, 0xffffff, 0.0, 1.0, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Sprite		Optional Sprite whose color should be tweened.
	 * @param	Duration	Duration of the tween in seconds.
	 * @param	FromColor	Start color.
	 * @param	ToColor		End color.
	 * @param	FromAlpha	Start alpha.
	 * @param	ToAlpha		End alpha.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 *  					startDelay	Seconds to wait until starting this tween, 0 by default.
	 * 						loopDelay	Seconds to wait between loops of this tween, 0 by default.
	 * @return	The added ColorTween object.</haxe_doc>
		</color>
		<linearMotion public="1" set="method" line="166" static="1">
			<f a="Object:FromX:FromY:ToX:ToY:?DurationOrSpeed:?UseDuration:?Options" v=":::::1:true:null">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.LinearMotion"/>
			</f>
			<haxe_doc>* Create a new LinearMotion tween.
	 * Example: FlxTween.linearMotion(Object, 0, 0, 500, 20, 5, false, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			An object containing key/value pairs of the following optional parameters:
	 * 							type		Tween type.
	 * 							complete	Optional completion callback function.
	 * 							ease		Optional easer function.
	 *  						startDelay	Seconds to wait until starting this tween, 0 by default.
	 * 							loopDelay	Seconds to wait between loops of this tween, 0 by default.
	 * @return The LinearMotion object.</haxe_doc>
		</linearMotion>
		<quadMotion public="1" set="method" line="195" static="1">
			<f a="Object:FromX:FromY:ControlX:ControlY:ToX:ToY:?DurationOrSpeed:?UseDuration:?Options" v=":::::::1:true:null">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.QuadMotion"/>
			</f>
			<haxe_doc>* Create a new QuadMotion tween.
	 * Example: FlxTween.quadMotion(Object, 0, 100, 300, 500, 100, 2, 5, false, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ControlX		X control, used to determine the curve.
	 * @param	ControlY		Y control, used to determine the curve.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			An object containing key/value pairs of the following optional parameters:
	 * 							type		Tween type.
	 * 							complete	Optional completion callback function.
	 * 							ease		Optional easer function.
	 *  						startDelay	Seconds to wait until starting this tween, 0 by default.
	 * 							loopDelay	Seconds to wait between loops of this tween, 0 by default.
	 * @return The QuadMotion object.</haxe_doc>
		</quadMotion>
		<cubicMotion public="1" set="method" line="225" static="1">
			<f a="Object:FromX:FromY:aX:aY:bX:bY:ToX:ToY:?Duration:?Options" v=":::::::::1:null">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.CubicMotion"/>
			</f>
			<haxe_doc>* Create a new CubicMotion tween.
	 * Example: FlxTween.cubicMotion(_sprite, 0, 0, 500, 100, 400, 200, 100, 100, 2, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object 		The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX		X start.
	 * @param	FromY		Y start.
	 * @param	aX			First control x.
	 * @param	aY			First control y.
	 * @param	bX			Second control x.
	 * @param	bY			Second control y.
	 * @param	ToX			X finish.
	 * @param	ToY			Y finish.
	 * @param	Duration	Duration of the movement in seconds.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 *  					startDelay	Seconds to wait until starting this tween, 0 by default.
	 * 						loopDelay	Seconds to wait between loops of this tween, 0 by default.
	 * @return The CubicMotion object.</haxe_doc>
		</cubicMotion>
		<circularMotion public="1" set="method" line="254" static="1">
			<f a="Object:CenterX:CenterY:Radius:Angle:Clockwise:?DurationOrSpeed:?UseDuration:?Options" v="::::::1:true:null">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.CircularMotion"/>
			</f>
			<haxe_doc>* Create a new CircularMotion tween.
	 * Example: FlxTween.circularMotion(Object, 250, 250, 50, 0, true, 2, true { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	CenterX			X position of the circle's center.
	 * @param	CenterY			Y position of the circle's center.
	 * @param	Radius			Radius of the circle.
	 * @param	Angle			Starting position on the circle.
	 * @param	Clockwise		If the motion is clockwise.
	 * @param	DurationOrSpeed	Duration of the movement in seconds.
	 * @param	UseDuration		Duration of the movement.
	 * @param	Eease			Optional easer function.
	 * @param	Options			An object containing key/value pairs of the following optional parameters:
	 * 							type		Tween type.
	 * 							complete	Optional completion callback function.
	 * 							ease		Optional easer function.
	 *  						startDelay	Seconds to wait until starting this tween, 0 by default.
	 * 							loopDelay	Seconds to wait between loops of this tween, 0 by default.
	 * @return The CircularMotion object.</haxe_doc>
		</circularMotion>
		<linearPath public="1" set="method" line="278" static="1">
			<f a="Object:Points:?DurationOrSpeed:?UseDuration:?Options" v="::1:true:null">
				<c path="flixel.FlxObject"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.LinearPath"/>
			</f>
			<haxe_doc>* Create a new LinearPath tween.
	 * Example: FlxTween.linearPath(Object, [FlxPoint.get(0, 0), FlxPoint.get(100, 100)], 2, true, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object 			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	Points			An array of at least 2 FlxPoints defining the path
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			An object containing key/value pairs of the following optional parameters:
	 * 							type		Tween type.
	 * 							complete	Optional completion callback function.
	 * 							ease		Optional easer function.
	 * 							startDelay	Seconds to wait until starting this tween, 0 by default.
	 * 							loopDelay	Seconds to wait between loops of this tween, 0 by default.
	 * @return	The LinearPath object.</haxe_doc>
		</linearPath>
		<quadPath public="1" set="method" line="311" static="1">
			<f a="Object:Points:?DurationOrSpeed:?UseDuration:?Options" v="::1:true:null">
				<c path="flixel.FlxObject"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<haxe_doc>* Create a new QuadPath tween.
	 * Example: FlxTween.quadPath(Object, [FlxPoint.get(0, 0), FlxPoint.get(200, 200), FlxPoint.get(400, 0)], 2, true, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	Points			An array of at least 3 FlxPoints defining the path
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			An object containing key/value pairs of the following optional parameters:
	 * 							type		Tween type.
	 * 							complete	Optional completion callback function.
	 * 							ease		Optional easer function.
	 * 							startDelay	Seconds to wait until starting this tween, 0 by default.
	 * 							loopDelay	Seconds to wait between loops of this tween, 0 by default.
	 * @return	The QuadPath object.</haxe_doc>
		</quadPath>
		<active public="1"><x path="Bool"/></active>
		<duration public="1"><x path="Float"/></duration>
		<ease public="1"><t path="flixel.tweens.EaseFunction"/></ease>
		<complete public="1"><t path="flixel.tweens.CompleteCallback"/></complete>
		<type public="1" set="accessor"><x path="Int"/></type>
		<percent public="1" get="accessor" set="accessor"><x path="Float"/></percent>
		<finished public="1" set="null"><x path="Bool"/></finished>
		<scale public="1" set="null"><x path="Float"/></scale>
		<backward public="1" set="null"><x path="Bool"/></backward>
		<executions public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* How many times this tween has been executed / has finished so far - useful to 
	 * stop the LOOPING and PINGPONG types after a certain amount of time</haxe_doc>
		</executions>
		<startDelay public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Seconds to wait until starting this tween, 0 by default</haxe_doc>
		</startDelay>
		<loopDelay public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Seconds to wait between loops of this tween, 0 by default</haxe_doc>
		</loopDelay>
		<_secondsSinceStart><x path="Float"/></_secondsSinceStart>
		<_delayToUse><x path="Float"/></_delayToUse>
		<resolveTweenOptions set="method" line="371"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<t path="flixel.tweens.TweenOptions"/>
</f></resolveTweenOptions>
		<destroy public="1" set="method" line="382"><f a=""><x path="Void"/></f></destroy>
		<update set="method" line="388"><f a=""><x path="Void"/></f></update>
		<start set="method" line="411">
			<f a=""><c path="flixel.tweens.FlxTween"/></f>
			<haxe_doc>* Starts the Tween, or restarts it if it's currently running.</haxe_doc>
		</start>
		<cancel public="1" set="method" line="429">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately stops the Tween and removes it from the 
	 * TweenManager without calling the complete callback.</haxe_doc>
		</cancel>
		<finish set="method" line="436"><f a=""><x path="Void"/></f></finish>
		<setDelays set="method" line="487">
			<f a="?StartDelay:?LoopDelay" v="null:null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.tweens.FlxTween"/>
			</f>
			<haxe_doc>* Set both type of delays for this tween.
	 * 
	 * @param	startDelay	Seconds to wait until starting this tween, 0 by default.
	 * @param	loopDelay	Seconds to wait between loops of this tween, 0 by default.</haxe_doc>
		</setDelays>
		<set_startDelay set="method" line="494"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_startDelay>
		<set_loopDelay set="method" line="505"><f a="value">
	<t path="Null"><x path="Float"/></t>
	<x path="Float"/>
</f></set_loopDelay>
		<get_percent get="inline" set="null" line="516"><f a=""><x path="Float"/></f></get_percent>
		<set_percent set="method" line="521"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_percent>
		<set_type set="method" line="526"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_type>
		<new set="method" line="361">
			<f a="Options">
				<t path="flixel.tweens.TweenOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function is called when tween is created, or recycled.</haxe_doc>
		</new>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.plugin.TweenManager" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/plugin/TweenManager.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<add_flixel_tweens_motion_QuadPath set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="flixel.tweens.motion.QuadPath"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</add_flixel_tweens_motion_QuadPath>
		<add_flixel_tweens_motion_LinearPath set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="flixel.tweens.motion.LinearPath"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.LinearPath"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</add_flixel_tweens_motion_LinearPath>
		<add_flixel_tweens_motion_CircularMotion set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="flixel.tweens.motion.CircularMotion"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.CircularMotion"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</add_flixel_tweens_motion_CircularMotion>
		<add_flixel_tweens_motion_CubicMotion set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="flixel.tweens.motion.CubicMotion"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.CubicMotion"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</add_flixel_tweens_motion_CubicMotion>
		<add_flixel_tweens_motion_QuadMotion set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="flixel.tweens.motion.QuadMotion"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.QuadMotion"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</add_flixel_tweens_motion_QuadMotion>
		<add_flixel_tweens_motion_LinearMotion set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="flixel.tweens.motion.LinearMotion"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.LinearMotion"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</add_flixel_tweens_motion_LinearMotion>
		<add_flixel_tweens_misc_ColorTween set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="flixel.tweens.misc.ColorTween"/>
				<x path="Bool"/>
				<c path="flixel.tweens.misc.ColorTween"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</add_flixel_tweens_misc_ColorTween>
		<add_flixel_tweens_misc_AngleTween set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="flixel.tweens.misc.AngleTween"/>
				<x path="Bool"/>
				<c path="flixel.tweens.misc.AngleTween"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</add_flixel_tweens_misc_AngleTween>
		<add_flixel_tweens_misc_NumTween set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="flixel.tweens.misc.NumTween"/>
				<x path="Bool"/>
				<c path="flixel.tweens.misc.NumTween"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</add_flixel_tweens_misc_NumTween>
		<add_flixel_tweens_misc_VarTween set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="flixel.tweens.misc.VarTween"/>
				<x path="Bool"/>
				<c path="flixel.tweens.misc.VarTween"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</add_flixel_tweens_misc_VarTween>
		<_tweens set="null">
			<c path="Array"><c path="flixel.tweens.FlxTween"/></c>
			<haxe_doc>* A list of all FlxTween objects.</haxe_doc>
		</_tweens>
		<update public="1" set="method" line="23" override="1"><f a=""><x path="Void"/></f></update>
		<add params="T" set="method" line="62">
			<f a="Tween:?Start" v=":false">
				<c path="add.T"/>
				<x path="Bool"/>
				<c path="add.T"/>
			</f>
			<meta>
				<m n=":generic"/>
				<m n=":allow"><e>'???'</e></m>
			</meta>
			<haxe_doc>* Add a FlxTween.
	 * 
	 * @param	Tween	The FlxTween to add.
	 * @param	Start	Whether you want it to start right away.
	 * @return	The added FlxTween object.</haxe_doc>
		</add>
		<remove set="method" line="87">
			<f a="Tween">
				<c path="flixel.tweens.FlxTween"/>
				<c path="flixel.tweens.FlxTween"/>
			</f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Remove a FlxTween.
	 * 
	 * @param	Tween		The FlxTween to remove.
	 * @param	Destroy		Whether you want to destroy the FlxTween.
	 * @return	The added FlxTween object.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="105">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all FlxTweens.</haxe_doc>
		</clear>
		<onStateSwitch public="1" get="inline" set="null" line="113" override="1"><f a=""><x path="Void"/></f></onStateSwitch>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A manager for FlxTweens.</haxe_doc>
	</class>
	<class path="flixel.util.FlxSave" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSave.hx">
		<SUCCESS line="18" static="1"><x path="Int"/></SUCCESS>
		<PENDING line="19" static="1"><x path="Int"/></PENDING>
		<ERROR line="20" static="1"><x path="Int"/></ERROR>
		<data public="1">
			<d/>
			<haxe_doc>* Allows you to directly access the data container in the local shared object.</haxe_doc>
		</data>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the local shared object.</haxe_doc>
		</name>
		<_sharedObject>
			<c path="flash.net.SharedObject"/>
			<haxe_doc>* The local shared object itself.</haxe_doc>
		</_sharedObject>
		<_onComplete>
			<f a="">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal tracker for callback function in case save takes too long.</haxe_doc>
		</_onComplete>
		<_closeRequested>
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for save object close request.</haxe_doc>
		</_closeRequested>
		<destroy public="1" set="method" line="55">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<bind public="1" set="method" line="70">
			<f a="Name">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Automatically creates or reconnects to locally saved data.
	 * 
	 * @param	Name	The name of the object (should be the same each time to access old data).
	 * @return	Whether or not you successfully connected to the save data.</haxe_doc>
		</bind>
		<close public="1" set="method" line="97">
			<f a="?MinFileSize:?OnComplete" v="0:null">
				<x path="Int"/>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>* A way to safely call flush() and destroy() on your save file.
	 * Will correctly handle storage size popups and all that good stuff.
	 * If you don't want to save your changes first, just call destroy() instead.
	 * 
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 * @param	OnComplete		This callback will be triggered when the data is written successfully.
	 * @return	The result of result of the flush() call (see below for more details).</haxe_doc>
		</close>
		<flush public="1" set="method" line="110">
			<f a="?MinFileSize:?OnComplete" v="0:null">
				<x path="Int"/>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Writes the local shared object to disk immediately.  Leaves the object open in memory.
	 * 
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 * @param	OnComplete		This callback will be triggered when the data is written successfully.
	 * @return	Whether or not the data was written immediately.  False could be an error OR a storage request popup.</haxe_doc>
		</flush>
		<erase public="1" set="method" line="155">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Erases everything stored in the local shared object.
	 * Data is immediately erased and the object is saved that way,
	 * so use with caution!
	 * 
	 * @return	Returns false if the save object is not bound yet.</haxe_doc>
		</erase>
		<onDone set="method" line="183">
			<f a="Result">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Event handler for special case storage requests.</haxe_doc>
		</onDone>
		<checkBinding set="method" line="209">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Handy utility function for checking and warning if the shared object is bound yet or not.
	 * 
	 * @return	Whether the shared object was bound yet.</haxe_doc>
		</checkBinding>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Blanks out the containers.</haxe_doc>
		</new>
		<haxe_doc>* A class to help automate and simplify save game functionality.
 * Basicaly a wrapper for the Flash SharedObject thing, but
 * handles some annoying storage request stuff too.</haxe_doc>
	</class>
	<class path="flixel.system.frontEnds.SignalFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/SignalFrontEnd.hx">
		<stateSwitched public="1" set="null">
			<t path="flixel.util.FlxSignal"/>
			<haxe_doc>* Gets dispatched when a state change occurs.</haxe_doc>
		</stateSwitched>
		<gameResized public="1" set="null">
			<x path="flixel.util.FlxTypedSignal"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<haxe_doc>* Gets dispatched when the game is resized. 
	 * Passes the new window width and height to callback functions.</haxe_doc>
		</gameResized>
		<gameReset public="1" set="null"><t path="flixel.util.FlxSignal"/></gameReset>
		<gameStarted public="1" set="null">
			<t path="flixel.util.FlxSignal"/>
			<haxe_doc>* Gets dispatched when the game is started (first state after the splash screen).</haxe_doc>
		</gameStarted>
		<preUpdate public="1" set="null"><t path="flixel.util.FlxSignal"/></preUpdate>
		<postUpdate public="1" set="null"><t path="flixel.util.FlxSignal"/></postUpdate>
		<preDraw public="1" set="null"><t path="flixel.util.FlxSignal"/></preDraw>
		<postDraw public="1" set="null"><t path="flixel.util.FlxSignal"/></postDraw>
		<focusGained public="1" set="null"><t path="flixel.util.FlxSignal"/></focusGained>
		<focusLost public="1" set="null"><t path="flixel.util.FlxSignal"/></focusLost>
		<new set="method" line="30">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</new>
	</class>
	<class path="flixel.system.frontEnds.SoundFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/SoundFrontEnd.hx">
		<music public="1">
			<c path="flixel.system.FlxSound"/>
			<haxe_doc>* A handy container for a background music object.</haxe_doc>
		</music>
		<muted public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the game sounds are muted.</haxe_doc>
		</muted>
		<volumeHandler public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set this hook to get a callback whenever the volume changes.
	 * Function should take the form myVolumeHandler(Volume:Number).</haxe_doc>
		</volumeHandler>
		<volumeUpKeys public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* The key codes used to increase volume (see FlxG.keys for the keys available).
	 * Default keys: + (and numpad +). Set to null to deactivate.</haxe_doc>
		</volumeUpKeys>
		<volumeDownKeys public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* The keys to decrease volume (see FlxG.keys for the keys available).
	 * Default keys: - (and numpad -). Set to null to deactivate.</haxe_doc>
		</volumeDownKeys>
		<muteKeys public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* The keys used to mute / unmute the game (see FlxG.keys for the keys available).
	 * Default keys: 0 (and numpad 0). Set to null to deactivate.</haxe_doc>
		</muteKeys>
		<soundTrayEnabled public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the soundTray should be shown when any of the
	 * volumeUp-, volumeDown- or muteKeys is pressed.</haxe_doc>
		</soundTrayEnabled>
		<list public="1" set="null">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.system.FlxSound"/></c>
			<haxe_doc>* A list of all the sounds being played in the game.</haxe_doc>
		</list>
		<volume public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Set this to a number between 0 and 1 to change the global volume.</haxe_doc>
		</volume>
		<_soundCache><x path="Map">
	<c path="String"/>
	<c path="flash.media.Sound"/>
</x></_soundCache>
		<_soundTransform><c path="flash.media.SoundTransform"/></_soundTransform>
		<playMusic public="1" set="method" line="73">
			<f a="Music:?Volume:?Looped" v=":1:true">
				<d/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set up and play a looping background soundtrack.
	 * 
	 * @param	Music		The sound file you want to loop in the background.
	 * @param	Volume		How loud the sound should be, from 0 to 1.
	 * @param	Looped		Whether to loop this music.</haxe_doc>
		</playMusic>
		<load public="1" set="method" line="101">
			<f a="?EmbeddedSound:?Volume:?Looped:?AutoDestroy:?AutoPlay:?URL:?OnComplete" v="null:1:false:false:false:null:null">
				<d/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* Creates a new sound object. 
	 * 
	 * @param	EmbeddedSound	The embedded sound resource you want to play.  To stream, use the optional URL parameter instead.
	 * @param	Volume			How loud to play it (0 to 1).
	 * @param	Looped			Whether to loop this sound.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this FlxSound instance.
	 * @param	AutoPlay		Whether to play the sound.
	 * @param	URL				Load a sound from an external web resource instead.  Only used if EmbeddedSound = null.
	 * @return	A FlxSound object.</haxe_doc>
		</load>
		<cache public="1" set="method" line="137">
			<f a="EmbeddedSound">
				<c path="String"/>
				<c path="flash.media.Sound"/>
			</f>
			<haxe_doc>* Method for sound caching (especially useful on mobile targets). The game may freeze
	 * for some time the first time yout try to play a sound if you don't use this method.
	 * 
	 * @param	EmbeddedSound	Name of sound assets specified in your .xml project file
	 * @return	Cached Sound object</haxe_doc>
		</cache>
		<play public="1" set="method" line="161">
			<f a="EmbeddedSound:?Volume:?Looped:?AutoDestroy:?OnComplete" v=":1:false:true:null">
				<c path="String"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* Plays a sound from an embedded sound. Tries to recycle a cached sound first.
	 * 
	 * @param	EmbeddedSound	The sound you want to play.
	 * @param	Volume			How loud to play it (0 to 1).
	 * @param	Looped			Whether to loop this sound.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this FlxSound instance.
	 * @return	The FlxSound object.</haxe_doc>
		</play>
		<stream public="1" get="inline" set="null" line="191">
			<f a="URL:?Volume:?Looped:?AutoDestroy:?OnComplete" v=":1:false:true:null">
				<c path="String"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* Creates a new sound object from a URL.
	 * NOTE: Just calls FlxG.loadSound() with AutoPlay == true.
	 * 
	 * @param	URL		The URL of the sound you want to play.
	 * @param	Volume	How loud to play it (0 to 1).
	 * @param	Looped	Whether or not to loop this sound.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this FlxSound instance.
	 * @return	A FlxSound object.</haxe_doc>
		</stream>
		<pause public="1" set="method" line="199">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pause all sounds currently playing.</haxe_doc>
		</pause>
		<resume public="1" set="method" line="218">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resume playing existing sounds.</haxe_doc>
		</resume>
		<destroy public="1" set="method" line="239">
			<f a="?ForceDestroy" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called by FlxGame on state changes to stop and destroy sounds.
	 * 
	 * @param	ForceDestroy	Kill sounds even if persist is true.</haxe_doc>
		</destroy>
		<update set="method" line="273">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game loop to make sure the sounds get updated each frame.</haxe_doc>
		</update>
		<onFocusLost set="method" line="286"><f a=""><x path="Void"/></f></onFocusLost>
		<onFocus set="method" line="302"><f a=""><x path="Void"/></f></onFocus>
		<loadSavedPrefs set="method" line="321">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Loads saved sound preferences if they exist.</haxe_doc>
		</loadSavedPrefs>
		<set_volume set="method" line="342"><f a="Volume">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<new set="method" line="256"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
		</meta>
	</class>
	<class path="flixel.group.FlxTypedGroup" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/group/FlxTypedGroup.hx">
		<extends path="flixel.FlxBasic"/>
		<members public="1" set="null">
			<c path="Array"><c path="flixel.group.FlxTypedGroup.T"/></c>
			<haxe_doc>* Array of all the members in this group.</haxe_doc>
		</members>
		<maxSize public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The maximum capacity of this group. Default is 0, meaning no max capacity, and the group can just grow.</haxe_doc>
		</maxSize>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The number of entries in the members array. For performance and safety you should check this 
	 * variable instead of members.length unless you really know what you're doing!</haxe_doc>
		</length>
		<_marker>
			<x path="Int"/>
			<haxe_doc>* Internal helper variable for recycling objects a la FlxEmitter.</haxe_doc>
		</_marker>
		<destroy public="1" set="method" line="54" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* WARNING: This will remove this group entirely. Use kill() if you want to disable it
	 * temporarily only and be able to revive() it later.
	 * Override this function to handle any deleting or "shutdown" type operations you might need,
	 * such as removing traditional Flash children like Sprite objects.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="78" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Automatically goes through and calls update on everything you added.</haxe_doc>
		</update>
		<draw public="1" set="method" line="97" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Automatically goes through and calls render on everything you added.</haxe_doc>
		</draw>
		<add public="1" set="method" line="124">
			<f a="Object">
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc>* Adds a new FlxBasic subclass (FlxBasic, FlxSprite, Enemy, etc) to the group.
	 * FlxGroup will try to replace a null member of the array first.
	 * Failing that, FlxGroup will add it to the end of the member array,
	 * assuming there is room for it, and doubling the size of the array if necessary.
	 * WARNING: If the group has a maxSize that has already been met,
	 * the object will NOT be added to the group!
	 * 
	 * @param	Object		The object you want to add to the group.
	 * @return	The same FlxBasic object that was passed in.</haxe_doc>
		</add>
		<recycle public="1" set="method" line="186">
			<f a="?ObjectClass:?ContructorArgs:?Force:?Revive" v="null:null:false:true">
				<x path="Class"><c path="flixel.group.FlxTypedGroup.T"/></x>
				<c path="Array"><d/></c>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc><![CDATA[* Recycling is designed to help you reuse game objects without always re-allocating or "newing" them.
	 * It behaves differently depending on whether maxSize equals 0 or is bigger than 0.
	 * 
	 * maxSize == 0 / "rotating-recycling" (used by FlxEmitter):
	 *   - at capacity:  returns the next object in line, no matter its properties like alive, exists etc.
	 *   - otherwise:    returns a new object.
	 * 
	 * maxSize > 0 / "grow-style-recycling"
	 *   - at capacity:  tries to find the first object with exists == false, or if none found:
	 *   - otherwise:    adds a new object to the members array, doubling its size if necessary
	 *
	 * WARNING: If this function needs to create a new object, and no object class was provided, 
	 * it will return null instead of a valid object!
	 * 
	 * @param	ObjectClass		The class type you want to recycle (e.g. FlxSprite, EvilRobot, etc). Do NOT "new" the class in the parameter!
	 * @param 	ContructorArgs  An array of arguments passed into a newly object if there aren't any dead members to recycle. 
	 * @param 	Force           Force the object to be an ObjectClass and not a super class of ObjectClass. 
	 * @param	Revive			Whether recycled members should automatically be revived (by calling revive() on them)
	 * @return	A reference to the object that was created.  Don't forget to cast it back to the Class you want (e.g. myObject = myGroup.recycle(myObjectClass) as myObjectClass;).]]></haxe_doc>
		</recycle>
		<remove public="1" set="method" line="255">
			<f a="Object:?Splice" v=":false">
				<c path="flixel.group.FlxTypedGroup.T"/>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc>* Removes an object from the group.
	 * 
	 * @param	Object	The FlxBasic you want to remove.
	 * @param	Splice	Whether the object should be cut from the array entirely or not.
	 * @return	The removed object.</haxe_doc>
		</remove>
		<replace public="1" set="method" line="281">
			<f a="OldObject:NewObject">
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc>* Replaces an existing FlxBasic with a new one. 
	 * Does not do anything and returns null if the old object is not part of the group.
	 * 
	 * @param	OldObject	The object you want to replace.
	 * @param	NewObject	The new object you want to use instead.
	 * @return	The new object.</haxe_doc>
		</replace>
		<sort public="1" get="inline" set="null" line="300">
			<f a="Function:?Order" v=":-1">
				<f a="::">
					<x path="Int"/>
					<c path="flixel.group.FlxTypedGroup.T"/>
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Int"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Call this function to sort the group according to a particular value and order. For example, to sort game objects for Zelda-style 
	 * overlaps you might call myGroup.sort(FlxSort.byY, FlxSort.ASCENDING) at the bottom of your FlxState.update() override.
	 * 
	 * @param	Function	The sorting function to use - you can use one of the premade ones in FlxSort or write your own using FlxSort.byValues() as a backend
	 * @param	Order		A FlxGroup constant that defines the sort order.  Possible values are FlxSort.ASCENDING (default) and FlxSort.DESCENDING.</haxe_doc>
		</sort>
		<setAll public="1" set="method" line="312">
			<f a="VariableName:Value:?Recurse" v="::true">
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Go through and set the specified variable to the specified value on all members of the group.
	 * 
	 * @param	VariableName	The string representation of the variable name you want to modify, for example "visible" or "scrollFactor".
	 * @param	Value			The value you want to assign to that variable.
	 * @param	Recurse			Default value is true, meaning if setAll() encounters a member that is a group, it will call setAll() on that group rather than modifying its variable.</haxe_doc>
		</setAll>
		<callAll public="1" set="method" line="342">
			<f a="FunctionName:?Args:?Recurse" v=":null:true">
				<c path="String"/>
				<c path="Array"><d/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Go through and call the specified function on all members of the group, recursively by default.
	 * 
	 * @param	FunctionName	The string representation of the function you want to call on each object, for example "kill()" or "init()".
	 * @param	Args			An array of arguments to call the function with
	 * @param	Recurse			Default value is true, meaning if callAll() encounters a member that is a group, it will call callAll() on that group rather than calling the group's function.</haxe_doc>
		</callAll>
		<getFirstAvailable public="1" set="method" line="376">
			<f a="?ObjectClass:?Force" v="null:false">
				<x path="Class"><c path="flixel.group.FlxTypedGroup.T"/></x>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc>* Call this function to retrieve the first object with exists == false in the group.
	 * This is handy for recycling in general, e.g. respawning enemies.
	 * 
	 * @param	ObjectClass		An optional parameter that lets you narrow the results to instances of this particular class.
	 * @param 	Force           Force the object to be an ObjectClass and not a super class of ObjectClass. 
	 * @return	A FlxBasic currently flagged as not existing.</haxe_doc>
		</getFirstAvailable>
		<getFirstNull public="1" set="method" line="404">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to retrieve the first index set to 'null'.
	 * Returns -1 if no index stores a null object.
	 * 
	 * @return	An Int indicating the first null slot in the group.</haxe_doc>
		</getFirstNull>
		<getFirstExisting public="1" set="method" line="426">
			<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with exists == true in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A FlxBasic currently flagged as existing.</haxe_doc>
		</getFirstExisting>
		<getFirstAlive public="1" set="method" line="450">
			<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with dead == false in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A FlxBasic currently flagged as not dead.</haxe_doc>
		</getFirstAlive>
		<getFirstDead public="1" set="method" line="474">
			<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with dead == true in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A FlxBasic currently flagged as dead.</haxe_doc>
		</getFirstDead>
		<countLiving public="1" set="method" line="497">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to find out how many members of the group are not dead.
	 * 
	 * @return	The number of FlxBasics flagged as not dead.  Returns -1 if group is empty.</haxe_doc>
		</countLiving>
		<countDead public="1" set="method" line="528">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to find out how many members of the group are dead.
	 * 
	 * @return	The number of FlxBasics flagged as dead.  Returns -1 if group is empty.</haxe_doc>
		</countDead>
		<getRandom public="1" set="method" line="561">
			<f a="?StartIndex:?Length" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc>* Returns a member at random from the group.
	 * 
	 * @param	StartIndex	Optional offset off the front of the array. Default value is 0, or the beginning of the array.
	 * @param	Length		Optional restriction on the number of values you want to randomly select from.
	 * @return	A FlxBasic from the members list.</haxe_doc>
		</getRandom>
		<clear public="1" set="method" line="579">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove all instances of FlxBasic subclass (FlxSprite, FlxBlock, etc) from the list.
	 * WARNING: does not destroy() or kill() any of these objects!</haxe_doc>
		</clear>
		<kill public="1" set="method" line="589" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Calls kill on the group's members and then on the group itself. 
	 * You can revive this group later via revive() after this.</haxe_doc>
		</kill>
		<iterator public="1" get="inline" set="null" line="612">
			<f a="?filter" v="null">
				<f a="">
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Bool"/>
				</f>
				<c path="flixel.group.FlxTypedGroupIterator"><c path="flixel.group.FlxTypedGroup.T"/></c>
			</f>
			<haxe_doc>* Iterate through every member
	 * 
	 * @return An iterator</haxe_doc>
		</iterator>
		<forEach public="1" set="method" line="622">
			<f a="Function">
				<f a="">
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies a function to all members
	 * 
	 * @param   Function   A function that modifies one element at a time</haxe_doc>
		</forEach>
		<forEachAlive public="1" set="method" line="641">
			<f a="Function">
				<f a="">
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies a function to all alive members
	 * 
	 * @param   Function   A function that modifies one element at a time</haxe_doc>
		</forEachAlive>
		<forEachDead public="1" set="method" line="660">
			<f a="Function">
				<f a="">
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies a function to all dead members
	 * 
	 * @param   Function   A function that modifies one element at a time</haxe_doc>
		</forEachDead>
		<forEachExists public="1" set="method" line="679">
			<f a="Function">
				<f a="">
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies a function to all existing members
	 * 
	 * @param   Function   A function that modifies one element at a time</haxe_doc>
		</forEachExists>
		<forEachOfType public="1" params="K" set="method" line="699">
			<f a="ObjectClass:Function">
				<x path="Class"><c path="forEachOfType.K"/></x>
				<f a="">
					<c path="forEachOfType.K"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Applies a function to all members of type Class<K>
	 * 
	 * @param   ObjectClass   A class that objects will be checked against before Function is applied, ex: FlxSprite
	 * @param   Function      A function that modifies one element at a time]]></haxe_doc>
		</forEachOfType>
		<set_maxSize set="method" line="713"><f a="Size">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxSize>
		<new public="1" set="method" line="37">
			<f a="?MaxSize" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	MaxSize		Maximum amount of members allowed</haxe_doc>
		</new>
		<haxe_doc>* This is an organizational class that can update and render a bunch of FlxBasics.
 * NOTE: Although FlxGroup extends FlxBasic, it will not automatically
 * add itself to the global collisions quad tree, it will only add its members.</haxe_doc>
	</class>
	<class path="flixel.system.frontEnds.VCRFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/VCRFrontEnd.hx">
		<paused public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the debugger has been paused.</haxe_doc>
		</paused>
		<stepRequested public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether a "1 frame step forward" was requested.</haxe_doc>
		</stepRequested>
		<pause public="1" set="method" line="55">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pause the main game loop</haxe_doc>
		</pause>
		<resume public="1" set="method" line="75">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resume the main game loop from FlxG.vcr.pause();</haxe_doc>
		</resume>
		<new set="method" line="373">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</new>
	</class>
	<class path="flixel.system.frontEnds.WatchFrontEnd" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/frontEnds/WatchFrontEnd.hx">
		<add public="1" get="inline" set="null" line="15">
			<f a="AnyObject:VariableName:?DisplayName" v="::null">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a variable to the watch list in the debugger.
	 * This lets you see the value of the variable all the time.
	 * 
	 * @param	AnyObject		A reference to any object in your game, e.g. Player or Robot or this.
	 * @param	VariableName	The name of the variable you want to watch, in quotes, as a string: e.g. "speed" or "health".
	 * @param	DisplayName		Optional, display your own string instead of the class name + variable name: e.g. "enemy count".</haxe_doc>
		</add>
		<remove public="1" get="inline" set="null" line="29">
			<f a="AnyObject:?VariableName" v=":null">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a variable from the watch list in the debugger.
	 * Don't pass a Variable Name to remove all watched variables for the specified object.
	 * 
	 * @param	AnyObject		A reference to any object in your game, e.g. Player or Robot or this.
	 * @param	VariableName	The name of the variable you want to watch, in quotes, as a string: e.g. "speed" or "health".</haxe_doc>
		</remove>
		<addQuick public="1" get="inline" set="null" line="44">
			<f a="Name:NewValue">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add or update a quickWatch entry to the watch list in the debugger.
	 * Extremely useful when called in update() functions when there 
	 * doesn't exist a variable for a value you want to watch - so you won't have to create one.
	 * 
	 * @param	Name		The name of the quickWatch entry, for example "mousePressed".
	 * @param	NewValue	The new value for this entry, for example FlxG.mouse.pressed.</haxe_doc>
		</addQuick>
		<removeQuick public="1" get="inline" set="null" line="56">
			<f a="Name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a quickWatch entry from the watch list of the debugger.
	 * 
	 * @param	Name	The name of the quickWatch entry you want to remove.</haxe_doc>
		</removeQuick>
		<addMouse public="1" get="inline" set="null" line="67">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add the mouse coords to the watch window. Useful for quickly 
	 * getting coordinates for object placement during prototyping!</haxe_doc>
		</addMouse>
		<removeMouse public="1" get="inline" set="null" line="77">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes the mouse coords from the watch window.</haxe_doc>
		</removeMouse>
		<new public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Just needed to create an instance.</haxe_doc>
		</new>
	</class>
	<class path="flixel.util.FlxPool_flixel_util_FlxRect" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxPool.hx">
		<_pool><c path="Array"><c path="flixel.util.FlxRect"/></c></_pool>
		<_class><x path="Class"><c path="flixel.util.FlxRect"/></x></_class>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<get public="1" set="method" line="23"><f a=""><c path="flixel.util.FlxRect"/></f></get>
		<put public="1" set="method" line="33"><f a="obj">
	<c path="flixel.util.FlxRect"/>
	<x path="Void"/>
</f></put>
		<putUnsafe public="1" set="method" line="43"><f a="obj">
	<c path="flixel.util.FlxRect"/>
	<x path="Void"/>
</f></putUnsafe>
		<preAllocate public="1" set="method" line="52"><f a="numObjects">
	<x path="Int"/>
	<x path="Void"/>
</f></preAllocate>
		<clear public="1" set="method" line="60"><f a=""><c path="Array"><c path="flixel.util.FlxRect"/></c></f></clear>
		<get_length get="inline" set="null" line="67"><f a=""><x path="Int"/></f></get_length>
		<new public="1" set="method" line="17"><f a="classObj">
	<x path="Class"><c path="flixel.util.FlxRect"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.util.FlxRect" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxRect.hx">
		<implements path="flixel.interfaces.IFlxPooled"/>
		<_pool line="13" static="1"><c path="flixel.util.FlxPool_flixel_util_FlxRect"/></_pool>
		<get public="1" get="inline" set="null" line="22" static="1">
			<f a="?X:?Y:?Width:?Height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Recycle or create new FlxRect.
	 * Be sure to put() them back into the pool after you're done with them!
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.</haxe_doc>
		</get>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<left public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The x coordinate of the left side of the rectangle.</haxe_doc>
		</left>
		<right public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The x coordinate of the right side of the rectangle.</haxe_doc>
		</right>
		<top public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The x coordinate of the top of the rectangle.</haxe_doc>
		</top>
		<bottom public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The y coordinate of the bottom of the rectangle.</haxe_doc>
		</bottom>
		<_inPool><x path="Bool"/></_inPool>
		<put public="1" get="inline" set="null" line="64">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this FlxRect to the recycling pool.</haxe_doc>
		</put>
		<setSize public="1" get="inline" set="null" line="79">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Shortcut for setting both width and Height.
	 * 
	 * @param	Width	The new sprite width.
	 * @param	Height	The new sprite height.</haxe_doc>
		</setSize>
		<set public="1" get="inline" set="null" line="95">
			<f a="?X:?Y:?Width:?Height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Fill this rectangle with the data provided.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.
	 * @return	A reference to itself.</haxe_doc>
		</set>
		<copyFrom public="1" get="inline" set="null" line="110">
			<f a="Rect">
				<c path="flixel.util.FlxRect"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from the specified rectangle.
	 * 
	 * @param	Rect	Any FlxRect.
	 * @return	A reference to itself.</haxe_doc>
		</copyFrom>
		<copyTo public="1" get="inline" set="null" line="125">
			<f a="Rect">
				<c path="flixel.util.FlxRect"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from this rectangle to the specified rectangle.
	 * 
	 * @param	Point	Any FlxRect.
	 * @return	A reference to the altered rectangle parameter.</haxe_doc>
		</copyTo>
		<copyFromFlash public="1" get="inline" set="null" line="140">
			<f a="FlashRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from the specified Flash rectangle.
	 * 
	 * @param	FlashRect	Any Rectangle.
	 * @return	A reference to itself.</haxe_doc>
		</copyFromFlash>
		<copyToFlash public="1" get="inline" set="null" line="155">
			<f a="FlashRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from this rectangle to the specified Flash rectangle.
	 * 
	 * @param	Point	Any Rectangle.
	 * @return	A reference to the altered rectangle parameter.</haxe_doc>
		</copyToFlash>
		<overlaps public="1" get="inline" set="null" line="170">
			<f a="Rect">
				<c path="flixel.util.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if some FlxRect object overlaps this FlxRect object.
	 * 
	 * @param	Rect	The rectangle being tested.
	 * @return	Whether or not the two rectangles overlap.</haxe_doc>
		</overlaps>
		<containsFlxPoint public="1" get="inline" set="null" line="181">
			<f a="Point">
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this FlxRect contains the FlxPoint
	 * 
	 * @param	Point	The FlxPoint to check
	 * @return	True if the FlxPoint is within this FlxRect, otherwise false</haxe_doc>
		</containsFlxPoint>
		<union public="1" get="inline" set="null" line="193">
			<f a="Rect">
				<c path="flixel.util.FlxRect"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Add another rectangle to this one by filling in the 
	 * horizontal and vertical space between the two rectangles.
	 * 
	 * @param	Rect	The second FlxRect to add to this one
	 * @return	The changed FlxRect</haxe_doc>
		</union>
		<destroy public="1" set="method" line="206">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Necessary for IFlxDestroyable.</haxe_doc>
		</destroy>
		<toString public="1" get="inline" set="null" line="211">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name. Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<get_left get="inline" set="null" line="220"><f a=""><x path="Float"/></f></get_left>
		<set_left get="inline" set="null" line="225"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_left>
		<get_right get="inline" set="null" line="231"><f a=""><x path="Float"/></f></get_right>
		<set_right get="inline" set="null" line="236"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_right>
		<get_top get="inline" set="null" line="242"><f a=""><x path="Float"/></f></get_top>
		<set_top get="inline" set="null" line="247"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_top>
		<get_bottom get="inline" set="null" line="253"><f a=""><x path="Float"/></f></get_bottom>
		<set_bottom get="inline" set="null" line="258"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bottom>
		<new public="1" set="method" line="56"><f a="?X:?Y:?Width:?Height" v="0:0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Stores a rectangle.</haxe_doc>
	</class>
	<class path="flixel.FlxG" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/FlxG.hx">
		<removeChild_flash_display_DisplayObject public="1" get="inline" set="null" line="399" static="1">
			<f a="Child">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</removeChild_flash_display_DisplayObject>
		<addChildBelowMouse_flash_display_DisplayObject public="1" set="method" line="382" static="1">
			<f a="Child:?IndexModifier" v=":0">
				<c path="flash.display.DisplayObject"/>
				<x path="Int"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</addChildBelowMouse_flash_display_DisplayObject>
		<autoPause public="1" line="69" static="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the game should be paused when focus is lost or not. Use FLX_NO_FOCUS_LOST_SCREEN if you only want to get rid of the default
	 * pause screen. Override onFocus() and onFocusLost() for your own behaviour in your state.</haxe_doc>
		</autoPause>
		<fixedTimestep public="1" line="74" static="1">
			<x path="Bool"/>
			<haxe_doc>* WARNING: Changing this can lead to issues with physics and the recording system. Setting this to 
	 * false might lead to smoother animations (even at lower fps) at the cost of physics accuracy.</haxe_doc>
		</fixedTimestep>
		<timeScale public="1" line="78" static="1">
			<x path="Float"/>
			<haxe_doc>* How fast or slow time should pass in the game; default is 1.0.</haxe_doc>
		</timeScale>
		<worldDivisions public="1" line="83" static="1">
			<x path="Int"/>
			<haxe_doc>* How many times the quad tree should divide the world on each axis. Generally, sparse collisions can have fewer divisons,
	 * while denser collision activity usually profits from more. Default value is 6.</haxe_doc>
		</worldDivisions>
		<camera public="1" static="1">
			<c path="flixel.FlxCamera"/>
			<haxe_doc>* By default this just refers to the first entry in the FlxG.cameras.list 
	 * array but you can do what you like with it.</haxe_doc>
		</camera>
		<VERSION public="1" set="null" line="94" static="1">
			<c path="flixel.system.FlxVersion"/>
			<haxe_doc>* The HaxeFlixel version, in semantic versioning syntax. Use Std.string()
	 * on it to get a String formatted like this: "HaxeFlixel MAJOR.MINOR.PATCH-PATCH_VERSION".</haxe_doc>
		</VERSION>
		<game public="1" set="null" static="1">
			<c path="flixel.FlxGame"/>
			<haxe_doc>* Internal tracker for game object.</haxe_doc>
		</game>
		<stage public="1" get="accessor" set="null" static="1">
			<c path="flash.display.Stage"/>
			<haxe_doc>* Read-only: retrieves the Flash stage object (required for event listeners)
	 * Will be null if it's not safe/useful yet.</haxe_doc>
		</stage>
		<state public="1" get="accessor" set="null" static="1">
			<c path="flixel.FlxState"/>
			<haxe_doc>* Read-only: access the current game state from anywhere. Consider using addChildBelowMouse()
	 * if you want to add a DisplayObject to the stage instead of directly adding it here!</haxe_doc>
		</state>
		<updateFramerate public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* How many times you want your game to update each second. More updates usually means better collisions and smoother motion.
	 * NOTE: This is NOT the same thing as the draw framerate!</haxe_doc>
		</updateFramerate>
		<drawFramerate public="1" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* How many times you want your game to step each second. More steps usually means greater responsiveness, 
	 * but it can also slowdown your game if the stage can't keep up with the update routine. NOTE: This is NOT the same thing as the Update framerate!</haxe_doc>
		</drawFramerate>
		<elapsed public="1" set="null" line="124" static="1">
			<x path="Float"/>
			<haxe_doc>* Represents the amount of time in seconds that passed since last frame.</haxe_doc>
		</elapsed>
		<maxElapsed public="1" line="129" static="1">
			<x path="Float"/>
			<haxe_doc>* Useful when the timestep is NOT fixed (i.e. variable), to prevent jerky movement or erratic behavior at very low fps.
	 * Essentially locks the framerate to a minimum value - any slower and you'll get slowdown instead of frameskip; default is 1/10th of a second.</haxe_doc>
		</maxElapsed>
		<width public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* The width of the screen in game pixels. Read-only, use resizeGame() to change.</haxe_doc>
		</width>
		<height public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* The height of the screen in game pixels. Read-only, use resizeGame() to change.</haxe_doc>
		</height>
		<scaleMode public="1" set="accessor" static="1">
			<c path="flixel.system.scaleModes.BaseScaleMode"/>
			<haxe_doc>* The scale mode the game should use - available policies are FillScaleMode, FixedScaleMode,
	 * RatioScaleMode, RelativeScaleMode and StageSizeScaleMode.</haxe_doc>
		</scaleMode>
		<fullscreen public="1" set="accessor" line="150" static="1">
			<x path="Bool"/>
			<haxe_doc>* Use this to toggle between fullscreen and normal mode. Works in cpp and flash.
	 * You can easily toggle fullscreen with eg: FlxG.fullscreen = !FlxG.fullscreen;</haxe_doc>
		</fullscreen>
		<worldBounds public="1" set="null" line="155" static="1">
			<c path="flixel.util.FlxRect"/>
			<haxe_doc>* The dimensions of the game world, used by the quad tree for collisions and overlap checks.
	 * Use .set() instead of creating a new object!</haxe_doc>
		</worldBounds>
		<save public="1" set="null" line="161" static="1">
			<c path="flixel.util.FlxSave"/>
			<haxe_doc>* A FlxSave used internally by flixel to save sound preferences and 
	 * the history of the console window, but no reason you can't use it for your own stuff too!</haxe_doc>
		</save>
		<mouse public="1" set="accessor" static="1">
			<c path="flixel.input.mouse.FlxMouse"/>
			<haxe_doc>* Used for mouse input. e.g.: check if the left mouse button 
	 * is pressed with if (FlxG.mouse.pressed) { }) in update().</haxe_doc>
		</mouse>
		<touches public="1" set="null" static="1">
			<c path="flixel.input.touch.FlxTouchManager"/>
			<haxe_doc>* Useful for devices with multitouch support.</haxe_doc>
		</touches>
		<swipes public="1" set="null" line="182" static="1">
			<c path="Array"><c path="flixel.input.FlxSwipe"/></c>
			<haxe_doc>* Contains all "swipes" from both mouse and touch input that have just ended.</haxe_doc>
		</swipes>
		<keys public="1" set="null" static="1">
			<c path="flixel.input.keyboard.FlxKeyboard"/>
			<haxe_doc>* Used for keyboard input e.g.: check if the left arrow key is 
	 * pressed with if (FlxG.keys.pressed.LEFT) { } in update().</haxe_doc>
		</keys>
		<gamepads public="1" set="null" static="1">
			<c path="flixel.input.gamepad.FlxGamepadManager"/>
			<haxe_doc>* A reference to a FlxGamepadManager object.</haxe_doc>
		</gamepads>
		<inputs public="1" set="null" line="224" static="1">
			<c path="flixel.system.frontEnds.InputFrontEnd"/>
			<haxe_doc>* Mostly used internally, but you can use it too to reset inputs and create input classes of your own.</haxe_doc>
		</inputs>
		<console public="1" set="null" line="228" static="1">
			<c path="flixel.system.frontEnds.ConsoleFrontEnd"/>
			<haxe_doc>* Used to register functions and objects or add new commands to the console window.</haxe_doc>
		</console>
		<log public="1" set="null" line="232" static="1">
			<c path="flixel.system.frontEnds.LogFrontEnd"/>
			<haxe_doc>* Used to add messages to the log window or enable trace() redirection.</haxe_doc>
		</log>
		<watch public="1" set="null" line="236" static="1">
			<c path="flixel.system.frontEnds.WatchFrontEnd"/>
			<haxe_doc>* Used to add or remove things to / from the watch window.</haxe_doc>
		</watch>
		<debugger public="1" set="null" line="241" static="1">
			<c path="flixel.system.frontEnds.DebuggerFrontEnd"/>
			<haxe_doc>* Used it to show / hide the debguger, change its layout, 
	 * activate debug drawing or change the key used to toggle it.</haxe_doc>
		</debugger>
		<vcr public="1" set="null" line="246" static="1">
			<c path="flixel.system.frontEnds.VCRFrontEnd"/>
			<haxe_doc>* Contains all the functions needed for recording and replaying.</haxe_doc>
		</vcr>
		<bitmap public="1" set="null" line="251" static="1">
			<c path="flixel.system.frontEnds.BitmapFrontEnd"/>
			<haxe_doc>* Contains things related to bimtaps, for example regarding the bitmap cache and the cache itself.</haxe_doc>
		</bitmap>
		<cameras public="1" set="null" line="255" static="1">
			<c path="flixel.system.frontEnds.CameraFrontEnd"/>
			<haxe_doc>* Contains things related to cameras, a list of all cameras and several effects like flash() or fade().</haxe_doc>
		</cameras>
		<plugins public="1" set="null" line="259" static="1">
			<c path="flixel.system.frontEnds.PluginFrontEnd"/>
			<haxe_doc>* Contains a list of all plugins and the functions required to add(), remove() them etc.</haxe_doc>
		</plugins>
		<sound public="1" set="null" line="265" static="1">
			<c path="flixel.system.frontEnds.SoundFrontEnd"/>
			<haxe_doc>* Contains a list of all sounds and other things to manage or play() sounds.</haxe_doc>
		</sound>
		<signals public="1" set="null" line="271" static="1">
			<c path="flixel.system.frontEnds.SignalFrontEnd"/>
			<haxe_doc>* Contains system-wide signals like gameResize or stateSwitch.</haxe_doc>
		</signals>
		<_scaleMode line="274" static="1">
			<c path="flixel.system.scaleModes.BaseScaleMode"/>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</_scaleMode>
		<resizeGame public="1" get="inline" set="null" line="279" static="1">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handy helper functions that takes care of all the things to resize the game.</haxe_doc>
		</resizeGame>
		<resetGame public="1" get="inline" set="null" line="287" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Like hitting the reset button a game console, this will re-launch the game as if it just started.</haxe_doc>
		</resetGame>
		<switchState public="1" get="inline" set="null" line="295" static="1">
			<f a="State">
				<c path="flixel.FlxState"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Switch from the current game state to the one specified here.</haxe_doc>
		</switchState>
		<resetState public="1" get="inline" set="null" line="303" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Request a reset of the current game state.</haxe_doc>
		</resetState>
		<overlap public="1" set="method" line="321" static="1">
			<f a="?ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback:?ProcessCallback" v="null:null:null:null">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<d/>
					<d/>
					<x path="Void"/>
				</f>
				<f a=":">
					<d/>
					<d/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Call this function to see if one FlxObject overlaps another.
	 * Can be called with one object and one group, or two groups, or two objects,
	 * whatever floats your boat! For maximum performance try bundling a lot of objects
	 * together using a FlxGroup (or even bundling groups together!).
	 * NOTE: does NOT take objects' scrollfactor into account, all overlaps are checked in world space.
	 * 
	 * @param	ObjectOrGroup1	The first object or group you want to check.
	 * @param	ObjectOrGroup2	The second object or group you want to check.  If it is the same as the first, flixel knows to just do a comparison within that group.
	 * @param	NotifyCallback	A function with two FlxObject parameters - e.g. myOverlapFunction(Object1:FlxObject,Object2:FlxObject) - that is called if those two objects overlap.
	 * @param	ProcessCallback	A function with two FlxObject parameters - e.g. myOverlapFunction(Object1:FlxObject,Object2:FlxObject) - that is called if those two objects overlap.  If a ProcessCallback is provided, then NotifyCallback will only be called if ProcessCallback returns true for those objects!
	 * @return	Whether any overlaps were detected.</haxe_doc>
		</overlap>
		<pixelPerfectOverlap public="1" get="inline" set="null" line="349" static="1">
			<f a="Sprite1:Sprite2:?AlphaTolerance:?Camera" v="::255:null">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* A Pixel Perfect Collision check between two FlxSprites. It will do a bounds check first, and if that passes it will run a 
	 * pixel perfect match on the intersecting area. Works with rotated and animated sprites. May be slow, so use it sparingly.
	 * 
	 * @param	Sprite1			The first FlxSprite to test against
	 * @param	Sprite2			The second FlxSprite to test again, sprite order is irrelevant
	 * @param	AlphaTolerance	The tolerance value above which alpha pixels are included. Default to 255 (must be fully opaque for collision).
	 * @param	Camera			If the collision is taking place in a camera other than FlxG.camera (the default/current) then pass it here
	 * @return	Whether the sprites collide</haxe_doc>
		</pixelPerfectOverlap>
		<collide public="1" get="inline" set="null" line="368" static="1">
			<f a="?ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback" v="null:null:null">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<d/>
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Call this function to see if one FlxObject collides with another.
	 * Can be called with one object and one group, or two groups, or two objects,
	 * whatever floats your boat! For maximum performance try bundling a lot of objects
	 * together using a FlxGroup (or even bundling groups together!).
	 * This function just calls FlxG.overlap and presets the ProcessCallback parameter to FlxObject.separate.
	 * To create your own collision logic, write your own ProcessCallback and use FlxG.overlap to set it up.
	 * NOTE: does NOT take objects' scrollfactor into account, all overlaps are checked in world space.
	 * 
	 * @param	ObjectOrGroup1	The first object or group you want to check.
	 * @param	ObjectOrGroup2	The second object or group you want to check.  If it is the same as the first, flixel knows to just do a comparison within that group.
	 * @param	NotifyCallback	A function with two FlxObject parameters - e.g. myOverlapFunction(Object1:FlxObject,Object2:FlxObject) - that is called if those two objects overlap.
	 * @return	Whether any objects were successfully collided/separated.</haxe_doc>
		</collide>
		<addChildBelowMouse public="1" params="T" set="method" line="382" static="1">
			<f a="Child:?IndexModifier" v=":0">
				<c path="addChildBelowMouse.T"/>
				<x path="Int"/>
				<c path="addChildBelowMouse.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Regular DisplayObjects are normally displayed over the flixel cursor and the flixel debugger if simply 
	 * added to stage. This function simplifies things by adding a DisplayObject directly below mouse level.
	 * 
	 * @param 	Child			The DisplayObject to add
	 * @param 	IndexModifier	Amount to add to the index - makes sure the index stays within bounds!
	 * @return	The added DisplayObject</haxe_doc>
		</addChildBelowMouse>
		<removeChild public="1" params="T" get="inline" set="null" line="399" static="1">
			<f a="Child">
				<c path="removeChild.T"/>
				<c path="removeChild.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Removes a child from the flixel display list, if it is part of it.
	 * 
	 * @param 	Child	The DisplayObject to add
	 * @return	The removed DisplayObject</haxe_doc>
		</removeChild>
		<openURL public="1" get="inline" set="null" line="415" static="1">
			<f a="URL:?Target" v=":'_blank'">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Opens a web page, by default a new tab or window. If the URL does not 
	 * already start with "http://" or "https://", it gets added automatically.
	 * 
	 * @param	URL		The address of the web page.
	 * @param	Target	"_blank", "_self", "_parent" or "_top"</haxe_doc>
		</openURL>
		<init set="method" line="427" static="1">
			<f a="Game:Width:Height:Zoom">
				<c path="flixel.FlxGame"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called by FlxGame to set up FlxG during FlxGame's constructor.</haxe_doc>
		</init>
		<reset set="method" line="472" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called whenever the game is reset, doesn't have to do quite as much work as the basic initialization stuff.</haxe_doc>
		</reset>
		<set_scaleMode set="method" line="491" static="1"><f a="ScaleMode">
	<c path="flixel.system.scaleModes.BaseScaleMode"/>
	<c path="flixel.system.scaleModes.BaseScaleMode"/>
</f></set_scaleMode>
		<set_mouse set="method" line="499" static="1"><f a="NewMouse">
	<c path="flixel.input.mouse.FlxMouse"/>
	<c path="flixel.input.mouse.FlxMouse"/>
</f></set_mouse>
		<get_updateFramerate get="inline" set="null" line="518" static="1"><f a=""><x path="Int"/></f></get_updateFramerate>
		<set_updateFramerate set="method" line="523" static="1"><f a="Framerate">
	<x path="Int"/>
	<x path="Int"/>
</f></set_updateFramerate>
		<set_drawFramerate set="method" line="541" static="1"><f a="Framerate">
	<x path="Int"/>
	<x path="Int"/>
</f></set_drawFramerate>
		<set_fullscreen set="method" line="565" static="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fullscreen>
		<get_stage get="inline" set="null" line="579" static="1"><f a=""><c path="flash.display.Stage"/></f></get_stage>
		<get_state get="inline" set="null" line="584" static="1"><f a=""><c path="flixel.FlxState"/></f></get_state>
		<haxe_doc>* Global helper class for audio, input, the camera system, the debugger and other global properties.</haxe_doc>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.FlxGame" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/FlxGame.hx">
		<extends path="flash.display.Sprite"/>
		<focusLostFramerate public="1">
			<x path="Int"/>
			<haxe_doc>* Framerate to use on focus lost. Default = 10.</haxe_doc>
		</focusLostFramerate>
		<soundTray public="1" set="null">
			<c path="flixel.system.ui.FlxSoundTray"/>
			<haxe_doc>* The sound tray display container (see createSoundTray()).</haxe_doc>
		</soundTray>
		<debugger public="1" set="null">
			<c path="flixel.system.debug.FlxDebugger"/>
			<haxe_doc>* The debugger overlay object.</haxe_doc>
		</debugger>
		<ticks public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Time in milliseconds that has passed (amount of "ticks" passed) since the game has started.</haxe_doc>
		</ticks>
		<_gameJustStarted>
			<x path="Bool"/>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* A flag for triggering the onGameStart "event".</haxe_doc>
		</_gameJustStarted>
		<_initialState>
			<x path="Class"><c path="flixel.FlxState"/></x>
			<haxe_doc>* Class type of the initial/first game state for the game, usually MenuState or something like that.</haxe_doc>
		</_initialState>
		<_state>
			<c path="flixel.FlxState"/>
			<haxe_doc>* Current game state.</haxe_doc>
		</_state>
		<_total>
			<x path="Int"/>
			<haxe_doc>* Total number of milliseconds elapsed since game start.</haxe_doc>
		</_total>
		<_accumulator>
			<x path="Int"/>
			<haxe_doc>* Total number of milliseconds elapsed since last update loop.
	 * Counts down as we step through the game loop.</haxe_doc>
		</_accumulator>
		<_elapsedMS>
			<x path="Int"/>
			<haxe_doc>* Milliseconds of time since last step.</haxe_doc>
		</_elapsedMS>
		<_stepMS>
			<x path="Int"/>
			<haxe_doc>* Milliseconds of time per step of the game loop. e.g. 60 fps = 16ms.</haxe_doc>
		</_stepMS>
		<_stepSeconds>
			<x path="Float"/>
			<haxe_doc>* Optimization so we don't have to divide step by 1000 to get its value in seconds every frame.</haxe_doc>
		</_stepSeconds>
		<_maxAccumulation>
			<x path="Int"/>
			<haxe_doc>* Max allowable accumulation (see _accumulator).
	 * Should always (and automatically) be set to roughly 2x the flash player framerate.</haxe_doc>
		</_maxAccumulation>
		<_lostFocus>
			<x path="Bool"/>
			<haxe_doc>* Whether the Flash player lost focus.</haxe_doc>
		</_lostFocus>
		<_onFocusFiredOnce>
			<x path="Bool"/>
			<haxe_doc>* Ugly workaround to ensure consistent behaviour between flash and cpp 
	 * (the focus event should not fire when the game starts up!)</haxe_doc>
		</_onFocusFiredOnce>
		<_focusLostScreen>
			<c path="flixel.system.ui.FlxFocusLostScreen"/>
			<haxe_doc>* The "focus lost" screen (see createFocusScreen()).</haxe_doc>
		</_focusLostScreen>
		<_inputContainer>
			<c path="flash.display.Sprite"/>
			<meta>
				<m n=":allow"><e>'???'</e></m>
				<m n=":allow"><e>'???'</e></m>
			</meta>
			<haxe_doc>* Mouse cursor.</haxe_doc>
		</_inputContainer>
		<_customSoundTray>
			<x path="Class"><c path="flixel.system.ui.FlxSoundTray"/></x>
			<haxe_doc>* Change this after calling super() in the FlxGame constructor to use a customized sound tray based on FlxSoundTray.</haxe_doc>
		</_customSoundTray>
		<_customFocusLostScreen>
			<x path="Class"><c path="flixel.system.ui.FlxFocusLostScreen"/></x>
			<haxe_doc>* Change this after calling super() in the FlxGame constructor to use a customized screen which will be show when the application lost focus.</haxe_doc>
		</_customFocusLostScreen>
		<_skipSplash>
			<x path="Bool"/>
			<haxe_doc>* Whether the splash screen should be skipped.</haxe_doc>
		</_skipSplash>
		<_startFullscreen>
			<x path="Bool"/>
			<haxe_doc>* Should we start Fullscreen or not? This is useful if you want to load Fullscreen settings from a FlxSave and set it when the game starts, instead of having it hard-set in your project XML.</haxe_doc>
		</_startFullscreen>
		<_requestedState>
			<c path="flixel.FlxState"/>
			<haxe_doc>* If a state change was requested, the new state object is stored here until we switch to it.</haxe_doc>
		</_requestedState>
		<_resetGame>
			<x path="Bool"/>
			<haxe_doc>* A flag for keeping track of whether a game reset was requested or not.</haxe_doc>
		</_resetGame>
		<create set="method" line="252">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to instantiate the guts of the flixel game object once we have a valid reference to the root.</haxe_doc>
		</create>
		<onFocus set="method" line="329"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onFocus>
		<onFocusLost set="method" line="374"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onFocusLost>
		<onResize set="method" line="411">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</onResize>
		<resizeGame set="method" line="427"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resizeGame>
		<onEnterFrame set="method" line="456">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handles the onEnterFrame call and figures out how many updates and draw calls to do.</haxe_doc>
		</onEnterFrame>
		<resetGame get="inline" set="null" line="519">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal method to create a new instance of iState and reset the game.
	 * This gets called when the game is created, as well as when a new state is requested.</haxe_doc>
		</resetGame>
		<switchState set="method" line="557">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* If there is a state change requested during the update loop,
	 * this function handles actual destroying the old state and related processes,
	 * and calls creates on the new state and plugs it into the game object.</haxe_doc>
		</switchState>
		<gameStart set="method" line="604"><f a=""><x path="Void"/></f></gameStart>
		<step set="method" line="616">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This is the main game update logic section.
	 * The onEnterFrame() handler is in charge of calling this
	 * the appropriate number of times each frame.
	 * This block handles state changes, replays, all that good stuff.</haxe_doc>
		</step>
		<update set="method" line="668">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called by step() and updates the actual game state.
	 * May be called multiple times per "frame" or draw call.</haxe_doc>
		</update>
		<updateInput set="method" line="727"><f a=""><x path="Void"/></f></updateInput>
		<draw set="method" line="789">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Goes through the game state and draws all the game objects and special effects.</haxe_doc>
		</draw>
		<new public="1" set="method" line="220">
			<f a="?GameSizeX:?GameSizeY:?InitialState:?Zoom:?UpdateFramerate:?DrawFramerate:?SkipSplash:?StartFullscreen" v="640:480:null:1:60:60:false:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Class"><c path="flixel.FlxState"/></x>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new game object.
	 * 
	 * @param	GameSizeX		The width of your game in game pixels, not necessarily final display pixels (see Zoom).
	 * @param	GameSizeY		The height of your game in game pixels, not necessarily final display pixels (see Zoom).
	 * @param	InitialState	The class name of the state you want to create and switch to first (e.g. MenuState).
	 * @param	Zoom			The default level of zoom for the game's cameras (e.g. 2 = all pixels are now drawn at 2x).  Default = 1.
	 * @param	UpdateFramerate	How frequently the game should update (default is 60 times per second).
	 * @param	DrawFramerate	Sets the actual display / draw framerate for the game (default is 60 times per second).
	 * @param	SkipSplash		Whether you want to skip the flixel splash screen in FLX_NO_DEBUG or not.
	 * @param	StartFullscreen	Whether to start the game in fullscreen mode (desktop targets only), false by default</haxe_doc>
		</new>
		<haxe_doc>* FlxGame is the heart of all flixel games, and contains a bunch of basic game loops and things.
 * It is a long and sloppy file that you shouldn't have to worry about too much!
 * It is basically only used to create your game object in the first place,
 * after that FlxG and FlxState have all the useful stuff you actually need.</haxe_doc>
		<meta>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
		</meta>
	</class>
	<class path="flixel.FlxObject" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/FlxObject.hx">
		<extends path="flixel.FlxBasic"/>
		<SEPARATE_BIAS public="1" line="28" static="1">
			<x path="Float"/>
			<haxe_doc>* This value dictates the maximum number of pixels two objects have to intersect before collision stops trying to separate them.
	 * Don't modify this unless your objects are passing through eachother.</haxe_doc>
		</SEPARATE_BIAS>
		<LEFT public="1" get="inline" set="null" line="32" static="1">
			<x path="Int"/>
			<haxe_doc>* Generic value for "left" Used by facing, allowCollisions, and touching.</haxe_doc>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" line="36" static="1">
			<x path="Int"/>
			<haxe_doc>* Generic value for "right" Used by facing, allowCollisions, and touching.</haxe_doc>
		</RIGHT>
		<UP public="1" get="inline" set="null" line="40" static="1">
			<x path="Int"/>
			<haxe_doc>* Generic value for "up" Used by facing, allowCollisions, and touching.</haxe_doc>
		</UP>
		<DOWN public="1" get="inline" set="null" line="44" static="1">
			<x path="Int"/>
			<haxe_doc>* Generic value for "down" Used by facing, allowCollisions, and touching.</haxe_doc>
		</DOWN>
		<NONE public="1" get="inline" set="null" line="48" static="1">
			<x path="Int"/>
			<haxe_doc>* Special-case constant meaning no collisions, used mainly by allowCollisions and touching.</haxe_doc>
		</NONE>
		<CEILING public="1" get="inline" set="null" line="52" static="1">
			<x path="Int"/>
			<haxe_doc>* Special-case constant meaning up, used mainly by allowCollisions and touching.</haxe_doc>
		</CEILING>
		<FLOOR public="1" get="inline" set="null" line="56" static="1">
			<x path="Int"/>
			<haxe_doc>* Special-case constant meaning down, used mainly by allowCollisions and touching.</haxe_doc>
		</FLOOR>
		<WALL public="1" get="inline" set="null" line="60" static="1">
			<x path="Int"/>
			<haxe_doc>* Special-case constant meaning only the left and right sides, used mainly by allowCollisions and touching.</haxe_doc>
		</WALL>
		<ANY public="1" get="inline" set="null" line="64" static="1">
			<x path="Int"/>
			<haxe_doc>* Special-case constant meaning any direction, used mainly by allowCollisions and touching.</haxe_doc>
		</ANY>
		<_firstSeparateFlxRect line="66" static="1"><c path="flixel.util.FlxRect"/></_firstSeparateFlxRect>
		<_secondSeparateFlxRect line="67" static="1"><c path="flixel.util.FlxRect"/></_secondSeparateFlxRect>
		<separate public="1" set="method" line="76" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* The main collision resolution function in flixel.
	 * 
	 * @param	Object1 	Any FlxObject.
	 * @param	Object2		Any other FlxObject.
	 * @return	Whether the objects in fact touched and were separated.</haxe_doc>
		</separate>
		<separateX public="1" set="method" line="90" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* The X-axis component of the object separation process.
	 * 
	 * @param	Object1 	Any FlxObject.
	 * @param	Object2		Any other FlxObject.
	 * @return	Whether the objects in fact touched and were separated along the X axis.</haxe_doc>
		</separateX>
		<separateY public="1" set="method" line="203" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* The Y-axis component of the object separation process.
	 * 
	 * @param	Object1 	Any FlxObject.
	 * @param	Object2		Any other FlxObject.
	 * @return	Whether the objects in fact touched and were separated along the Y axis.</haxe_doc>
		</separateY>
		<x public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* X position of the upper left corner of this object in world space.</haxe_doc>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Y position of the upper left corner of this object in world space.</haxe_doc>
		</y>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* The width of this object's hitbox. For sprites, use offset to control the hitbox position.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* The height of this object's hitbox. For sprites, use offset to control the hitbox position.</haxe_doc>
		</height>
		<camera public="1" get="accessor" set="accessor">
			<c path="flixel.FlxCamera"/>
			<haxe_doc>* Gets ot sets the first camera of this object.</haxe_doc>
		</camera>
		<cameras public="1" get="accessor" set="accessor">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<haxe_doc>* This determines on which FlxCameras this object will be drawn. If it is null / has not been
	 * set, it uses FlxCamera.defaultCameras, which is a reference to FlxG.cameras.list (all cameras) by default.</haxe_doc>
		</cameras>
		<pixelPerfectRender public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the coordinates should be rounded during draw(), true by default (recommended for pixel art). 
	 * Only affects tilesheet rendering and rendering using BitmapData.draw() in blitting.
	 * (copyPixels() only renders on whole pixels by nature). Causes draw() to be used if false, which is more expensive.</haxe_doc>
		</pixelPerfectRender>
		<angle public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Set the angle of a sprite to rotate it. WARNING: rotating sprites decreases rendering
	 * performance for this sprite by a factor of 10x (in Flash target)!</haxe_doc>
		</angle>
		<moves public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Set this to false if you want to skip the automatic motion/movement stuff (see updateMotion()).
	 * FlxObject and FlxSprite default to true. FlxText, FlxTileblock and FlxTilemap default to false.</haxe_doc>
		</moves>
		<immovable public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether an object will move/alter position after a collision.</haxe_doc>
		</immovable>
		<solid public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the object collides or not.  For more control over what directions the object will collide from, 
	 * use collision constants (like LEFT, FLOOR, etc) to set the value of allowCollisions directly.</haxe_doc>
		</solid>
		<scrollFactor public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Controls how much this object is affected by camera scrolling. 0 = no movement (e.g. a background layer), 
	 * 1 = same movement speed as the foreground. Default value is (1,1), except for UI elements like FlxButton where it's (0,0).</haxe_doc>
		</scrollFactor>
		<velocity public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* The basic speed of this object (in pixels per second).</haxe_doc>
		</velocity>
		<acceleration public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* How fast the speed of this object is changing (in pixels per second).
	 * Useful for smooth movement and gravity.</haxe_doc>
		</acceleration>
		<drag public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* This isn't drag exactly, more like deceleration that is only applied
	 * when acceleration is not affecting the sprite.</haxe_doc>
		</drag>
		<maxVelocity public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* If you are using acceleration, you can use maxVelocity with it
	 * to cap the speed automatically (very useful!).</haxe_doc>
		</maxVelocity>
		<last public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Important variable for collision processing.
	 * By default this value is set automatically during preUpdate().</haxe_doc>
		</last>
		<mass public="1">
			<x path="Float"/>
			<haxe_doc>* The virtual mass of the object. Default value is 1. Currently only used with elasticity 
	 * during collision resolution. Change at your own risk; effects seem crazy unpredictable so far!</haxe_doc>
		</mass>
		<elasticity public="1">
			<x path="Float"/>
			<haxe_doc>* The bounciness of this object. Only affects collisions. Default value is 0, or "not bouncy at all."</haxe_doc>
		</elasticity>
		<angularVelocity public="1">
			<x path="Float"/>
			<haxe_doc>* This is how fast you want this sprite to spin (in degrees per second).</haxe_doc>
		</angularVelocity>
		<angularAcceleration public="1">
			<x path="Float"/>
			<haxe_doc>* How fast the spin speed should change (in degrees per second).</haxe_doc>
		</angularAcceleration>
		<angularDrag public="1">
			<x path="Float"/>
			<haxe_doc>* Like drag but for spinning.</haxe_doc>
		</angularDrag>
		<maxAngular public="1">
			<x path="Float"/>
			<haxe_doc>* Use in conjunction with angularAcceleration for fluid spin speed control.</haxe_doc>
		</maxAngular>
		<health public="1">
			<x path="Float"/>
			<haxe_doc>* Handy for storing health percentage or armor points or whatever.</haxe_doc>
		</health>
		<touching public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts. Use bitwise operators to check the values 
	 * stored here, or use isTouching(), justTouched(), etc. You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</touching>
		<wasTouching public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts from the previous game loop step. Use bitwise operators to check the values 
	 * stored here, or use isTouching(), justTouched(), etc. You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</wasTouching>
		<allowCollisions public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating collision directions. Use bitwise operators to check the values stored here.
	 * Useful for things like one-way platforms (e.g. allowCollisions = UP;). The accessor "solid" just flips this variable between NONE and ANY.</haxe_doc>
		</allowCollisions>
		<collisonXDrag public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether this sprite is dragged along with the horizontal movement of objects it collides with 
	 * (makes sense for horizontally-moving platforms in platformers for example).</haxe_doc>
		</collisonXDrag>
		<debugBoundingBoxColor public="1">
			<t path="Null"><x path="Int"/></t>
			<haxe_doc>* Overriding this will force a specific color to be used for debug rect.</haxe_doc>
		</debugBoundingBoxColor>
		<ignoreDrawDebug public="1">
			<x path="Bool"/>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when FlxG.debugger.drawDebug is true.</haxe_doc>
		</ignoreDrawDebug>
		<_point>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Internal private static variables, for performance reasons.</haxe_doc>
		</_point>
		<_cameras><c path="Array"><c path="flixel.FlxCamera"/></c></_cameras>
		<initVars set="method" line="489">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for initialization of some object's variables</haxe_doc>
		</initVars>
		<initMotionVars get="inline" set="null" line="502">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for initialization of some variables that are used in updateMotion()</haxe_doc>
		</initMotionVars>
		<destroy public="1" set="method" line="514" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* WARNING: This will remove this object entirely. Use kill() if you want to disable it temporarily only and reset() it later to revive it.
	 * Override this function to null out variables manually or call destroy() on class members if necessary. Don't forget to call super.destroy()!</haxe_doc>
		</destroy>
		<update public="1" set="method" line="532" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this function to update your class's position and appearance.
	 * This is where most of your game rules and behavioral code will go.</haxe_doc>
		</update>
		<updateMotion get="inline" set="null" line="555">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for updating the position and speed of this object. Useful for cases when you need to update this but are buried down in too many supers.
	 * Does a slightly fancier-than-normal integration to help with higher fidelity framerate-independenct motion.</haxe_doc>
		</updateMotion>
		<draw public="1" set="method" line="580" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Rarely called, and in this case just increments the visible objects count and calls drawDebug() if necessary.</haxe_doc>
		</draw>
		<overlaps public="1" set="method" line="598">
			<f a="ObjectOrGroup:?InScreenSpace:?Camera" v=":false:null">
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if some FlxObject overlaps this FlxObject or FlxGroup. If the group has a LOT of things in it, 
	 * it might be faster to use FlxG.overlaps(). WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * 
	 * @param	ObjectOrGroup	The object or group being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.  Default is false, or "only compare in world space."
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.</haxe_doc>
		</overlaps>
		<overlapsCallback get="inline" set="null" line="630"><f a="ObjectOrGroup:X:Y:InScreenSpace:Camera">
	<c path="flixel.FlxBasic"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></overlapsCallback>
		<overlapsAt public="1" set="method" line="646">
			<f a="X:Y:ObjectOrGroup:?InScreenSpace:?Camera" v=":::false:null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if this FlxObject were located at the given position, would it overlap the FlxObject or FlxGroup?
	 * This is distinct from overlapsPoint(), which just checks that point, rather than taking the object's size into account. WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * 
	 * @param	X				The X position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	Y				The Y position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	ObjectOrGroup	The object or group being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.  Default is false, or "only compare in world space."
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.</haxe_doc>
		</overlapsAt>
		<overlapsAtCallback get="inline" set="null" line="681"><f a="ObjectOrGroup:X:Y:InScreenSpace:Camera">
	<c path="flixel.FlxBasic"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></overlapsAtCallback>
		<overlapsPoint public="1" set="method" line="694">
			<f a="point:?InScreenSpace:?Camera" v=":false:null">
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if a point in 2D world space overlaps this FlxObject object.
	 * 
	 * @param	Point			The point in world space you want to check.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.</haxe_doc>
		</overlapsPoint>
		<inWorldBounds public="1" get="inline" set="null" line="717">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check and see if this object is currently within the Worldbounds - useful for killing objects that get too far away.
	 * 
	 * @return	Whether the object is within the Worldbounds or not.</haxe_doc>
		</inWorldBounds>
		<getScreenXY public="1" set="method" line="729">
			<f a="?point:?Camera" v="null:null">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.FlxCamera"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Call this function to figure out the on-screen position of the object.
	 * 
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @param	Point		Takes a FlxPoint object and assigns the post-scrolled X and Y values of this object to it.
	 * @return	The Point you passed in, or a new Point if you didn't pass one, containing the screen X and Y position of this object.</haxe_doc>
		</getScreenXY>
		<getMidpoint public="1" set="method" line="748">
			<f a="?point" v="null">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Retrieve the midpoint of this object in world coordinates.
	 * 
	 * @param	point	Allows you to pass in an existing FlxPoint object if you're so inclined.  Otherwise a new one is created.
	 * @return	A FlxPoint object containing the midpoint of this object in world coordinates.</haxe_doc>
		</getMidpoint>
		<reset public="1" set="method" line="764">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handy function for reviving game objects.
	 * Resets their existence flags and position.
	 * 
	 * @param	X	The new X position of this object.
	 * @param	Y	The new Y position of this object.</haxe_doc>
		</reset>
		<isOnScreen public="1" set="method" line="780">
			<f a="?Camera" v="null">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check and see if this object is currently on screen.
	 * 
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether the object is on screen or not.</haxe_doc>
		</isOnScreen>
		<isTouching public="1" get="inline" set="null" line="796">
			<f a="Direction">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Handy function for checking if this object is touching a particular surface.
	 * 
	 * @param	Direction	Any of the collision flags (e.g. LEFT, FLOOR, etc).
	 * @return	Whether the object is touching an object in (any of) the specified direction(s) this frame.</haxe_doc>
		</isTouching>
		<justTouched public="1" get="inline" set="null" line="807">
			<f a="Direction">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Handy function for checking if this object is just landed on a particular surface.
	 * 
	 * @param	Direction	Any of the collision flags (e.g. LEFT, FLOOR, etc).
	 * @return	Whether the object just landed on (any of) the specified surface(s) this frame.</haxe_doc>
		</justTouched>
		<hurt public="1" set="method" line="818">
			<f a="Damage">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Reduces the "health" variable of this sprite by the amount specified in Damage.
	 * Calls kill() if health drops to or below zero.
	 * 
	 * @param	Damage		How much health to take away (use a negative number to give a health bonus).</haxe_doc>
		</hurt>
		<setPosition public="1" set="method" line="834">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function to set the coordinates of this object.
	 * Handy since it only requires one line of code.
	 * 
	 * @param	X	The new x position
	 * @param	Y	The new y position</haxe_doc>
		</setPosition>
		<setSize public="1" set="method" line="846">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shortcut for setting both width and Height.
	 * 
	 * @param	Width	The new sprite width.
	 * @param	Height	The new sprite height.</haxe_doc>
		</setSize>
		<drawDebug public="1" set="method" line="853"><f a=""><x path="Void"/></f></drawDebug>
		<drawDebugOnCamera public="1" set="method" line="870">
			<f a="Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this function to draw custom "debug mode" graphics to the
	 * specified camera while the debugger's drawDebug mode is toggled on.
	 * 
	 * @param	Camera	Which camera to draw the debug visuals to.</haxe_doc>
		</drawDebugOnCamera>
		<toString public="1" set="method" line="942" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name.  Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<set_x set="method" line="953"><f a="NewX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="958"><f a="NewY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_width set="method" line="963"><f a="Width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="981"><f a="Height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<get_width set="method" line="999"><f a=""><x path="Float"/></f></get_width>
		<get_height set="method" line="1004"><f a=""><x path="Float"/></f></get_height>
		<get_solid get="inline" set="null" line="1009"><f a=""><x path="Bool"/></f></get_solid>
		<set_solid set="method" line="1014"><f a="Solid">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_solid>
		<set_angle set="method" line="1027"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<set_moves set="method" line="1032"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_moves>
		<set_immovable set="method" line="1037"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_immovable>
		<get_camera set="method" line="1042"><f a=""><c path="flixel.FlxCamera"/></f></get_camera>
		<set_camera set="method" line="1047"><f a="Value">
	<c path="flixel.FlxCamera"/>
	<c path="flixel.FlxCamera"/>
</f></set_camera>
		<get_cameras set="method" line="1056"><f a=""><c path="Array"><c path="flixel.FlxCamera"/></c></f></get_cameras>
		<set_cameras set="method" line="1061"><f a="Value">
	<c path="Array"><c path="flixel.FlxCamera"/></c>
	<c path="Array"><c path="flixel.FlxCamera"/></c>
</f></set_cameras>
		<set_pixelPerfectRender set="method" line="1066"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pixelPerfectRender>
		<new public="1" set="method" line="474">
			<f a="?X:?Y:?Width:?Height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.</haxe_doc>
		</new>
		<haxe_doc>* This is the base class for most of the display objects (FlxSprite, FlxText, etc).
 * It includes some basic attributes about game objects, basic state information, sizes, scrolling, and basic physics and motion.</haxe_doc>
	</class>
	<class path="flixel._FlxSprite.GraphicDefault" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/FlxSprite.hx" private="1" module="flixel.FlxSprite">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/logo/default.png"</e></m>
		</meta>
	</class>
	<class path="flixel.FlxSprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/FlxSprite.hx">
		<extends path="flixel.FlxObject"/>
		<animation public="1">
			<c path="flixel.animation.FlxAnimationController"/>
			<haxe_doc>* Class that handles adding and playing animations on this sprite.</haxe_doc>
		</animation>
		<framePixels public="1">
			<c path="flash.display.BitmapData"/>
			<haxe_doc>* The actual Flash BitmapData object representing the current display state of the sprite.</haxe_doc>
		</framePixels>
		<antialiasing public="1">
			<x path="Bool"/>
			<haxe_doc>* Controls whether the object is smoothed when rotated, affects performance.</haxe_doc>
		</antialiasing>
		<dirty public="1">
			<x path="Bool"/>
			<haxe_doc>* Set this flag to true to force the sprite to update during the draw() call.
	 * NOTE: Rarely if ever necessary, most sprite operations will flip this flag automatically.</haxe_doc>
		</dirty>
		<isColored public="1"><x path="Bool"/></isColored>
		<pixels public="1" get="accessor" set="accessor">
			<c path="flash.display.BitmapData"/>
			<haxe_doc>* Set pixels to any BitmapData object.
	 * Automatically adjust graphic size and render helpers.</haxe_doc>
		</pixels>
		<frame public="1" set="accessor">
			<c path="flixel.system.layer.frames.FlxFrame"/>
			<haxe_doc>* Link to current FlxFrame from loaded atlas</haxe_doc>
		</frame>
		<frameWidth public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The width of the actual graphic or image being displayed (not necessarily the game object/bounding box).</haxe_doc>
		</frameWidth>
		<frameHeight public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The height of the actual graphic or image being displayed (not necessarily the game object/bounding box).</haxe_doc>
		</frameHeight>
		<frames public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The total number of frames in this image.  WARNING: assumes each row in the sprite sheet is full!</haxe_doc>
		</frames>
		<region public="1" set="null">
			<c path="flixel.system.layer.Region"/>
			<haxe_doc>* Rendering variables.</haxe_doc>
		</region>
		<framesData public="1" set="null"><c path="flixel.system.layer.frames.FlxSpriteFrames"/></framesData>
		<cachedGraphics public="1" set="accessor"><c path="flixel.util.loaders.CachedGraphics"/></cachedGraphics>
		<bakedRotationAngle public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The minimum angle (out of 360°) for which a new baked rotation exists. Example: 90 means there 
	 * are 4 baked rotations in the spritesheet. 0 if this sprite does not have any baked rotations.</haxe_doc>
		</bakedRotationAngle>
		<alpha public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Set alpha to a number between 0 and 1 to change the opacity of the sprite.</haxe_doc>
		</alpha>
		<facing public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Set facing using FlxObject.LEFT, RIGHT, UP, and DOWN to take advantage 
	 * of flipped sprites and/or just track player orientation more easily.</haxe_doc>
		</facing>
		<flipX public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether this sprite is flipped on the X axis</haxe_doc>
		</flipX>
		<flipY public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether this sprite is flipped on the Y axis</haxe_doc>
		</flipY>
		<origin public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* WARNING: The origin of the sprite will default to its center. If you change this, 
	 * the visuals and the collisions will likely be pretty out-of-sync if you do any rotation.</haxe_doc>
		</origin>
		<offset public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Controls the position of the sprite's hitbox. Likely needs to be adjusted after
	 * changing a sprite's width, height or scale.</haxe_doc>
		</offset>
		<scale public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Change the size of your sprite's graphic. NOTE: The hitbox is not automatically adjusted, use updateHitbox for that
	 * (or setGraphicSize(). WARNING: When using blitting (flash), scaling sprites decreases rendering performance by a factor of about x10!</haxe_doc>
		</scale>
		<blend public="1" set="accessor">
			<e path="flash.display.BlendMode"/>
			<haxe_doc>* Blending modes, just like Photoshop or whatever, e.g. "multiply", "screen", etc.</haxe_doc>
		</blend>
		<color public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Tints the whole sprite to a color (0xRRGGBB format) - similar to OpenGL vertex colors. You can use
	 * 0xAARRGGBB colors, but the alpha value will simply be ignored. To change the opacity use alpha.</haxe_doc>
		</color>
		<colorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></colorTransform>
		<useColorTransform public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether or not to use a colorTransform set via setColorTransform.</haxe_doc>
		</useColorTransform>
		<_red><x path="Float"/></_red>
		<_green><x path="Float"/></_green>
		<_blue><x path="Float"/></_blue>
		<_facingHorizontalMult><x path="Int"/></_facingHorizontalMult>
		<_facingVerticalMult><x path="Int"/></_facingVerticalMult>
		<_blendInt><x path="Int"/></_blendInt>
		<_flashPoint>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashPoint>
		<_flashRect>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashRect>
		<_flashRect2>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashRect2>
		<_flashPointZero>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating. Always contains (0,0).</haxe_doc>
		</_flashPointZero>
		<_matrix>
			<c path="flash.geom.Matrix"/>
			<haxe_doc>* Internal, helps with animation, caching and drawing.</haxe_doc>
		</_matrix>
		<_halfWidth>
			<x path="Float"/>
			<haxe_doc>* These vars are being used for rendering in some of FlxSprite subclasses (FlxTileblock, FlxBar, 
	 * FlxBitmapFont and FlxBitmapTextField) and for checks if the sprite is in camera's view.</haxe_doc>
		</_halfWidth>
		<_halfHeight><x path="Float"/></_halfHeight>
		<_sinAngle><x path="Float"/></_sinAngle>
		<_cosAngle><x path="Float"/></_cosAngle>
		<_angleChanged><x path="Bool"/></_angleChanged>
		<_facingFlip>
			<x path="Map">
				<x path="Int"/>
				<a>
					<y><x path="Bool"/></y>
					<x><x path="Bool"/></x>
				</a>
			</x>
			<haxe_doc>* Maps FlxObject direction constants to axis flips</haxe_doc>
		</_facingFlip>
		<initVars set="method" line="202" override="1"><f a=""><x path="Void"/></f></initVars>
		<destroy public="1" set="method" line="222" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* WARNING: This will remove this object entirely. Use kill() if you want to disable it temporarily only and reset() it later to revive it.
	 * Override this function to null out variables manually or call destroy() on class members if necessary. Don't forget to call super.destroy()!</haxe_doc>
		</destroy>
		<clone public="1" set="method" line="248"><f a="?NewSprite" v="null">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.FlxSprite"/>
</f></clone>
		<loadGraphicFromSprite public="1" set="method" line="265">
			<f a="Sprite">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Load graphic from another FlxSprite and copy its tileSheet data. 
	 * This method can useful for non-flash targets (and is used by the FlxTrail effect).
	 * 
	 * @param	Sprite	The FlxSprite from which you want to load graphic data
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadGraphicFromSprite>
		<loadGraphic public="1" set="method" line="303">
			<f a="Graphic:?Animated:?Width:?Height:?Unique:?Key" v=":false:0:0:false:null">
				<d/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Load an image from an embedded graphic file.
	 * 
	 * @param	Graphic		The image you want to use.
	 * @param	Animated	Whether the Graphic parameter is a single sprite or a row of sprites.
	 * @param	Width		Optional, specify the width of your sprite (helps FlxSprite figure out what to do with non-square sprites or sprite sheets).
	 * @param	Height		Optional, specify the height of your sprite (helps FlxSprite figure out what to do with non-square sprites or sprite sheets).
	 * @param	Unique		Optional, whether the graphic should be a unique instance in the graphics cache.  Default is false.
	 * @param	Key			Optional, set this parameter if you're loading BitmapData.
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadGraphic>
		<loadRotatedGraphic public="1" set="method" line="364">
			<f a="Graphic:?Rotations:?Frame:?AntiAliasing:?AutoBuffer:?Key" v=":16:-1:false:false:null">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Create a pre-rotated sprite sheet from a simple sprite.
	 * This can make a huge difference in graphical performance!
	 * 
	 * @param	Graphic			The image you want to rotate and stamp.
	 * @param	Rotations		The number of rotation frames the final sprite should have.  For small sprites this can be quite a large number (360 even) without any problems.
	 * @param	Frame			If the Graphic has a single row of square animation frames on it, you can specify which of the frames you want to use here.  Default is -1, or "use whole graphic."
	 * @param	AntiAliasing	Whether to use high quality rotations when creating the graphic.  Default is false.
	 * @param	AutoBuffer		Whether to automatically increase the image size to accomodate rotated corners.  Default is false.  Will create frames that are 150% larger on each axis than the original frame or graphic.
	 * @param	Key			Optional, set this parameter if you're loading BitmapData.
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadRotatedGraphic>
		<loadGraphicFromTexture public="1" set="method" line="512">
			<f a="Data:?Unique:?FrameName" v=":false:null">
				<d/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Loads TexturePacker atlas.
	 * 
	 * @param	Data		Atlas data holding links to json-data and atlas image
	 * @param	Unique		Optional, whether the graphic should be a unique instance in the graphics cache.  Default is false.
	 * @param	FrameName	Default frame to show. If null then will be used first available frame.
	 * @return This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadGraphicFromTexture>
		<loadRotatedGraphicFromTexture public="1" set="method" line="563">
			<f a="Data:Image:?Rotations:?AntiAliasing:?AutoBuffer" v="::16:false:false">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Creates a pre-rotated sprite sheet from provided image in atlas.
	 * This can make a huge difference in graphical performance on flash target!
	 * 
	 * @param	Data			Atlas data holding links to json-data and atlas image
	 * @param	Image			The image from atlas you want to rotate and stamp.
	 * @param	Rotations		The number of rotation frames the final sprite should have.  For small sprites this can be quite a large number (360 even) without any problems.
	 * @param	AntiAliasing	Whether to use high quality rotations when creating the graphic.  Default is false.
	 * @param	AutoBuffer		Whether to automatically increase the image size to accomodate rotated corners.
	 * @return This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadRotatedGraphicFromTexture>
		<makeGraphic public="1" set="method" line="593">
			<f a="Width:Height:?Color:?Unique:?Key" v="::-1:false:null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This function creates a flat colored square image dynamically.
	 * @param	Width		The width of the sprite you want to generate.
	 * @param	Height		The height of the sprite you want to generate.
	 * @param	Color		Specifies the color of the generated block (ARGB format).
	 * @param	Unique		Whether the graphic should be a unique instance in the graphics cache.  Default is false.
	 * @param	Key			Optional parameter - specify a string key to identify this graphic in the cache.  Trumps Unique flag.
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</makeGraphic>
		<resetSize public="1" get="inline" set="null" line="611">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets _flashRect variable used for frame bitmapData calculation</haxe_doc>
		</resetSize>
		<resetFrameSize public="1" get="inline" set="null" line="622">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets frame size to frame dimensions</haxe_doc>
		</resetFrameSize>
		<resetSizeFromFrame public="1" get="inline" set="null" line="632">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets sprite's size back to frame size</haxe_doc>
		</resetSizeFromFrame>
		<setGraphicSize public="1" set="method" line="645">
			<f a="?Width:?Height" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Helper function to set the graphic's dimensions by using scale, allowing you to keep the current aspect ratio
	 * should one of the Integers be <= 0. It might make sense to call updateHitbox() afterwards!
	 * 
	 * @param   Width    How wide the graphic should be. If <= 0, and a Height is set, the aspect ratio will be kept.
	 * @param   Height   How high the graphic should be. If <= 0, and a Width is set, the aspect ratio will be kept.]]></haxe_doc>
		</setGraphicSize>
		<updateHitbox public="1" set="method" line="667">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the sprite's hitbox (width, height, offset) according to the current scale. 
	 * Also calls setOriginToCenter(). Called by setGraphicSize().</haxe_doc>
		</updateHitbox>
		<resetHelpers set="method" line="681">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets some important variables for sprite optimization and rendering.</haxe_doc>
		</resetHelpers>
		<update public="1" set="method" line="706" override="1"><f a=""><x path="Void"/></f></update>
		<draw public="1" set="method" line="715" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by game loop, updates then blits or renders current frame of animation to the screen</haxe_doc>
		</draw>
		<stamp public="1" set="method" line="921">
			<f a="Brush:?X:?Y" v=":0:0">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function draws or stamps one FlxSprite onto another.
	 * This function is NOT intended to replace draw()!
	 * @param	Brush		The image you want to use as a brush or stamp or pen or whatever.
	 * @param	X			The X coordinate of the brush's top left corner on this sprite.
	 * @param	Y			They Y coordinate of the brush's top left corner on this sprite.</haxe_doc>
		</stamp>
		<drawFrame public="1" get="inline" set="null" line="967">
			<f a="?Force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Request (or force) that the sprite update the frame before rendering.
	 * Useful if you are doing procedural generation or other weirdness!
	 * @param	Force	Force the frame to redraw, even if its not flagged as necessary.</haxe_doc>
		</drawFrame>
		<centerOffsets public="1" set="method" line="983">
			<f a="?AdjustPosition" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function that adjusts the offset automatically to center the bounding box within the graphic.
	 * @param	AdjustPosition		Adjusts the actual X and Y position just once to match the offset change. Default is false.</haxe_doc>
		</centerOffsets>
		<centerOrigin public="1" get="inline" set="null" line="998">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets the sprite's origin to its center - useful after adjusting 
	 * scale to make sure rotations work as expected.</haxe_doc>
		</centerOrigin>
		<replaceColor public="1" set="method" line="1010">
			<f a="Color:NewColor:?FetchPositions" v="::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			</f>
			<haxe_doc>* Replaces all pixels with specified Color with NewColor pixels
	 * @param	Color				Color to replace
	 * @param	NewColor			New color
	 * @param	FetchPositions		Whether we need to store positions of pixels which colors were replaced
	 * @return	Array replaced pixels positions</haxe_doc>
		</replaceColor>
		<setColorTransform public="1" set="method" line="1058">
			<f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset" v="1.0f:1.0f:1.0f:1.0f:0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set sprite's color transformation with control over color offsets.
	 * 
	 * @param	redMultiplier		The value for the red multiplier, in the range from 0 to 1. 
	 * @param	greenMultiplier		The value for the green multiplier, in the range from 0 to 1. 
	 * @param	blueMultiplier		The value for the blue multiplier, in the range from 0 to 1. 
	 * @param	alphaMultiplier		The value for the alpha transparency multiplier, in the range from 0 to 1. 
	 * @param	redOffset			The offset value for the red color channel, in the range from -255 to 255.
	 * @param	greenOffset			The offset value for the green color channel, in the range from -255 to 255. 
	 * @param	blueOffset			The offset for the blue color channel value, in the range from -255 to 255. 
	 * @param	alphaOffset			The offset for alpha transparency channel value, in the range from -255 to 255.</haxe_doc>
		</setColorTransform>
		<updateColorTransform set="method" line="1083"><f a=""><x path="Void"/></f></updateColorTransform>
		<pixelsOverlapPoint public="1" set="method" line="1124">
			<f a="point:?Mask:?Camera" v=":255:null">
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if a point in 2D world space overlaps this FlxSprite object's current displayed pixels.
	 * This check is ALWAYS made in screen space, and always takes scroll factors into account.
	 * 
	 * @param	Point		The point in world space you want to check.
	 * @param	Mask		Used in the pixel hit test to determine what counts as solid.
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.</haxe_doc>
		</pixelsOverlapPoint>
		<calcFrame set="method" line="1157">
			<f a="?RunOnCpp" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function to update the current animation frame.
	 * 
	 * @param	RunOnCpp	Whether the frame should also be recalculated if we're on a non-flash target</haxe_doc>
		</calcFrame>
		<updateFrameData public="1" set="method" line="1196">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this method for creating tileSheet for FlxSprite. Must be called after makeGraphic(), loadGraphic or loadRotatedGraphic().
	 * If you forget to call it then you will not see this FlxSprite on c++ target</haxe_doc>
		</updateFrameData>
		<getFlxFrameBitmapData public="1" get="inline" set="null" line="1220">
			<f a=""><c path="flash.display.BitmapData"/></f>
			<haxe_doc>* Retrieves BitmapData of current FlxFrame</haxe_doc>
		</getFlxFrameBitmapData>
		<getGraphicMidpoint public="1" set="method" line="1252">
			<f a="?point" v="null">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Retrieve the midpoint of this sprite's graphic in world coordinates.
	 * 
	 * @param	point	Allows you to pass in an existing FlxPoint object if you're so inclined. Otherwise a new one is created.
	 * @return	A FlxPoint object containing the midpoint of this sprite's graphic in world coordinates.</haxe_doc>
		</getGraphicMidpoint>
		<resetFrameBitmapDatas public="1" get="inline" set="null" line="1265">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Helper function for reseting precalculated FlxFrame bitmapdatas.
	 * Useful when _pixels bitmapdata changes (e.g. after stamp(), FlxSpriteUtil.drawLine() and other similar method calls).</haxe_doc>
		</resetFrameBitmapDatas>
		<isOnScreen public="1" set="method" line="1277" override="1">
			<f a="?Camera" v="null">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check and see if this object is currently on screen. Differs from FlxObject's implementation
	 * in that it takes the actual graphic into account, not just the hitbox or bounding box or whatever.
	 * 
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether the object is on screen or not.</haxe_doc>
		</isOnScreen>
		<isSimpleRender public="1" set="method" line="1350">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Checks if the Sprite is being rendered in "simple mode" (via copyPixels). True for flash when no angle, bakedRotations, 
	 * scaling or blend modes are used. This enables the sprite to be rendered much faster if true.</haxe_doc>
		</isSimpleRender>
		<setFacingFlip public="1" get="inline" set="null" line="1369">
			<f a="Direction:FlipX:FlipY">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set how a sprite flips when facing in a particular direction.
	 * 
	 * @param	Direction Use constants from FlxObject: LEFT, RIGHT, UP, and DOWN.
	 * 			These may be combined with the bitwise OR operator.
	 * 			E.g. To make a sprite flip horizontally when it is facing both UP and LEFT,
	 * 			use setFacingFlip(FlxObject.LEFT | FlxObject.UP, true, false);
	 * @param	FlipX Whether to flip the sprite on the X axis
	 * @param	FlipY Whether to flip the sprite on the Y axis</haxe_doc>
		</setFacingFlip>
		<get_pixels set="method" line="1377">
			<f a=""><c path="flash.display.BitmapData"/></f>
			<haxe_doc>* PROPERTIES</haxe_doc>
		</get_pixels>
		<set_pixels set="method" line="1382"><f a="Pixels">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
</f></set_pixels>
		<set_frame set="method" line="1423"><f a="Value">
	<c path="flixel.system.layer.frames.FlxFrame"/>
	<c path="flixel.system.layer.frames.FlxFrame"/>
</f></set_frame>
		<set_facing set="method" line="1439"><f a="Direction">
	<x path="Int"/>
	<x path="Int"/>
</f></set_facing>
		<set_alpha set="method" line="1451"><f a="Alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_color set="method" line="1470"><f a="Color">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<set_angle set="method" line="1490" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<set_blend set="method" line="1496"><f a="Value">
	<e path="flash.display.BlendMode"/>
	<e path="flash.display.BlendMode"/>
</f></set_blend>
		<set_cachedGraphics set="method" line="1528">
			<f a="Value">
				<c path="flixel.util.loaders.CachedGraphics"/>
				<c path="flixel.util.loaders.CachedGraphics"/>
			</f>
			<haxe_doc>* Internal function for setting cachedGraphics property for this object. 
	 * It changes cachedGraphics' useCount also for better memory tracking.</haxe_doc>
		</set_cachedGraphics>
		<set_flipX set="method" line="1545"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipX>
		<set_flipY set="method" line="1557"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipY>
		<new public="1" set="method" line="192">
			<f a="?X:?Y:?SimpleGraphic" v="0:0:null">
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a FlxSprite at a specified position with a specified one-frame graphic. 
	 * If none is provided, a 16x16 image of the HaxeFlixel logo is used.
	 * 
	 * @param	X				The initial X position of the sprite.
	 * @param	Y				The initial Y position of the sprite.
	 * @param	SimpleGraphic	The graphic you want to display (OPTIONAL - for simple stuff only, do NOT use for animated images!).</haxe_doc>
		</new>
		<haxe_doc>* The main "game object" class, the sprite is a FlxObject
 * with a bunch of graphics options and abilities, like animation and stamping.</haxe_doc>
	</class>
	<class path="flixel.group.FlxGroup" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/group/FlxGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="flixel.FlxBasic"/></extends>
		<overlaps get="inline" set="null" line="21" static="1">
			<f a="Callback:Group:X:Y:InScreenSpace:Camera">
				<f a="::::">
					<c path="flixel.FlxBasic"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Bool"/>
					<c path="flixel.FlxCamera"/>
					<x path="Bool"/>
				</f>
				<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxBasic"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":allow"><e>'???'</e></m>
				<m n=":allow"><e>'???'</e></m>
			</meta>
			<haxe_doc>* Helper function for overlap functions in FlxObject and FlxTilemap.</haxe_doc>
		</overlaps>
		<resolveGroup get="inline" set="null" line="48" static="1">
			<f a="ObjectOrGroup">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxBasic"/></c>
			</f>
			<meta>
				<m n=":allow"><e>'???'</e></m>
				<m n=":allow"><e>'???'</e></m>
				<m n=":allow"><e>'???'</e></m>
			</meta>
		</resolveGroup>
		<new public="1" set="method" line="14"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* This is an organizational class that can update and render a bunch of FlxBasics.
 * NOTE: Although FlxGroup extends FlxBasic, it will not automatically
 * add itself to the global collisions quad tree, it will only add its members.</haxe_doc>
	</class>
	<class path="flixel.FlxState" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/FlxState.hx">
		<extends path="flixel.group.FlxGroup"/>
		<persistentUpdate public="1">
			<x path="Bool"/>
			<haxe_doc>* Determines whether or not this state is updated even when it is not the active state. For example, if you have your game state first, and then you push a menu state on top of it,
	 * if this is set to true, the game state would continue to update in the background. By default this is false, so background states will be "paused" when they are not active.</haxe_doc>
		</persistentUpdate>
		<persistentDraw public="1">
			<x path="Bool"/>
			<haxe_doc>* Determines whether or not this state is updated even when it is not the active state. For example, if you have your game state first, and then you push a menu state on top of it, if this is set to true, the game state would continue to be drawn behind the pause state.
	 * By default this is true, so background states will continue to be drawn behind the current state. If background states are not visible when you have a different state on top, you should set this to false for improved performance.</haxe_doc>
		</persistentDraw>
		<destroySubStates public="1">
			<x path="Bool"/>
			<haxe_doc>* If substates get destroyed when they are closed, setting this to false might reduce state creation time, at greater memory cost.</haxe_doc>
		</destroySubStates>
		<bgColor public="1" get="accessor" set="accessor"><x path="Int"/></bgColor>
		<subState public="1" set="null">
			<c path="flixel.FlxSubState"/>
			<haxe_doc>* Current substate. Substates also can be nested.</haxe_doc>
		</subState>
		<_requestedSubState>
			<c path="flixel.FlxSubState"/>
			<haxe_doc>* If a state change was requested, the new state object is stored here until we switch to it.</haxe_doc>
		</_requestedSubState>
		<_requestSubStateReset>
			<x path="Bool"/>
			<haxe_doc>* Whether to reset the substate (when it changes, or when it's closed).</haxe_doc>
		</_requestSubStateReset>
		<create public="1" set="method" line="49">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called after the game engine successfully switches states. Override this function, NOT the constructor, to initialize or set up your game state.
	 * We do NOT recommend overriding the constructor, unless you want some crazy unpredictable things to happen!</haxe_doc>
		</create>
		<draw public="1" set="method" line="51" override="1"><f a=""><x path="Void"/></f></draw>
		<openSubState public="1" get="inline" set="null" line="64"><f a="SubState">
	<c path="flixel.FlxSubState"/>
	<x path="Void"/>
</f></openSubState>
		<closeSubState public="1" get="inline" set="null" line="73">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Closes the substate of this state, if one exists.</haxe_doc>
		</closeSubState>
		<resetSubState public="1" set="method" line="82">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Load substate for this state</haxe_doc>
		</resetSubState>
		<destroy public="1" set="method" line="117" override="1"><f a=""><x path="Void"/></f></destroy>
		<onFocusLost public="1" set="method" line="131">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This method is called after application losts its focus.
	 * Can be useful if you using third part libraries, such as tweening engines.</haxe_doc>
		</onFocusLost>
		<onFocus public="1" set="method" line="137">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This method is called after application gets focus.
	 * Can be useful if you using third part libraries, such as tweening engines.</haxe_doc>
		</onFocus>
		<onResize public="1" set="method" line="145">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function is called whenever the window size has been changed.
	 * 
	 * @param 	Width	The new window width
	 * @param 	Height	The new window Height</haxe_doc>
		</onResize>
		<tryUpdate set="method" line="148">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</tryUpdate>
		<get_bgColor set="method" line="166"><f a=""><x path="Int"/></f></get_bgColor>
		<set_bgColor set="method" line="171"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_bgColor>
		<new public="1" set="method" line="9"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* This is the basic game "state" object - e.g. in a simple game you might have a menu state and a play state.
 * It is for all intents and purpose a fancy FlxGroup. And really, it's not even that fancy.</haxe_doc>
	</class>
	<class path="flixel.FlxSubState" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/FlxSubState.hx">
		<extends path="flixel.FlxState"/>
		<closeCallback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Callback method for state close event</haxe_doc>
		</closeCallback>
		<_bgSprite>
			<c path="flixel.system.FlxBGSprite"/>
			<haxe_doc>* Helper sprite object for non-flash targets. Draws background</haxe_doc>
		</_bgSprite>
		<_parentState>
			<c path="flixel.FlxState"/>
			<haxe_doc>* Helper var for close() so closeSubState() can be called on the parent.</haxe_doc>
		</_parentState>
		<_bgColor><x path="Int"/></_bgColor>
		<_created><x path="Bool"/></_created>
		<draw public="1" set="method" line="48" override="1"><f a=""><x path="Void"/></f></draw>
		<destroy public="1" set="method" line="64" override="1"><f a=""><x path="Void"/></f></destroy>
		<close public="1" set="method" line="77">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Closes this substate.</haxe_doc>
		</close>
		<get_bgColor get="inline" set="null" line="85" override="1"><f a=""><x path="Int"/></f></get_bgColor>
		<set_bgColor set="method" line="90" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_bgColor>
		<new public="1" set="method" line="37">
			<f a="?BGColor" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	BGColor		background color for this substate</haxe_doc>
		</new>
		<haxe_doc>* This is the basic game "state" object - e.g. in a simple game you might have a menu state and a play state.
 * It is for all intents and purpose a fancy FlxGroup. And really, it's not even that fancy.</haxe_doc>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.addons.api.FlxGameJolt" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/api/FlxGameJolt.hx">
		<hashType public="1" line="42" static="1">
			<x path="Int"/>
			<haxe_doc>* The hash type to be used for private key encryption. Set to FlxGameJolt.HASH_MD5 or FlxGameJolt.HASH_SHA1. Default is MD5. See http://gamejolt.com/api/doc/game/ section "Signature".</haxe_doc>
		</hashType>
		<verbose public="1" line="49" static="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not to log the URL that is contacted and messages returned from GameJolt.
	 * Useful if you're not getting the right data back.
	 * Only works in debug mode.</haxe_doc>
		</verbose>
		<initialized public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the API has been fully initialized by passing game id, private key, and authenticating user name and token.</haxe_doc>
		</initialized>
		<get_initialized set="method" line="56" static="1"><f a=""><x path="Bool"/></f></get_initialized>
		<HASH_MD5 public="1" get="inline" set="null" line="64" static="1">
			<x path="Int"/>
			<haxe_doc>* Hash types for the cryptography function. Use this or HASH_SHA1 for encryptURL(). MD5 is used by default.</haxe_doc>
		</HASH_MD5>
		<HASH_SHA1 public="1" get="inline" set="null" line="69" static="1">
			<x path="Int"/>
			<haxe_doc>* Hash types for the cryptography function. Use this or HASH_MD5 for encryptURL(). MD5 is used by default.</haxe_doc>
		</HASH_SHA1>
		<TROPHIES_MISSING public="1" get="inline" set="null" line="74" static="1">
			<x path="Int"/>
			<haxe_doc>* Trophy data return type, will return only non-unlocked trophies. As an alternative, can just pass in the ID of the trophy to see if it's unlocked.</haxe_doc>
		</TROPHIES_MISSING>
		<TROPHIES_ACHIEVED public="1" get="inline" set="null" line="79" static="1">
			<x path="Int"/>
			<haxe_doc>* Trophy data return type, will return only unlocked trophies. As an alternative, can just pass in the ID of the trophy to see if it's unlocked.</haxe_doc>
		</TROPHIES_ACHIEVED>
		<_callBack static="1">
			<d/>
			<haxe_doc>* Internal storage for a callback function, used when the URLLoader is complete.</haxe_doc>
		</_callBack>
		<_gameID line="89" static="1">
			<x path="Int"/>
			<haxe_doc>* Internal storage for this game's ID.</haxe_doc>
		</_gameID>
		<_privateKey line="97" static="1">
			<c path="String"/>
			<haxe_doc>* Internal storage for this game's private key.
	 * Do NOT store your private key as a string literal in your game!
	 * This can be found at http://gamejolt.com/dashboard/developer/games/achievements/GAME_ID/ where GAME_ID is your unique game ID number.
	 * Each game has a unique private key; you cannot use one key for all of your games.</haxe_doc>
		</_privateKey>
		<_userName static="1">
			<c path="String"/>
			<haxe_doc>* Internal storage for this user's username. Can be retrieved automatically if Flash or QuickPlay.</haxe_doc>
		</_userName>
		<_userToken static="1">
			<c path="String"/>
			<haxe_doc>* Internal storage for this user's token. Can be retrieved automatically if Flash or QuickPlay.</haxe_doc>
		</_userToken>
		<_idURL static="1">
			<c path="String"/>
			<haxe_doc>* Internal storage for the most common URL elements: the gameID, user name, and user token.</haxe_doc>
		</_idURL>
		<_initialized line="117" static="1">
			<x path="Bool"/>
			<haxe_doc>* Set to true once game ID, user name, user token have been set and user name and token have been verified.</haxe_doc>
		</_initialized>
		<_verifyAuth line="122" static="1">
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for authenticating user data.</haxe_doc>
		</_verifyAuth>
		<_getImage line="127" static="1">
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for getting bitmapdata for a trophy image.</haxe_doc>
		</_getImage>
		<_loader static="1">
			<c path="flash.net.URLLoader"/>
			<haxe_doc>* URLLoader object for sending URL requests.</haxe_doc>
		</_loader>
		<URL_API get="inline" set="null" line="137" static="1">
			<c path="String"/>
			<haxe_doc>* Various common strings required by the API's HTTP values.</haxe_doc>
		</URL_API>
		<RETURN_TYPE get="inline" set="null" line="138" static="1"><c path="String"/></RETURN_TYPE>
		<URL_GAME_ID get="inline" set="null" line="139" static="1"><c path="String"/></URL_GAME_ID>
		<URL_USER_NAME get="inline" set="null" line="140" static="1"><c path="String"/></URL_USER_NAME>
		<URL_USER_TOKEN get="inline" set="null" line="141" static="1"><c path="String"/></URL_USER_TOKEN>
		<init public="1" set="method" line="155" static="1">
			<f a="GameID:PrivateKey:?AutoAuth:?UserName:?UserToken:?Callback" v="::false:null:null:null">
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize this class by storing the GameID and private key.
	 * You must call this function first for many of the other functions to work.
	 * To enable user-specific functions, call authUser() afterward, or set AutoAuth to true.
	 * 
	 * @param	GameID		The unique game ID associated with this game on GameJolt. You must create a game profile on GameJolt to get this number.	
	 * @param	PrivateKey	Your private key. You must have a developer account on GameJolt to have this number. Do NOT store this as plaintext in your game!
	 * @param	AutoAuth	Call authUser after init() has run to authenticate user data.
	 * @param 	?UserName	The username to authenticate, if AutoAuth is true. If you set AutoAuth to true but don't put a value here, FlxGameJolt will attempt to get the user data automatically, which will only work for Flash embedded on GameJolt, or desktop games run via Quick Play.
	 * @param 	?UserToken	The user token to authenticate, if AutoAuth is true. If you set AutoAuth to true but don't put a value here, FlxGameJolt will attempt to get the user data automatically, which will only work for Flash embedded on GameJolt, or desktop games run via Quick Play.
	 * @param 	?Callback 	An optional callback function, which is only used if AutoAuth is set to true. Will return true if authentication was successful, false otherwise.</haxe_doc>
		</init>
		<fetchUser public="1" set="method" line="185" static="1">
			<f a="?UserID:?UserName:?UserIDs:?Callback" v="null:null:null:null">
				<x path="Int"/>
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Fetch user data. Pass UserID to get user name, pass UserName to get UserID, or pass multiple UserIDs to get multiple usernames.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/users/fetch/
	 * @param	?UserID		An integer user ID value. If this is passed, UserName and UserIDs are ignored. Pass 0 to ignore.
	 * @param	?UserName	A string user name. If this is passed, UserIDs is ignored. Pass "" or nothing to ignore. Usernames can only have letters, numbers, hyphens (-) and underscores (_), and must be 3-30 characters long.
	 * @param	?UserIDs	An array of integers representing user IDs. Pass [] or nothing to ignore.
	 * @param	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</fetchUser>
		<authUser public="1" set="method" line="216" static="1">
			<f a="?UserName:?UserToken:?Callback" v="null:null:null">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Verify user data. Must be called before any user-specific functions, and after init(). Will set initialized to true if successful.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/users/auth/
	 * @param	?UserName	A user name. Leave null to automatically pull user data (only works for embedded Flash on GameJolt or Quick Play). Usernames can only have letters, numbers, hyphens (-) and underscores (_), and must be 3-30 characters long.
	 * @param	?UserToken	A user token. Players enter this instead of a password to enable highscores, trophies, etc. Leave null to automatically pull user data (only works for embedded Flash on GameJolt or Quick Play). User tokens can only have letters and numbers, and must be 4-30 characters long.
	 * @param	?Callback	An optional callback function. Will return true if authentication was successful, false otherwise.</haxe_doc>
		</authUser>
		<openSession public="1" set="method" line="271" static="1">
			<f a="?Callback" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Begin a new session. Sessions that are not pinged at most every 120 seconds will be closed. Requires user authentication.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/sessions/open/
	 * @param 	?Callback 	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</openSession>
		<pingSession public="1" set="method" line="285" static="1">
			<f a="?Active:?Callback" v="true:null">
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Ping the current session. The API states that a session will be closed after 120 seconds without a ping, and recommends pinging every 30 seconds or so. Requires user authentication.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/sessions/ping/
	 * @param	Active		Leave true to set the session to active, or set to false to set the session to idle.
	 * @param	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</pingSession>
		<closeSession public="1" set="method" line="306" static="1">
			<f a="?Callback" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Close the current session. Requires user data authentication.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/sessions/close/
	 * @param	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</closeSession>
		<fetchTrophy public="1" set="method" line="320" static="1">
			<f a="?DataType:?Callback" v="0:null">
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Retrieve trophy data. Requires user authentication.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/trophies/fetch/
	 * @param	DataType	Pass FlxGameJolt.TROPHIES_MISSING or FlxGameJolt.TROPHIES_ACHIEVED to get the trophies this user is missing or already has, respectively.  Or, pass in a trophy ID # to see if this user has that trophy or not.  If unused or zero, will return all trophies.
	 * @param	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</fetchTrophy>
		<addTrophy public="1" set="method" line="347" static="1">
			<f a="TrophyID:?Callback" v=":null">
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Unlock a trophy for this user. Requires user authentication.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/trophies/add-achieved/
	 * @param	TrophyID	The unique ID number for this trophy. Can be seen at http://gamejolt.com/dashboard/developer/games/achievements/<Your Game ID>/ in the right-hand column.
	 * @param 	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</addTrophy>
		<fetchScore public="1" set="method" line="361" static="1">
			<f a="?Limit:?Callback" v="null:null">
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Retrieve the high scores from this game's remote data. If not authenticated, leaving Limit null will still return the top ten scores. Requires initialization.
	 * 
	 * @see		http://gamejolt.com/api/doc/game/scores/fetch/
	 * @param	?Limit		The maximum number of scores to retrieve. Leave null to retrieve only this user's scores.
	 * @param	?CallBack	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</fetchScore>
		<addScore public="1" set="method" line="396" static="1">
			<f a="Score:Sort:?TableID:?AllowGuest:?GuestName:?ExtraData:?Callback" v="::null:false:null:null:null">
				<c path="String"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set a new high score, either globally or for this particular user. Requires game initialization.
	 * If user data is not authenticated, GuestName is required.
	 * Please note: On native platforms, having spaces in your Sort, GuestName, or ExtraData values will break this function.
	 * 
	 * @see		http://gamejolt.com/api/doc/game/scores/add/
	 * @param	Score		A string representation of the score, such as "234 Jumps".
	 * @param	Sort		A numerical representation of the score, such as 234. Used for sorting of data.
	 * @param 	?TableID	Optional: the ID of the table you'd lke to send data to. If null, score will be sent to the primary high score table. Ignored if zero.
	 * @param 	AllowGuest	Whether or not to allow guest scores. If true is passed, and user data is not present (i.e. authUser() was not successful), GuestName will be used if present. If false, the score will only be added if user data is authenticated.
	 * @param	?GuestName	The guest name to use, if AllowGuest is true. Ignored otherwise, or if "".
	 * @param	?ExtraData	Optional extra data associated with the score, which will NOT be visible on the site but can be retrieved by the API. Ignored if "".
	 * @param 	?Callback 	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</addScore>
		<getTables public="1" set="method" line="429" static="1">
			<f a="?Callback" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Retrieve a list of high score tables for this game.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/scores/tables/
	 * @param	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</getTables>
		<fetchData public="1" set="method" line="444" static="1">
			<f a="Key:?User:?Callback" v=":true:null">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Get data from the remote data store.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/data-store/fetch/
	 * @param	Key			The key for the data to retrieve.
	 * @param	User		Whether or not to get the data associated with this user. True by default.
	 * @param	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</fetchData>
		<setData public="1" set="method" line="470" static="1">
			<f a="Key:Value:?User:?Callback" v="::true:null">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set data in the remote data store.
	 * Please note: On native platforms, having spaces in your Value parameter will break this function.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/data-store/set/
	 * @param	Key			The key for this data.
	 * @param	Value		The key value.
	 * @param	User		Whether or not to associate this with this user. True by default.
	 * @param	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</setData>
		<updateData public="1" set="method" line="497" static="1">
			<f a="Key:Operation:Value:?User:?Callback" v=":::true:null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Update data which is in the data store.
	 * Please note: On native platforms, having spaces in your Value parameter will break this function.
	 * 
	 * @see		http://gamejolt.com/api/doc/game/data-store/update/
	 * @param	Key			The key of the data you'd like to manipulate.
	 * @param	Operation	The type of operation. Acceptable values: "add", "subtract", "multiply", "divide", "append", "prepend". The former four are only valid on numerical values, the latter two only on strings.
	 * @param	Value		The value that you'd like to work with on the data store.
	 * @param	User		Whether or not to work with the data associated with this user.
	 * @param	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</updateData>
		<removeData public="1" set="method" line="521" static="1">
			<f a="Key:?User:?Callback" v=":true:null">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Remove data from the remote data store.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/data-store/remove/
	 * @param	Key			The key for the data to remove.
	 * @param	User		Whether or not to remove the data associated with this user. True by default.
	 * @param	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</removeData>
		<getAllKeys public="1" set="method" line="544" static="1">
			<f a="?User:?Callback" v="true:null">
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Get all keys in the data store.
	 * 
	 * @see 	http://gamejolt.com/api/doc/game/data-store/get-keys/
	 * @param	User		Whether or not to get the keys associated with this user. True by default.
	 * @param	?Callback	An optional callback function. Will return a Map<String:String> whose keys and values are equivalent to the key-value pairs returned by GameJolt.]]></haxe_doc>
		</getAllKeys>
		<sendLoaderRequest set="method" line="566" static="1">
			<f a="URLString:?Callback" v=":null">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A generic internal function to setup and send a URLRequest. All of the functions that interact with the API use this.
	 * 
	 * @param	URLString	The URL to send to. Usually formatted as the API url, section of the API (e.g. "trophies/") and then variables to pass (e.g. user name, trophy ID).
	 * @param	?Callback	A function to call when loading is done and data is parsed.</haxe_doc>
		</sendLoaderRequest>
		<parseData set="method" line="595" static="1">
			<f a="e">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Called when the URLLoader has received data back.
	 * Will call _callBack() with the data received from GameJolt as Map<String,String> when done.
	 * However, if we're getting an image, a second URLRequest is called, and that will be done first.
	 * Or, if we're authenticating the user, the verifyAuthentication function will be called instead.
	 * 
	 * @param	The URLLoader complete event.]]></haxe_doc>
		</parseData>
		<verifyAuthentication set="method" line="646" static="1">
			<f a="ReturnMap">
				<x path="Map">
					<c path="String"/>
					<c path="String"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function to evaluate whether or not a user was successfully authenticated and store the result in _initialized. If authentication failed, the tentative user name and token are nulled.
	 * 
	 * @param	ReturnMap	The data received back from GameJolt. This should be {"success"="true"} if authenticated, or {"success"="false"} otherwise.</haxe_doc>
		</verifyAuthentication>
		<resetUser public="1" set="method" line="670" static="1">
			<f a="UserName:UserToken:?Callback" v="::null">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Function to authenticate a new user, to be used when a user has already been authenticated but you'd like to authenticate a new one.
	 * If you just try to run authUser after a user has been authenticated, it will fail.
	 * 
	 * @param	UserName	The user's name.
	 * @param	UserToken	The user's token.
	 * @param	?Callback	An optional callback function. Will return true if authentication was successful, false otherwise.</haxe_doc>
		</resetUser>
		<fetchTrophyImage public="1" set="method" line="687" static="1">
			<f a="ID:?Callback" v=":null">
				<x path="Int"/>
				<f a="">
					<c path="flash.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* An easy-to-use function that returns the image associated with a trophy as BitmapData.
	 * All trophy images will be 75px by 75px.
	 * 
	 * @param	ID			The ID of the trophy whose image you want to get.
	 * @param	?Callback	An optional callback function. Must take a BitmapData object as a parameter.</haxe_doc>
		</fetchTrophyImage>
		<fetchAvatarImage public="1" set="method" line="701" static="1">
			<f a="?Callback" v="null">
				<f a="">
					<c path="flash.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* An easy-to-use function that returns the user's avatar image as BitmapData.
	 * Requires that you've authenticated the user's data.
	 * All user images will be 60px by 60px.
	 * 
	 * @param	?Callback	An optional callback function. Must take a BitmapData object as a parameter.</haxe_doc>
		</fetchAvatarImage>
		<retrieveImage set="method" line="711" static="1">
			<f a="ImageMap">
				<x path="Map">
					<c path="String"/>
					<c path="String"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function that uses the image_url or avatar_url element from GameJolt to start a Loader that will retrieve the desired image.</haxe_doc>
		</retrieveImage>
		<returnImage set="method" line="733" static="1">
			<f a="e">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function to send the image_url or avatar_url content to the callback function as BitmapData.</haxe_doc>
		</returnImage>
		<encryptURL set="method" line="749" static="1">
			<f a="Url">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Generate an MD5 or SHA1 hash signature, required by the API to verify game data is valid. Passed to the API as "&signature=".
	 * 
	 * @see		http://gamejolt.com/api/doc/game/ 	Section titled "Signature".
	 * @param	Url		The URL to encrypt. This and the private key form the string which is encoded.
	 * @return	An encoded MD5 or SHA1 hash. By default, will be MD5; set FlxGameJolt.hashType = FlxGameJolt.HASH_SHA1 to use SHA1 encoding.]]></haxe_doc>
		</encryptURL>
		<gameInit get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* Internal method to verify that init() has been called on this class. Called before running functions that require game ID or private key but not user data.
	 * 
	 * @return	True if game ID is set, false otherwise.</haxe_doc>
		</gameInit>
		<get_gameInit set="method" line="765" static="1"><f a=""><x path="Bool"/></f></get_gameInit>
		<authenticated get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* Internal method to verify that this user (and game) have been authenticated. Called before running functions which require authentication.
	 * 
	 * @return 	True if authenticated, false otherwise.</haxe_doc>
		</authenticated>
		<get_authenticated set="method" line="784" static="1"><f a=""><x path="Bool"/></f></get_authenticated>
		<username public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* The user's GameJolt user name. Only works if you've called authUser() and/or init(), otherwise will return "No user".</haxe_doc>
		</username>
		<get_username set="method" line="803" static="1"><f a=""><c path="String"/></f></get_username>
		<usertoken public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* The user's GameJolt user token. Only works if you've called authUser() and/or init(), otherwise will return "No token".
	 * Generally you should not need to mess with this.</haxe_doc>
		</usertoken>
		<get_usertoken set="method" line="818" static="1"><f a=""><c path="String"/></f></get_usertoken>
		<isQuickPlay public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* An alternative to running authUser() and hoping for the best; this will tell you if your game was run via Quick Play, and user name and token is available. Does NOT authenticate the user data!
	 *
	 * @return	True if this was run via Quick Play with user name and token available, false otherwise.</haxe_doc>
		</isQuickPlay>
		<get_isQuickPlay set="method" line="834" static="1"><f a=""><x path="Bool"/></f></get_isQuickPlay>
		<isEmbeddedFlash public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* An alternative to running authUser() and hoping for the best; this will tell you if your game was run as an embedded Flash on GameJolt that has user name and token data already. Does NOT authenticate the user data!
	 *
	 * @return	True if it's an embedded SWF with user name and token available, false otherwise.</haxe_doc>
		</isEmbeddedFlash>
		<get_isEmbeddedFlash set="method" line="861" static="1"><f a=""><x path="Bool"/></f></get_isEmbeddedFlash>
		<haxe_doc><![CDATA[* Similar to FlxKongregate, this allows access to the GameJolt API. Based loosely on the AS3 version by SumYungGai with many changes.
 * 
 * @see 	http://gamejolt.com/community/forums/topics/as3-trophy-api/305/
 * @see 	http://gamejolt.com/api/doc/game/
 * @author 	SumYungGai
 * @author 	Steve Richey (STVR)
 * 
 * Usage:
 * Note: Do NOT store you private key as an unobfuscated string! One method is to save it as a text file called "myKey.privatekey" and add "*.privatekey" to your ignore list for version control (.gitignore for git, global-ignores in your config file for svn, .hgignore for Mercurial). Then:
	 * Below your import statements, add @:file("myKey.privatekey") class MyKey extends ByteArray { } to embed that file's data as a ByteArray.
	 * If your game is embedded as Flash on GameJolt's site, or run via Quick Play, you do not need to get the user name and token; this will be done automatically.
	 * Otherwise, you will need to retrieve the user name and token (possibly via an input box prompt).
	 * Then, verify this data via the following method:
		 * var bytearray = new MyKey(); // This will load your private key data as a ByteArray.
		 * var keystring = bytearray.readUTFBytes( bytearray.length ); // This converts the ByteArray to a string.
		 * var gameid = 1; // Replace "1" with your game ID, visible if you go to http://gamejolt.com/dashboard/ -> Click on your game under "Manage Games" -> Click on "Achievements" in the menu.
		 * FlxGameJolt.init( gameid, keystring ); // Use this if your game is embedded as Flash on GameJolt's site, or run via Quick Play. If]]></haxe_doc>
	</class>
	<class path="flixel.addons.display.FlxBackdrop" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxBackdrop.hx">
		<extends path="flixel.FlxSprite"/>
		<_ppoint><c path="flash.geom.Point"/></_ppoint>
		<_scrollW><x path="Int"/></_scrollW>
		<_scrollH><x path="Int"/></_scrollH>
		<_repeatX><x path="Bool"/></_repeatX>
		<_repeatY><x path="Bool"/></_repeatY>
		<_tileID><x path="Int"/></_tileID>
		<_tileInfo><c path="Array"><x path="Float"/></c></_tileInfo>
		<_numTiles><x path="Int"/></_numTiles>
		<destroy public="1" set="method" line="111" override="1"><f a=""><x path="Void"/></f></destroy>
		<draw public="1" set="method" line="123" override="1"><f a=""><x path="Void"/></f></draw>
		<updateFrameData public="1" set="method" line="197" override="1"><f a=""><x path="Void"/></f></updateFrameData>
		<new public="1" set="method" line="42">
			<f a="Graphic:?ScrollX:?ScrollY:?RepeatX:?RepeatY" v=":1:1:true:true">
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates an instance of the FlxBackdrop class, used to create infinitely scrolling backgrounds.
	 * 
	 * @param   Graphic		The image you want to use for the backdrop.
	 * @param   ScrollX 	Scrollrate on the X axis.
	 * @param   ScrollY 	Scrollrate on the Y axis.
	 * @param   RepeatX 	If the backdrop should repeat on the X axis.
	 * @param   RepeatY 	If the backdrop should repeat on the Y axis.</haxe_doc>
		</new>
		<haxe_doc>* Used for showing infinitely scrolling backgrounds.
 * @author Chevy Ray</haxe_doc>
	</class>
	<class path="flixel.addons.display.FlxExtendedSprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxExtendedSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<priorityID public="1">
			<x path="Int"/>
			<haxe_doc>* Used by FlxMouseControl when multiple sprites overlap and register clicks, and you need to determine which sprite has priority</haxe_doc>
		</priorityID>
		<isPressed public="1">
			<x path="Bool"/>
			<haxe_doc>* If the mouse currently pressed down on this sprite?</haxe_doc>
		</isPressed>
		<clickable public="1">
			<x path="Bool"/>
			<haxe_doc>* Is this sprite allowed to be clicked?</haxe_doc>
		</clickable>
		<throwable public="1">
			<x path="Bool"/>
			<haxe_doc>* Is this sprite allowed to be thrown?</haxe_doc>
		</throwable>
		<boundsRect public="1">
			<c path="flixel.util.FlxRect"/>
			<haxe_doc>* An FlxRect region of the game world within which the sprite is restricted during mouse drag</haxe_doc>
		</boundsRect>
		<boundsSprite public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* An FlxSprite the bounds of which this sprite is restricted during mouse drag</haxe_doc>
		</boundsSprite>
		<hasGravity public="1">
			<x path="Bool"/>
			<haxe_doc>* Does this sprite have gravity applied to it?</haxe_doc>
		</hasGravity>
		<gravityX public="1">
			<x path="Int"/>
			<haxe_doc>* The x axis gravity influence</haxe_doc>
		</gravityX>
		<gravityY public="1">
			<x path="Int"/>
			<haxe_doc>* The y axis gravity influence</haxe_doc>
		</gravityY>
		<frictionX public="1">
			<x path="Float"/>
			<haxe_doc>* Determines how quickly the Sprite come to rest on the walls if the sprite has x gravity enabled</haxe_doc>
		</frictionX>
		<frictionY public="1">
			<x path="Float"/>
			<haxe_doc>* Determines how quickly the Sprite come to rest on the ground if the sprite has y gravity enabled</haxe_doc>
		</frictionY>
		<toleranceX public="1">
			<x path="Float"/>
			<haxe_doc>* If the velocity.x of this sprite falls between zero and this amount, then the sprite will come to a halt (have velocity.x set to zero)</haxe_doc>
		</toleranceX>
		<toleranceY public="1">
			<x path="Float"/>
			<haxe_doc>* If the velocity.y of this sprite falls between zero and this amount, then the sprite will come to a halt (have velocity.y set to zero)</haxe_doc>
		</toleranceY>
		<isDragged public="1">
			<x path="Bool"/>
			<haxe_doc>* Is this sprite being dragged by the mouse or not?</haxe_doc>
		</isDragged>
		<draggable public="1">
			<x path="Bool"/>
			<haxe_doc>* Is this sprite allowed to be dragged by the mouse? true = yes, false = no</haxe_doc>
		</draggable>
		<springOnPressed public="1">
			<x path="Bool"/>
			<haxe_doc>* Will the Mouse Spring be active always (false) or only when pressed (true)</haxe_doc>
		</springOnPressed>
		<springOffsetX public="1">
			<x path="Int"/>
			<haxe_doc>* By default the spring attaches to the top left of the sprite. To change this location provide an x offset (in pixels)</haxe_doc>
		</springOffsetX>
		<springOffsetY public="1">
			<x path="Int"/>
			<haxe_doc>* By default the spring attaches to the top left of the sprite. To change this location provide a y offset (in pixels)</haxe_doc>
		</springOffsetY>
		<mousePressedCallback public="1">
			<t path="flixel.addons.display.MouseCallback"/>
			<haxe_doc>* Function called when the mouse is pressed down on this sprite. Function is passed these parameters: obj:FlxExtendedSprite, x:int, y:int</haxe_doc>
		</mousePressedCallback>
		<mouseReleasedCallback public="1">
			<t path="flixel.addons.display.MouseCallback"/>
			<haxe_doc>* Function called when the mouse is released from this sprite. Function is passed these parameters: obj:FlxExtendedSprite, x:int, y:int</haxe_doc>
		</mouseReleasedCallback>
		<mouseSpring public="1">
			<c path="flixel.addons.display.FlxMouseSpring"/>
			<haxe_doc>* The MouseSpring object which is used to tie this sprite to the mouse</haxe_doc>
		</mouseSpring>
		<mouseStartDragCallback public="1">
			<t path="flixel.addons.display.MouseCallback"/>
			<haxe_doc>* Function called when the mouse starts to drag this sprite. Function is passed these parameters: obj:FlxExtendedSprite, x:int, y:int</haxe_doc>
		</mouseStartDragCallback>
		<mouseStopDragCallback public="1">
			<t path="flixel.addons.display.MouseCallback"/>
			<haxe_doc>* Function called when the mouse stops dragging this sprite. Function is passed these parameters: obj:FlxExtendedSprite, x:int, y:int</haxe_doc>
		</mouseStopDragCallback>
		<hasMouseSpring public="1">
			<x path="Bool"/>
			<haxe_doc>* Is this sprite using a mouse spring?</haxe_doc>
		</hasMouseSpring>
		<clicks public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The number of clicks this item has received. Usually you'd only set it to zero.</haxe_doc>
		</clicks>
		<springX public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The spring x coordinate in game world space. Consists of sprite.x + springOffsetX</haxe_doc>
		</springX>
		<springY public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The spring y coordinate in game world space. Consists of sprite.y + springOffsetY</haxe_doc>
		</springY>
		<point public="1" get="accessor" set="accessor">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* A FlxPoint consisting of this sprites world x/y coordinates</haxe_doc>
		</point>
		<rect public="1" get="accessor" set="null">
			<c path="flixel.util.FlxRect"/>
			<haxe_doc>* Returns a FlxRect consisting of the bounds of this Sprite.</haxe_doc>
		</rect>
		<mouseOver public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Return true if the mouse is over this Sprite, otherwise false. Only takes the Sprites bounding box into consideration and does not check if there 
	 * are other sprites potentially on-top of this one. Check the value of this.isPressed if you need to know if the mouse is currently clicked on this sprite.</haxe_doc>
		</mouseOver>
		<mouseX public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Returns how many horizontal pixels the mouse pointer is inside this sprite from the top left corner. Returns -1 if outside.</haxe_doc>
		</mouseX>
		<mouseY public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Returns how many vertical pixels the mouse pointer is inside this sprite from the top left corner. Returns -1 if outside.</haxe_doc>
		</mouseY>
		<_snapOnDrag><x path="Bool"/></_snapOnDrag>
		<_snapOnRelease><x path="Bool"/></_snapOnRelease>
		<_snapX><x path="Int"/></_snapX>
		<_snapY><x path="Int"/></_snapY>
		<_clickOnRelease><x path="Bool"/></_clickOnRelease>
		<_clickPixelPerfect><x path="Bool"/></_clickPixelPerfect>
		<_clickPixelPerfectAlpha><x path="Int"/></_clickPixelPerfectAlpha>
		<_clickCounter><x path="Int"/></_clickCounter>
		<_rect><c path="flixel.util.FlxRect"/></_rect>
		<_throwXFactor><x path="Int"/></_throwXFactor>
		<_throwYFactor><x path="Int"/></_throwYFactor>
		<_dragPixelPerfect><x path="Bool"/></_dragPixelPerfect>
		<_dragPixelPerfectAlpha><x path="Int"/></_dragPixelPerfectAlpha>
		<_dragOffsetX><x path="Int"/></_dragOffsetX>
		<_dragOffsetY><x path="Int"/></_dragOffsetY>
		<_dragFromPoint><x path="Bool"/></_dragFromPoint>
		<_allowHorizontalDrag><x path="Bool"/></_allowHorizontalDrag>
		<_allowVerticalDrag><x path="Bool"/></_allowVerticalDrag>
		<enableMouseClicks public="1" set="method" line="203">
			<f a="OnRelease:?PixelPerfect:?AlphaThreshold" v=":false:255">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Allow this Sprite to receive mouse clicks, the total number of times this sprite is clicked is stored in this.clicks
	 * You can add callbacks via mousePressedCallback and mouseReleasedCallback
	 * 
	 * @param	OnRelease			Register the click when the mouse is pressed down (false) or when it's released (true). Note that callbacks still fire regardless of this setting.
	 * @param	PixelPerfect		If true it will use a pixel perfect test to see if you clicked the Sprite. False uses the bounding box.
	 * @param	AlphaThreshold		If using pixel perfect collision this specifies the alpha level from 0 to 255 above which a collision is processed (default 255)</haxe_doc>
		</enableMouseClicks>
		<disableMouseClicks public="1" get="inline" set="null" line="221">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops this sprite from checking for mouse clicks and clears any set callbacks</haxe_doc>
		</disableMouseClicks>
		<enableMouseDrag public="1" set="method" line="237">
			<f a="?LockCenter:?PixelPerfect:?AlphaThreshold:?BoundsRect:?BoundsSprite" v="false:false:255:null:null">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flixel.util.FlxRect"/>
				<c path="flixel.FlxSprite"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Make this Sprite draggable by the mouse. You can also optionally set mouseStartDragCallback and mouseStopDragCallback
	 * 
	 * @param	LockCenter			If false the Sprite will drag from where you click it. If true it will center itself to the tip of the mouse pointer.
	 * @param	PixelPerfect		If true it will use a pixel perfect test to see if you clicked the Sprite. False uses the bounding box.
	 * @param	AlphaThreshold		If using pixel perfect collision this specifies the alpha level from 0 to 255 above which a collision is processed (default 255)
	 * @param	BoundsRect			If you want to restrict the drag of this sprite to a specific FlxRect, pass the FlxRect here, otherwise it's free to drag anywhere
	 * @param	BoundsSprite		If you want to restrict the drag of this sprite to within the bounding box of another sprite, pass it here</haxe_doc>
		</enableMouseDrag>
		<disableMouseDrag public="1" set="method" line="265">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops this sprite from being able to be dragged. If it is currently the target of 
	 * an active drag it will be stopped immediately. Also disables any set callbacks.</haxe_doc>
		</disableMouseDrag>
		<enableMouseThrow public="1" set="method" line="286">
			<f a="FactorX:FactorY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Make this Sprite throwable by the mouse. The sprite is thrown only when the mouse button is released.
	 * 
	 * @param	FactorX		The sprites velocity is set to FlxMouseControl.speedX * xFactor. Try a value around 50+
	 * @param	FactorY		The sprites velocity is set to FlxMouseControl.speedY * yFactor. Try a value around 50+</haxe_doc>
		</enableMouseThrow>
		<disableMouseThrow public="1" set="method" line="306">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops this sprite from being able to be thrown. If it currently has velocity this is NOT removed from it.</haxe_doc>
		</disableMouseThrow>
		<enableMouseSnap public="1" set="method" line="320">
			<f a="SnapX:SnapY:?OnDrag:?OnRelease" v="::true:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Make this Sprite snap to the given grid either during drag or when it's released.
	 * For example 16x16 as the snapX and snapY would make the sprite snap to every 16 pixels.
	 * 
	 * @param	SnapX		The width of the grid cell in pixels
	 * @param	SnapY		The height of the grid cell in pixels
	 * @param	OnDrag		If true the sprite will snap to the grid while being dragged
	 * @param	OnRelease	If true the sprite will snap to the grid when released</haxe_doc>
		</enableMouseSnap>
		<disableMouseSnap public="1" set="method" line="331">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the sprite from snapping to a grid during drag or release.</haxe_doc>
		</disableMouseSnap>
		<enableMouseSpring public="1" set="method" line="348">
			<f a="?OnPressed:?RetainVelocity:?Tension:?Friction:?Gravity" v="true:false:0.1f:0.95f:0">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.addons.display.FlxMouseSpring"/>
			</f>
			<haxe_doc>* Adds a simple spring between the mouse and this Sprite. The spring can be activated either when the mouse is pressed (default), or enabled all the time.
	 * Note that nearly always the Spring will over-ride any other motion setting the sprite has (like velocity or gravity)
	 * 
	 * @param	OnPressed			True if the spring should only be active when the mouse is pressed down on this sprite
	 * @param	RetainVelocity		True to retain the velocity of the spring when the mouse is released, or false to clear it
	 * @param	Tension				The tension of the spring, smaller numbers create springs closer to the mouse pointer
	 * @param	Friction			The friction applied to the spring as it moves
	 * @param	Gravity				The gravity controls how far "down" the spring hangs (use a negative value for it to hang up!)
	 * @return	The FlxMouseSpring object if you wish to perform further chaining on it. Also available via FlxExtendedSprite.mouseSpring</haxe_doc>
		</enableMouseSpring>
		<disableMouseSpring public="1" set="method" line="380">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the sprite to mouse spring from being active</haxe_doc>
		</disableMouseSpring>
		<setDragLock public="1" set="method" line="393">
			<f a="?AllowHorizontalDrag:?AllowVerticalDrag" v="true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Restricts this sprite to drag movement only on the given axis. Note: If both are set to false the sprite will never move!
	 * 
	 * @param	AllowHorizontalDrag		To enable the sprite to be dragged horizontally set to true, otherwise false
	 * @param	AllowVerticalDrag		To enable the sprite to be dragged vertically set to true, otherwise false</haxe_doc>
		</setDragLock>
		<update public="1" set="method" line="402" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Core update loop</haxe_doc>
		</update>
		<updateGravity set="method" line="446">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by update, applies friction if the sprite has gravity to stop jittery motion when slowing down</haxe_doc>
		</updateGravity>
		<updateDrag set="method" line="546">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the Mouse Drag on this Sprite.</haxe_doc>
		</updateDrag>
		<checkForClick set="method" line="584">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Checks if the mouse is over this sprite and pressed, then does a pixel 
	 * perfect check if needed and adds it to the FlxMouseControl check stack.</haxe_doc>
		</checkForClick>
		<mousePressedHandler public="1" set="method" line="615">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by FlxMouseControl when this sprite is clicked. Should not usually be called directly.</haxe_doc>
		</mousePressedHandler>
		<mouseReleasedHandler public="1" set="method" line="633">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by FlxMouseControl when this sprite is released from a click. Should not usually be called directly.</haxe_doc>
		</mouseReleasedHandler>
		<startDrag public="1" set="method" line="663">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by FlxMouseControl when Mouse Drag starts on this Sprite. Should not usually be called directly.</haxe_doc>
		</startDrag>
		<checkBoundsRect set="method" line="685">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Bounds Rect check for the sprite drag</haxe_doc>
		</checkBoundsRect>
		<checkBoundsSprite set="method" line="709">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Parent Sprite Bounds check for the sprite drag</haxe_doc>
		</checkBoundsSprite>
		<stopDrag public="1" set="method" line="733">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by FlxMouseControl when Mouse Drag is stopped on this Sprite. Should not usually be called directly.</haxe_doc>
		</stopDrag>
		<setGravity public="1" set="method" line="755">
			<f a="GravityX:GravityY:?FrictionX:?FrictionY:?ToleranceX:?ToleranceY" v="::500:500:10:10">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Gravity can be applied to the sprite, pulling it in any direction. Gravity is given in pixels per second and is applied as acceleration.
	 * If you don't want gravity for a specific direction pass a value of zero. To cancel it entirely pass both values as zero.
	 * 
	 * @param	GravityX	A positive value applies gravity dragging the sprite to the right. A negative value drags the sprite to the left. Zero disables horizontal gravity.
	 * @param	GravityY	A positive value applies gravity dragging the sprite down. A negative value drags the sprite up. Zero disables vertical gravity.
	 * @param	FrictionX	The amount of friction applied to the sprite if it hits a wall. Allows it to come to a stop without constantly jittering.
	 * @param	FrictionY	The amount of friction applied to the sprite if it hits the floor/roof. Allows it to come to a stop without constantly jittering.
	 * @param	ToleranceX	If the velocity.x of the sprite falls between 0 and +- this value, it is set to stop (velocity.x = 0)
	 * @param	ToleranceY	If the velocity.y of the sprite falls between 0 and +- this value, it is set to stop (velocity.y = 0)</haxe_doc>
		</setGravity>
		<flipGravity public="1" set="method" line="781">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Switches the gravity applied to the sprite. If gravity was +400 Y (pulling them down) this will swap it to -400 Y (pulling them up)
	 * To reset call flipGravity again</haxe_doc>
		</flipGravity>
		<get_clicks get="inline" set="null" line="796"><f a=""><x path="Int"/></f></get_clicks>
		<set_clicks get="inline" set="null" line="801"><f a="NewValue">
	<x path="Int"/>
	<x path="Int"/>
</f></set_clicks>
		<get_springX get="inline" set="null" line="806"><f a=""><x path="Int"/></f></get_springX>
		<get_springY get="inline" set="null" line="811"><f a=""><x path="Int"/></f></get_springY>
		<get_point get="inline" set="null" line="816"><f a=""><c path="flixel.util.FlxPoint"/></f></get_point>
		<set_point get="inline" set="null" line="821"><f a="NewPoint">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
</f></set_point>
		<get_mouseOver set="method" line="829"><f a=""><x path="Bool"/></f></get_mouseOver>
		<get_mouseX set="method" line="840"><f a=""><x path="Int"/></f></get_mouseX>
		<get_mouseY set="method" line="850"><f a=""><x path="Int"/></f></get_mouseY>
		<get_rect get="inline" set="null" line="861"><f a=""><c path="flixel.util.FlxRect"/></f></get_rect>
		<new public="1" set="method" line="187">
			<f a="?X:?Y:?SimpleGraphic" v="0:0:null">
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a white 8x8 square FlxExtendedSprite at the specified position.
	 * Optionally can load a simple, one-frame graphic instead.
	 * 
	 * @param	X				The initial X position of the sprite.
	 * @param	Y				The initial Y position of the sprite.
	 * @param	SimpleGraphic	The graphic you want to display (OPTIONAL - for simple stuff only, do NOT use for animated images!).</haxe_doc>
		</new>
		<haxe_doc>* An enhanced FlxSprite that is capable of receiving mouse clicks, being dragged and thrown, mouse springs, gravity and other useful things
 *
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
	</class>
	<typedef path="flixel.addons.display.MouseCallback" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxExtendedSprite.hx" module="flixel.addons.display.FlxExtendedSprite"><f a="::">
	<c path="flixel.addons.display.FlxExtendedSprite"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></typedef>
	<class path="flixel.addons.display.FlxGridOverlay" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxGridOverlay.hx">
		<create public="1" set="method" line="33" static="1">
			<f a="CellWidth:CellHeight:?Width:?Height:?AddLegend:?Alternate:?Color1:?Color2" v="::-1:-1:false:true:-1579290:-2501163">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Creates an FlxSprite of the given width and height filled with a checkerboard pattern.
	 * Each grid cell is the specified width and height, and alternates between two colors.
	 * If alternate is true each row of the pattern will be offset, for a proper checkerboard style. If false each row will be the same colour, creating a striped-pattern effect.
	 * So to create an 8x8 grid you'd call create(8,8)
	 * 
	 * @param	CellWidth		The grid cell width
	 * @param	CellHeight		The grid cell height
	 * @param	Width			The width of the FlxSprite. If -1 it will be the size of the game (FlxG.width)
	 * @param	Height			The height of the FlxSprite. If -1 it will be the size of the game (FlxG.height)
	 * @param	AddLegend		TODO
	 * @param	Alternate		Should the pattern alternate on each new row? Default true = checkerboard effect. False = vertical stripes
	 * @param	Color1			The first fill colour in 0xAARRGGBB format
	 * @param	Color2			The second fill colour in 0xAARRGGBB format
	 * @return	FlxSprite of given width/height</haxe_doc>
		</create>
		<overlay public="1" set="method" line="77" static="1">
			<f a="Sprite:CellWidth:CellHeight:?Width:?Height:?AddLegend:?Alternate:?Color1:?Color2" v=":::-1:-1:false:true:-1998067994:-1998989867">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Creates a checkerboard pattern of the given width/height and overlays it onto the given FlxSprite.
	 * Each grid cell is the specified width and height, and alternates between two colors.
	 * If alternate is true each row of the pattern will be offset, for a proper checkerboard style. If false each row will be the same colour, creating a striped-pattern effect.
	 * So to create an 8x8 grid you'd call create(8,8,
	 * 
	 * @param	Sprite			The FlxSprite you wish to draw the grid on-top of. This updates its pixels value, not just the current frame (don't use animated sprites!)
	 * @param	CellWidth		The grid cell width
	 * @param	CellHeight		The grid cell height
	 * @param	Width			The width of the FlxSprite. If -1 it will be the size of the game (FlxG.width)
	 * @param	Height			The height of the FlxSprite. If -1 it will be the size of the game (FlxG.height)
	 * @param	AddLegend		TODO
	 * @param	Alternate		Should the pattern alternate on each new row? Default true = checkerboard effect. False = vertical stripes
	 * @param	Color1			The first fill colour in 0xAARRGGBB format
	 * @param	Color2			The second fill colour in 0xAARRGGBB format
	 * @return	The modified source FlxSprite</haxe_doc>
		</overlay>
		<addLegend public="1" set="method" line="105" static="1"><f a="Sprite:CellWidth:CellHeight:?AxisX:?AxisY" v=":::true:true">
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="flixel.FlxSprite"/>
</f></addLegend>
		<createGrid public="1" set="method" line="130" static="1"><f a="CellWidth:CellHeight:Width:Height:Alternate:Color1:Color2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.display.BitmapData"/>
</f></createGrid>
		<haxe_doc>* FlxGridOverlay
 *  
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
	</class>
	<class path="flixel.addons.display.FlxMouseSpring" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxMouseSpring.hx">
		<sprite public="1"><c path="flixel.addons.display.FlxExtendedSprite"/></sprite>
		<tension public="1">
			<x path="Float"/>
			<haxe_doc>* The tension of the spring, smaller numbers create springs closer to the mouse pointer
	 * @default 0.1</haxe_doc>
		</tension>
		<friction public="1">
			<x path="Float"/>
			<haxe_doc>* The friction applied to the spring as it moves
	 * @default 0.95</haxe_doc>
		</friction>
		<gravity public="1">
			<x path="Float"/>
			<haxe_doc>* The gravity controls how far "down" the spring hangs (use a negative value for it to hang up!)
	 * @default 0</haxe_doc>
		</gravity>
		<_retainVelocity><x path="Bool"/></_retainVelocity>
		<_vx><x path="Float"/></_vx>
		<_vy><x path="Float"/></_vy>
		<_dx><x path="Float"/></_dx>
		<_dy><x path="Float"/></_dy>
		<_ax><x path="Float"/></_ax>
		<_ay><x path="Float"/></_ay>
		<update public="1" set="method" line="57">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the spring physics and repositions the sprite</haxe_doc>
		</update>
		<reset public="1" set="method" line="79">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the internal spring physics</haxe_doc>
		</reset>
		<new public="1" set="method" line="45">
			<f a="Sprite:?RetainVelocity:?Tension:?Friction:?Gravity" v=":false:0.1f:0.95f:0">
				<c path="flixel.addons.display.FlxExtendedSprite"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a spring between the mouse and a FlxExtendedSprite.
	 * 
	 * @param	Sprite			The FlxExtendedSprite to which this spring is attached
	 * @param	RetainVelocity	True to retain the velocity of the spring when the mouse is released, or false to clear it
	 * @param	Tension			The tension of the spring, smaller numbers create springs closer to the mouse pointer
	 * @param	Friction		The friction applied to the spring as it moves
	 * @param	Gravity			The gravity controls how far "down" the spring hangs (use a negative value for it to hang up!)</haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.display.FlxNestedSprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxNestedSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<relativeX public="1">
			<x path="Float"/>
			<haxe_doc>* X position of this sprite relative to parent, 0 by default</haxe_doc>
		</relativeX>
		<relativeY public="1">
			<x path="Float"/>
			<haxe_doc>* Y position of this sprite relative to parent, 0 by default</haxe_doc>
		</relativeY>
		<relativeAngle public="1">
			<x path="Float"/>
			<haxe_doc>* Angle of this sprite relative to parent</haxe_doc>
		</relativeAngle>
		<relativeAngularVelocity public="1">
			<x path="Float"/>
			<haxe_doc>* Angular velocity relative to parent sprite</haxe_doc>
		</relativeAngularVelocity>
		<relativeAngularAcceleration public="1">
			<x path="Float"/>
			<haxe_doc>* Angular acceleration relative to parent sprite</haxe_doc>
		</relativeAngularAcceleration>
		<relativeAlpha public="1"><x path="Float"/></relativeAlpha>
		<relativeScale public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Scale of this sprite relative to parent</haxe_doc>
		</relativeScale>
		<relativeVelocity public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Velocity relative to parent sprite</haxe_doc>
		</relativeVelocity>
		<relativeAcceleration public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Acceleration relative to parent sprite</haxe_doc>
		</relativeAcceleration>
		<children public="1" set="null">
			<c path="Array"><c path="flixel.addons.display.FlxNestedSprite"/></c>
			<haxe_doc>* All FlxNestedSprites in this list.</haxe_doc>
		</children>
		<count public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Amount of Graphics in this list.</haxe_doc>
		</count>
		<_parentRed><x path="Float"/></_parentRed>
		<_parentGreen><x path="Float"/></_parentGreen>
		<_parentBlue><x path="Float"/></_parentBlue>
		<destroy public="1" set="method" line="90" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* WARNING: This will remove this sprite entirely. Use kill() if you 
	 * want to disable it temporarily only and reset() it later to revive it.
	 * Used to clean up memory.</haxe_doc>
		</destroy>
		<add public="1" set="method" line="115">
			<f a="Child">
				<c path="flixel.addons.display.FlxNestedSprite"/>
				<c path="flixel.addons.display.FlxNestedSprite"/>
			</f>
			<haxe_doc>* Adds the FlxNestedSprite to the children list.
	 * 
	 * @param	Child	The FlxNestedSprite to add.
	 * @return	The added FlxNestedSprite.</haxe_doc>
		</add>
		<remove public="1" set="method" line="146">
			<f a="Child">
				<c path="flixel.addons.display.FlxNestedSprite"/>
				<c path="flixel.addons.display.FlxNestedSprite"/>
			</f>
			<haxe_doc>* Removes the FlxNestedSprite from the children list.
	 * 
	 * @param	Child	The FlxNestedSprite to remove.
	 * @return	The removed FlxNestedSprite.</haxe_doc>
		</remove>
		<removeAt public="1" set="method" line="163">
			<f a="?Index" v="0">
				<x path="Int"/>
				<c path="flixel.addons.display.FlxNestedSprite"/>
			</f>
			<haxe_doc>* Removes the FlxNestedSprite from the position in the children list.
	 * 
	 * @param	Index	Index to remove.</haxe_doc>
		</removeAt>
		<removeAll public="1" set="method" line="176">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all children sprites from this sprite.</haxe_doc>
		</removeAll>
		<preUpdate public="1" set="method" line="184"><f a=""><x path="Void"/></f></preUpdate>
		<update public="1" set="method" line="202" override="1"><f a=""><x path="Void"/></f></update>
		<postUpdate public="1" set="method" line="217"><f a=""><x path="Void"/></f></postUpdate>
		<draw public="1" set="method" line="293" override="1"><f a=""><x path="Void"/></f></draw>
		<drawDebug public="1" set="method" line="307" override="1"><f a=""><x path="Void"/></f></drawDebug>
		<set_alpha set="method" line="321" override="1"><f a="Alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_color set="method" line="382" override="1"><f a="Color">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<set_facing set="method" line="452" override="1"><f a="Direction">
	<x path="Int"/>
	<x path="Int"/>
</f></set_facing>
		<get_count get="inline" set="null" line="468"><f a=""><x path="Int"/></f></get_count>
		<new public="1" set="method" line="76"><f a="?X:?Y:?SimpleGraphic" v="0:0:null">
	<x path="Float"/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Some sort of DisplayObjectContainer but very limited.
 * It can contain only other FlxNestedSprites.
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.addons.display.FlxSkewedSprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxSkewedSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<skew public="1" set="null"><c path="flixel.util.FlxPoint"/></skew>
		<transformMatrix public="1" set="null">
			<c path="flash.geom.Matrix"/>
			<haxe_doc>* Tranformation matrix for this sprite.
	 * Used only when matrixExposed is set to true</haxe_doc>
		</transformMatrix>
		<matrixExposed public="1">
			<x path="Bool"/>
			<haxe_doc>* Bool flag showing whether transformMatrix is used for rendering or not.
	 * False by default, which means that transformMatrix isn't used for rendering</haxe_doc>
		</matrixExposed>
		<_skewMatrix>
			<c path="flash.geom.Matrix"/>
			<haxe_doc>* Internal helper matrix object. Used for rendering calculations when matrixExposed is set to false</haxe_doc>
		</_skewMatrix>
		<destroy public="1" set="method" line="53" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* WARNING: This will remove this sprite entirely. Use kill() if you 
	 * want to disable it temporarily only and reset() it later to revive it.
	 * Used to clean up memory.</haxe_doc>
		</destroy>
		<draw public="1" set="method" line="62" override="1"><f a=""><x path="Void"/></f></draw>
		<updateSkewMatrix set="method" line="205"><f a=""><x path="Void"/></f></updateSkewMatrix>
		<isSimpleRender public="1" set="method" line="218" override="1"><f a=""><x path="Bool"/></f></isSimpleRender>
		<new public="1" set="method" line="39"><f a="?X:?Y:?SimpleGraphic" v="0:0:null">
	<x path="Float"/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.addons.display.FlxSpriteAniRot" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxSpriteAniRot.hx">
		<extends path="flixel.FlxSprite"/>
		<cached><c path="Array"><c path="flixel.util.loaders.CachedGraphics"/></c></cached>
		<framesCache><c path="Array"><c path="flixel.system.layer.frames.FlxSpriteFrames"/></c></framesCache>
		<rotations><x path="Float"/></rotations>
		<angleIndex><x path="Int"/></angleIndex>
		<destroy public="1" set="method" line="47" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="55" override="1"><f a=""><x path="Void"/></f></update>
		<calcFrame set="method" line="81" override="1">
			<f a="?RunOnCpp" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function to update the current animation frame.
	 * 
	 * @param	RunOnCpp	Whether the frame should also be recalculated if we're on a non-flash target</haxe_doc>
		</calcFrame>
		<new public="1" set="method" line="26"><f a="AnimatedGraphic:Rotations:?X:?Y" v="::0:0">
	<d/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Creating animated and rotated sprite from an un-rotated animated image. 
 * THE ANIMATION MUST CONTAIN ONLY ONE ROW OF SPRITE FRAMES.
 * 
 * @version 1.0 - November 8th 2011
 * @link http://www.gameonaut.com
 * @author Simon Etienne Rozner / Gameonaut.com, ported to Haxe by Sam Batista</haxe_doc>
	</class>
	<class path="flixel.addons.display._FlxStarField.FlxStarField" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxStarField.hx" private="1" module="flixel.addons.display.FlxStarField">
		<extends path="flixel.FlxSprite"/>
		<bgColor public="1"><x path="Int"/></bgColor>
		<_stars><c path="Array"><c path="flixel.addons.display._FlxStarField.FlxStar"/></c></_stars>
		<_depthColors><c path="Array"><x path="Int"/></c></_depthColors>
		<_minSpeed><x path="Float"/></_minSpeed>
		<_maxSpeed><x path="Float"/></_maxSpeed>
		<destroy public="1" set="method" line="135" override="1"><f a=""><x path="Void"/></f></destroy>
		<draw public="1" set="method" line="146" override="1"><f a=""><x path="Void"/></f></draw>
		<setStarDepthColors public="1" get="inline" set="null" line="169">
			<f a="Depth:?LowestColor:?HighestColor" v=":267933784:-723724">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the number of layers (depth) and colors used for each layer of the starfield.
	 * 
	 * @param	Depth			Number of depths (for a 2D starfield the default is 5)
	 * @param	LowestColor		The color given to the slowest stars, typically the darker colour
	 * @param	HighestColor	The color given to the fastest stars, typically the brighter colour</haxe_doc>
		</setStarDepthColors>
		<setStarSpeed public="1" set="method" line="174"><f a="Min:Max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setStarSpeed>
		<new public="1" set="method" line="115"><f a="X:Y:Width:Height:StarAmount">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.addons.display.FlxStarField2D" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxStarField.hx" module="flixel.addons.display.FlxStarField">
		<extends path="flixel.addons.display._FlxStarField.FlxStarField"/>
		<starVelocityOffset public="1" set="null"><c path="flixel.util.FlxPoint"/></starVelocityOffset>
		<destroy public="1" set="method" line="27" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="33" override="1"><f a=""><x path="Void"/></f></update>
		<new public="1" set="method" line="19"><f a="?X:?Y:?Width:?Height:?StarAmount" v="0:0:0:0:300">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.addons.display.FlxStarField3D" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxStarField.hx" module="flixel.addons.display.FlxStarField">
		<extends path="flixel.addons.display._FlxStarField.FlxStarField"/>
		<center public="1" set="null"><c path="flixel.util.FlxPoint"/></center>
		<destroy public="1" set="method" line="76" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="82" override="1"><f a=""><x path="Void"/></f></update>
		<new public="1" set="method" line="68"><f a="?X:?Y:?Width:?Height:?StarAmount" v="0:0:0:0:300">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.addons.display._FlxStarField.FlxStar" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxStarField.hx" private="1" module="flixel.addons.display.FlxStarField">
		<index public="1"><x path="Int"/></index>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<d public="1"><x path="Float"/></d>
		<r public="1"><x path="Float"/></r>
		<speed public="1"><x path="Float"/></speed>
		<new public="1" set="method" line="195"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.addons.display.FlxZoomCamera" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/FlxZoomCamera.hx">
		<extends path="flixel.FlxCamera"/>
		<targetZoom public="1">
			<x path="Float"/>
			<haxe_doc>* Tell the camera to LERP here eventually</haxe_doc>
		</targetZoom>
		<_zoomSpeed>
			<x path="Float"/>
			<haxe_doc>* This number is pretty arbitrary, make sure it's greater than zero!</haxe_doc>
		</_zoomSpeed>
		<_zoomMargin>
			<x path="Float"/>
			<haxe_doc>* Determines how far to "look ahead" when the target is near the edge of the camera's bounds
	 * 0 = no effect, 1 = huge effect</haxe_doc>
		</_zoomMargin>
		<update public="1" set="method" line="41" override="1"><f a=""><x path="Void"/></f></update>
		<alignCamera set="method" line="66">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Align the camera x and y to center on the target 
	 * that it's following when zoomed in
	 * 
	 * This took many guesses!</haxe_doc>
		</alignCamera>
		<clamp set="method" line="98">
			<f a="Value:Min:Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given a value passed in, returns a Number between min and max (inclusive)
	 * 
	 * @param 	Value	The Number you want to evaluate
	 * @param 	Min		The minimum number that should be returned
	 * @param 	Max		The maximum number that should be returned
	 * @return 	Value clamped between min and max
	 *</haxe_doc>
		</clamp>
		<setScale public="1" set="method" line="112" override="1"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setScale>
		<new public="1" set="method" line="32"><f a="X:Y:Width:Height:?Zoom" v="::::0">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ZoomCamera: A FlxCamera that centers its zoom on the target that it follows 
 * Flixel version: 2.5+
 * 
 * @link http://www.kwarp.com
 * @author greglieberman
 * @email greg@kwarp.com</haxe_doc>
	</class>
	<class path="flixel.addons.display.shapes.FlxShape" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShape.hx">
		<extends path="flixel.FlxSprite"/>
		<lineStyle public="1" set="accessor"><t path="flixel.util.LineStyle"/></lineStyle>
		<fillStyle public="1" set="accessor"><t path="flixel.util.FillStyle"/></fillStyle>
		<shape_id public="1"><c path="String"/></shape_id>
		<shapeDirty public="1"><x path="Bool"/></shapeDirty>
		<_drawStyle><t path="flixel.util.DrawStyle"/></_drawStyle>
		<destroy public="1" set="method" line="70" override="1"><f a=""><x path="Void"/></f></destroy>
		<drawSpecificShape public="1" set="method" line="77"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<redrawShape public="1" set="method" line="83"><f a=""><x path="Void"/></f></redrawShape>
		<draw public="1" set="method" line="95" override="1"><f a=""><x path="Void"/></f></draw>
		<fixBoundaries set="method" line="111">
			<f a="trueWidth:trueHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Fixes boundaries so that the sprite's bbox & origin line up with the underlying geometric object's
	 * 
	 * @param	trueWidth	width of geometric object (ignoring strokes, etc)
	 * @param	trueHeight	height of geometric object (ignoring strokes, etc)]]></haxe_doc>
		</fixBoundaries>
		<set_lineStyle get="inline" set="null" line="125"><f a="ls">
	<t path="flixel.util.LineStyle"/>
	<t path="flixel.util.LineStyle"/>
</f></set_lineStyle>
		<set_fillStyle get="inline" set="null" line="132"><f a="fs">
	<t path="flixel.util.FillStyle"/>
	<t path="flixel.util.FillStyle"/>
</f></set_fillStyle>
		<getStrokeOffsetMatrix set="method" line="139"><f a="matrix">
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.Matrix"/>
</f></getStrokeOffsetMatrix>
		<new public="1" set="method" line="40">
			<f a="X:Y:CanvasWidth:CanvasHeight:LineStyle_:FillStyle_:?TrueWidth:?TrueHeight" v="::::::0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* (You should never instantiate this directly, only call it as a super)
	 * Creates a Shape wrapped in a FlxSprite
	 * 
	 * @param	X				X location
	 * @param	Y				Y location
	 * @param	CanvasWidth		Width of pixel canvas
	 * @param	CanvasHeight	Height of pixel canvas
	 * @param	LineStyle_		Drawing style for strokes -- see flixel.util.FlxSpriteUtil.LineStyle
	 * @param	FillStyle_		Drawing style for fills -- see flixel.util.FlxSpriteUtil.FillStyle
	 * @param	TrueWidth		Width of raw unstyled geometric object, ignoring line thickness, filters, etc
	 * @param	TrueHeight		Height of raw unstyled geometric object, ignoring line thickness, filters, etc</haxe_doc>
		</new>
		<haxe_doc>* A convenience class for wrapping vector shape drawing in FlxSprites, all ready to go.
 * Don't use this class by itself -- use things like FlxLine, FlxCircle, that extend it
 * @author Lars A. Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.display.shapes.FlxShapeArrow" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeArrow.hx">
		<extends path="flixel.addons.display.shapes.FlxShape"/>
		<outlineStyle public="1" set="accessor"><t path="flixel.util.LineStyle"/></outlineStyle>
		<arrowSize public="1" set="accessor"><x path="Float"/></arrowSize>
		<point public="1" set="null"><c path="flixel.util.FlxPoint"/></point>
		<point2 public="1" set="null"><c path="flixel.util.FlxPoint"/></point2>
		<_matrix2><c path="flash.geom.Matrix"/></_matrix2>
		<_vertices><c path="Array"><c path="flixel.util.FlxPoint"/></c></_vertices>
		<destroy public="1" set="method" line="64" override="1"><f a=""><x path="Void"/></f></destroy>
		<drawSpecificShape public="1" set="method" line="71" override="1"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<setPointCallback get="inline" set="null" line="114"><f a="p">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></setPointCallback>
		<set_arrowSize get="inline" set="null" line="119"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_arrowSize>
		<set_outlineStyle get="inline" set="null" line="126"><f a="ls">
	<t path="flixel.util.LineStyle"/>
	<t path="flixel.util.LineStyle"/>
</f></set_outlineStyle>
		<new public="1" set="method" line="32">
			<f a="X:Y:Start:End:ArrowSize:LineStyle_:?OutlineStyle_" v="::::::null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.LineStyle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a line with an arrowhead on the end point
	 * 
	 * @param	X				X location of the sprite canvas
	 * @param	Y				Y location of the sprite canvas
	 * @param	Start			starting point of the arrow
	 * @param	End				ending point of the arrow (this is where the arrowhead is)
	 * @param	ArrowSize		how big the arrow is (height)
	 * @param	LineStyle_		line style for the line and arrowhead
	 * @param	OutlineStyle_	line style for the outer line (optional)</haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.display.shapes.FlxShapeBox" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeBox.hx">
		<extends path="flixel.addons.display.shapes.FlxShape"/>
		<shapeWidth public="1" set="accessor"><x path="Float"/></shapeWidth>
		<shapeHeight public="1" set="accessor"><x path="Float"/></shapeHeight>
		<drawSpecificShape public="1" set="method" line="38" override="1"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<set_shapeWidth get="inline" set="null" line="43"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_shapeWidth>
		<set_shapeHeight get="inline" set="null" line="50"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_shapeHeight>
		<new public="1" set="method" line="19">
			<f a="X:Y:W:H:LineStyle_:FillStyle_">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a FlxSprite with a circle drawn on top of it. 
	 * X/Y is where the SPRITE is, the circle's upper-left</haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.display.shapes.FlxShapeCircle" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeCircle.hx">
		<extends path="flixel.addons.display.shapes.FlxShape"/>
		<radius public="1" set="accessor"><x path="Float"/></radius>
		<drawSpecificShape public="1" get="inline" set="null" line="36" override="1"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<set_radius get="inline" set="null" line="41"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<new public="1" set="method" line="14">
			<f a="X:Y:Radius:LineStyle_:FillStyle_">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a FlxSprite with a circle drawn on top of it. 
	 * X/Y is where the SPRITE is, the circle's upper-left</haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.display.shapes.FlxShapeCross" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeCross.hx">
		<extends path="flixel.addons.display.shapes.FlxShape"/>
		<horizontalLength public="1" set="accessor"><x path="Float"/></horizontalLength>
		<horizontalSize public="1" set="accessor"><x path="Float"/></horizontalSize>
		<verticalLength public="1" set="accessor"><x path="Float"/></verticalLength>
		<verticalSize public="1" set="accessor"><x path="Float"/></verticalSize>
		<intersectionV public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Sets where the two arms intersect vertically. 
	 * value (0-1): 0 makes a T, 1 makes inverted T, 0.5 makes a +; (if intersectionH is 0.5)</haxe_doc>
		</intersectionV>
		<intersectionH public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Sets where the two arms intersect horizontally. 
	 * value (0-1): 0 makes a |-, 1 makes a -|, 0.5 makes a +; (if intersectionV is 0.5)</haxe_doc>
		</intersectionH>
		<vertices><c path="Array"><c path="flixel.util.FlxPoint"/></c></vertices>
		<destroy public="1" set="method" line="57" override="1"><f a=""><x path="Void"/></f></destroy>
		<drawSpecificShape public="1" set="method" line="68" override="1"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<set_horizontalLength get="inline" set="null" line="140"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_horizontalLength>
		<set_horizontalSize get="inline" set="null" line="147"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_horizontalSize>
		<set_verticalLength get="inline" set="null" line="154"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_verticalLength>
		<set_verticalSize get="inline" set="null" line="161"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_verticalSize>
		<set_intersectionV set="method" line="168"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_intersectionV>
		<set_intersectionH set="method" line="177"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_intersectionH>
		<new public="1" set="method" line="33"><f a="X:Y:HLength:HSize:VLength:VSize:IntersectionH:IntersectionV:LineStyle_:FillStyle_">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="flixel.util.LineStyle"/>
	<t path="flixel.util.FillStyle"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A cross shape drawn onto a FlxSprite. Useful for tactics games and stuff!</haxe_doc>
	</class>
	<class path="flixel.addons.display.shapes.FlxShapeDonut" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeDonut.hx">
		<extends path="flixel.addons.display.shapes.FlxShape"/>
		<radius_out public="1" set="accessor"><x path="Float"/></radius_out>
		<radius_in public="1" set="accessor"><x path="Float"/></radius_in>
		<drawSpecificShape public="1" set="method" line="43" override="1"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<set_radius_out get="inline" set="null" line="55"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius_out>
		<set_radius_in get="inline" set="null" line="62"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius_in>
		<new public="1" set="method" line="20">
			<f a="X:Y:RadiusOut:RadiusIn:LineStyle_:FillStyle_">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a FlxSprite with a donut drawn on top of it. 
	 * X/Y is where the SPRITE is, the donut's upper-left</haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.display.shapes.FlxShapeDoubleCircle" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeDoubleCircle.hx">
		<extends path="flixel.addons.display.shapes.FlxShapeDonut"/>
		<drawSpecificShape public="1" set="method" line="17" override="1"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<new public="1" set="method" line="12">
			<f a="X:Y:RadiusOut:RadiusIn:LineStyle_:FillStyle_">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a FlxSprite with a double-circle drawn on top of it. 
	 * X/Y is where the SPRITE is, the double-circle's upper-left</haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.display.shapes.FlxShapeGrid" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeGrid.hx">
		<extends path="flixel.addons.display.shapes.FlxShapeBox"/>
		<cellWidth public="1" set="accessor"><x path="Float"/></cellWidth>
		<cellHeight public="1" set="accessor"><x path="Float"/></cellHeight>
		<cellsWide public="1" set="accessor"><x path="Int"/></cellsWide>
		<cellsTall public="1" set="accessor"><x path="Int"/></cellsTall>
		<drawSpecificShape public="1" set="method" line="30" override="1"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<set_cellWidth get="inline" set="null" line="47"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cellWidth>
		<set_cellHeight get="inline" set="null" line="54"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cellHeight>
		<set_cellsWide get="inline" set="null" line="61"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_cellsWide>
		<set_cellsTall get="inline" set="null" line="68"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_cellsTall>
		<new public="1" set="method" line="17">
			<f a="X:Y:CellWidth:CellHeight:CellsWide:CellsTall:LineStyle_:FillStyle_">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a FlxSprite with a grid drawn on top of it. 
	 * X/Y is where the SPRITE is, the grid upper-left</haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.display.shapes.FlxShapeLine" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeLine.hx">
		<extends path="flixel.addons.display.shapes.FlxShape"/>
		<point public="1" set="null"><c path="flixel.util.FlxPoint"/></point>
		<point2 public="1" set="null"><c path="flixel.util.FlxPoint"/></point2>
		<drawSpecificShape public="1" set="method" line="52" override="1"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<setPoint get="inline" set="null" line="57"><f a="p">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></setPoint>
		<new public="1" set="method" line="23">
			<f a="X:Y:a:b:LineStyle_">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<t path="flixel.util.LineStyle"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a FlxSprite with a line drawn on top of it. X/Y is where the SPRITE is, and points a&b are RELATIVE to this object's origin. 
	 * Points with negative values will not draw correctly since they'll appear beyond the sprite's canvas.
	 * 
	 * @param	X x position of the canvas
	 * @param	Y y position of the canvas
	 * @param	a first point in the line (relative to the sprite's origin)
	 * @param	b second point in the line (relative to the sprite's origin)
	 * @param	LineStyle_]]></haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.display.shapes.FlxShapeLightning" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeLightning.hx">
		<extends path="flixel.addons.display.shapes.FlxShapeLine"/>
		<lightningStyle public="1" set="accessor"><t path="flixel.addons.display.shapes.LightningStyle"/></lightningStyle>
		<halo_cols><c path="Array"><d/></c></halo_cols>
		<detail><x path="Float"/></detail>
		<magnitude><x path="Float"/></magnitude>
		<list_segs><c path="Array"><c path="flixel.addons.display.shapes.LineSegment"/></c></list_segs>
		<list_branch><c path="Array"><c path="flixel.addons.display.shapes.LineSegment"/></c></list_branch>
		<filterDirty><x path="Bool"/></filterDirty>
		<addSegment get="inline" set="null" line="75"><f a="A:B">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></addSegment>
		<calculate set="method" line="80"><f a="A:B:Displacement:Iteration">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></calculate>
		<set_lightningStyle get="inline" set="null" line="101"><f a="Style">
	<t path="flixel.addons.display.shapes.LightningStyle"/>
	<t path="flixel.addons.display.shapes.LightningStyle"/>
</f></set_lightningStyle>
		<copyLineStyle set="method" line="108"><f a="ls">
	<t path="flixel.util.LineStyle"/>
	<t path="flixel.util.LineStyle"/>
</f></copyLineStyle>
		<drawSpecificShape public="1" set="method" line="123" override="1"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<fixBoundaries get="inline" set="null" line="195" override="1"><f a="trueWidth:trueHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fixBoundaries>
		<draw public="1" set="method" line="201" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="48">
			<f a="X:Y:A:B:Style:?UseDefaults" v=":::::true">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<t path="flixel.addons.display.shapes.LightningStyle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a lightning bolt!
	 * 
	 * @param	X			X location of the sprite canvas
	 * @param	Y			Y location of the sprite canvas
	 * @param	A			start point, relative to canvas
	 * @param	B			end point, relative to canvas
	 * @param	Style		LightningStyle object
	 * @param	UseDefaults	use default settings to fill in style gaps?</haxe_doc>
		</new>
		<haxe_doc>* This creates a Lightning bolt drawn on top of a FlxSprite object. 
 * 
 * TODO:
 * I'm not currently adding enough border room to properly account for the filter effect</haxe_doc>
	</class>
	<typedef path="flixel.addons.display.shapes.LightningStyle" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeLightning.hx" module="flixel.addons.display.shapes.FlxShapeLightning"><a>
	<thickness>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</thickness>
	<halo_colors>
		<c path="Array"><x path="Int"/></c>
		<meta><m n=":optional"/></meta>
	</halo_colors>
	<displacement>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</displacement>
	<detail>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</detail>
	<color>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</color>
</a></typedef>
	<class path="flixel.addons.display.shapes.LineSegment" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeLightning.hx" module="flixel.addons.display.shapes.FlxShapeLightning">
		<a public="1" set="null"><c path="flixel.util.FlxPoint"/></a>
		<b public="1" set="null"><c path="flixel.util.FlxPoint"/></b>
		<copy public="1" get="inline" set="null" line="274"><f a=""><c path="flixel.addons.display.shapes.LineSegment"/></f></copy>
		<new public="1" set="method" line="266"><f a="A:B">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Helper for FlxShapeLightning
 * @author Lars A. Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.display.shapes.FlxShapeSquareDonut" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/display/shapes/FlxShapeSquareDonut.hx">
		<extends path="flixel.addons.display.shapes.FlxShape"/>
		<radius_out public="1" set="accessor"><x path="Float"/></radius_out>
		<radius_in public="1" set="accessor"><x path="Float"/></radius_in>
		<drawSpecificShape public="1" set="method" line="42" override="1"><f a="?matrix" v="null">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></drawSpecificShape>
		<set_radius_out get="inline" set="null" line="54"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius_out>
		<set_radius_in get="inline" set="null" line="61"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius_in>
		<new public="1" set="method" line="19">
			<f a="X:Y:RadiusOut:RadiusIn:LineStyle_:FillStyle_">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a FlxSprite with a square donut drawn on top of it. 
	 * X/Y is where the SPRITE is, the square's upper-left</haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.editors.ogmo.FlxOgmoLoader" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/ogmo/FlxOgmoLoader.hx">
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<_xml><c path="Xml"/></_xml>
		<_fastXml><c path="haxe.xml.Fast"/></_fastXml>
		<loadTilemap public="1" set="method" line="68">
			<f a="TileGraphic:?TileWidth:?TileHeight:?TileLayer" v=":16:16:'tiles'">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="flixel.tile.FlxTilemap"/>
			</f>
			<haxe_doc>* Load a Tilemap. Tile layers must have the Export Mode set to "CSV".
	* Collision with entities should be handled with the reference returned from this function. Here's a tip:
	* 
		// IMPORTANT: Always collide the map with objects, not the other way around. 
		//			  This prevents odd collision errors (collision separation code off by 1 px).
		FlxG.collide(map, obj, notifyCallback);
	* 
	* @param	TileGraphic		A String or Class representing the location of the image asset for the tilemap.
	* @param	TileWidth		The width of each individual tile.
	* @param	TileHeight		The height of each individual tile.
	* @param	TileLayer		The name of the layer the tilemap data is stored in Ogmo editor, usually "tiles" or "stage".
	* @return	A FlxTilemap, where you can collide your entities against.</haxe_doc>
		</loadTilemap>
		<loadEntities public="1" set="method" line="95">
			<f a="EntityLoadCallback:?EntityLayer" v=":'entities'">
				<f a=":">
					<c path="String"/>
					<c path="Xml"/>
					<x path="Void"/>
				</f>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Parse every entity in the specified layer and call a function that will spawn game objects based on their name. 
	* Optional data can be read from the xml object, here's an example that reads the position of an object:
	* 
		public function loadEntity( type:String, data:Xml ):Void
		{
			switch (type.toLowerCase())
			{
			case "player":
				player.x = Std.parseFloat(data.get("x"));
				player.y = Std.parseFloat(data.get("y"));
			default:
				throw "Unrecognized actor type '" + type + "' detected in level file.";
			}
		}
	* 
	* @param	EntityLoadCallback		A function that takes in the following parameters (name:String, data:Xml):Void (returns Void) that spawns entities based on their name.
	* @param	EntityLayer				The name of the layer the entities are stored in Ogmo editor. Usually "entities" or "actors"</haxe_doc>
		</loadEntities>
		<loadRectangles public="1" set="method" line="113">
			<f a="RectLoadCallback:?RectLayer" v=":'rectangles'">
				<f a="">
					<c path="flixel.util.FlxRect"/>
					<x path="Void"/>
				</f>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Parse every 'rect' in the specified layer and call a function to do something based on each rectangle.
	 * Useful for setting up zones or regions in your game that can be filled in procedurally.
	 * 
	 * @param	RectLoadCallback	A function that takes in the Rectangle object and returns Void.
	 * @param	RectLayer			The name of the layer which contains 'rect' objects.</haxe_doc>
		</loadRectangles>
		<new public="1" set="method" line="29">
			<f a="LevelData">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new instance of OgmoLevelLoader and prepares the XML level data to be loaded.
	 * This object can either be contained or ovewritten. 
	 * 
	 * IMPORTANT: -> Tile layers must have the Export Mode set to "CSV".
	 * 			  -> First tile in spritesheet must be blank or debug. It will never get drawn so don't place them in Ogmo! 
	 * 			  	 (This is needed to support many other editors that use index 0 as empty.)
	 * 
	 * @param	LevelData	A String or Class representing the location of xml level data.]]></haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.editors.spine.FlxSpine" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/spine/FlxSpine.hx">
		<extends path="flixel.FlxSprite"/>
		<readSkeletonData public="1" set="method" line="40" static="1">
			<f a="DataName:DataPath:?Scale" v="::1">
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<c path="spinehx.SkeletonData"/>
			</f>
			<haxe_doc>* Get Spine animation data.
	 * 
	 * @param	DataName	The name of the animation data files exported from Spine (.atlas .json .png).
	 * @param	DataPath	The directory these files are located at
	 * @param	Scale		Animation scale</haxe_doc>
		</readSkeletonData>
		<skeleton public="1"><c path="spinehx.Skeleton"/></skeleton>
		<skeletonData public="1"><c path="spinehx.SkeletonData"/></skeletonData>
		<state public="1"><c path="spinehx.AnimationState"/></state>
		<stateData public="1"><c path="spinehx.AnimationStateData"/></stateData>
		<collider public="1"><c path="flixel.FlxObject"/></collider>
		<wrapperAngles public="1"><c path="haxe.ds.ObjectMap">
	<c path="spinehx.attachments.RegionAttachment"/>
	<x path="Float"/>
</c></wrapperAngles>
		<cachedSprites public="1"><c path="haxe.ds.ObjectMap">
	<c path="spinehx.attachments.RegionAttachment"/>
	<c path="flixel.FlxSprite"/>
</c></cachedSprites>
		<destroy public="1" set="method" line="91" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="118" override="1"><f a=""><x path="Void"/></f></update>
		<draw public="1" set="method" line="130" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by game loop, updates then blits or renders current frame of animation to the screen</haxe_doc>
		</draw>
		<drawDebugOnCamera public="1" set="method" line="182" override="1"><f a="Camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawDebugOnCamera>
		<get public="1" set="method" line="202"><f a="regionAttachment">
	<c path="spinehx.attachments.RegionAttachment"/>
	<c path="flixel.FlxSprite"/>
</f></get>
		<set_flipX set="method" line="239" override="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipX>
		<set_flipY set="method" line="247" override="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipY>
		<new public="1" set="method" line="69">
			<f a="skeletonData:?X:?Y" v=":0:0">
				<c path="spinehx.SkeletonData"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new Spine Sprite.
	 * @param	skeletonData	Animation data from Spine (.json .skel .png), get it like this: FlxSpineSprite.readSkeletonData( "mySpriteData", "assets/" );
	 * @param	X				The initial X position of the sprite.
	 * @param	Y				The initial Y position of the sprite.
	 * @param	Width			The maximum width of this sprite (avoid very large sprites since they are performance intensive).
	 * @param	Height			The maximum height of this sprite (avoid very large sprites since they are performance intensive).</haxe_doc>
		</new>
		<haxe_doc>* A Sprite that can play animations exported by Spine (http://esotericsoftware.com/)
 * 
 * @author Big thanks to the work on spinehx by nitrobin (https://github.com/nitrobin/spinehx).
 * HaxeFlixel Port by: Sasha (Beeblerox), Sam Batista (crazysam), Kuris Makku (xraven13)</haxe_doc>
	</class>
	<class path="spinehx.atlas.Texture" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/atlas/Texture.hx" interface="1">
		<getWidth public="1" set="method"><f a=""><x path="Int"/></f></getWidth>
		<getHeight public="1" set="method"><f a=""><x path="Int"/></f></getHeight>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<setWrap public="1" set="method"><f a="uWrap:vWrap">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setWrap>
		<setFilter public="1" set="method"><f a="minFilter:magFilter">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setFilter>
	</class>
	<class path="flixel.addons.editors.spine.texture.FlixelTexture" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/spine/texture/FlixelTexture.hx">
		<implements path="spinehx.atlas.Texture"/>
		<bd public="1"><c path="flash.display.BitmapData"/></bd>
		<key public="1"><c path="String"/></key>
		<getWidth public="1" set="method" line="20"><f a=""><x path="Int"/></f></getWidth>
		<getHeight public="1" set="method" line="25"><f a=""><x path="Int"/></f></getHeight>
		<dispose public="1" set="method" line="30"><f a=""><x path="Void"/></f></dispose>
		<setWrap public="1" set="method" line="37"><f a="uWrap:vWrap">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setWrap>
		<setFilter public="1" set="method" line="38"><f a="minFilter:magFilter">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setFilter>
		<new public="1" set="method" line="13"><f a="textureFile">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.atlas.TextureLoader" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/atlas/TextureLoader.hx" interface="1"><loadTexture public="1" set="method"><f a="textureFile:format:useMipMaps">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="spinehx.atlas.Texture"/>
</f></loadTexture></class>
	<class path="flixel.addons.editors.spine.texture.FlixelTextureLoader" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/spine/texture/FlixelTextureLoader.hx">
		<implements path="spinehx.atlas.TextureLoader"/>
		<loadTexture public="1" set="method" line="10"><f a="textureFile:format:useMipMaps">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="spinehx.atlas.Texture"/>
</f></loadTexture>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.addons.editors.tiled.TiledLayer" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/tiled/TiledLayer.hx">
		<BASE64_CHARS get="inline" set="null" line="26" static="1"><c path="String"/></BASE64_CHARS>
		<base64ToByteArray set="method" line="97" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.utils.ByteArray"/>
</f></base64ToByteArray>
		<map public="1"><c path="flixel.addons.editors.tiled.TiledMap"/></map>
		<name public="1"><c path="String"/></name>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<opacity public="1"><x path="Float"/></opacity>
		<visible public="1"><x path="Bool"/></visible>
		<properties public="1"><c path="flixel.addons.editors.tiled.TiledPropertySet"/></properties>
		<tiles public="1"><c path="Array"><c path="flixel.addons.editors.tiled.TiledTile"/></c></tiles>
		<_xmlData><c path="haxe.xml.Fast"/></_xmlData>
		<getByteArrayData set="method" line="60"><f a=""><c path="flash.utils.ByteArray"/></f></getByteArrayData>
		<resolveTile set="method" line="149"><f a="GlobalTileID">
	<x path="Int"/>
	<x path="Int"/>
</f></resolveTile>
		<resolveCsvTiles set="method" line="173">
			<f a="csvData">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Function that tries to resolve the tiles gid in the csv data.
	 * TODO: It fails because I can't find a function to parse an unsigned int from a string :(
	 * @param	csvData		The csv string to resolve
	 * @return	The csv string resolved</haxe_doc>
		</resolveCsvTiles>
		<csvData public="1" get="accessor" set="null"><c path="String"/></csvData>
		<get_csvData set="method" line="198"><f a=""><c path="String"/></f></get_csvData>
		<tileArray public="1" get="accessor" set="null"><c path="Array"><x path="Int"/></c></tileArray>
		<get_tileArray set="method" line="216"><f a=""><c path="Array"><x path="Int"/></c></f></get_tileArray>
		<new public="1" set="method" line="30"><f a="Source:Parent">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.editors.tiled.TiledMap"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Copyright (c) 2013 by Samuel Batista
 * (original by Matt Tuttle based on Thomas Jahn's. Haxe port by Adrien Fischer)
 * This content is released under the MIT License.</haxe_doc>
	</class>
	<class path="flixel.addons.editors.tiled.TiledMap" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/tiled/TiledMap.hx">
		<version public="1"><c path="String"/></version>
		<orientation public="1"><c path="String"/></orientation>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<tileWidth public="1"><x path="Int"/></tileWidth>
		<tileHeight public="1"><x path="Int"/></tileHeight>
		<fullWidth public="1"><x path="Int"/></fullWidth>
		<fullHeight public="1"><x path="Int"/></fullHeight>
		<properties public="1"><c path="flixel.addons.editors.tiled.TiledPropertySet"/></properties>
		<noLoadHash><x path="Map">
	<c path="String"/>
	<x path="Bool"/>
</x></noLoadHash>
		<tilesets public="1"><x path="Map">
	<c path="String"/>
	<c path="flixel.addons.editors.tiled.TiledTileSet"/>
</x></tilesets>
		<layers public="1"><c path="Array"><c path="flixel.addons.editors.tiled.TiledLayer"/></c></layers>
		<objectGroups public="1"><c path="Array"><c path="flixel.addons.editors.tiled.TiledObjectGroup"/></c></objectGroups>
		<getTileSet public="1" set="method" line="146"><f a="Name">
	<c path="String"/>
	<c path="flixel.addons.editors.tiled.TiledTileSet"/>
</f></getTileSet>
		<getLayer public="1" set="method" line="151"><f a="Name">
	<c path="String"/>
	<c path="flixel.addons.editors.tiled.TiledLayer"/>
</f></getLayer>
		<getObjectGroup public="1" set="method" line="166"><f a="Name">
	<c path="String"/>
	<c path="flixel.addons.editors.tiled.TiledObjectGroup"/>
</f></getObjectGroup>
		<getGidOwner public="1" set="method" line="182"><f a="Gid">
	<x path="Int"/>
	<c path="flixel.addons.editors.tiled.TiledTileSet"/>
</f></getGidOwner>
		<new public="1" set="method" line="42"><f a="Data">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Copyright (c) 2013 by Samuel Batista
 * (original by Matt Tuttle based on Thomas Jahn's. Haxe port by Adrien Fischer)
 * This content is released under the MIT License.</haxe_doc>
	</class>
	<class path="flixel.addons.editors.tiled.TiledObject" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/tiled/TiledObject.hx">
		<FLIPPED_VERTICALLY_FLAG public="1" get="inline" set="null" line="19" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Use these to determine whether a sprite should be flipped, for example:
	 * 
	 * var flipped:Bool = cast (oject.gid & TiledObject.FLIPPED_HORIZONTALLY_FLAG);
	 * sprite.facing = flipped ? FlxObject.LEFT : FlxObject.RIGHT;]]></haxe_doc>
		</FLIPPED_VERTICALLY_FLAG>
		<FLIPPED_HORIZONTALLY_FLAG public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></FLIPPED_HORIZONTALLY_FLAG>
		<RECTANGLE public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></RECTANGLE>
		<ELLIPSE public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></ELLIPSE>
		<POLYGON public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></POLYGON>
		<POLYLINE public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></POLYLINE>
		<TILE public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></TILE>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<name public="1"><c path="String"/></name>
		<type public="1"><c path="String"/></type>
		<xmlData public="1"><c path="haxe.xml.Fast"/></xmlData>
		<angle public="1">
			<x path="Float"/>
			<haxe_doc>* In degrees</haxe_doc>
		</angle>
		<gid public="1">
			<x path="Int"/>
			<haxe_doc>* Global identifier for this object</haxe_doc>
		</gid>
		<custom public="1">
			<c path="flixel.addons.editors.tiled.TiledPropertySet"/>
			<haxe_doc>* Custom properties that users can set on this object</haxe_doc>
		</custom>
		<shared public="1">
			<c path="flixel.addons.editors.tiled.TiledPropertySet"/>
			<haxe_doc>* Shared properties are tileset properties added on object tile</haxe_doc>
		</shared>
		<group public="1">
			<c path="flixel.addons.editors.tiled.TiledObjectGroup"/>
			<haxe_doc>* Information on the group or "Layer" that contains this object</haxe_doc>
		</group>
		<objectType public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The type of the object (RECTANGLE, ELLIPSE, POLYGON, POLYLINE, TILE)</haxe_doc>
		</objectType>
		<flippedHorizontally public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the object is flipped horizontally.</haxe_doc>
		</flippedHorizontally>
		<flippedVertically public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the object is flipped vertically.</haxe_doc>
		</flippedVertically>
		<points public="1">
			<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			<haxe_doc>* An array with points if the object is a POLYGON or POLYLINE</haxe_doc>
		</points>
		<getPoints set="method" line="130"><f a="Node">
	<c path="haxe.xml.Fast"/>
	<x path="Void"/>
</f></getPoints>
		<get_flippedHorizontally get="inline" set="null" line="144">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Property accessors</haxe_doc>
		</get_flippedHorizontally>
		<get_flippedVertically get="inline" set="null" line="149"><f a=""><x path="Bool"/></f></get_flippedVertically>
		<new public="1" set="method" line="72"><f a="Source:Parent">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.editors.tiled.TiledObjectGroup"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Last modified 10/3/2013 by Samuel Batista
 * (original by Matt Tuttle based on Thomas Jahn's. Haxe port by Adrien Fischer)
 * This content is released under the MIT License.</haxe_doc>
	</class>
	<class path="flixel.addons.editors.tiled.TiledObjectGroup" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/tiled/TiledObjectGroup.hx">
		<map public="1"><c path="flixel.addons.editors.tiled.TiledMap"/></map>
		<name public="1"><c path="String"/></name>
		<color public="1"><x path="Int"/></color>
		<opacity public="1"><x path="Float"/></opacity>
		<visible public="1"><x path="Bool"/></visible>
		<properties public="1"><c path="flixel.addons.editors.tiled.TiledPropertySet"/></properties>
		<objects public="1"><c path="Array"><c path="flixel.addons.editors.tiled.TiledObject"/></c></objects>
		<new public="1" set="method" line="20"><f a="Source:Parent">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.editors.tiled.TiledMap"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Copyright (c) 2013 by Samuel Batista
 * (original by Matt Tuttle based on Thomas Jahn's. Haxe port by Adrien Fischer)
 * This content is released under the MIT License.</haxe_doc>
	</class>
	<class path="flixel.addons.editors.tiled.TiledPropertySet" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/tiled/TiledPropertySet.hx">
		<get public="1" get="inline" set="null" line="17"><f a="Key">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<contains public="1" get="inline" set="null" line="22"><f a="Key">
	<c path="String"/>
	<x path="Bool"/>
</f></contains>
		<resolve public="1" get="inline" set="null" line="27"><f a="Name">
	<c path="String"/>
	<c path="String"/>
</f></resolve>
		<keysIterator public="1" get="inline" set="null" line="32"><f a=""><t path="Iterator"><c path="String"/></t></f></keysIterator>
		<extend public="1" set="method" line="37"><f a="Source">
	<c path="haxe.xml.Fast"/>
	<x path="Void"/>
</f></extend>
		<keys public="1"><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></keys>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Copyright (c) 2013 by Samuel Batista
 * (original by Matt Tuttle based on Thomas Jahn's. Haxe port by Adrien Fischer)
 * This content is released under the MIT License.</haxe_doc>
		<haxe_dynamic><c path="String"/></haxe_dynamic>
	</class>
	<class path="flixel.addons.editors.tiled.TiledTile" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/tiled/TiledTile.hx">
		<FLIPPED_HORIZONTAL public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></FLIPPED_HORIZONTAL>
		<FLIPPED_VERTICAL public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></FLIPPED_VERTICAL>
		<FLIPPED_DIAGONAL public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></FLIPPED_DIAGONAL>
		<ROTATE_0 public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></ROTATE_0>
		<ROTATE_90 public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></ROTATE_90>
		<ROTATE_270 public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></ROTATE_270>
		<tileID public="1"><x path="Int"/></tileID>
		<tilesetID public="1" set="null"><x path="Int"/></tilesetID>
		<isFlipHorizontally public="1"><x path="Bool"/></isFlipHorizontally>
		<isFlipVertically public="1"><x path="Bool"/></isFlipVertically>
		<rotate public="1"><x path="Int"/></rotate>
		<resolveFlipAndRotation set="method" line="48"><f a=""><x path="Void"/></f></resolveFlipAndRotation>
		<resolveTilesetID get="inline" set="null" line="77"><f a=""><x path="Int"/></f></resolveTilesetID>
		<new public="1" set="method" line="41"><f a="OriginalId">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.addons.editors.tiled.TiledTileSet" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/editors/tiled/TiledTileSet.hx">
		<firstGID public="1"><x path="Int"/></firstGID>
		<name public="1"><c path="String"/></name>
		<tileWidth public="1"><x path="Int"/></tileWidth>
		<tileHeight public="1"><x path="Int"/></tileHeight>
		<spacing public="1"><x path="Int"/></spacing>
		<margin public="1"><x path="Int"/></margin>
		<imageSource public="1"><c path="String"/></imageSource>
		<numTiles public="1"><x path="Int"/></numTiles>
		<numRows public="1"><x path="Int"/></numRows>
		<numCols public="1"><x path="Int"/></numCols>
		<properties public="1"><c path="flixel.addons.editors.tiled.TiledPropertySet"/></properties>
		<tileProps public="1"><c path="Array"><c path="flixel.addons.editors.tiled.TiledPropertySet"/></c></tileProps>
		<hasGid public="1" get="inline" set="null" line="121"><f a="Gid">
	<x path="Int"/>
	<x path="Bool"/>
</f></hasGid>
		<fromGid public="1" get="inline" set="null" line="126"><f a="Gid">
	<x path="Int"/>
	<x path="Int"/>
</f></fromGid>
		<toGid public="1" get="inline" set="null" line="131"><f a="ID">
	<x path="Int"/>
	<x path="Int"/>
</f></toGid>
		<getPropertiesByGid public="1" set="method" line="136"><f a="Gid">
	<x path="Int"/>
	<c path="flixel.addons.editors.tiled.TiledPropertySet"/>
</f></getPropertiesByGid>
		<getProperties public="1" get="inline" set="null" line="146"><f a="ID">
	<x path="Int"/>
	<c path="flixel.addons.editors.tiled.TiledPropertySet"/>
</f></getProperties>
		<getRect public="1" get="inline" set="null" line="151"><f a="ID">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<new public="1" set="method" line="31"><f a="data">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Copyright (c) 2013 by Samuel Batista
 * (original by Matt Tuttle based on Thomas Jahn's. Haxe port by Adrien Fischer)
 * This content is released under the MIT License.</haxe_doc>
	</class>
	<class path="flixel.addons.effects.FlxGlitchSprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/effects/FlxGlitchSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<size public="1">
			<x path="Int"/>
			<haxe_doc>* How thick each glitch segment should be.</haxe_doc>
		</size>
		<delay public="1">
			<x path="Float"/>
			<haxe_doc>* Time, in seconds, between glitch updates</haxe_doc>
		</delay>
		<target public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* The target FlxSprite that the glitch effect copies from.</haxe_doc>
		</target>
		<direction public="1" set="accessor">
			<e path="flixel.addons.effects.GlitchDirection"/>
			<haxe_doc>* Which direction the glitch effect should be applied.</haxe_doc>
		</direction>
		<strength public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* How strong the glitch effect should be (how much it should move from the center)</haxe_doc>
		</strength>
		<_time><x path="Float"/></_time>
		<draw public="1" set="method" line="63" override="1"><f a=""><x path="Void"/></f></draw>
		<initPixels set="method" line="109"><f a=""><x path="Void"/></f></initPixels>
		<set_direction set="method" line="119"><f a="Value">
	<e path="flixel.addons.effects.GlitchDirection"/>
	<e path="flixel.addons.effects.GlitchDirection"/>
</f></set_direction>
		<set_strength set="method" line="129"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_strength>
		<new public="1" set="method" line="50">
			<f a="Target:?Strength:?Size:?Delay:?Direction" v=":4:1:0.05f:null">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<e path="flixel.addons.effects.GlitchDirection"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxGlitchSprite, which clones a target FlxSprite and applies a Glitch-distortion effect to the clone.
	 * This effect is non-destructive to the target's pixels, and can be used on animated FlxSprites.
	 * 
	 * @param	Target		The target FlxSprite you want to clone.
	 * @param	Strength	How strong you want the effect
	 * @param	Size		How 'thick' you want each piece of the glitch
	 * @param	Delay		How long (in seconds) between each glitch update
	 * @param	Direction	Which Direction you want the effect to be applied (HORIZONTAL or VERTICAL)</haxe_doc>
		</new>
		<haxe_doc>* This creates a FlxSprite which copies a target FlxSprite and applies a non-destructive wave-distortion effect.
 * Usage: Create a FlxSprite object, position it where you want (don't add it), and then create a new FlxWaveSprite, 
 * passing the Target object to it, and then add the FlxWaveSprite to your state/group.
 * Based, in part, from PhotonStorm's GlitchFX Class in Flixel Power Tools.
 * @author Tim Hely / tims-world.com</haxe_doc>
	</class>
	<enum path="flixel.addons.effects.GlitchDirection" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/effects/FlxGlitchSprite.hx" module="flixel.addons.effects.FlxGlitchSprite">
		<HORIZONTAL/>
		<VERTICAL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flixel.addons.effects.FlxTrail" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/effects/FlxTrail.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></extends>
		<sprite public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Stores the FlxSprite the trail is attached to.</haxe_doc>
		</sprite>
		<delay public="1">
			<x path="Int"/>
			<haxe_doc>* How often to update the trail.</haxe_doc>
		</delay>
		<xEnabled public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to check for X changes or not.</haxe_doc>
		</xEnabled>
		<yEnabled public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to check for Y changes or not.</haxe_doc>
		</yEnabled>
		<rotationsEnabled public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to check for angle changes or not.</haxe_doc>
		</rotationsEnabled>
		<scalesEnabled public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to check for scale changes or not.</haxe_doc>
		</scalesEnabled>
		<framesEnabled public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to check for frame changes of the "parent" FlxSprite or not.</haxe_doc>
		</framesEnabled>
		<_counter>
			<x path="Int"/>
			<haxe_doc>*  Counts the frames passed.</haxe_doc>
		</_counter>
		<_trailLength>
			<x path="Int"/>
			<haxe_doc>*  How long is the trail?</haxe_doc>
		</_trailLength>
		<_image>
			<d/>
			<haxe_doc>*  Stores the trailsprite image.</haxe_doc>
		</_image>
		<_transp>
			<x path="Float"/>
			<haxe_doc>*  The alpha value for the next trailsprite.</haxe_doc>
		</_transp>
		<_difference>
			<x path="Float"/>
			<haxe_doc>*  How much lower the alpha value of the next trailsprite is.</haxe_doc>
		</_difference>
		<_recentPositions>
			<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			<haxe_doc>*  Stores the sprites recent positions.</haxe_doc>
		</_recentPositions>
		<_recentAngles>
			<c path="Array"><x path="Float"/></c>
			<haxe_doc>*  Stores the sprites recent angles.</haxe_doc>
		</_recentAngles>
		<_recentScales>
			<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			<haxe_doc>*  Stores the sprites recent scale.</haxe_doc>
		</_recentScales>
		<_recentFrames>
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>*  Stores the sprites recent frame.</haxe_doc>
		</_recentFrames>
		<_recentFacings>
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>*  Stores the sprites recent facing.</haxe_doc>
		</_recentFacings>
		<_spriteOrigin>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>*  Stores the sprite origin (rotation axis)</haxe_doc>
		</_spriteOrigin>
		<destroy public="1" set="method" line="125" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="154" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates positions and other values according to the delay that has been set.
	 *</haxe_doc>
		</update>
		<resetTrail public="1" set="method" line="266"><f a=""><x path="Void"/></f></resetTrail>
		<increaseLength public="1" set="method" line="288">
			<f a="Amount">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A function to add a specific number of sprites to the trail to increase its length.
	 *
	 * @param 	Amount	The amount of sprites to add to the trail.</haxe_doc>
		</increaseLength>
		<changeGraphic public="1" set="method" line="330">
			<f a="Image">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* In case you want to change the trailsprite image in runtime...
	 *
	 * @param 	Image	The image the sprites should load</haxe_doc>
		</changeGraphic>
		<changeValuesEnabled public="1" set="method" line="348">
			<f a="Angle:?X:?Y:?Scale" v=":true:true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handy little function to change which events affect the trail.
	 *
	 * @param 	Angle 	Whether the trail reacts to angle changes or not.
	 * @param 	X 		Whether the trail reacts to x changes or not.
	 * @param 	Y 		Whether the trail reacts to y changes or not.
	 * @param	Scale	Wheater the trail reacts to scale changes or not.</haxe_doc>
		</changeValuesEnabled>
		<solid public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Determines whether trailsprites are solid or not. False by default.</haxe_doc>
		</solid>
		<set_solid set="method" line="361"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_solid>
		<new public="1" set="method" line="102">
			<f a="Sprite:?Image:?Length:?Delay:?Alpha:?Diff" v=":null:10:3:0.4f:0.05f">
				<c path="flixel.FlxSprite"/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxTrail effect for a specific FlxSprite.
	 * 
	 * @param	Sprite		The FlxSprite the trail is attached to.
	 * @param  	Image   	The image to ues for the trailsprites. Optional, uses the sprite's graphic if null.
	 * @param	Length		The amount of trailsprites to create. 
	 * @param	Delay		How often to update the trail. 0 updates every frame.
	 * @param	Alpha		The alpha value for the very first trailsprite.
	 * @param	Diff		How much lower the alpha of the next trailsprite is.</haxe_doc>
		</new>
		<haxe_doc>* Nothing too fancy, just a handy little class to attach a trail effect to a FlxSprite.
 * Inspired by the way "Buck" from the inofficial #flixel IRC channel 
 * creates a trail effect for the character in his game.
 * Feel free to use this class and adjust it to your needs.
 * @author Gama11</haxe_doc>
	</class>
	<class path="flixel.addons.effects.FlxTrailArea" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/effects/FlxTrailArea.hx">
		<extends path="flixel.FlxSprite"/>
		<delay public="1">
			<x path="Int"/>
			<haxe_doc>* How often the trail is updated, in frames. Default value is 2, or "every frame".</haxe_doc>
		</delay>
		<simpleRender public="1">
			<x path="Bool"/>
			<haxe_doc>* If this is true, the render process ignores any color/scale/rotation manipulation of the sprites
	 * with the advantage of being faster</haxe_doc>
		</simpleRender>
		<blendMode public="1">
			<e path="flash.display.BlendMode"/>
			<haxe_doc>* Specifies the blendMode for the trails.
	 * Ignored in simple render mode. Only works on the flash target.</haxe_doc>
		</blendMode>
		<group public="1">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></c>
			<haxe_doc>* Stores all sprites that have a trail.</haxe_doc>
		</group>
		<redMultiplier public="1">
			<x path="Float"/>
			<haxe_doc>* The bitmap's red value is multiplied by this every update</haxe_doc>
		</redMultiplier>
		<greenMultiplier public="1">
			<x path="Float"/>
			<haxe_doc>* The bitmap's green value is multiplied by this every update</haxe_doc>
		</greenMultiplier>
		<blueMultiplier public="1">
			<x path="Float"/>
			<haxe_doc>* The bitmap's blue value is multiplied by this every update</haxe_doc>
		</blueMultiplier>
		<alphaMultiplier public="1">
			<x path="Float"/>
			<haxe_doc>* The bitmap's alpha value is multiplied by this every update</haxe_doc>
		</alphaMultiplier>
		<redOffset public="1">
			<x path="Float"/>
			<haxe_doc>* The bitmap's red value is offsettet by this every update</haxe_doc>
		</redOffset>
		<greenOffset public="1">
			<x path="Float"/>
			<haxe_doc>* The bitmap's green value is offsettet by this every update</haxe_doc>
		</greenOffset>
		<blueOffset public="1">
			<x path="Float"/>
			<haxe_doc>* The bitmap's blue value is offsettet by this every update</haxe_doc>
		</blueOffset>
		<alphaOffset public="1">
			<x path="Float"/>
			<haxe_doc>* The bitmap's alpha value is offsettet by this every update</haxe_doc>
		</alphaOffset>
		<_counter>
			<x path="Int"/>
			<haxe_doc>* Counts the frames passed.</haxe_doc>
		</_counter>
		<_width>
			<x path="Float"/>
			<haxe_doc>* Internal width variable
	 * Initialized to 1 to prevent invalid bitmapData during construction</haxe_doc>
		</_width>
		<_height>
			<x path="Float"/>
			<haxe_doc>* Internal height variable
	 * Initialized to 1 to prevent invalid bitmapData during construction</haxe_doc>
		</_height>
		<setSize public="1" set="method" line="139" override="1">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the FlxTrailArea to a new size. Clears the area!
	 * 
	 * @param	Width		The new width
	 * @param	Height		The new height</haxe_doc>
		</setSize>
		<destroy public="1" set="method" line="154" override="1"><f a=""><x path="Void"/></f></destroy>
		<draw public="1" set="method" line="162" override="1"><f a=""><x path="Void"/></f></draw>
		<resetTrail public="1" get="inline" set="null" line="221">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Wipes the trail area</haxe_doc>
		</resetTrail>
		<add public="1" get="inline" set="null" line="233">
			<f a="Sprite">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Adds a FlxSprite to the FlxTrailArea. Not an add() in the traditional sense,
	 * this just enables the trail effect for the sprite. You still need to add it to your state for it to update!
	 * 
	 * @param	Sprite		The sprite to enable the trail effect for
	 * @return 	The FlxSprite, useful for chaining stuff together</haxe_doc>
		</add>
		<get_width get="inline" set="null" line="241" override="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Redirects width to _width</haxe_doc>
		</get_width>
		<set_width set="method" line="249" override="1">
			<f a="Width">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Setter for width, defaults to FlxG.width, creates new _rendeBitmap if neccessary</haxe_doc>
		</set_width>
		<get_height get="inline" set="null" line="263" override="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Redirects height to _height</haxe_doc>
		</get_height>
		<set_height set="method" line="271" override="1">
			<f a="Height">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Setter for height, defaults to FlxG.height, creates new _rendeBitmap if neccessary</haxe_doc>
		</set_height>
		<new public="1" set="method" line="115">
			<f a="?X:?Y:?Width:?Height:?AlphaMultiplier:?Delay:?SimpleRender:?Antialiasing:?TrailBlendMode" v="0:0:0:0:0.8f:2:false:false:null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<e path="flash.display.BlendMode"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxTrailArea, in which all added sprites get a trail effect.
	  * 
	  * @param	X				x position of the trail area
	  * @param	Y				y position of the trail area
	  * @param	Width			The width of the area - defaults to FlxG.width
	  * @param	Height			The height of the area - defaults to FlxG.height
	  * @param	AlphaMultiplier By what the area's alpha is multiplied per update
	  * @param	Delay			How often to update the trail. 1 updates every frame
	  * @param	SimpleRender 	If simple rendering should be used. Ignores all sprite transformations
	  * @param	Antialiasing	If sprites should be smoothed when drawn to the area. Ignored when simple rendering is on
	  * @param	TrailBlendMode 	The blend mode used for the area. Only works in flash</haxe_doc>
		</new>
		<haxe_doc>* This provides an area in which the added sprites have a trail effect. Usage: Create the FlxTrailArea and 
 * add it to the display. Then add all sprites that should have a trail effect via the add function.
 * @author KeyMaster</haxe_doc>
	</class>
	<class path="flixel.addons.effects.FlxWaveSprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/effects/FlxWaveSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<BASE_STRENGTH get="inline" set="null" line="17" static="1"><x path="Float"/></BASE_STRENGTH>
		<mode public="1">
			<e path="flixel.addons.effects.WaveMode"/>
			<haxe_doc>* Which mode we're using for the effect</haxe_doc>
		</mode>
		<speed public="1">
			<x path="Float"/>
			<haxe_doc>* How fast should the wave effect be (higher = faster)</haxe_doc>
		</speed>
		<center public="1">
			<x path="Int"/>
			<haxe_doc>* The 'center' of our sprite (where the wave effect should start/end)</haxe_doc>
		</center>
		<strength public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* How strong the wave effect should be</haxe_doc>
		</strength>
		<_target>
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* The target FlxSprite we're going to be using</haxe_doc>
		</_target>
		<_targetOffset><x path="Float"/></_targetOffset>
		<_time><x path="Float"/></_time>
		<draw public="1" set="method" line="68" override="1"><f a=""><x path="Void"/></f></draw>
		<calculateOffset get="inline" set="null" line="120"><f a="p">
	<x path="Float"/>
	<x path="Float"/>
</f></calculateOffset>
		<initPixels set="method" line="125"><f a=""><x path="Void"/></f></initPixels>
		<set_strength set="method" line="133"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_strength>
		<new public="1" set="method" line="53">
			<f a="Target:?Mode:?Strength:?Center:?Speed" v=":null:20:-1:3">
				<c path="flixel.FlxSprite"/>
				<e path="flixel.addons.effects.WaveMode"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxWaveSprite, which clones a target FlxSprite and applies a wave-distortion effect to the clone.
	 * 
	 * @param	Target		The target FlxSprite you want to clone.
	 * @param	Mode		Which Mode you would like to use for the effect. ALL = applies a constant distortion throughout the image, BOTTOM = makes the effect get stronger towards the bottom of the image, and TOP = the reverse of BOTTOM
	 * @param	Strength	How strong you want the effect
	 * @param	Center		The 'center' of the effect when using BOTTOM or TOP modes. Anything above(BOTTOM)/below(TOP) this point on the image will have no distortion effect.
	 * @param	Speed		How fast you want the effect to move. Higher values = faster.</haxe_doc>
		</new>
		<haxe_doc>* This creates a FlxSprite which copies a target FlxSprite and applies a non-destructive wave-distortion effect.
 * Usage: Create a FlxSprite object, position it where you want (don't add it), and then create a new FlxWaveSprite, 
 * passing the Target object to it, and then add the FlxWaveSprite to your state/group.
 * @author Tim Hely / tims-world.com</haxe_doc>
	</class>
	<enum path="flixel.addons.effects.WaveMode" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/effects/FlxWaveSprite.hx" module="flixel.addons.effects.FlxWaveSprite">
		<ALL/>
		<TOP/>
		<BOTTOM/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flixel.addons.nape.FlxNapeSprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/nape/FlxNapeSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<body public="1">
			<c path="nape.phys.Body"/>
			<haxe_doc>* body is the physics body associated with this sprite.</haxe_doc>
		</body>
		<physicsEnabled public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Enables/Disables this sprites physics body in simulations.</haxe_doc>
		</physicsEnabled>
		<_linearDrag>
			<x path="Float"/>
			<haxe_doc>* Internal var to update body.velocity.x and body.velocity.y. 
	 * Default is 1, which menas no drag.</haxe_doc>
		</_linearDrag>
		<_angularDrag>
			<x path="Float"/>
			<haxe_doc>* Internal var to update body.angularVel
	 * Default is 1, which menas no drag.</haxe_doc>
		</_angularDrag>
		<destroy public="1" set="method" line="75" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* WARNING: This will remove this sprite entirely. Use kill() if you 
	 * want to disable it temporarily only and reset() it later to revive it.
	 * Override this function to null out variables or manually call
	 * destroy() on class members if necessary.
	 * Don't forget to call super.destroy()!</haxe_doc>
		</destroy>
		<update public="1" set="method" line="85" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override core physics velocity etc</haxe_doc>
		</update>
		<kill public="1" set="method" line="99" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handy function for "killing" game objects.
	 * Default behavior is to flag them as nonexistent AND dead.</haxe_doc>
		</kill>
		<revive public="1" set="method" line="113" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handy function for bringing game objects "back to life". Just sets alive and exists back to true.
	 * In practice, this function is most often called by FlxObject.reset().</haxe_doc>
		</revive>
		<addPremadeBody public="1" set="method" line="129">
			<f a="NewBody">
				<c path="nape.phys.Body"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Makes it easier to add a physics body of your own to this sprite by setting it's position,
	 * space and material for you.
	 * 
	 * @param	NewBody 	The new physics body replacing the old one.</haxe_doc>
		</addPremadeBody>
		<createCircularBody public="1" set="method" line="152">
			<f a="?Radius:?_Type" v="16:null">
				<x path="Float"/>
				<c path="nape.phys.BodyType"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a circular physics body for this sprite.
	 * 
	 * @param	Radius	The radius of the circle-shaped body - 16 by default
	 * @param 	_Type	The BodyType of the physics body. Optional, DYNAMIC by default.</haxe_doc>
		</createCircularBody>
		<createRectangularBody public="1" set="method" line="180">
			<f a="?Width:?Height:?_Type" v="0:0:null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.phys.BodyType"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Default method to create the physics body used by this sprite in shape of a rectangle.
	 * Override this method to create your own physics body!
	 * The width and height used are based on the size of sprite graphics if 0 is passed.
	 * Call this method after calling makeGraphics() or loadGraphic() to update the body size.
	 * 
	 * @param	Width	The width of the rectangle. 0 = frameWidth
	 * @param	Height	The height of the rectangle. 0 = frameHeight
	 * @param	_Type	The BodyType of the physics body. Optional, DYNAMIC by default.</haxe_doc>
		</createRectangularBody>
		<setBodyMaterial public="1" set="method" line="216">
			<f a="?Elasticity:?DynamicFriction:?StaticFriction:?Density:?RotationFriction" v="1:0.2f:0.4f:1:0.001f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shortcut method to set/change the physics body material.
	 * 
	 * @param	Elasticity			Elasticity of material.		
	 * @param	DynamicFriction		Coeffecient of dynamic friction for material.
	 * @param	StaticFriction		Coeffecient of static friction for material.
	 * @param	Density				Density of this Material.
	 * @param	RotationFriction	Coeffecient of rolling friction for circle interactions.</haxe_doc>
		</setBodyMaterial>
		<destroyPhysObjects public="1" set="method" line="229">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroys the physics main body.</haxe_doc>
		</destroyPhysObjects>
		<setDrag public="1" get="inline" set="null" line="246">
			<f a="?LinearDrag:?AngularDrag" v="1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Nape requires fluid spaces to add empty space linear drag and angular drag.
	 * This provides a simple drag alternative. 
	 * Set any values to linearDrag or angularDrag to activate this feature for this object.
	 * 
	 * @param	LinearDrag		Typical value 0.96 (1 = no drag).
	 * @param	AngularDrag		Typical value 0.96 (1 = no drag);</haxe_doc>
		</setDrag>
		<drawDebug public="1" set="method" line="256" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Hide debug outline on physics sprites if the physics debug shapes are turned on</haxe_doc>
		</drawDebug>
		<updatePhysObjects set="method" line="269">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates physics FlxSprite graphics to follow this sprite physics object, called at the end of update().
	 * Things that are updated: Position, angle, angular and linear drag.</haxe_doc>
		</updatePhysObjects>
		<set_physicsEnabled get="inline" set="null" line="288"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_physicsEnabled>
		<new public="1" set="method" line="57">
			<f a="?X:?Y:?SimpleGraphic:?CreateRectangularBody:?EnablePhysics" v="0:0:null:true:true">
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates an FlxNapeSprite with an optional physics body (body).
	 * At each step, the physics are updated, and so is the position and rotation of the sprite 
	 * to match the bodys position and rotation values.
	 * By default a physics body with rectangle shape will be created around your sprite graphics.
	 * You can override this functionality and add a premade body of your own (see addPremadeBody).
	 * 
	 * @param	X						The initial X position of the sprite.
	 * @param	Y						The initial Y position of the sprite.
	 * @param	SimpleGraphic 			The graphic you want to display (OPTIONAL - for simple stuff only, do NOT use for animated images!).
	 * @param	CreateRectangularBody	Whether to create a rectangular body for this sprite (use false if you want to add a custom body).
	 * @param	EnablePhysics			Whether to enable physics simulation on the rectangular body (only relevant if CreateRectangularBody == true).</haxe_doc>
		</new>
		<haxe_doc>* FlxNapeSprite consists of an FlxSprite with a physics body.
 * During the simulation, the sprite follows the physics body position and rotation.
 * 
 * By default, a rectangular physics body is created upon construction in createRectangularBody().
 * 
 * @author TiagoLr ( ~~~ProG4mr~~~ )</haxe_doc>
	</class>
	<class path="flixel.addons.nape.GraphicNapeDebug" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/nape/FlxNapeState.hx" module="flixel.addons.nape.FlxNapeState">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/napeDebug.png"</e></m>
		</meta>
	</class>
	<class path="flixel.addons.nape.FlxNapeState" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/nape/FlxNapeState.hx">
		<extends path="flixel.FlxState"/>
		<space public="1" static="1">
			<c path="nape.space.Space"/>
			<haxe_doc>* The space where the nape physics simulation occur.</haxe_doc>
		</space>
		<debug public="1" get="accessor" set="null" static="1">
			<c path="nape.util.ShapeDebug"/>
			<haxe_doc>* Contains the sprite used for nape debug graphics.</haxe_doc>
		</debug>
		<get_debug set="method" line="45" static="1"><f a=""><c path="nape.util.ShapeDebug"/></f></get_debug>
		<velocityIterations public="1">
			<x path="Int"/>
			<haxe_doc>* The number of iterations used by nape in resolving errors in the velocities of objects. This is together with collision 
	 * detection the most expensive phase of a simulation update, as well as the most important for stable results. (default 10)</haxe_doc>
		</velocityIterations>
		<positionIterations public="1">
			<x path="Int"/>
			<haxe_doc>* The number of iterations used by nape in resolving errors in the positions of objects. This is far more lightweight than 
	 * velocity iterations, is well as being less important for the stability of results. (default 10)</haxe_doc>
		</positionIterations>
		<napeDebugEnabled public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the nape debug graphics are enabled or not.</haxe_doc>
		</napeDebugEnabled>
		<_physDbgSpr>
			<c path="nape.util.ShapeDebug"/>
			<haxe_doc>* Contains the sprite used for nape debug graphics.</haxe_doc>
		</_physDbgSpr>
		<_button>
			<c path="flixel.system.ui.FlxSystemButton"/>
			<haxe_doc>* Contains a reference to the Nape button in the debugger.</haxe_doc>
		</_button>
		<create public="1" set="method" line="83" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this method like a normal FlxState, but add
	 * super.create() to it, so that this function is called.</haxe_doc>
		</create>
		<createWalls public="1" set="method" line="107">
			<f a="?MinX:?MinY:?MaxX:?MaxY:?Thickness:?_Material" v="0:0:0:0:10:null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.phys.Material"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc>* Creates simple walls around game area - usefull for prototying.
	 *
	 * @param 	MinX 		The smallest X value of your level (usually 0).
	 * @param 	MinY 		The smallest Y value of your level (usually 0).
	 * @param 	MaxX 		The largest X value of your level - 0 means FlxG.width (usually the level width).
	 * @param 	MaxY 		The largest Y value of your level - 0 means FlxG.height (usually the level height).
	 * @param 	Thickness 	How thick the walls are. 10 by default.
	 * @param 	_Material 	The Material to use for the physics body of the walls.</haxe_doc>
		</createWalls>
		<update public="1" set="method" line="144" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this method and add super.update().</haxe_doc>
		</update>
		<draw public="1" set="method" line="153" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this method to draw debug physics shapes</haxe_doc>
		</draw>
		<destroy public="1" set="method" line="166" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this function to null out variables or manually call destroy() 
	 * on class members if necessary. Don't forget to call super.destroy()!</haxe_doc>
		</destroy>
		<set_napeDebugEnabled set="method" line="186"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_napeDebugEnabled>
		<drawPhysDebug get="inline" set="null" line="216">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Draws debug graphics.</haxe_doc>
		</drawPhysDebug>
		<toggleDebug set="method" line="240"><f a=""><x path="Void"/></f></toggleDebug>
		<new public="1" set="method" line="32"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* FlxNapeState is a FlxState that integrates nape.space.Space
 * to provide Nape physics simulation in Flixel.
 *
 * Extend this state, add some FlxNapeSprite(s) to start using flixel + nape physics.
 *
 * Note that space is a static variable, use FlxNapeState.space
 * to access it.
 *
 * @author TiagoLr ( ~~~ProG4mr~~~ )</haxe_doc>
	</class>
	<class path="flixel.tile.FlxTilemapBuffer" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tile/FlxTilemapBuffer.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The current X position of the buffer.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The current Y position of the buffer.</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the buffer (usually just a few tiles wider than the camera).</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the buffer (usually just a few tiles taller than the camera).</haxe_doc>
		</height>
		<dirty public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the buffer needs to be redrawn.</haxe_doc>
		</dirty>
		<rows public="1">
			<x path="Int"/>
			<haxe_doc>* How many rows of tiles fit in this buffer.</haxe_doc>
		</rows>
		<columns public="1">
			<x path="Int"/>
			<haxe_doc>* How many columns of tiles fit in this buffer.</haxe_doc>
		</columns>
		<pixelPerfectRender public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the coordinates should be rounded during draw(), true by default (recommended for pixel art). 
	 * Only affects tilesheet rendering and rendering using BitmapData.draw() in blitting.
	 * (copyPixels() only renders on whole pixels by nature). Causes draw() to be used if false, which is more expensive.</haxe_doc>
		</pixelPerfectRender>
		<destroy public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<updateColumns public="1" set="method" line="136">
			<f a="TileWidth:WidthInTiles:?ScaleX:?Camera" v="::1.0f:null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fill the buffer with the specified color.
	 * Default value is transparent.
	 * 
	 * @param	Color	What color to fill with, in 0xAARRGGBB hex format.</haxe_doc>
		</updateColumns>
		<updateRows public="1" set="method" line="158"><f a="TileHeight:HeightInTiles:?ScaleY:?Camera" v="::1.0f:null">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></updateRows>
		<new public="1" set="method" line="71">
			<f a="TileWidth:TileHeight:WidthInTiles:HeightInTiles:?Camera:?ScaleX:?ScaleY" v="::::null:1.0f:1.0f">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiates a new camera-specific buffer for storing the visual tilemap data.
	 * 
	 * @param	TileWidth		The width of the tiles in this tilemap.
	 * @param	TileHeight	The height of the tiles in this tilemap.
	 * @param	WidthInTiles	How many tiles wide the tilemap is.
	 * @param	HeightInTiles	How many tiles tall the tilemap is.
	 * @param	Camera		Which camera this buffer relates to.</haxe_doc>
		</new>
		<haxe_doc>* A helper object to keep tilemap drawing performance decent across the new multi-camera system.
 * Pretty much don't even have to think about this class unless you are doing some crazy hacking.</haxe_doc>
	</class>
	<class path="flixel.tile.FlxTilemap" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tile/FlxTilemap.hx">
		<extends path="flixel.FlxObject"/>
		<OFF public="1" get="inline" set="null" line="44" static="1">
			<x path="Int"/>
			<haxe_doc>* No auto-tiling.</haxe_doc>
		</OFF>
		<AUTO public="1" get="inline" set="null" line="48" static="1">
			<x path="Int"/>
			<haxe_doc>* Good for levels with thin walls that don'tile need interior corner art.</haxe_doc>
		</AUTO>
		<ALT public="1" get="inline" set="null" line="52" static="1">
			<x path="Int"/>
			<haxe_doc>* Better for levels with thick walls that look better with interior corner art.</haxe_doc>
		</ALT>
		<_helperBuffer line="59" static="1">
			<c path="flixel.tile.FlxTilemapBuffer"/>
			<haxe_doc>* A helper buffer for calculating number of columns and rows when the game size changed
	 * We are only using its member functions that's why it is an empty instance</haxe_doc>
		</_helperBuffer>
		<auto public="1">
			<x path="Int"/>
			<haxe_doc>* Set this flag to use one of the 16-tile binary auto-tile algorithms (OFF, AUTO, or ALT).</haxe_doc>
		</auto>
		<widthInTiles public="1">
			<x path="Int"/>
			<haxe_doc>* Read-only variable, do NOT recommend changing after the map is loaded!</haxe_doc>
		</widthInTiles>
		<heightInTiles public="1">
			<x path="Int"/>
			<haxe_doc>* Read-only variable, do NOT recommend changing after the map is loaded!</haxe_doc>
		</heightInTiles>
		<totalTiles public="1">
			<x path="Int"/>
			<haxe_doc>* Read-only variable, do NOT recommend changing after the map is loaded!</haxe_doc>
		</totalTiles>
		<tileScaleHack public="1">
			<x path="Float"/>
			<haxe_doc>* Helper variable for non-flash targets. Adjust it's value if you'll see tilemap tearing (empty pixels between tiles). To something like 1.02 or 1.03</haxe_doc>
		</tileScaleHack>
		<customTileRemap public="1">
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* Set this to create your own image index remapper, so you can create your own tile layouts.
	 * Mostly useful in combination with the auto-tilers.
	 * 
	 * Normally, each tile's value in _data corresponds to the index of a 
	 * tile frame in the tilesheet. With this active, each value in _data
	 * is a lookup value to that index in customTileRemap.
	 * 
	 * Example:
	 *  customTileRemap = [10,9,8,7,6]
	 *  means: 0=10, 1=9, 2=8, 3=7, 4=6</haxe_doc>
		</customTileRemap>
		<scale public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Changes the size of this tilemap. Default is (1, 1). 
	 * Anything other than the default is very slow with blitting!</haxe_doc>
		</scale>
		<region public="1" set="null">
			<c path="flixel.system.layer.Region"/>
			<haxe_doc>* Rendering variables.</haxe_doc>
		</region>
		<framesData public="1" set="null"><c path="flixel.system.layer.frames.FlxSpriteFrames"/></framesData>
		<cachedGraphics public="1" set="accessor"><c path="flixel.util.loaders.CachedGraphics"/></cachedGraphics>
		<_randomIndices>
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* If these next two arrays are not null, you're telling FlxTilemap to 
	 * draw random tiles in certain places. 
	 * 
	 * _randomIndices is a list of tilemap values that should be replaced
	 * by a randomly selected value. The available values are chosen from
	 * the corresponding array in randomize_choices
	 * 
	 * So if you have:
	 *   randomIndices = [12,14]
	 *   randomChoices = [[0,1,2],[3,4,5,6,7]]
	 * 
	 * Everywhere the tilemap has a value of 12 it will be replaced by 0, 1, or, 2
	 * Everywhere the tilemap has a value of 14 it will be replaced by 3, 4, 5, 6, 7</haxe_doc>
		</_randomIndices>
		<_randomChoices><c path="Array"><c path="Array"><x path="Int"/></c></c></_randomChoices>
		<_randomLambda>
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Setting this function allows you to control which choice will be selected for each element within _randomIndices array.
	 * Must return a 0-1 value that gets multiplied by _randomChoices[randIndex].length;</haxe_doc>
		</_randomLambda>
		<_flashPoint>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods.</haxe_doc>
		</_flashPoint>
		<_flashRect>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods.</haxe_doc>
		</_flashRect>
		<_buffers>
			<c path="Array"><c path="flixel.tile.FlxTilemapBuffer"/></c>
			<haxe_doc>* Internal list of buffers, one for each camera, used for drawing the tilemaps.</haxe_doc>
		</_buffers>
		<_data>
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* Internal representation of the actual tile data, as a large 1D array of integers.</haxe_doc>
		</_data>
		<_tileWidth>
			<x path="Int"/>
			<haxe_doc>* Internal representation of rectangles, one for each tile in the entire tilemap, used to speed up drawing.</haxe_doc>
		</_tileWidth>
		<_tileHeight>
			<x path="Int"/>
			<haxe_doc>* Internal, the height of a single tile.</haxe_doc>
		</_tileHeight>
		<_scaledTileWidth><x path="Float"/></_scaledTileWidth>
		<_scaledTileHeight><x path="Float"/></_scaledTileHeight>
		<_tileObjects>
			<c path="Array"><c path="flixel.tile.FlxTile"/></c>
			<haxe_doc>* Internal collection of tile objects, one for each type of tile in the map (NOTE one for every single tile in the whole map).</haxe_doc>
		</_tileObjects>
		<_startingIndex>
			<x path="Int"/>
			<haxe_doc>* Internal, used to sort of insert blank tiles in front of the tiles in the provided graphic.</haxe_doc>
		</_startingIndex>
		<_helperPoint>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods. Used only in cpp</haxe_doc>
		</_helperPoint>
		<_rectIDs>
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* Internal representation of rectangles (actually id of rectangle in tileSheet), one for each tile in the entire tilemap, used to speed up drawing.</haxe_doc>
		</_rectIDs>
		<destroy public="1" set="method" line="233" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<loadMap public="1" set="method" line="305">
			<f a="MapData:TileGraphic:?TileWidth:?TileHeight:?AutoTile:?StartingIndex:?DrawIndex:?CollideIndex" v="::0:0:0:0:1:1">
				<d/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.tile.FlxTilemap"/>
			</f>
			<haxe_doc>* Load the tilemap with string data and a tile graphic.
	 * 
	 * @param	MapData      	A string of comma and line-return delineated indices indicating what order the tiles should go in, or an Array of Int. YOU MUST SET widthInTiles and heightInTyles manually BEFORE CALLING loadMap if you pass an Array!
	 * @param	TileGraphic		All the tiles you want to use, arranged in a strip corresponding to the numbers in MapData.
	 * @param	TileWidth		The width of your tiles (e.g. 8) - defaults to height of the tile graphic if unspecified.
	 * @param	TileHeight		The height of your tiles (e.g. 8) - defaults to width if unspecified.
	 * @param	AutoTile		Whether to load the map using an automatic tile placement algorithm (requires 16 tiles!).  Setting this to either AUTO or ALT will override any values you put for StartingIndex, DrawIndex, or CollideIndex.
	 * @param	StartingIndex	Used to sort of insert empty tiles in front of the provided graphic.  Default is 0, usually safest ot leave it at that.  Ignored if AutoTile is set.
	 * @param	DrawIndex		Initializes all tile objects equal to and after this index as visible. Default value is 1.  Ignored if AutoTile is set.
	 * @param	CollideIndex	Initializes all tile objects equal to and after this index as allowCollisions = ANY.  Default value is 1.  Ignored if AutoTile is set.  Can override and customize per-tile-type collision behavior using setTileProperties().
	 * @return	A reference to this instance of FlxTilemap, for chaining as usual :)</haxe_doc>
		</loadMap>
		<setCustomTileMappings public="1" set="method" line="537">
			<f a="mappings:?randomIndices:?randomChoices:?randomLambda" v=":null:null:null">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<f a=""><x path="Float"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set custom tile mapping and/or randomization rules prior to loading. This MUST be called BEFORE loadMap().
	 * WARNING: Using this will cause your maps to take longer to load. Be careful using this in very large tilemaps.
	 * 
	 * @param	mappings		Array of ints for remapping tiles. Ex: [7,4,12] means "0-->7, 1-->4, 2-->12"
	 * @param	randomIndices	(optional) Array of ints indicating which tile indices should be randmoized. Ex: [7,4,12] means "replace tile index of 7, 4, or 12 with a randomized value"
	 * @param	randomChoices	(optional) A list of int-arrays that serve as the corresponding choices to randomly choose from. Ex: indices = [7,4], choices = [[1,2],[3,4,5]], 7 will be replaced by either 1 or 2, 4 will be replaced by 3, 4, or 5.
	 * @param	randomLambda	(optional) A custom randomizer function, should return value between 0.0 and 1.0. Initialize your random seed before passing this in! If not defined, will default to unseeded Math.random() calls.]]></haxe_doc>
		</setCustomTileMappings>
		<drawDebugOnCamera public="1" set="method" line="552" override="1"><f a="Camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawDebugOnCamera>
		<draw public="1" set="method" line="671" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Draws the tilemap buffers to the cameras.</haxe_doc>
		</draw>
		<getData public="1" set="method" line="735">
			<f a="?Simple" v="false">
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Fetches the tilemap data array.
	 * 
	 * @param	Simple		If true, returns the data as copy, as a series of 1s and 0s (useful for auto-tiling stuff). Default value is false, meaning it will return the actual data array (NOT a copy).
	 * @return	An array the size of the tilemap full of integers indicating tile placement.</haxe_doc>
		</getData>
		<setDirty public="1" set="method" line="762">
			<f a="?Dirty" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the dirty flag on all the tilemap buffers.
	 * Basically forces a reset of the drawn tilemaps, even if it wasn'tile necessary.
	 * 
	 * @param	Dirty		Whether to flag the tilemap buffers as dirty or not.</haxe_doc>
		</setDirty>
		<findPath public="1" set="method" line="781">
			<f a="Start:End:?Simplify:?RaySimplify:?WideDiagonal" v="::true:false:true">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			</f>
			<haxe_doc>* Find a path through the tilemap.  Any tile with any collision flags set is treated as impassable.
	 * If no path is discovered then a null reference is returned.
	 * 
	 * @param	Start		The start point in world coordinates.
	 * @param	End			The end point in world coordinates.
	 * @param	Simplify	Whether to run a basic simplification algorithm over the path data, removing extra points that are on the same line.  Default value is true.
	 * @param	RaySimplify	Whether to run an extra raycasting simplification algorithm over the remaining path data.  This can result in some close corners being cut, and should be used with care if at all (yet).  Default value is false.
	 * @param   WideDiagonal   Whether to require an additional tile to make diagonal movement. Default value is true;
	 * @return	An Array of FlxPoints, containing all waypoints from the start to the end.  If no path could be found, then a null reference is returned.</haxe_doc>
		</findPath>
		<overlaps public="1" set="method" line="851" override="1">
			<f a="ObjectOrGroup:?InScreenSpace:?Camera" v=":false:null">
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if some FlxObject overlaps this FlxObject object in world space.
	 * If the group has a LOT of things in it, it might be faster to use FlxG.overlaps().
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * 
	 * @param	Object			The object being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.</haxe_doc>
		</overlaps>
		<tilemapOverlapsCallback get="inline" set="null" line="865"><f a="ObjectOrGroup:?X:?Y:?InScreenSpace:?Camera" v=":0:0:false:null">
	<c path="flixel.FlxBasic"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></tilemapOverlapsCallback>
		<overlapsAt public="1" set="method" line="890" override="1">
			<f a="X:Y:ObjectOrGroup:?InScreenSpace:?Camera" v=":::false:null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if this FlxObject were located at the given position, would it overlap the FlxObject or FlxGroup?
	 * This is distinct from overlapsPoint(), which just checks that point, rather than taking the object's size into account.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks! 
	 * 
	 * @param	X				The X position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	Y				The Y position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	ObjectOrGroup	The object or group being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.  Default is false, or "only compare in world space."
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.</haxe_doc>
		</overlapsAt>
		<tilemapOverlapsAtCallback get="inline" set="null" line="905"><f a="ObjectOrGroup:X:Y:InScreenSpace:Camera">
	<c path="flixel.FlxBasic"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></tilemapOverlapsAtCallback>
		<overlapsWithCallback public="1" set="method" line="929">
			<f a="Object:?Callback:?FlipCallbackParams:?Position" v=":null:false:null">
				<c path="flixel.FlxObject"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if the Object overlaps any tiles with any collision flags set,
	 * and calls the specified callback function (if there is one).
	 * Also calls the tile's registered callback if the filter matches.
	 * 
	 * @param	Object				The FlxObject you are checking for overlaps against.
	 * @param	Callback			An optional function that takes the form "myCallback(Object1:FlxObject,Object2:FlxObject)", where Object1 is a FlxTile object, and Object2 is the object passed in in the first parameter of this method.
	 * @param	FlipCallbackParams	Used to preserve A-B list ordering from FlxObject.separate() - returns the FlxTile object as the second parameter instead.
	 * @param	Position			Optional, specify a custom position for the tilemap (useful for overlapsAt()-type funcitonality).
	 * @return	Whether there were overlaps, or if a callback was specified, whatever the return value of the callback was.</haxe_doc>
		</overlapsWithCallback>
		<overlapsPoint public="1" set="method" line="1033" override="1">
			<f a="WorldPoint:?InScreenSpace:?Camera" v=":false:null">
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if a point in 2D world space overlaps this FlxObject object.
	 * 
	 * @param	WorldPoint		The point in world space you want to check.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.</haxe_doc>
		</overlapsPoint>
		<getTile public="1" set="method" line="1061">
			<f a="X:Y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Check the value of a particular tile.
	 * 
	 * @param	X		The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y		The Y coordinate of the tile (in tiles, not pixels).
	 * @return	An integer containing the value of the tile at this spot in the array.</haxe_doc>
		</getTile>
		<getTileByIndex public="1" set="method" line="1072">
			<f a="Index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the value of a tile in the tilemap by index.
	 * 
	 * @param	Index	The slot in the data array (Y * widthInTiles + X) where this tile is stored.
	 * @return	An integer containing the value of the tile at this spot in the array.</haxe_doc>
		</getTileByIndex>
		<getTileCollisions public="1" set="method" line="1083">
			<f a="Index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Gets the collision flags of tile by index.
	 * 
	 * @param	Index	Tile index returned by getTile or getTileByIndex
	 * @return	The internal collision flag for the requested tile.</haxe_doc>
		</getTileCollisions>
		<getTileInstances public="1" set="method" line="1094">
			<f a="Index">
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Returns a new array full of every map index of the requested tile type.
	 * 
	 * @param	Index	The requested tile type.
	 * @return	An Array with a list of all map indices of that tile type.</haxe_doc>
		</getTileInstances>
		<getTileCoords public="1" set="method" line="1124">
			<f a="Index:?Midpoint" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			</f>
			<haxe_doc>* Returns a new array full of every coordinate of the requested tile type.
	 * 
	 * @param	Index		The requested tile type.
	 * @param	Midpoint	Whether to return the coordinates of the tile midpoint, or upper left corner. Default is true, return midpoint.
	 * @return	An Array with a list of all the coordinates of that tile type.</haxe_doc>
		</getTileCoords>
		<setTile public="1" set="method" line="1166">
			<f a="X:Y:Tile:?UpdateGraphics" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Change the data and graphic of a tile in the tilemap.
	 * 
	 * @param	X				The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y				The Y coordinate of the tile (in tiles, not pixels).
	 * @param	Tile			The new integer data you wish to inject.
	 * @param	UpdateGraphics	Whether the graphical representation of this tile should change.
	 * @return	Whether or not the tile was actually changed.</haxe_doc>
		</setTile>
		<setTileByIndex public="1" set="method" line="1184">
			<f a="Index:Tile:?UpdateGraphics" v="::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Change the data and graphic of a tile in the tilemap.
	 * 
	 * @param	Index			The slot in the data array (Y * widthInTiles + X) where this tile is stored.
	 * @param	Tile			The new integer data you wish to inject.
	 * @param	UpdateGraphics	Whether the graphical representation of this tile should change.
	 * @return	Whether or not the tile was actually changed.</haxe_doc>
		</setTileByIndex>
		<setTileProperties public="1" set="method" line="1245">
			<f a="Tile:?AllowCollisions:?Callback:?CallbackFilter:?Range" v=":4369:null:null:1">
				<x path="Int"/>
				<x path="Int"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Void"/>
				</f>
				<x path="Class"><d/></x>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adjust collision settings and/or bind a callback function to a range of tiles.
	 * This callback function, if present, is triggered by calls to overlap() or overlapsWithCallback().
	 * 
	 * @param	Tile				The tile or tiles you want to adjust.
	 * @param	AllowCollisions		Modify the tile or tiles to only allow collisions from certain directions, use FlxObject constants NONE, ANY, LEFT, RIGHT, etc.  Default is "ANY".
	 * @param	Callback			The function to trigger, e.g. lavaCallback(Tile:FlxTile, Object:FlxObject).
	 * @param	CallbackFilter		If you only want the callback to go off for certain classes or objects based on a certain class, set that class here.
	 * @param	Range				If you want this callback to work for a bunch of different tiles, input the range here.  Default value is 1.</haxe_doc>
		</setTileProperties>
		<follow public="1" set="method" line="1272">
			<f a="?Camera:?Border:?UpdateWorld" v="null:0:true">
				<c path="flixel.FlxCamera"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Call this function to lock the automatic camera to the map's edges.
	 * 
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @param	Border			Adjusts the camera follow boundary by whatever number of tiles you specify here.  Handy for blocking off deadends that are offscreen, etc.  Use a negative number to add padding instead of hiding the edges.
	 * @param	UpdateWorld		Whether to update the collision system's world size, default value is true.</haxe_doc>
		</follow>
		<getBounds public="1" set="method" line="1288">
			<f a="?Bounds" v="null">
				<c path="flixel.util.FlxRect"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Get the world coordinates and size of the entire tilemap as a FlxRect.
	 * 
	 * @param	Bounds		Optional, pass in a pre-existing FlxRect to prevent instantiation of a new object.
	 * @return	A FlxRect containing the world coordinates and size of the entire tilemap.</haxe_doc>
		</getBounds>
		<ray public="1" set="method" line="1308">
			<f a="Start:End:?Result:?Resolution" v="::null:1">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Shoots a ray from the start point to the end point.
	 * If/when it passes through a tile, it stores that point and returns false.
	 * 
	 * @param	Start		The world coordinates of the start of the ray.
	 * @param	End			The world coordinates of the end of the ray.
	 * @param	Result		An optional point containing the first wall impact if there was one. Null otherwise.
	 * @param	Resolution	Defaults to 1, meaning check every tile or so.  Higher means more checks!
	 * @return	Returns true if the ray made it from Start to End without hitting anything. Returns false and fills Result if a tile was hit.</haxe_doc>
		</ray>
		<updateFrameData public="1" set="method" line="1417">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this method for creating tileSheet for FlxTilemap. Must be called after loadMap() method.
	 * If you forget to call it then you will not see this FlxTilemap on c++ target</haxe_doc>
		</updateFrameData>
		<tileToFlxSprite public="1" set="method" line="1444">
			<f a="X:Y:?NewTile" v="::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Change a particular tile to FlxSprite. Or just copy the graphic if you dont want any changes to mapdata itself.
	 * 
	 * @link http://forums.flixel.org/index.php/topic,5398.0.html
	 * @param	X		The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y		The Y coordinate of the tile (in tiles, not pixels).
	 * @param	NewTile	New tile to the mapdata. Use -1 if you dont want any changes. Default = 0 (empty)
	 * @return	FlxSprite.</haxe_doc>
		</tileToFlxSprite>
		<updateBuffers public="1" set="method" line="1503">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this method so the tilemap buffers are updated, eg when resizing your game</haxe_doc>
		</updateBuffers>
		<drawTilemap set="method" line="1530">
			<f a="Buffer:Camera">
				<c path="flixel.tile.FlxTilemapBuffer"/>
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function that actually renders the tilemap to the tilemap buffer. Called by draw().
	 * 
	 * @param	Buffer		The FlxTilemapBuffer you are rendering to.
	 * @param	Camera		The related FlxCamera, mainly for scroll values.</haxe_doc>
		</drawTilemap>
		<simplifyPath set="method" line="1707">
			<f a="Points">
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function to clean up the map loading code.
	 * Just generates a wireframe box the size of a tile with the specified color.</haxe_doc>
		</simplifyPath>
		<raySimplifyPath set="method" line="1740">
			<f a="Points">
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pathfinding helper function, strips out even more points by raycasting from one point to the next and dropping unnecessary points.
	 * 
	 * @param	Points		An array of FlxPoint nodes.</haxe_doc>
		</raySimplifyPath>
		<computePathDistance public="1" set="method" line="1783">
			<f a="StartIndex:EndIndex:WideDiagonal:?StopOnEnd" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Pathfinding helper function, floods a grid with distance information until it finds the end point.
	 * NOTE: Currently this process does NOT use any kind of fancy heuristic! It's pretty brute.
	 * 
	 * @param	StartIndex		The starting tile's map index.
	 * @param	EndIndex		The ending tile's map index.
	 * @param	WideDiagonal	Whether to require an additional tile to make diagonal movement. Default value is true.
	 * @param	StopOnEnd		Whether to stop at the end or not (default true)
	 * @return	A Flash Array of FlxPoint nodes.  If the end tile could not be found, then a null Array is returned instead.</haxe_doc>
		</computePathDistance>
		<walkPath set="method" line="1965">
			<f a="Data:Start:Points">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pathfinding helper function, recursively walks the grid and finds a shortest path back to the start.
	 * 
	 * @param	Data	A Flash Array of distance information.
	 * @param	Start	The tile we're on in our walk backward.
	 * @param	Points	A Flash Array of FlxPoint nodes composing the path from the start to the end, compiled in reverse order.</haxe_doc>
		</walkPath>
		<updateTile set="method" line="2064">
			<f a="Index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function used in setTileByIndex() and the constructor to update the map.
	 * 
	 * @param	Index		The index of the tile you want to update.</haxe_doc>
		</updateTile>
		<autoTile set="method" line="2099">
			<f a="Index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An internal function used by the binary auto-tilers.
	 * 
	 * @param	Index		The index of the tile you want to analyze.</haxe_doc>
		</autoTile>
		<createBuffer get="inline" set="null" line="2157"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<c path="flixel.tile.FlxTilemapBuffer"/>
</f></createBuffer>
		<onGameResize set="method" line="2167">
			<f a="_:_">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Signal listener for gameResize</haxe_doc>
		</onGameResize>
		<set_cachedGraphics set="method" line="2193">
			<f a="Value">
				<c path="flixel.util.loaders.CachedGraphics"/>
				<c path="flixel.util.loaders.CachedGraphics"/>
			</f>
			<haxe_doc>* Internal function for setting cachedGraphics property for this object. 
	 * It changes cachedGraphics' useCount also for better memory tracking.</haxe_doc>
		</set_cachedGraphics>
		<set_pixelPerfectRender set="method" line="2210" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pixelPerfectRender>
		<setScaleXYCallback set="method" line="2223"><f a="Scale">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></setScaleXYCallback>
		<setScaleXCallback set="method" line="2229"><f a="Scale">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></setScaleXCallback>
		<setScaleYCallback set="method" line="2246"><f a="Scale">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></setScaleYCallback>
		<new public="1" set="method" line="208">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The tilemap constructor just initializes some basic variables.</haxe_doc>
		</new>
		<haxe_doc>* This is a traditional tilemap display and collision class. It takes a string of comma-separated numbers and then associates
 * those values with tiles from the sheet you pass in. It also includes some handy static parsers that can convert
 * arrays or images into strings that can be loaded.</haxe_doc>
	</class>
	<class path="flixel.addons.nape.FlxNapeTilemap" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/nape/FlxNapeTilemap.hx">
		<extends path="flixel.tile.FlxTilemap"/>
		<body public="1"><c path="nape.phys.Body"/></body>
		<_binaryData><c path="Array"><x path="Int"/></c></_binaryData>
		<update public="1" set="method" line="30" override="1"><f a=""><x path="Void"/></f></update>
		<loadMap public="1" set="method" line="37" override="1"><f a="MapData:TileGraphic:?TileWidth:?TileHeight:?AutoTile:?StartingIndex:?DrawIndex:?CollideIndex" v="::0:0:0:0:1:1">
	<d/>
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="flixel.tile.FlxTilemap"/>
</f></loadMap>
		<addSolidTile public="1" set="method" line="54">
			<f a="X:Y:?mat" v="::null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="nape.phys.Material"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a collision box for one tile at the specified position
	 * Using this many times will fragment the collider mesh, possibly impacting performance!
	 * If you are changing a lot of tiles, consider calling body.shapes.clear() and then setupCollideIndex or setupTileIndices
	 * 
	 * @param	X		The X-Position of the tile
	 * @param	Y		The Y-Position of the tile
	 * @param	?mat	The material for the collider. Defaults to default nape material</haxe_doc>
		</addSolidTile>
		<placeCustomPolygon public="1" set="method" line="74"><f a="tileIndices:vertices:?mat" v="::null">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><c path="nape.geom.Vec2"/></c>
	<c path="nape.phys.Material"/>
	<x path="Void"/>
</f></placeCustomPolygon>
		<setupCollideIndex public="1" set="method" line="96">
			<f a="?CollideIndex:?mat" v="1:null">
				<x path="Int"/>
				<c path="nape.phys.Material"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Builds the nape collider with all tiles indices greater or equal to CollideIndex as solid (like normally with FlxTilemap), and assigns the nape material
	 * 
	 * @param	CollideIndex	All tiles with an index greater or equal to this will be solid
	 * @param	?mat			The Nape physics material to use. Will use the default material if not specified</haxe_doc>
		</setupCollideIndex>
		<setupTileIndices public="1" set="method" line="122">
			<f a="tileIndices:?mat" v=":null">
				<c path="Array"><x path="Int"/></c>
				<c path="nape.phys.Material"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Builds the nape collider with all indices in the array as solid, assigning the material
	 * 
	 * @param	tileIndices		An array of all tile indices that should be solid
	 * @param	?mat			The nape physics material applied to the collider. Defaults to nape default material</haxe_doc>
		</setupTileIndices>
		<drawDebug public="1" set="method" line="142" override="1"><f a=""><x path="Void"/></f></drawDebug>
		<constructCollider set="method" line="151"><f a="?mat" v="null">
	<c path="nape.phys.Material"/>
	<x path="Void"/>
</f></constructCollider>
		<constructRectangle set="method" line="236">
			<f a="StartX:StartY:EndY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Scans along x in the rows between StartY to EndY for the biggest rectangle covering solid tiles in the binary data
	 * 
	 * @param	StartX	The column in which the rectangle starts
	 * @param	StartY	The row in which the rectangle starts
	 * @param	EndY	The row in which the rectangle ends
	 * @return			The rectangle covering solid tiles. CAUTION: Width is used as bottom-right x coordinate, height is used as bottom-right y coordinate</haxe_doc>
		</constructRectangle>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* @author KeyMaster</haxe_doc>
	</class>
	<class path="flixel.addons.nape.FlxNapeVelocity" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/nape/FlxNapeVelocity.hx">
		<moveTowardsObject public="1" get="inline" set="null" line="22" static="1">
			<f a="Source:Dest:?Speed" v="::100">
				<c path="flixel.addons.nape.FlxNapeSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the source FlxNapeSprite x/y velocity so it will move directly towards the destination FlxSprite at the speed given (in pixels per second)
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * @param	Source		The FlxNapeSprite on which the velocity will be set
	 * @param	Dest		The FlxSprite where the source object will move to
	 * @param	Speed		The speed it will move, in pixels per second (default is 100 pixels/sec)</haxe_doc>
		</moveTowardsObject>
		<moveTowardsMouse public="1" get="inline" set="null" line="36" static="1">
			<f a="Source:?Speed" v=":100">
				<c path="flixel.addons.nape.FlxNapeSprite"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the given FlxNapeSprite towards the mouse pointer coordinates at a steady velocity
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * @param	Source		The FlxNapeSprite to move
	 * @param	Speed		The speed it will move, in pixels per second (default is 100 pixels/sec)</haxe_doc>
		</moveTowardsMouse>
		<moveTowardsTouch public="1" get="inline" set="null" line="51" static="1">
			<f a="Source:Touch:?Speed" v="::100">
				<c path="flixel.addons.nape.FlxNapeSprite"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the given FlxNapeSprite towards a FlxTouch point at a steady velocity
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * @param	Source			The FlxNapeSprite to move
	 * @param	Speed			The speed it will move, in pixels per second (default is 100 pixels/sec)</haxe_doc>
		</moveTowardsTouch>
		<moveTowardsPoint public="1" get="inline" set="null" line="66" static="1">
			<f a="Source:Target:?Speed" v="::100">
				<c path="flixel.addons.nape.FlxNapeSprite"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the x/y velocity on the source FlxNapeSprite so it will move towards the target coordinates at the speed given (in pixels per second)
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * @param	Source		The FlxNapeSprite to move
	 * @param	Target		The FlxPoint coordinates to move the source FlxSprite towards
	 * @param	Speed		The speed it will move, in pixels per second (default is 100 pixels/sec)</haxe_doc>
		</moveTowardsPoint>
		<stopVelocity public="1" get="inline" set="null" line="76" static="1">
			<f a="Source">
				<c path="flixel.addons.nape.FlxNapeSprite"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops a FlxNapeSprite from moving by setting its velocity to 0, 0.
	 * @param	Source		The FlxNapeSprite to stop</haxe_doc>
		</stopVelocity>
		<haxe_doc>* Some of the FlxVelocity functions, working with nape.</haxe_doc>
	</class>
	<class path="flixel.addons.plugin.FlxMouseControl" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/plugin/FlxMouseControl.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<ASCENDING public="1" get="inline" set="null" line="23" static="1">
			<x path="Int"/>
			<haxe_doc>* Use with sort() to sort in ascending order.</haxe_doc>
		</ASCENDING>
		<DESCENDING public="1" get="inline" set="null" line="27" static="1">
			<x path="Int"/>
			<haxe_doc>* Use with sort() to sort in descending order.</haxe_doc>
		</DESCENDING>
		<sortIndex public="1" line="31" static="1">
			<c path="String"/>
			<haxe_doc>* The value that the FlxExtendedSprites are sorted by before deciding which is "on-top" for click select</haxe_doc>
		</sortIndex>
		<sortOrder public="1" line="35" static="1">
			<x path="Int"/>
			<haxe_doc>* The sorting order. If the sortIndex is "y" and the order is ASCENDING then a sprite with a Y value of 200 would be "on-top" of one with a Y value of 100.</haxe_doc>
		</sortOrder>
		<isDragging public="1" line="39" static="1">
			<x path="Bool"/>
			<haxe_doc>* Is the mouse currently dragging a sprite? If you have just clicked but NOT yet moved the mouse then this might return false.</haxe_doc>
		</isDragging>
		<dragTarget public="1" static="1">
			<c path="flixel.addons.display.FlxExtendedSprite"/>
			<haxe_doc>* The FlxExtendedSprite that is currently being dragged, if any.</haxe_doc>
		</dragTarget>
		<clickTarget public="1" static="1"><c path="flixel.addons.display.FlxExtendedSprite"/></clickTarget>
		<speedX public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* The speed the mouse is moving on the X axis in pixels per frame</haxe_doc>
		</speedX>
		<speedY public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* The speed the mouse is moving on the Y axis in pixels per frame</haxe_doc>
		</speedY>
		<mouseZone public="1" static="1">
			<c path="flixel.util.FlxRect"/>
			<haxe_doc>* The mouse can be set to only be active within a specific FlxRect region of the game world.
	 * If outside this FlxRect no clicks, drags or throws will be processed.
	 * If the mouse leaves this region while still dragging then the sprite is automatically dropped and its release handler is called.
	 * Set the FlxRect to null to disable the zone.</haxe_doc>
		</mouseZone>
		<linkToDeadZone public="1" line="65" static="1">
			<x path="Bool"/>
			<haxe_doc>* Instead of using a mouseZone (which is calculated in world coordinates) you can limit the mouse to the FlxG.camera.deadzone area instead.
	 * If set to true the mouse will use the camera deadzone. If false (or the deadzone is null) no check will take place.
	 * Note that this takes priority over the mouseZone above. If the mouseZone and deadzone are set, the deadzone is used.</haxe_doc>
		</linkToDeadZone>
		<_clickStack line="70" static="1">
			<c path="Array"><c path="flixel.addons.display.FlxExtendedSprite"/></c>
			<haxe_doc>* The FlxExtendedSprite that currently has the mouse button pressed on it</haxe_doc>
		</_clickStack>
		<_clickCoords static="1"><c path="flixel.util.FlxPoint"/></_clickCoords>
		<_hasClickTarget line="72" static="1"><x path="Bool"/></_hasClickTarget>
		<_oldX line="74" static="1"><x path="Int"/></_oldX>
		<_oldY line="75" static="1"><x path="Int"/></_oldY>
		<addToStack public="1" set="method" line="82" static="1">
			<f a="Item">
				<c path="flixel.addons.display.FlxExtendedSprite"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds the given FlxExtendedSprite to the stack of potential sprites that were clicked, the stack is then sorted and the final sprite is selected from that
	 * 
	 * @param	Item	The FlxExtendedSprite that was clicked by the mouse</haxe_doc>
		</addToStack>
		<clear public="1" set="method" line="100" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all references to any click / drag targets and resets this class</haxe_doc>
		</clear>
		<update public="1" set="method" line="128" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Main Update Loop - checks mouse status and updates FlxExtendedSprites accordingly</haxe_doc>
		</update>
		<releaseMouse set="method" line="185">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function used to release the click / drag targets and reset the mouse state</haxe_doc>
		</releaseMouse>
		<assignClickedSprite set="method" line="200">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Once the clickStack is created this sorts it and then picks the sprite with the highest priority (based on sortIndex and sortOrder)</haxe_doc>
		</assignClickedSprite>
		<sortHandler set="method" line="227">
			<f a="Item1:Item2">
				<c path="flixel.addons.display.FlxExtendedSprite"/>
				<c path="flixel.addons.display.FlxExtendedSprite"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Helper function for the sort process.
	 * 
	 * @param 	Item1	The first object being sorted.
	 * @param	Item2	The second object being sorted.
	 * 
	 * @return	An integer value: -1 (item1 before item2), 0 (same), or 1 (item1 after item2)</haxe_doc>
		</sortHandler>
		<destroy public="1" set="method" line="247" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Runs when this plugin is destroyed</haxe_doc>
		</destroy>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* FlxMouseControl
 * 
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
	</class>
	<class path="flixel.addons.plugin.FlxScrollingText" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/plugin/FlxScrollingText.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<members line="23" static="1"><x path="Map">
	<c path="flixel.FlxSprite"/>
	<d/>
</x></members>
		<zeroPoint line="24" static="1"><c path="flash.geom.Point"/></zeroPoint>
		<add public="1" set="method" line="41" static="1">
			<f a="bitmapFont:region:?pixels:?steps:?text:?onlyScrollOnscreen:?loopOnWrap" v="::1:0:'FLIXEL ROCKS!':true:true">
				<c path="flixel.addons.text.FlxBitmapFont"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Adds an FlxBitmapFont to the Scrolling Text Manager and returns an FlxSprite which contains the text scroller in it.
	 * The FlxSprite will automatically update itself via this plugin, but can be treated as a normal FlxSprite in all other regards
	 * re: positioning, collision, rotation, etc.
	 * 
	 * @param	bitmapFont			A pre-prepared FlxBitmapFont object (see the Test Suite examples for details on how this works)
	 * @param	region				A Rectangle that defines the size of the scrolling FlxSprite. The sprite will be placed at region.x/y and be region.width/height in size.
	 * @param	pixels				The number of pixels to scroll per step. For a smooth (but slow) scroll use low values. Keep the value proportional to the font width, so if the font width is 16 use a value like 1, 2, 4 or 8.
	 * @param	steps				How many steps should pass before the text is next scrolled? Default 0 means every step we scroll. Higher values slow things down.
	 * @param	text				The default text for your scrolling message. Can be changed in real-time via the addText method.
	 * @param	onlyScrollOnscreen	Only update the text scroller when this FlxSprite is visible on-screen? Default true.
	 * @param	loopOnWrap			When the scroller reaches the end of the given "text" should it wrap to the start? Default true. If false it will clear the screen then set itself to not update.
	 * 
	 * @return	An FlxSprite of size region.width/height, positioned at region.x/y, that auto-updates its contents while this plugin runs</haxe_doc>
		</add>
		<addText public="1" set="method" line="105" static="1">
			<f a="source:text:?overwrite" v="::false">
				<c path="flixel.FlxSprite"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds or replaces the text in the given Text Scroller.
	 * Can be called while the scroller is still active.
	 * 
	 * @param	source		The FlxSprite Text Scroller you wish to update (must have been added to FlxScrollingText via a call to add()
	 * @param	text		The text to add or update to the Scroller
	 * @param	overwrite	If true the given text will fully replace the previous scroller text. If false it will be appended to the end (default)</haxe_doc>
		</addText>
		<scroll set="method" line="119" static="1"><f a="data">
	<d/>
	<x path="Void"/>
</f></scroll>
		<clear public="1" set="method" line="201" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all FlxSprites
	 * This is called automatically if the plugin is destroyed, but should be called manually by you if you change States
	 * as all the FlxSprites will be destroyed by Flixel otherwise</haxe_doc>
		</clear>
		<startScrolling public="1" set="method" line="215" static="1">
			<f a="?source" v="null">
				<c path="flixel.FlxSprite"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Starts scrolling on the given FlxSprite. If no FlxSprite is given it starts scrolling on all FlxSprites currently added.
	 * Scrolling is enabled by default, but this can be used to re-start it if you have stopped it via stopScrolling.
	 * 
	 * @param	source	The FlxSprite to start scrolling on. If left as null it will start scrolling on all sprites.</haxe_doc>
		</startScrolling>
		<stopScrolling public="1" set="method" line="236" static="1">
			<f a="?source" v="null">
				<c path="flixel.FlxSprite"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops scrolling on the given FlxSprite. If no FlxSprite is given it stops scrolling on all FlxSprites currently added.
	 * Scrolling is enabled by default, but this can be used to stop it.
	 * 
	 * @param	source	The FlxSprite to stop scrolling on. If left as null it will stop scrolling on all sprites.</haxe_doc>
		</stopScrolling>
		<isScrolling public="1" set="method" line="258" static="1">
			<f a="source">
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if the given FlxSprite is a Scrolling Text, and is actively scrolling or not
	 * Note: If the text is set to only scroll when on-screen, but if off-screen when this is called, it will still return true.
	 * 
	 * @param	source	The FlxSprite to check for scrolling on.
	 * @return	Bool true is the FlxSprite was found and is scrolling, otherwise false</haxe_doc>
		</isScrolling>
		<remove public="1" set="method" line="274" static="1">
			<f a="source">
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Removes an FlxSprite from the Text Scroller. Note that it doesn't restore the sprite bitmapData.
	 * 
	 * @param	source	The FlxSprite to remove scrolling for.
	 * @return	Bool	true if the FlxSprite was removed, otherwise false.</haxe_doc>
		</remove>
		<draw public="1" set="method" line="286" override="1"><f a=""><x path="Void"/></f></draw>
		<destroy public="1" set="method" line="297" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* FlxScrollingText
 * -- Part of the Flixel Power Tools set
 * 
 * v1.0 First version released
 * 
 * @version 1.0 - May 5th 2011
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm
 * @co-author Ungar Djordje / ArtBIT (HaXe port)</haxe_doc>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="C:\HaxeToolkit\haxe\std/cpp/_std/haxe/ds/ObjectMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<__Internal><c path="haxe.ds.IntMap"><c path="haxe.ds.ObjectMap.V"/></c></__Internal>
		<__KeyRefs><c path="haxe.ds.IntMap"><c path="haxe.ds.ObjectMap.K"/></c></__KeyRefs>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="40">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="44">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="48">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="54">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="58">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="62">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.
	
	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="C:\HaxeToolkit\haxe\std/cpp/_std/haxe/ds/IntMap.hx">
		<implements path="IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><d/></h>
		<set public="1" set="method" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="36">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="40">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="44">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="48">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="58">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="flixel.addons.plugin.control.FlxControl" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/plugin/control/FlxControl.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<player1 public="1" static="1"><c path="flixel.addons.plugin.control.FlxControlHandler"/></player1>
		<player2 public="1" static="1"><c path="flixel.addons.plugin.control.FlxControlHandler"/></player2>
		<player3 public="1" static="1"><c path="flixel.addons.plugin.control.FlxControlHandler"/></player3>
		<player4 public="1" static="1"><c path="flixel.addons.plugin.control.FlxControlHandler"/></player4>
		<_members line="24" static="1"><c path="haxe.ds.ObjectMap">
	<c path="flixel.addons.plugin.control.FlxControlHandler"/>
	<c path="flixel.addons.plugin.control.FlxControlHandler"/>
</c></_members>
		<create public="1" set="method" line="38" static="1">
			<f a="Sprite:MovementType:StoppingType:?Player:?UpdateFacing:?EnableArrowKeys" v=":::1:false:true">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.addons.plugin.control.FlxControlHandler"/>
			</f>
			<haxe_doc>* Creates a new FlxControlHandler. You can have as many FlxControlHandlers as you like, but you usually only have one per player. The first handler you make
	 * will be assigned to the FlxControl.player1 var. The 2nd to FlxControl.player2 and so on for player3 and player4. Beyond this you need to keep a reference to the
	 * handler yourself.
	 * 
	 * @param	Sprite			The FlxSprite you want this class to control. It can only control one FlxSprite at once.
	 * @param	MovementType	Set to either MOVEMENT_INSTANT or MOVEMENT_ACCELERATES
	 * @param	StoppingType	Set to STOPPING_INSTANT, STOPPING_DECELERATES or STOPPING_NEVER
	 * @param	UpdateFacing	If true it sets the FlxSprite.facing value to the direction pressed (default false)
	 * @param	EnableArrowKeys	If true it will enable all arrow keys (default) - see setCursorControl for more fine-grained control
	 * @return	The new FlxControlHandler</haxe_doc>
		</create>
		<remove public="1" set="method" line="82" static="1">
			<f a="ControlHandler">
				<c path="flixel.addons.plugin.control.FlxControlHandler"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Removes a FlxControlHandler 
	 * 
	 * @param	ControlHandler	The FlxControlHandler to delete
	 * @return	Boolean	true if the FlxControlHandler was removed, otherwise false.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="97" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all FlxControlHandlers.
	 * This is called automatically if this plugin is ever destroyed.</haxe_doc>
		</clear>
		<start public="1" set="method" line="111" static="1">
			<f a="?ControlHandler" v="null">
				<c path="flixel.addons.plugin.control.FlxControlHandler"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Starts updating the given FlxControlHandler, enabling keyboard actions for it. If no FlxControlHandler is given it starts updating all FlxControlHandlers currently added.
	 * Updating is enabled by default, but this can be used to re-start it if you have stopped it via stop().
	 * 
	 * @param	ControlHandler	The FlxControlHandler to start updating on. If left as null it will start updating all handlers.</haxe_doc>
		</start>
		<stop public="1" set="method" line="132" static="1">
			<f a="?ControlHandler" v="null">
				<c path="flixel.addons.plugin.control.FlxControlHandler"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops updating the given FlxControlHandler. If no FlxControlHandler is given it stops updating all FlxControlHandlers currently added.
	 * Updating is enabled by default, but this can be used to stop it, for example if you paused your game (see start() to restart it again).
	 * 
	 * @param	ControlHandler	The FlxControlHandler to stop updating. If left as null it will stop updating all handlers.</haxe_doc>
		</stop>
		<update public="1" set="method" line="150" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Runs update on all currently active FlxControlHandlers</haxe_doc>
		</update>
		<destroy public="1" set="method" line="164" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Runs when this plugin is destroyed</haxe_doc>
		</destroy>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* FlxControl
 *
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
	</class>
	<class path="flixel.addons.plugin.control.FlxControlHandler" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/plugin/control/FlxControlHandler.hx">
		<MOVEMENT_INSTANT public="1" get="inline" set="null" line="32" static="1">
			<x path="Int"/>
			<haxe_doc>* The "Instant" Movement Type means the sprite will move at maximum speed instantly, and will not "accelerate" (or speed-up) before reaching that speed.</haxe_doc>
		</MOVEMENT_INSTANT>
		<MOVEMENT_ACCELERATES public="1" get="inline" set="null" line="36" static="1">
			<x path="Int"/>
			<haxe_doc>* The "Accelerates" Movement Type means the sprite will accelerate until it reaches maximum speed.</haxe_doc>
		</MOVEMENT_ACCELERATES>
		<STOPPING_INSTANT public="1" get="inline" set="null" line="40" static="1">
			<x path="Int"/>
			<haxe_doc>* The "Instant" Stopping Type means the sprite will stop immediately when no direction keys are being pressed, there will be no deceleration.</haxe_doc>
		</STOPPING_INSTANT>
		<STOPPING_DECELERATES public="1" get="inline" set="null" line="44" static="1">
			<x path="Int"/>
			<haxe_doc>* The "Decelerates" Stopping Type means the sprite will start decelerating when no direction keys are being pressed. Deceleration continues until the speed reaches zero.</haxe_doc>
		</STOPPING_DECELERATES>
		<STOPPING_NEVER public="1" get="inline" set="null" line="48" static="1">
			<x path="Int"/>
			<haxe_doc>* The "Never" Stopping Type means the sprite will never decelerate, any speed built up will be carried on and never reduce.</haxe_doc>
		</STOPPING_NEVER>
		<ROTATION_INSTANT public="1" get="inline" set="null" line="53" static="1">
			<x path="Int"/>
			<haxe_doc>* The "Instant" Movement Type means the sprite will rotate at maximum speed instantly, and will not "accelerate" (or speed-up) before reaching that speed.</haxe_doc>
		</ROTATION_INSTANT>
		<ROTATION_ACCELERATES public="1" get="inline" set="null" line="57" static="1">
			<x path="Int"/>
			<haxe_doc>* The "Accelerates" Rotaton Type means the sprite will accelerate until it reaches maximum rotation speed.</haxe_doc>
		</ROTATION_ACCELERATES>
		<ROTATION_STOPPING_INSTANT public="1" get="inline" set="null" line="61" static="1">
			<x path="Int"/>
			<haxe_doc>* The "Instant" Stopping Type means the sprite will stop rotating immediately when no rotation keys are being pressed, there will be no deceleration.</haxe_doc>
		</ROTATION_STOPPING_INSTANT>
		<ROTATION_STOPPING_DECELERATES public="1" get="inline" set="null" line="65" static="1">
			<x path="Int"/>
			<haxe_doc>* The "Decelerates" Stopping Type means the sprite will start decelerating when no rotation keys are being pressed. Deceleration continues until rotation speed reaches zero.</haxe_doc>
		</ROTATION_STOPPING_DECELERATES>
		<ROTATION_STOPPING_NEVER public="1" get="inline" set="null" line="69" static="1">
			<x path="Int"/>
			<haxe_doc>* The "Never" Stopping Type means the sprite will never decelerate, any speed built up will be carried on and never reduce.</haxe_doc>
		</ROTATION_STOPPING_NEVER>
		<KEYMODE_PRESSED public="1" get="inline" set="null" line="74" static="1">
			<x path="Int"/>
			<haxe_doc>* This keymode fires for as long as the key is held down</haxe_doc>
		</KEYMODE_PRESSED>
		<KEYMODE_JUST_DOWN public="1" get="inline" set="null" line="79" static="1">
			<x path="Int"/>
			<haxe_doc>* This keyboard fires when the key has just been pressed down, and not again until it is released and re-pressed</haxe_doc>
		</KEYMODE_JUST_DOWN>
		<KEYMODE_RELEASED public="1" get="inline" set="null" line="84" static="1">
			<x path="Int"/>
			<haxe_doc>* This keyboard fires only when the key has been pressed and then released again</haxe_doc>
		</KEYMODE_RELEASED>
		<DIAGONAL_COMPENSATION_FACTOR get="inline" set="null" line="95" static="1"><x path="Float"/></DIAGONAL_COMPENSATION_FACTOR>
		<isPressedUp public="1"><x path="Bool"/></isPressedUp>
		<isPressedDown public="1"><x path="Bool"/></isPressedDown>
		<isPressedLeft public="1"><x path="Bool"/></isPressedLeft>
		<isPressedRight public="1"><x path="Bool"/></isPressedRight>
		<enabled public="1"><x path="Bool"/></enabled>
		<_entity><c path="flixel.FlxSprite"/></_entity>
		<_bounds><c path="flash.geom.Rectangle"/></_bounds>
		<_up><x path="Bool"/></_up>
		<_down><x path="Bool"/></_down>
		<_left><x path="Bool"/></_left>
		<_right><x path="Bool"/></_right>
		<_fire><x path="Bool"/></_fire>
		<_altFire><x path="Bool"/></_altFire>
		<_jump><x path="Bool"/></_jump>
		<_altJump><x path="Bool"/></_altJump>
		<_xFacing><x path="Bool"/></_xFacing>
		<_yFacing><x path="Bool"/></_yFacing>
		<_rotateAntiClockwise><x path="Bool"/></_rotateAntiClockwise>
		<_rotateClockwise><x path="Bool"/></_rotateClockwise>
		<_upMoveSpeed><x path="Int"/></_upMoveSpeed>
		<_downMoveSpeed><x path="Int"/></_downMoveSpeed>
		<_leftMoveSpeed><x path="Int"/></_leftMoveSpeed>
		<_rightMoveSpeed><x path="Int"/></_rightMoveSpeed>
		<_thrustSpeed><x path="Int"/></_thrustSpeed>
		<_reverseSpeed><x path="Int"/></_reverseSpeed>
		<_thrustEnabled><x path="Bool"/></_thrustEnabled>
		<_reverseEnabled><x path="Bool"/></_reverseEnabled>
		<_isRotating><x path="Bool"/></_isRotating>
		<_antiClockwiseRotationSpeed><x path="Float"/></_antiClockwiseRotationSpeed>
		<_clockwiseRotationSpeed><x path="Float"/></_clockwiseRotationSpeed>
		<_enforceAngleLimits><x path="Bool"/></_enforceAngleLimits>
		<_minAngle><x path="Int"/></_minAngle>
		<_maxAngle><x path="Int"/></_maxAngle>
		<_capAngularVelocity><x path="Bool"/></_capAngularVelocity>
		<_xSpeedAdjust><x path="Float"/></_xSpeedAdjust>
		<_ySpeedAdjust><x path="Float"/></_ySpeedAdjust>
		<_gravityX><x path="Int"/></_gravityX>
		<_gravityY><x path="Int"/></_gravityY>
		<_fireRate><x path="Int"/></_fireRate>
		<_nextFireTime><x path="Int"/></_nextFireTime>
		<_lastFiredTime><x path="Int"/></_lastFiredTime>
		<_fireKeyMode><x path="Int"/></_fireKeyMode>
		<_fireCallback><f a=""><x path="Void"/></f></_fireCallback>
		<_jumpHeight><x path="Int"/></_jumpHeight>
		<_jumpRate><x path="Int"/></_jumpRate>
		<_jumpKeyMode><x path="Int"/></_jumpKeyMode>
		<_nextJumpTime><x path="Int"/></_nextJumpTime>
		<_lastJumpTime><x path="Int"/></_lastJumpTime>
		<_jumpFromFallTime><x path="Int"/></_jumpFromFallTime>
		<_extraSurfaceTime><x path="Int"/></_extraSurfaceTime>
		<_jumpSurface><x path="Int"/></_jumpSurface>
		<_jumpCallback><f a=""><x path="Void"/></f></_jumpCallback>
		<_movement><x path="Int"/></_movement>
		<_stopping><x path="Int"/></_stopping>
		<_rotation><x path="Int"/></_rotation>
		<_rotationStopping><x path="Int"/></_rotationStopping>
		<_capVelocity><x path="Bool"/></_capVelocity>
		<_hotkeys><c path="Array"><c path="String"/></c></_hotkeys>
		<_upKey><c path="String"/></_upKey>
		<_downKey><c path="String"/></_downKey>
		<_leftKey><c path="String"/></_leftKey>
		<_rightKey><c path="String"/></_rightKey>
		<_fireKey><c path="String"/></_fireKey>
		<_altFireKey><c path="String"/></_altFireKey>
		<_jumpKey><c path="String"/></_jumpKey>
		<_altJumpKey><c path="String"/></_altJumpKey>
		<_antiClockwiseKey><c path="String"/></_antiClockwiseKey>
		<_clockwiseKey><c path="String"/></_clockwiseKey>
		<_thrustKey><c path="String"/></_thrustKey>
		<_reverseKey><c path="String"/></_reverseKey>
		<_jumpSound><c path="flixel.system.FlxSound"/></_jumpSound>
		<_fireSound><c path="flixel.system.FlxSound"/></_fireSound>
		<_walkSound><c path="flixel.system.FlxSound"/></_walkSound>
		<_thrustSound><c path="flixel.system.FlxSound"/></_thrustSound>
		<setMovementSpeed public="1" set="method" line="243">
			<f a="SpeedX:SpeedY:SpeedMaxX:SpeedMaxY:?DecelerationX:?DecelerationY" v="::::0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed at which the sprite will move when a direction key is pressed.
	 * All values are given in pixels per second. So an xSpeed of 100 would move the sprite 100 pixels in 1 second (1000ms)
	 * Due to the nature of the internal Flash timer this amount is not 100% accurate and will vary above/below the desired distance by a few pixels.
	 * 
	 * If you need different speed values for left/right or up/down then use setAdvancedMovementSpeed
	 * 
	 * @param	SpeedX			The speed in pixels per second in which the sprite will move/accelerate horizontally
	 * @param	SpeedY			The speed in pixels per second in which the sprite will move/accelerate vertically
	 * @param	SpeedMaxX		The maximum speed in pixels per second in which the sprite can move horizontally
	 * @param	SpeedMaxY		The maximum speed in pixels per second in which the sprite can move vertically
	 * @param	DecelerationX	A deceleration speed in pixels per second to apply to the sprites horizontal movement (default 0)
	 * @param	DecelerationY	A deceleration speed in pixels per second to apply to the sprites vertical movement (default 0)</haxe_doc>
		</setMovementSpeed>
		<setStandardSpeed public="1" set="method" line="260">
			<f a="Speed:?Acceleration" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you know you need the same value for the acceleration, maximum speeds and (optionally) deceleration then this is a quick way to set them.
	 * 
	 * @param	Speed			The speed in pixels per second in which the sprite will move/accelerate/decelerate
	 * @param	Acceleration	If true it will set the speed value as the deceleration value (default) false will leave deceleration disabled</haxe_doc>
		</setStandardSpeed>
		<setAdvancedMovementSpeed public="1" set="method" line="288">
			<f a="LeftSpeed:RightSpeed:UpSpeed:DownSpeed:SpeedMaxX:SpeedMaxY:?DecelerationX:?DecelerationY" v="::::::0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed at which the sprite will move when a direction key is pressed.
	 * All values are given in pixels per second. So an xSpeed of 100 would move the sprite 100 pixels in 1 second (1000ms)
	 * Due to the nature of the internal Flash timer this amount is not 100% accurate and will vary above/below the desired distance by a few pixels.
	 * 
	 * If you don't need different speed values for every direction on its own then use setMovementSpeed
	 * 
	 * @param	LeftSpeed		The speed in pixels per second in which the sprite will move/accelerate to the left
	 * @param	RightSpeed		The speed in pixels per second in which the sprite will move/accelerate to the right
	 * @param	UpSpeed			The speed in pixels per second in which the sprite will move/accelerate up
	 * @param	DownSpeed		The speed in pixels per second in which the sprite will move/accelerate down
	 * @param	SpeedMaxX		The maximum speed in pixels per second in which the sprite can move horizontally
	 * @param	SpeedMaxY		The maximum speed in pixels per second in which the sprite can move vertically
	 * @param	DecelerationX	Deceleration speed in pixels per second to apply to the sprites horizontal movement (default 0)
	 * @param	DecelerationY	Deceleration speed in pixels per second to apply to the sprites vertical movement (default 0)</haxe_doc>
		</setAdvancedMovementSpeed>
		<setRotationSpeed public="1" set="method" line="305">
			<f a="AntiClockwiseSpeed:ClockwiseSpeed:SpeedMax:Deceleration">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the speed at which the sprite will rotate when a direction key is pressed.
	 * Use this in combination with setMovementSpeed to create a Thrust like movement system.
	 * All values are given in pixels per second. So an xSpeed of 100 would rotate the sprite 100 pixels in 1 second (1000ms)
	 * Due to the nature of the internal Flash timer this amount is not 100% accurate and will vary above/below the desired distance by a few pixels.</haxe_doc>
		</setRotationSpeed>
		<setRotationType public="1" set="method" line="319">
			<f a="RotationType:StoppingType">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	RotationType
	 * @param	StoppingType</haxe_doc>
		</setRotationType>
		<setMaximumRotationSpeed public="1" set="method" line="333">
			<f a="Speed:?LimitVelocity" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the maximum speed (in pixels per second) that the FlxSprite can rotate.
	 * When the FlxSprite is accelerating (movement type MOVEMENT_ACCELERATES) its speed won't increase above this value.
	 * However Flixel allows the velocity of an FlxSprite to be set to anything. So if you'd like to check the value and restrain it, then enable "limitVelocity".
	 * 
	 * @param	Speed			The maximum speed in pixels per second in which the sprite can rotate
	 * @param	LimitVelocity	If true the angular velocity of the FlxSprite will be checked and kept within the limit. If false it can be set to anything.</haxe_doc>
		</setMaximumRotationSpeed>
		<setRotationDeceleration public="1" set="method" line="346">
			<f a="Speed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Deceleration is a speed (in pixels per second) that is applied to the sprite if stopping type is "DECELERATES" and if no rotation is taking place.
	 * The velocity of the sprite will be reduced until it reaches zero.
	 * 
	 * @param	Speed	The speed in pixels per second at which the sprite will have its angular rotation speed decreased</haxe_doc>
		</setRotationDeceleration>
		<setRotationLimits public="1" set="method" line="358">
			<f a="MinimumAngle:MaximumAngle">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set minimum and maximum angle limits that the Sprite won't be able to rotate beyond.
	 * Values must be between -180 and +180. 0 is pointing right, 90 down, 180 left, -90 up.
	 * 
	 * @param	MinimumAngle	Minimum angle below which the sprite cannot rotate (must be -180 or above)
	 * @param	MaximumAngle	Maximum angle above which the sprite cannot rotate (must be 180 or below)</haxe_doc>
		</setRotationLimits>
		<disableRotationLimits public="1" set="method" line="375">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Disables rotation limits set in place by setRotationLimits()</haxe_doc>
		</disableRotationLimits>
		<setRotationKeys public="1" set="method" line="388">
			<f a="?LeftRight:?UpDown:?CustomAntiClockwise:?CustomClockwise" v="true:false:'':''">
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set which keys will rotate the sprite. The speed of rotation is set in setRotationSpeed.
	 * 
	 * @param	LeftRight				Use the LEFT and RIGHT arrow keys for anti-clockwise and clockwise rotation respectively.
	 * @param	UpDown					Use the UP and DOWN arrow keys for anti-clockwise and clockwise rotation respectively.
	 * @param	CustomAntiClockwise		The String value of your own key to use for anti-clockwise rotation (as taken from flixel.system.input.Keyboard)
	 * @param	CustomClockwise			The String value of your own key to use for clockwise rotation (as taken from flixel.system.input.Keyboard)</haxe_doc>
		</setRotationKeys>
		<setThrust public="1" set="method" line="418">
			<f a="ThrustKey:ThrustSpeed:?ReverseKey:?ReverseSpeed" v="::null:0">
				<c path="String"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you want to enable a Thrust like motion for your sprite use this to set the speed and keys.
	 * This is usually used in conjunction with Rotation and it will over-ride anything already defined in setMovementSpeed.
	 * 
	 * @param	ThrustKey		Specify the key String (as taken from flixel.system.input.Keyboard) to use for the Thrust action
	 * @param	ThrustSpeed		The speed in pixels per second which the sprite will move. Acceleration or Instant movement is determined by the Movement Type.
	 * @param	ReverseKey		If you want to be able to reverse, set the key string as taken from flixel.system.input.Keyboard (defaults to null).
	 * @param	ReverseSpeed	The speed in pixels per second which the sprite will reverse. Acceleration or Instant movement is determined by the Movement Type.</haxe_doc>
		</setThrust>
		<setMaximumSpeed public="1" set="method" line="447">
			<f a="SpeedX:SpeedY:?LimitVelocity" v="::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the maximum speed (in pixels per second) that the FlxSprite can move. You can set the horizontal and vertical speeds independantly.
	 * When the FlxSprite is accelerating (movement type MOVEMENT_ACCELERATES) its speed won't increase above this value.
	 * However Flixel allows the velocity of an FlxSprite to be set to anything. So if you'd like to check the value and restrain it, then enable "limitVelocity".
	 * 
	 * @param	SpeedX			The maximum speed in pixels per second in which the sprite can move horizontally
	 * @param	SpeedY			The maximum speed in pixels per second in which the sprite can move vertically
	 * @param	LimitVelocity	If true the velocity of the FlxSprite will be checked and kept within the limit. If false it can be set to anything.</haxe_doc>
		</setMaximumSpeed>
		<setDeceleration public="1" set="method" line="462">
			<f a="SpeedX:SpeedY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Deceleration is a speed (in pixels per second) that is applied to the sprite if stopping type is "DECELERATES" and if no acceleration is taking place.
	 * The velocity of the sprite will be reduced until it reaches zero, and can be configured separately per axis.
	 * 
	 * @param	SpeedX		The speed in pixels per second at which the sprite will have its horizontal speed decreased
	 * @param	SpeedY		The speed in pixels per second at which the sprite will have its vertical speed decreased</haxe_doc>
		</setDeceleration>
		<setGravity public="1" set="method" line="476">
			<f a="ForceX:ForceY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Gravity can be applied to the sprite, pulling it in any direction.
	 * Gravity is given in pixels per second and is applied as acceleration. The speed the sprite reaches under gravity will never exceed the Maximum Movement Speeds set.
	 * If you don't want gravity for a specific direction pass a value of zero.
	 * 
	 * @param	ForceX	A positive value applies gravity dragging the sprite to the right. A negative value drags the sprite to the left. Zero disables horizontal gravity.
	 * @param	ForceY	A positive value applies gravity dragging the sprite down. A negative value drags the sprite up. Zero disables vertical gravity.</haxe_doc>
		</setGravity>
		<flipGravity public="1" set="method" line="489">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Switches the gravity applied to the sprite. If gravity was +400 Y (pulling them down) this will swap it to -400 Y (pulling them up)
	 * To reset call flipGravity again</haxe_doc>
		</flipGravity>
		<speedUp public="1" set="method" line="510">
			<f a="FactorX:FactorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* TODO
	 * 
	 * @param	FactorX
	 * @param	FactorY</haxe_doc>
		</speedUp>
		<slowDown public="1" set="method" line="520">
			<f a="FactorX:FactorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* TODO
	 * 
	 * @param	FactorX
	 * @param	FactorY</haxe_doc>
		</slowDown>
		<resetSpeeds public="1" set="method" line="530">
			<f a="?ResetX:?ResetY" v="true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* TODO
	 * 
	 * @param	ResetX
	 * @param	ResetY</haxe_doc>
		</resetSpeeds>
		<addHotKey public="1" set="method" line="550">
			<f a="Key:Callback:Keymode">
				<c path="String"/>
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new Hot Key, which can be bound to any function you specify (such as "swap weapon", "quit", etc)
	 * 
	 * @param	Key			The key to use as the hot key (String from flixel.system.input.Keyboard, i.e. "SPACE", "CONTROL", "Q", etc)
	 * @param	Callback	The function to call when the key is pressed
	 * @param	Keymode		The keymode that will trigger the callback, either KEYMODE_PRESSED, KEYMODE_JUST_DOWN or KEYMODE_RELEASED</haxe_doc>
		</addHotKey>
		<removeHotKey public="1" set="method" line="561">
			<f a="Key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Removes a previously defined hot key
	 * 
	 * @param	Key		The key to use as the hot key (String from flixel.system.input.Keyboard, i.e. "SPACE", "CONTROL", "Q", etc)
	 * @return	True if the key was found and removed, false if the key couldn't be found</haxe_doc>
		</removeHotKey>
		<setSounds public="1" set="method" line="574">
			<f a="?Jump:?Fire:?Walk:?Thrust" v="null:null:null:null">
				<c path="flixel.system.FlxSound"/>
				<c path="flixel.system.FlxSound"/>
				<c path="flixel.system.FlxSound"/>
				<c path="flixel.system.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set sound effects for the movement events jumping, firing, walking and thrust.
	 * 
	 * @param	Jump	The FlxSound to play when the user jumps
	 * @param	Fire	The FlxSound to play when the user fires
	 * @param	Walk	The FlxSound to play when the user walks
	 * @param	Thrust	The FlxSound to play when the user thrusts</haxe_doc>
		</setSounds>
		<setFireButton public="1" set="method" line="606">
			<f a="Key:Keymode:RepeatDelay:Callback:?AltKey" v="::::''">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<f a=""><x path="Void"/></f>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enable a fire button
	 * 
	 * @param	Key				The key to use as the fire button (String from flixel.system.input.Keyboard, i.e. "SPACE", "CONTROL")
	 * @param	Keymode			The FlxControlHandler KEYMODE value (KEYMODE_PRESSED, KEYMODE_JUST_DOWN, KEYMODE_RELEASED)
	 * @param	RepeatDelay		Time delay in ms between which the fire action can repeat (0 means instant, 250 would allow it to fire approx. 4 times per second)
	 * @param	Callback		A user defined function to call when it fires
	 * @param	AltKey			Specify an alternative fire key that works AS WELL AS the primary fire key (TODO)</haxe_doc>
		</setFireButton>
		<setJumpButton public="1" set="method" line="633">
			<f a="Key:Keymode:Height:Surface:?RepeatDelay:?JumpFromFall:?Callback:?AltKey" v="::::250:0:null:''">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<f a=""><x path="Void"/></f>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enable a jump button
	 * 
	 * @param	Key				The key to use as the jump button (String from flixel.system.input.Keyboard, i.e. "SPACE", "CONTROL")
	 * @param	Keymode			The FlxControlHandler KEYMODE value (KEYMODE_PRESSED, KEYMODE_JUST_DOWN, KEYMODE_RELEASED)
	 * @param	Height			The height in pixels/sec that the Sprite will attempt to jump (gravity and acceleration can influence this actual height obtained)
	 * @param	Surface			A bitwise combination of all valid surfaces the Sprite can jump off (from FlxObject, such as FlxObject.FLOOR)
	 * @param	RepeatDelay		Time delay in ms between which the jumping can repeat (250 would be 4 times per second)
	 * @param	JumpFromFall	A time in ms that allows the Sprite to still jump even if it's just fallen off a platform, if still within ths time limit
	 * @param	Callback		A user defined function to call when the Sprite jumps
	 * @param	AltKey			Specify an alternative jump key that works AS WELL AS the primary jump key (TODO)</haxe_doc>
		</setJumpButton>
		<setBounds public="1" set="method" line="660">
			<f a="X:Y:Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Limits the sprite to only be allowed within this rectangle. If its x/y coordinates go outside it will be repositioned back inside.
	 * Coordinates should be given in GAME WORLD pixel values (not screen value, although often they are the two same things)
	 * 
	 * @param	X		The x coordinate of the top left corner of the area (in game world pixels)
	 * @param	Y		The y coordinate of the top left corner of the area (in game world pixels)
	 * @param	Width	The width of the area (in pixels)
	 * @param	Height	The height of the area (in pixels)</haxe_doc>
		</setBounds>
		<removeBounds public="1" set="method" line="668">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears any previously set sprite bounds</haxe_doc>
		</removeBounds>
		<moveUp set="method" line="673"><f a=""><x path="Bool"/></f></moveUp>
		<moveDown set="method" line="705"><f a=""><x path="Bool"/></f></moveDown>
		<moveLeft set="method" line="738"><f a=""><x path="Bool"/></f></moveLeft>
		<moveRight set="method" line="770"><f a=""><x path="Bool"/></f></moveRight>
		<moveAntiClockwise set="method" line="802"><f a=""><x path="Bool"/></f></moveAntiClockwise>
		<moveClockwise set="method" line="829"><f a=""><x path="Bool"/></f></moveClockwise>
		<moveThrust set="method" line="856"><f a=""><x path="Bool"/></f></moveThrust>
		<moveReverse set="method" line="893"><f a=""><x path="Bool"/></f></moveReverse>
		<runFire set="method" line="923"><f a=""><x path="Bool"/></f></runFire>
		<runJump set="method" line="962"><f a=""><x path="Bool"/></f></runJump>
		<update public="1" set="method" line="1043">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the FlxControl plugin</haxe_doc>
		</update>
		<setCustomKeys public="1" set="method" line="1234">
			<f a="CustomUpKey:CustomDownKey:CustomLeftKey:CustomRightKey">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets Custom Key controls. Useful if none of the pre-defined sets work. All String values should be taken from flixel.system.input.Keyboard
	 * Pass a blank (empty) String to disable that key from being checked.
	 * 
	 * @param	CustomUpKey		The String to use for the Up key.
	 * @param	CustomDownKey	The String to use for the Down key.
	 * @param	CustomLeftKey	The String to use for the Left key.
	 * @param	CustomRightKey	The String to use for the Right key.</haxe_doc>
		</setCustomKeys>
		<setCursorControl public="1" set="method" line="1270">
			<f a="?AllowUp:?AllowDown:?AllowLeft:?AllowRight" v="true:true:true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables Cursor/Arrow Key controls. Can be set on a per-key basis. Useful if you only want to allow a few keys.
	 * For example in a Space Invaders game you'd only enable LEFT and RIGHT.
	 * 
	 * @param	AllowUp		Enable the UP key
	 * @param	AllowDown	Enable the DOWN key
	 * @param	AllowLeft	Enable the LEFT key
	 * @param	AllowRight	Enable the RIGHT key</haxe_doc>
		</setCursorControl>
		<setWASDControl public="1" set="method" line="1292">
			<f a="?AllowUp:?AllowDown:?AllowLeft:?AllowRight" v="true:true:true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables WASD controls. Can be set on a per-key basis. Useful if you only want to allow a few keys.
	 * For example in a Space Invaders game you'd only enable LEFT and RIGHT.
	 * 
	 * @param	allowUp		Enable the up (W) key
	 * @param	allowDown	Enable the down (S) key
	 * @param	allowLeft	Enable the left (A) key
	 * @param	allowRight	Enable the right (D) key</haxe_doc>
		</setWASDControl>
		<setESDFControl public="1" set="method" line="1314">
			<f a="?AllowUp:?AllowDown:?AllowLeft:?AllowRight" v="true:true:true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables ESDF (home row) controls. Can be set on a per-key basis. Useful if you only want to allow a few keys.
	 * For example in a Space Invaders game you'd only enable LEFT and RIGHT.
	 * 
	 * @param	AllowUp		Enable the up (E) key
	 * @param	AllowDown	Enable the down (D) key
	 * @param	AllowLeft	Enable the left (S) key
	 * @param	AllowRight	Enable the right (F) key</haxe_doc>
		</setESDFControl>
		<setIJKLControl public="1" set="method" line="1336">
			<f a="?AllowUp:?AllowDown:?AllowLeft:?AllowRight" v="true:true:true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables IJKL (right-sided or secondary player) controls. Can be set on a per-key basis. Useful if you only want to allow a few keys.
	 * For example in a Space Invaders game you'd only enable LEFT and RIGHT.
	 * 
	 * @param	AllowUp		Enable the up (I) key
	 * @param	AllowDown	Enable the down (K) key
	 * @param	AllowLeft	Enable the left (J) key
	 * @param	AllowRight	Enable the right (L) key</haxe_doc>
		</setIJKLControl>
		<setHJKLControl public="1" set="method" line="1358">
			<f a="?AllowUp:?AllowDown:?AllowLeft:?AllowRight" v="true:true:true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables HJKL (Rogue / Net-Hack) controls. Can be set on a per-key basis. Useful if you only want to allow a few keys.
	 * For example in a Space Invaders game you'd only enable LEFT and RIGHT.
	 * 
	 * @param	AllowUp		Enable the up (K) key
	 * @param	AllowDown	Enable the down (J) key
	 * @param	AllowLeft	Enable the left (H) key
	 * @param	AllowRight	Enable the right (L) key</haxe_doc>
		</setHJKLControl>
		<setZQSDControl public="1" set="method" line="1380">
			<f a="?AllowUp:?AllowDown:?AllowLeft:?AllowRight" v="true:true:true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables ZQSD (Azerty keyboard) controls. Can be set on a per-key basis. Useful if you only want to allow a few keys.
	 * For example in a Space Invaders game you'd only enable LEFT and RIGHT.
	 * 
	 * @param	AllowUp		Enable the up (Z) key
	 * @param	AllowDown	Enable the down (Q) key
	 * @param	AllowLeft	Enable the left (S) key
	 * @param	AllowRight	Enable the right (D) key</haxe_doc>
		</setZQSDControl>
		<setDvorakSimplifiedControl public="1" set="method" line="1402">
			<f a="?AllowUp:?AllowDown:?AllowLeft:?AllowRight" v="true:true:true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables Dvoark Simplified Controls. Can be set on a per-key basis. Useful if you only want to allow a few keys.
	 * For example in a Space Invaders game you'd only enable LEFT and RIGHT.
	 * 
	 * @param	AllowUp		Enable the up (COMMA) key
	 * @param	AllowDown	Enable the down (A) key
	 * @param	AllowLeft	Enable the left (O) key
	 * @param	AllowRight	Enable the right (E) key</haxe_doc>
		</setDvorakSimplifiedControl>
		<setNumpadControl public="1" set="method" line="1424">
			<f a="?AllowUp:?AllowDown:?AllowLeft:?AllowRight" v="true:true:true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables Numpad (left-handed) Controls. Can be set on a per-key basis. Useful if you only want to allow a few keys.
	 * For example in a Space Invaders game you'd only enable LEFT and RIGHT.
	 * 
	 * @param	AllowUp		Enable the up (NUMPADEIGHT) key
	 * @param	AllowDown	Enable the down (NUMPADTWO) key
	 * @param	AllowLeft	Enable the left (NUMPADFOUR) key
	 * @param	AllowRight	Enable the right (NUMPADSIX) key</haxe_doc>
		</setNumpadControl>
		<new public="1" set="method" line="208">
			<f a="Sprite:MovementType:StoppingType:?UpdateFacing:?EnableArrowKeys" v=":::false:true">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the FlxSprite to be controlled by this class, and defines the initial movement and stopping types.
	 * After creating an instance of this class you should call setMovementSpeed, and one of the enableXControl functions if you need more than basic cursors.
	 * 
	 * @param	Sprite			The FlxSprite you want this class to control. It can only control one FlxSprite at once.
	 * @param	MovementType	Set to either MOVEMENT_INSTANT or MOVEMENT_ACCELERATES
	 * @param	StoppingType	Set to STOPPING_INSTANT, STOPPING_DECELERATES or STOPPING_NEVER
	 * @param	UpdateFacing	If true it sets the FlxSprite.facing value to the direction pressed (default false)
	 * @param	EnableArrowKeys	If true it will enable all arrow keys (default) - see setCursorControl for more fine-grained control</haxe_doc>
		</new>
		<haxe_doc>* 
 * Makes controlling an FlxSprite with the keyboard a LOT easier and quicker to set-up!
 * Sometimes it's hard to know what values to set, especially if you want gravity, jumping, sliding, etc.
 * This class helps sort that - and adds some cool extra functionality too :)
 * 
 * TODO: Hot Keys
 * TODO: Binding of sound effects to keys (seperate from setSounds? as those are event based)
 * TODO: Specify animation frames to play based on velocity
 * TODO: Variable gravity (based on height, the higher the stronger the effect)
 * 
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
	</class>
	<class path="flixel.addons.plugin.screengrab.FlxScreenGrab" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/plugin/screengrab/FlxScreenGrab.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<screenshot public="1" static="1"><c path="flash.display.Bitmap"/></screenshot>
		<_hotkeys static="1"><c path="Array"><c path="String"/></c></_hotkeys>
		<_autoSave line="28" static="1"><x path="Bool"/></_autoSave>
		<_autoHideMouse line="29" static="1"><x path="Bool"/></_autoHideMouse>
		<_region static="1"><c path="flash.geom.Rectangle"/></_region>
		<defineCaptureRegion public="1" set="method" line="42" static="1">
			<f a="X:Y:Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Defines the region of the screen that should be captured. If you need it to be a fixed location then use this.
	 * If you want to grab the whole SWF size, you don't need to set this as that is the default.
	 * Remember that if your game is running in a zoom mode > 1 you need to account for this here.
	 * 
	 * @param	X		The x coordinate (in Flash display space, not Flixel game world)
	 * @param	Y		The y coordinate (in Flash display space, not Flixel game world)
	 * @param	Width	The width of the grab region
	 * @param	Height	The height of the grab region]]></haxe_doc>
		</defineCaptureRegion>
		<clearCaptureRegion public="1" set="method" line="50" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears a previously defined capture region</haxe_doc>
		</clearCaptureRegion>
		<defineHotKeys public="1" set="method" line="63" static="1">
			<f a="Keys:?SaveToFile:?HideMouse" v=":false:false">
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Specify which key will capture a screen shot. Use the String value of the key in the same way FlxG.keys does (so "F1" for example)
	 * Optionally save the image to a file immediately. This uses the file systems "Save as" dialog window and pauses your game during the process.
	 * 
	 * @param	Key			The key(s) you press to capture the screen (i.e. ["F1", "SPACE"])
	 * @param	SaveToFile	If true it will immediately encodes the grab to a PNG and open a "Save As" dialog window when the hotkey is pressed
	 * @param	HideMouse	If true the mouse will be hidden before capture and displayed afterwards when the hotkey is pressed</haxe_doc>
		</defineHotKeys>
		<clearHotKeys public="1" set="method" line="73" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears a previously defined hotkey</haxe_doc>
		</clearHotKeys>
		<grab public="1" set="method" line="88" static="1">
			<f a="?CaptureRegion:?SaveToFile:?HideMouse" v="null:false:false">
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flash.display.Bitmap"/>
			</f>
			<haxe_doc>* Takes a screen grab immediately of the given region or a previously defined region
	 * 
	 * @param	CaptureRegion	A Rectangle area to capture. This over-rides that set by "defineCaptureRegion". If neither are set the full SWF size is used.
	 * @param	SaveToFile		Boolean If set to true it will immediately encode the grab to a PNG and open a "Save As" dialog window
	 * @param	HideMouse		Boolean If set to true the mouse will be hidden before capture and displayed again afterwards
	 * @return	Bitmap			The screen grab as a Flash Bitmap image</haxe_doc>
		</grab>
		<save set="method" line="135" static="1"><f a="?Filename" v="''">
	<c path="String"/>
	<x path="Void"/>
</f></save>
		<update public="1" set="method" line="167" override="1"><f a=""><x path="Void"/></f></update>
		<destroy public="1" set="method" line="180" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Captures a screen grab of the game and stores it locally, optionally saving as a PNG.
 * 
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
	</class>
	<class path="flixel.addons.plugin.taskManager.AntTask" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/plugin/taskManager/AntTask.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<func public="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Method-task to be executed</haxe_doc>
		</func>
		<ignoreCycle public="1">
			<x path="Bool"/>
			<haxe_doc>* If true then the task will be deleted from the manager immediately after execution.</haxe_doc>
		</ignoreCycle>
		<instant public="1">
			<x path="Bool"/>
			<haxe_doc>* If true the task will be completed right after it's first call</haxe_doc>
		</instant>
		<next public="1">
			<c path="flixel.addons.plugin.taskManager.AntTask"/>
			<haxe_doc>* Pointer to the next task.</haxe_doc>
		</next>
		<destroy public="1" set="method" line="45">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroys the list.</haxe_doc>
		</destroy>
		<new public="1" set="method" line="34">
			<f a="Func:?IgnoreCycle:?Instant:?Next" v=":false:false:null">
				<f a=""><x path="Bool"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.addons.plugin.taskManager.AntTask"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new AntTask</haxe_doc>
		</new>
		<haxe_doc>* @author Anton Karlov
 * @since  08.22.2012
 * @author Zaphod
 * @since  11.19.2012</haxe_doc>
	</class>
	<class path="flixel.addons.plugin.taskManager.AntTaskManager" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/plugin/taskManager/AntTaskManager.hx">
		<extends path="flixel.FlxBasic"/>
		<onComplete public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function will be called when all tasks in the task manager are completed</haxe_doc>
		</onComplete>
		<length public="1">
			<x path="Int"/>
			<haxe_doc>* Number of tasks in the list</haxe_doc>
		</length>
		<_taskList>
			<c path="flixel.addons.plugin.taskManager.AntTask"/>
			<haxe_doc>* The list of active tasks</haxe_doc>
		</_taskList>
		<_cycle>
			<x path="Bool"/>
			<haxe_doc>* Determines whether tasks are performed in a loop</haxe_doc>
		</_cycle>
		<_delay>
			<x path="Float"/>
			<haxe_doc>* Used to calculate the current pause between tasks</haxe_doc>
		</_delay>
		<destroy public="1" set="method" line="50" override="1"><f a=""><x path="Void"/></f></destroy>
		<addTask public="1" set="method" line="64">
			<f a="Function:?IgnoreCycle" v=":false">
				<f a=""><x path="Bool"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a task to the end of queue, the method will be executed while it returns false.
	 * The task will be completed only when the method will return true. And manager will switch to the next task.
	 * 
	 * @param	Function		Method-task to be executed in sequence.
	 * @param	IgnoreCycle		If true then the task will be deleted from the manager immediately after execution.</haxe_doc>
		</addTask>
		<addInstantTask public="1" set="method" line="75">
			<f a="Function:?IgnoreCycle" v=":false">
				<f a=""><x path="Bool"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a task to the end of queue, the method will be executed only ONCE, after that we go to the next task.
	 * 
	 * @param	Function		Method-task to be executed in sequence.
	 * @param	IgnoreCycle		If true then the task will be deleted from the manager immediately after execution.</haxe_doc>
		</addInstantTask>
		<addUrgentTask public="1" set="method" line="87">
			<f a="Function:?IgnoreCycle" v=":false">
				<f a=""><x path="Bool"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a task to the top of the queue, the method will be executed while it returns false.
	 * The task will be completed only when the method will return true, and the manager will move to the next task.
	 * 
	 * @param	Function		Method-task to be executed in sequence.
	 * @param	IgnoreCycle		If true then the task will be deleted from the manager immediately after execution.</haxe_doc>
		</addUrgentTask>
		<addUrgentInstantTask public="1" set="method" line="98">
			<f a="Function:?IgnoreCycle" v=":false">
				<f a=""><x path="Bool"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a task to the top of the queue, the method will be executed only ONCE, after that we go to the next task.
	 * 
	 * @param	Function		Method-task to be executed in sequence.
	 * @param	IgnoreCycle		If true then the task will be deleted from the manager immediately after execution.</haxe_doc>
		</addUrgentInstantTask>
		<addPause public="1" set="method" line="109">
			<f a="Delay:?IgnoreCycle" v=":false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a pause between tasks
	 * 
	 * @param	Delay		Pause duration
	 * @param	IgnoreCycle	If true, the pause will be executed only once per cycle</haxe_doc>
		</addPause>
		<clear public="1" set="method" line="117">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all the tasks from manager and stops it</haxe_doc>
		</clear>
		<nextTask public="1" set="method" line="128">
			<f a="?IgnoreCycle" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move to the next task
	 * 
	 * @param	IgnoreCycle 	Specifies whether to leave the previous problem in the manager</haxe_doc>
		</nextTask>
		<update public="1" set="method" line="143" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Current task processing</haxe_doc>
		</update>
		<taskPause set="method" line="169">
			<f a="Delay">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Method-task for a pause between tasks
	 * 
	 * @param	Delay	 Delay
	 * @return	Returns true when the task is completed</haxe_doc>
		</taskPause>
		<push set="method" line="188">
			<f a="Task">
				<c path="flixel.addons.plugin.taskManager.AntTask"/>
				<c path="flixel.addons.plugin.taskManager.AntTask"/>
			</f>
			<haxe_doc>* Adds the specified object to the end of the list
	 * 
	 * @param	Task	The AntTask to be added.
	 * @return	Returns a pointer to the added AntTask.</haxe_doc>
		</push>
		<unshift set="method" line="220">
			<f a="Task">
				<c path="flixel.addons.plugin.taskManager.AntTask"/>
				<c path="flixel.addons.plugin.taskManager.AntTask"/>
			</f>
			<haxe_doc>* Adds task to the top of task list
	 * 
	 * @param	Task	The AntTask to be added.
	 * @return	Returns a pointer to the added AntTask</haxe_doc>
		</unshift>
		<shift set="method" line="241">
			<f a=""><c path="flixel.addons.plugin.taskManager.AntTask"/></f>
			<haxe_doc>* Removes first task
	 * 
	 * @return	The task that has been removed</haxe_doc>
		</shift>
		<new public="1" set="method" line="43"><f a="?Cycle:?OnComplete" v="false:null">
	<x path="Bool"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* The Task Manager is used to perform tasks (call methods) in specified order.
 * Allows you to quickly and easily program any action, such as the appearance of the buttons in the game menus.
 * Task Manager is started automatically when you add at least one task, and stops when all tasks are done.
 * 
 * @author Anton Karlov
 * @since  08.22.2012
 * @author Zaphod
 * @since  11.19.2012</haxe_doc>
	</class>
	<class path="flixel.addons.text.FlxBitmapFont" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/text/FlxBitmapFont.hx">
		<extends path="flixel.FlxSprite"/>
		<ALIGN_LEFT public="1" get="inline" set="null" line="29" static="1">
			<c path="String"/>
			<haxe_doc>* Align each line of multi-line text to the left.</haxe_doc>
		</ALIGN_LEFT>
		<ALIGN_RIGHT public="1" get="inline" set="null" line="33" static="1">
			<c path="String"/>
			<haxe_doc>* Align each line of multi-line text to the right.</haxe_doc>
		</ALIGN_RIGHT>
		<ALIGN_CENTER public="1" get="inline" set="null" line="37" static="1">
			<c path="String"/>
			<haxe_doc>* Align each line of multi-line text in the center.</haxe_doc>
		</ALIGN_CENTER>
		<TEXT_SET1 public="1" get="inline" set="null" line="42" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Text Set 1 = !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~]]></haxe_doc>
		</TEXT_SET1>
		<TEXT_SET2 public="1" get="inline" set="null" line="46" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Text Set 2 =  !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ]]></haxe_doc>
		</TEXT_SET2>
		<TEXT_SET3 public="1" get="inline" set="null" line="50" static="1">
			<c path="String"/>
			<haxe_doc>* Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</haxe_doc>
		</TEXT_SET3>
		<TEXT_SET4 public="1" get="inline" set="null" line="54" static="1">
			<c path="String"/>
			<haxe_doc>* Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789</haxe_doc>
		</TEXT_SET4>
		<TEXT_SET5 public="1" get="inline" set="null" line="58" static="1">
			<c path="String"/>
			<haxe_doc>* Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789</haxe_doc>
		</TEXT_SET5>
		<TEXT_SET6 public="1" get="inline" set="null" line="62" static="1">
			<c path="String"/>
			<haxe_doc>* Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.'</haxe_doc>
		</TEXT_SET6>
		<TEXT_SET7 public="1" get="inline" set="null" line="66" static="1">
			<c path="String"/>
			<haxe_doc>* Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39</haxe_doc>
		</TEXT_SET7>
		<TEXT_SET8 public="1" get="inline" set="null" line="70" static="1">
			<c path="String"/>
			<haxe_doc>* Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ</haxe_doc>
		</TEXT_SET8>
		<TEXT_SET9 public="1" get="inline" set="null" line="74" static="1">
			<c path="String"/>
			<haxe_doc>* Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!</haxe_doc>
		</TEXT_SET9>
		<TEXT_SET10 public="1" get="inline" set="null" line="78" static="1">
			<c path="String"/>
			<haxe_doc>* Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ</haxe_doc>
		</TEXT_SET10>
		<TEXT_SET11 public="1" get="inline" set="null" line="82" static="1">
			<c path="String"/>
			<haxe_doc>* Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789</haxe_doc>
		</TEXT_SET11>
		<align public="1">
			<c path="String"/>
			<haxe_doc>* Alignment of the text when multiLine = true or a fixedWidth is set. Set to FlxBitmapFont.ALIGN_LEFT (default), FlxBitmapFont.ALIGN_RIGHT or FlxBitmapFont.ALIGN_CENTER.</haxe_doc>
		</align>
		<multiLine public="1">
			<x path="Bool"/>
			<haxe_doc>* If set to true all carriage-returns in text will form new lines (see align). If false the font will only contain one single line of text (the default)</haxe_doc>
		</multiLine>
		<autoUpperCase public="1">
			<x path="Bool"/>
			<haxe_doc>* Automatically convert any text to upper case. Lots of old bitmap fonts only contain upper-case characters, so the default is true.</haxe_doc>
		</autoUpperCase>
		<customSpacingX public="1">
			<x path="Int"/>
			<haxe_doc>* Adds horizontal spacing between each character of the font, in pixels. Default is 0.</haxe_doc>
		</customSpacingX>
		<customSpacingY public="1">
			<x path="Int"/>
			<haxe_doc>* Adds vertical spacing between each line of multi-line text, set in pixels. Default is 0.</haxe_doc>
		</customSpacingY>
		<_points>
			<c path="Array"><x path="Float"/></c>
			<haxe_doc>* Offsets for each letter in the sprite (not affected by scale and rotation)</haxe_doc>
		</_points>
		<_charFrameIDs>
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* Frame IDs for each letter in the font set bitmapData</haxe_doc>
		</_charFrameIDs>
		<_fontSet>
			<c path="flixel.util.loaders.CachedGraphics"/>
			<haxe_doc>* Internval values. All set in the constructor. They should not be changed after that point.</haxe_doc>
		</_fontSet>
		<_fontRegion><c path="flixel.system.layer.Region"/></_fontRegion>
		<_grabData><c path="Array"><c path="flash.geom.Rectangle"/></c></_grabData>
		<_characterPerRow><x path="Int"/></_characterPerRow>
		<_fixedWidth><x path="Int"/></_fixedWidth>
		<_text><c path="String"/></_text>
		<_charsInFont><c path="String"/></_charsInFont>
		<_textWidth><x path="Int"/></_textWidth>
		<_textHeight><x path="Int"/></_textHeight>
		<characterWidth public="1" set="null"><x path="Int"/></characterWidth>
		<characterHeight public="1" set="null"><x path="Int"/></characterHeight>
		<setFontGraphics public="1" set="method" line="180"><f a="value">
	<c path="flixel.util.loaders.CachedGraphics"/>
	<x path="Void"/>
</f></setFontGraphics>
		<updateFrameData public="1" set="method" line="195" override="1"><f a=""><x path="Void"/></f></updateFrameData>
		<destroy public="1" set="method" line="204" override="1"><f a=""><x path="Void"/></f></destroy>
		<updateCharFrameIDs set="method" line="218"><f a=""><x path="Void"/></f></updateCharFrameIDs>
		<draw public="1" set="method" line="273" override="1"><f a=""><x path="Void"/></f></draw>
		<isSimpleRender public="1" set="method" line="370" override="1"><f a=""><x path="Bool"/></f></isSimpleRender>
		<text public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Set this value to update the text in this sprite. Carriage returns are automatically stripped 
	 * out if multiLine is false. Text is converted to upper case if autoUpperCase is true.</haxe_doc>
		</text>
		<get_text set="method" line="382"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="387"><f a="NewText">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<updateTextString set="method" line="409"><f a="NewText">
	<c path="String"/>
	<x path="Void"/>
</f></updateTextString>
		<setFixedWidth public="1" set="method" line="423">
			<f a="Width:?LineAlignment" v=":'left'">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you need this FlxSprite to have a fixed width and custom alignment you can set the width here.
	 * If text is wider than the width specified it will be cropped off.
	 * 
	 * @param	Width			Width in pixels of this FlxBitmapFont. Set to zero to disable and re-enable automatic resizing.
	 * @param	LineAlignment	Align the text within this width. Set to FlxBitmapFont.ALIGN_LEFT (default), FlxBitmapFont.ALIGN_RIGHT or FlxBitmapFont.ALIGN_CENTER.</haxe_doc>
		</setFixedWidth>
		<setText public="1" set="method" line="439">
			<f a="Text:?MultiLines:?CharacterSpacing:?LineSpacing:?LineAlignment:?AllowLowerCase" v=":false:0:0:'left':false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A helper function that quickly sets lots of variables at once, and then updates the text.
	 * 
	 * @param	Text				The text of this sprite
	 * @param	MultiLines			Set to true if you want to support carriage-returns in the text and create a multi-line sprite instead of a single line (default is false).
	 * @param	CharacterSpacing	To add horizontal spacing between each character specify the amount in pixels (default 0).
	 * @param	LineSpacing			To add vertical spacing between each line of text, set the amount in pixels (default 0).
	 * @param	LineAlignment		Align each line of multi-line text. Set to FlxBitmapFont.ALIGN_LEFT (default), FlxBitmapFont.ALIGN_RIGHT or FlxBitmapFont.ALIGN_CENTER.
	 * @param	AllowLowerCase		Lots of bitmap font sets only include upper-case characters, if yours needs to support lower case then set this to true.</haxe_doc>
		</setText>
		<buildBitmapFontText set="method" line="464">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the BitmapData of the Sprite with the text</haxe_doc>
		</buildBitmapFontText>
		<getCharacter public="1" set="method" line="594">
			<f a="Char">
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Returns a single character from the font set as an FlxSprite.
	 * 
	 * @param	Char	The character you wish to have returned.
	 * @return	A FlxSprite containing a single character from the font set.</haxe_doc>
		</getCharacter>
		<getCharacterAsBitmapData public="1" set="method" line="615">
			<f a="Char">
				<c path="String"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Returns a single character from the font set as bitmapData
	 * 
	 * @param	Char	The character you wish to have returned.
	 * @return	bitmapData containing a single character from the font set.</haxe_doc>
		</getCharacterAsBitmapData>
		<pasteLine set="method" line="640">
			<f a="Line:?X:?Y:?CustomSpacingX" v=":0:0:0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function that takes a single line of text (2nd parameter) and pastes it into the BitmapData at the given coordinates.
	 * Used by getLine and getMultiLine
	 * 
	 * @param	Output			The BitmapData that the text will be drawn onto
	 * @param	Line			The single line of text to paste
	 * @param	X				The x coordinate
	 * @param	Y
	 * @param	CustomSpacingX</haxe_doc>
		</pasteLine>
		<getLongestLine set="method" line="683">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Works out the longest line of text in _text and returns its length
	 * 
	 * @return	A value</haxe_doc>
		</getLongestLine>
		<removeUnsupportedCharacters set="method" line="709">
			<f a="?StripCR" v="true">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Internal helper function that removes all unsupported characters from the _text String, leaving only characters contained in the font set.
	 * 
	 * @param	StripCR		Should it strip carriage returns as well? (default = true)
	 * @return	A clean version of the string</haxe_doc>
		</removeUnsupportedCharacters>
		<new public="1" set="method" line="145">
			<f a="Font:CharacterWidth:CharacterHeight:Chars:CharsPerRow:?SpacingX:?SpacingY:?OffsetX:?OffsetY" v=":::::0:0:0:0">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Loads 'font' and prepares it for use by future calls to .text
	 * 
	 * @param	Font			The font set graphic class (as defined by your embed)
	 * @param	CharacterWidth	The width of each character in the font set.
	 * @param	CharacterHeight	The height of each character in the font set.
	 * @param	Chars			The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.
	 * @param	CharsPerRow		The number of characters per row in the font set.
	 * @param	SpacingX		If the characters in the font set have horizontal spacing between them set the required amount here.
	 * @param	SpacingY		If the characters in the font set have vertical spacing between them set the required amount here
	 * @param	OffsetX			If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
	 * @param	OffsetY			If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.</haxe_doc>
		</new>
		<haxe_doc>* FlxBitmapFont
 *
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm
 * @see Requires FlxMath</haxe_doc>
	</class>
	<class path="flixel.addons.text.TypeSound" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/text/FlxTypeText.hx" module="flixel.addons.text.FlxTypeText">
		<extends path="flash.media.Sound"/>
		<resourceName line="15" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="15"><f a="?stream:?context:?forcePlayAsMusic" v="null:null:false">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":sound"><e>"assets/sounds/typetext.wav"</e></m>
		</meta>
	</class>
	<class path="flixel.text.FlxText" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/text/FlxText.hx">
		<extends path="flixel.FlxSprite"/>
		<BORDER_NONE public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></BORDER_NONE>
		<BORDER_SHADOW public="1" get="inline" set="null" line="33" static="1">
			<x path="Int"/>
			<haxe_doc>* A simple shadow to the lower-right</haxe_doc>
		</BORDER_SHADOW>
		<BORDER_OUTLINE public="1" get="inline" set="null" line="37" static="1">
			<x path="Int"/>
			<haxe_doc>* Outline on all 8 sides</haxe_doc>
		</BORDER_OUTLINE>
		<BORDER_OUTLINE_FAST public="1" get="inline" set="null" line="41" static="1">
			<x path="Int"/>
			<haxe_doc>* Outline, optimized using only 4 draw calls. (Might not work for narrow and/or 1-pixel fonts)</haxe_doc>
		</BORDER_OUTLINE_FAST>
		<text public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* The text being displayed.</haxe_doc>
		</text>
		<size public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The size of the text being displayed.</haxe_doc>
		</size>
		<font public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* The font used for this text (assuming that it's using embedded font).</haxe_doc>
		</font>
		<embedded public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether this text field uses an embedded font (by default) or not. 
	 * Read-only - use systemFont to specify a system font to use, which then automatically sets this to false.</haxe_doc>
		</embedded>
		<systemFont public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* The system font for this text (not embedded). Setting this sets embedded to false.
	 * Passing an invalid font name (like "" or null) causes a default font to be used.</haxe_doc>
		</systemFont>
		<bold public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether to use bold text or not (false by default).</haxe_doc>
		</bold>
		<italic public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether to use italic text or not (false by default). It only works in Flash.</haxe_doc>
		</italic>
		<wordWrap public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether to use word wrapping and multiline or not (true by default).</haxe_doc>
		</wordWrap>
		<alignment public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* The alignment of the font ("left", "right", or "center").</haxe_doc>
		</alignment>
		<borderStyle public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Use a border style like FlxText.SHADOW or FlxText.OUTLINE</haxe_doc>
		</borderStyle>
		<borderColor public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The color of the border in 0xRRGGBB format</haxe_doc>
		</borderColor>
		<borderSize public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The size of the border, in pixels.</haxe_doc>
		</borderSize>
		<borderQuality public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* How many iterations do use when drawing the border. 0: only 1 iteration, 1: one iteration for every pixel in borderSize
	 * A value of 1 will have the best quality for large border sizes, but might reduce performance when changing text. 
	 * NOTE: If the borderSize is 1, borderQuality of 0 or 1 will have the exact same effect (and performance).</haxe_doc>
		</borderQuality>
		<textField public="1" get="accessor" set="null">
			<c path="flash.text.TextField"/>
			<haxe_doc>* Internal reference to a Flash TextField object.</haxe_doc>
		</textField>
		<fieldWidth public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The width of the TextField object used for bitmap generation for this FlxText object.
	 * Use it when you want to change the visible width of text. Enables autoSize if <= 0.]]></haxe_doc>
		</fieldWidth>
		<autoSize public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the fieldWidth should be determined automatically. Requires wordWrap to be false.</haxe_doc>
		</autoSize>
		<shadowOffset public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Offset that is applied to the shadow border style, if active. 
	 * x and y are multiplied by borderSize. Default is (1, 1), or lower-right corner.</haxe_doc>
		</shadowOffset>
		<_textField>
			<c path="flash.text.TextField"/>
			<haxe_doc>* Internal reference to a Flash TextField object.</haxe_doc>
		</_textField>
		<_defaultFormat>
			<c path="flash.text.TextFormat"/>
			<haxe_doc>* Internal reference to a Flash TextFormat object.</haxe_doc>
		</_defaultFormat>
		<_formatAdjusted>
			<c path="flash.text.TextFormat"/>
			<haxe_doc>* Internal reference to another helper Flash TextFormat object.</haxe_doc>
		</_formatAdjusted>
		<_formats>
			<c path="Array"><c path="flixel.text.FlxTextFormat"/></c>
			<haxe_doc>* Internal reference to an Array of FlxTextFormat</haxe_doc>
		</_formats>
		<_filters><c path="Array"><c path="flash.filters.BitmapFilter"/></c></_filters>
		<_widthInc><x path="Int"/></_widthInc>
		<_heightInc><x path="Int"/></_heightInc>
		<destroy public="1" set="method" line="229" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<addFormat public="1" set="method" line="258">
			<f a="Format:?Start:?End" v=":-1:-1">
				<c path="flixel.text.FlxTextFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds another format to this FlxText
	 * 
	 * @param	Format	The format to be added.
	 * @param	Start	(Default = -1) The start index of the string where the format will be applied. If greater than -1, this value will override the format.start value.
	 * @param	End		(Default = -1) The end index of the string where the format will be applied. If greater than -1, this value will override the format.start value.</haxe_doc>
		</addFormat>
		<removeFormat public="1" get="inline" set="null" line="271">
			<f a="Format">
				<c path="flixel.text.FlxTextFormat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes a specific FlxTextFormat from this text.</haxe_doc>
		</removeFormat>
		<clearFormats public="1" set="method" line="280">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears all the formats applied.</haxe_doc>
		</clearFormats>
		<setFormat public="1" set="method" line="308">
			<f a="?Font:?Size:?Color:?Alignment:?BorderStyle:?BorderColor:?Embedded" v="null:8:16777215:null:0:0:true">
				<c path="String"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.text.FlxText"/>
			</f>
			<haxe_doc>* You can use this if you have a lot of text parameters
	 * to set instead of the individual properties.
	 * 
	 * @param	Font		The name of the font face for the text display.
	 * @param	Size		The size of the font (in pixels essentially).
	 * @param	Color		The color of the text in traditional flash 0xRRGGBB format.
	 * @param	Alignment	A string representing the desired alignment ("left,"right" or "center").
	 * @param	BorderStyle	FlxText.NONE, SHADOW, OUTLINE, or OUTLINE_FAST (use setBorderFormat
	 * @param	BorderColor Int, color for the border, 0xRRGGBB format
	 * @param	EmbeddedFont	Whether this text field uses embedded fonts or not
	 * @return	This FlxText instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</setFormat>
		<setBorderStyle public="1" get="inline" set="null" line="349">
			<f a="Style:?Color:?Size:?Quality" v=":0:1:1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set border's style (shadow, outline, etc), color, and size all in one go!
	 * 
	 * @param	Style outline style - FlxText.NONE, SHADOW, OUTLINE, OUTLINE_FAST
	 * @param	Color outline color in flash 0xRRGGBB format
	 * @param	Size outline size in pixels
	 * @param	Quality outline quality - # of iterations to use when drawing. 0:just 1, 1:equal number to BorderSize</haxe_doc>
		</setBorderStyle>
		<addFilter public="1" get="inline" set="null" line="357"><f a="filter:?widthInc:?heightInc" v=":0:0">
	<c path="flash.filters.BitmapFilter"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addFilter>
		<removeFilter public="1" set="method" line="365"><f a="filter">
	<c path="flash.filters.BitmapFilter"/>
	<x path="Void"/>
</f></removeFilter>
		<clearFilters public="1" set="method" line="374"><f a=""><x path="Void"/></f></clearFilters>
		<updateFrameData public="1" set="method" line="383" override="1"><f a=""><x path="Void"/></f></updateFrameData>
		<applyFormats get="inline" set="null" line="393"><f a="FormatAdjusted:?UseBorderColor" v=":false">
	<c path="flash.text.TextFormat"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></applyFormats>
		<set_fieldWidth set="method" line="420"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fieldWidth>
		<get_fieldWidth set="method" line="440"><f a=""><x path="Float"/></f></get_fieldWidth>
		<set_autoSize set="method" line="445"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoSize>
		<get_autoSize set="method" line="460"><f a=""><x path="Bool"/></f></get_autoSize>
		<get_text set="method" line="465"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="470"><f a="Text">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<get_size set="method" line="483"><f a=""><x path="Float"/></f></get_size>
		<set_size set="method" line="488"><f a="Size">
	<x path="Float"/>
	<x path="Float"/>
</f></set_size>
		<set_color set="method" line="501" override="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* The color of the text being displayed.</haxe_doc>
		</set_color>
		<get_font set="method" line="516"><f a=""><c path="String"/></f></get_font>
		<set_font set="method" line="521"><f a="Font">
	<c path="String"/>
	<c path="String"/>
</f></set_font>
		<get_embedded get="inline" set="null" line="531"><f a=""><x path="Bool"/></f></get_embedded>
		<get_systemFont get="inline" set="null" line="536"><f a=""><c path="String"/></f></get_systemFont>
		<set_systemFont set="method" line="541"><f a="Font">
	<c path="String"/>
	<c path="String"/>
</f></set_systemFont>
		<get_bold get="inline" set="null" line="551"><f a=""><x path="Bool"/></f></get_bold>
		<set_bold set="method" line="556"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bold>
		<get_italic get="inline" set="null" line="568"><f a=""><x path="Bool"/></f></get_italic>
		<set_italic set="method" line="573"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_italic>
		<get_wordWrap get="inline" set="null" line="585"><f a=""><x path="Bool"/></f></get_wordWrap>
		<set_wordWrap set="method" line="590"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wordWrap>
		<get_alignment get="inline" set="null" line="601"><f a=""><c path="String"/></f></get_alignment>
		<set_alignment set="method" line="606"><f a="Alignment">
	<c path="String"/>
	<c path="String"/>
</f></set_alignment>
		<set_borderStyle set="method" line="615"><f a="style">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderStyle>
		<set_borderColor set="method" line="626"><f a="Color">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderColor>
		<set_borderSize set="method" line="639"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderSize>
		<set_borderQuality set="method" line="650"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderQuality>
		<get_textField set="method" line="666"><f a=""><c path="flash.text.TextField"/></f></get_textField>
		<set_cachedGraphics set="method" line="671" override="1"><f a="Value">
	<c path="flixel.util.loaders.CachedGraphics"/>
	<c path="flixel.util.loaders.CachedGraphics"/>
</f></set_cachedGraphics>
		<updateColorTransform set="method" line="681" override="1"><f a=""><x path="Void"/></f></updateColorTransform>
		<regenGraphics set="method" line="708"><f a=""><x path="Void"/></f></regenGraphics>
		<calcFrame set="method" line="750" override="1">
			<f a="?RunOnCpp" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function to update the current animation frame.
	 * 
	 * @param	RunOnCpp	Whether the frame should also be recalculated if we're on a non-flash target</haxe_doc>
		</calcFrame>
		<dtfCopy set="method" line="908">
			<f a=""><c path="flash.text.TextFormat"/></f>
			<haxe_doc>* A helper function for updating the TextField that we use for rendering.
	 * 
	 * @return	A writable copy of TextField.defaultTextFormat.</haxe_doc>
		</dtfCopy>
		<convertTextAlignmentFromString set="method" line="921">
			<f a="StrAlign">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Method for converting string to TextFormatAlign</haxe_doc>
		</convertTextAlignmentFromString>
		<updateFormat get="inline" set="null" line="942"><f a="Format">
	<c path="flash.text.TextFormat"/>
	<x path="Void"/>
</f></updateFormat>
		<new public="1" set="method" line="165">
			<f a="?X:?Y:?FieldWidth:?Text:?Size:?EmbeddedFont" v="0:0:0:null:8:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new FlxText object at the specified position.
	 * 
	 * @param	X				The X position of the text.
	 * @param	Y				The Y position of the text.
	 * @param	FieldWidth		The width of the text object. Enables autoSize if <= 0. (height is determined automatically).
	 * @param	Text			The actual text you would like to display initially.
	 * @param	Size			The font size for this text object.
	 * @param	EmbeddedFont	Whether this text field uses embedded fonts or not.]]></haxe_doc>
		</new>
		<haxe_doc>* Extends FlxSprite to support rendering text. Can tint, fade, rotate and scale just like a sprite. Doesn't really animate 
 * though, as far as I know. Also does nice pixel-perfect centering on pixel fonts as long as they are only one liners.</haxe_doc>
	</class>
	<class path="flixel.addons.text.FlxTypeText" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/text/FlxTypeText.hx">
		<extends path="flixel.text.FlxText"/>
		<helperString line="155" static="1">
			<c path="String"/>
			<haxe_doc>* Helper string to reduce garbage generation.</haxe_doc>
		</helperString>
		<delay public="1">
			<x path="Float"/>
			<haxe_doc>* The delay between each character, in seconds.</haxe_doc>
		</delay>
		<eraseDelay public="1">
			<x path="Float"/>
			<haxe_doc>* The delay between each character erasure, in seconds.</haxe_doc>
		</eraseDelay>
		<showCursor public="1">
			<x path="Bool"/>
			<haxe_doc>* Set to true to show a blinking cursor at the end of the text.</haxe_doc>
		</showCursor>
		<cursorCharacter public="1">
			<c path="String"/>
			<haxe_doc>* The character to blink at the end of the text.</haxe_doc>
		</cursorCharacter>
		<cursorBlinkSpeed public="1">
			<x path="Float"/>
			<haxe_doc>* The speed at which the cursor should blink, if shown at all.</haxe_doc>
		</cursorBlinkSpeed>
		<prefix public="1">
			<c path="String"/>
			<haxe_doc>* Text to add at the beginning, without animating.</haxe_doc>
		</prefix>
		<autoErase public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not to erase this message when it is complete.</haxe_doc>
		</autoErase>
		<waitTime public="1">
			<x path="Float"/>
			<haxe_doc>* How long to pause after finishing the text before erasing it. Only used if autoErase is true.</haxe_doc>
		</waitTime>
		<paused public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not to animate the text. Set to false by start() and erase().</haxe_doc>
		</paused>
		<useDefaultSound public="1">
			<x path="Bool"/>
			<haxe_doc>* If this is set to true, this class will use typetext.wav from flixel-addons for the type sound unless you specify another.</haxe_doc>
		</useDefaultSound>
		<sound public="1">
			<c path="flixel.system.FlxSound"/>
			<haxe_doc>* The sound that is played when letters are added; optional.</haxe_doc>
		</sound>
		<skipKeys public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* An array of keys as string values (e.g. "SPACE", "L") that will advance the text.</haxe_doc>
		</skipKeys>
		<_finalText>
			<c path="String"/>
			<haxe_doc>* The text that will ultimately be displayed.</haxe_doc>
		</_finalText>
		<_onComplete>
			<d/>
			<haxe_doc>* This function is called when the message is done typing.</haxe_doc>
		</_onComplete>
		<_onCompleteParams>
			<c path="Array"><d/></c>
			<haxe_doc>* Optional parameters that will be passed to the _onComplete function.</haxe_doc>
		</_onCompleteParams>
		<_onErase>
			<d/>
			<haxe_doc>* This function is called when the message is done erasing, if that is enabled.</haxe_doc>
		</_onErase>
		<_onEraseParams>
			<c path="Array"><d/></c>
			<haxe_doc>* Optional parameters that will be passed to the _onErase function.</haxe_doc>
		</_onEraseParams>
		<_timer>
			<x path="Float"/>
			<haxe_doc>* This is incremented every frame by FlxG.elapsed, and when greater than delay, adds the next letter.</haxe_doc>
		</_timer>
		<_waitTimer>
			<x path="Float"/>
			<haxe_doc>* A timer that is used while waiting between typing and erasing.</haxe_doc>
		</_waitTimer>
		<_length>
			<x path="Int"/>
			<haxe_doc>* Internal tracker for current string length, not counting the prefix.</haxe_doc>
		</_length>
		<_typing>
			<x path="Bool"/>
			<haxe_doc>* Whether or not to type the text. Set to true by start() and false by pause().</haxe_doc>
		</_typing>
		<_erasing>
			<x path="Bool"/>
			<haxe_doc>* Whether or not to erase the text. Set to true by erase() and false by pause().</haxe_doc>
		</_erasing>
		<_waiting>
			<x path="Bool"/>
			<haxe_doc>* Whether or not we're waiting between the type and erase phases.</haxe_doc>
		</_waiting>
		<_cursorTimer>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for cursor blink time.</haxe_doc>
		</_cursorTimer>
		<_typingVariation>
			<x path="Bool"/>
			<haxe_doc>* Whether or not to add a "natural" uneven rhythm to the typing speed.</haxe_doc>
		</_typingVariation>
		<_typeVarPercent>
			<x path="Float"/>
			<haxe_doc>* How much to vary typing speed, as a percent. So, at 0.5, each letter will be "typed" up to 50% sooner or later than the delay variable is set.</haxe_doc>
		</_typeVarPercent>
		<setCompleteCallback public="1" set="method" line="186">
			<f a="Callback:?Params" v=":null">
				<d/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a function to be called when typing the message is complete.
	 * 
	 * @param	Callback	The callback function.
	 * @param	Params		Any params you want to pass to the function. Optional!</haxe_doc>
		</setCompleteCallback>
		<setEraseCallback public="1" set="method" line="205">
			<f a="Callback:?Params" v=":null">
				<d/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a function to be called when erasing is complete.
	 * Make sure to set erase = true or else this will never be called!
	 * 
	 * @param	Callback		The callback function.
	 * @param	Params			Any params you want to pass to the function. Optional!</haxe_doc>
		</setEraseCallback>
		<start public="1" set="method" line="228">
			<f a="?Delay:?ForceRestart:?AutoErase:?Sound:?SkipKeys:?Callback:?Params" v="null:false:false:null:null:null:null">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.system.FlxSound"/>
				<c path="Array"><c path="String"/></c>
				<d/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Start the text animation.
	 * 
	 * @param	Delay			Optionally, set the delay between characters. Can also be set separately.
	 * @param	ForceRestart	Whether or not to start this animation over if currently animating; false by default.
	 * @param	AutoErase		Whether or not to begin the erase animation when the typing animation is complete. Can also be set separately.
	 * @param	Sound			A FlxSound object to play when a character is typed. Can also be set separately.
	 * @param	SkipKeys		An array of keys as string values (e.g. "SPACE", "L") that will advance the text. Can also be set separately.
	 * @param	Callback		An optional callback function, to be called when the typing animation is complete.
	 * @param 	Params			Optional parameters to pass to the callback function.</haxe_doc>
		</start>
		<erase public="1" set="method" line="285">
			<f a="?Delay:?ForceRestart:?Sound:?SkipKeys:?Callback:?Params" v="null:false:null:null:null:null">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.system.FlxSound"/>
				<c path="Array"><c path="String"/></c>
				<d/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Begin an animated erase of this text.
	 * 
	 * @param	Delay			Optionally, set the delay between characters. Can also be set separately.
	 * @param	ForceRestart	Whether or not to start this animation over if currently animating; false by default.
	 * @param	Sound			A FlxSound object to play when a character is typed. Can also be set separately.
	 * @param	SkipKeys		An array of keys as string values (e.g. "SPACE", "L") that will advance the text. Can also be set separately.
	 * @param	Callback		An optional callback function, to be called when the erasing animation is complete.
	 * @param	Params			Optional parameters to pass to the callback function.</haxe_doc>
		</erase>
		<resetText public="1" set="method" line="335">
			<f a="Text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Reset the text with a new text string. Automatically cancels typing, and erasing.
	 * 
	 * @param	Text	The text that will ultimately be displayed.</haxe_doc>
		</resetText>
		<setSkipKeys public="1" set="method" line="350">
			<f a="Keys">
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Define the keys that can be used to advance text.
	 * 
	 * @param	Keys	An array of keys as string values (e.g. "SPACE", "L") that will advance the text.</haxe_doc>
		</setSkipKeys>
		<setSound public="1" set="method" line="360">
			<f a="Sound">
				<c path="flixel.system.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a sound that will be played each time a letter is added to the text.
	 * 
	 * @param	Sound	A FlxSound object.</haxe_doc>
		</setSound>
		<setTypingVariation public="1" set="method" line="373">
			<f a="?Amount:?On" v="0.5f:true">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* If called with On set to true, a random variation will be added to the rate of typing.
	 * Especially with sound enabled, this can give a more "natural" feel to the typing.
	 * Much more noticable with longer text delays.
	 * 
	 * @param	Amount		How much variation to add, as a percentage of delay (0.5 = 50% is the maximum amount that will be added or subtracted from the delay variable). Only valid if >0 and <1.
	 * @param	On			Whether or not to add the random variation. True by default.]]></haxe_doc>
		</setTypingVariation>
		<onComplete set="method" line="390">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function that is called when typing is complete.</haxe_doc>
		</onComplete>
		<onErased set="method" line="411"><f a=""><x path="Void"/></f></onErased>
		<update public="1" set="method" line="422" override="1"><f a=""><x path="Void"/></f></update>
		<skip public="1" set="method" line="549">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately finishes the animation. Called if any of the skipKeys is pressed.
	 * Handy for custom skipping behaviour (for example with different inputs like mouse or gamepad).</haxe_doc>
		</skip>
		<new public="1" set="method" line="168">
			<f a="X:Y:Width:Text:?Size:?EmbeddedFont" v="::::8:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a FlxTypeText object, which is very similar to FlxText except that the text is initially hidden and can be
	 * animated one character at a time by calling start().
	 * 
	 * @param	X				The X position for this object.
	 * @param	Y				The Y position for this object.
	 * @param	Width			The width of this object. Text wraps automatically.
	 * @param	Text			The text that will ultimately be displayed.
	 * @param	Size			The size of the text.
	 * @param	EmbeddedFont	Whether this text field uses embedded fonts or not.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is loosely based on the TypeText class by Noel Berry, who wrote it for his Ludum Dare 22 game - Abandoned
 * http://www.ludumdare.com/compo/ludum-dare-22/?action=preview&uid=1527
 * @author Noel Berry]]></haxe_doc>
	</class>
	<class path="flixel.addons.tile.FlxCaveGenerator" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/tile/FlxCaveGenerator.hx">
		<convertMatrixToString public="1" set="method" line="18" static="1">
			<f a="Matrix">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Convert a matrix generated via generateCaveMatrix() into data 
	 * that is usable by FlxTilemap.
	 * 
	 * @param 	Matrix		A matrix of data
	 * @return 	A string that is usuable for FlxTilemap.loadMap()</haxe_doc>
		</convertMatrixToString>
		<generateCaveMatrix public="1" set="method" line="44" static="1">
			<f a="Columns:Rows:?SmoothingIterations:?WallRatio" v="::6:0.5f">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<haxe_doc>* Generate the matrix (2-dimensional array of Ints) for a cave.
	 * 
	 * @param	Columns 				Number of columns for the matrix
	 * @param	Rows					Number of rows for the matrix
	 * @param	SmoothingIterations 	How many times do you want to "smooth" the caev - the higher the smoother, but slower
	 * @param	WallRatio 				Chance for a tile to become a wall - the closer the value is to 1.0, the more walls there are
	 * @return	Returns a matrix of a cave!</haxe_doc>
		</generateCaveMatrix>
		<generateCaveString public="1" get="inline" set="null" line="84" static="1">
			<f a="Columns:Rows:?SmoothingIterations:?WallRatio" v="::6:0.5f">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Generates a new cave matrix via generateCaveMatrix() and returns it in a format 
	 * usable by FlxTilemap.load() via convertMatrixToString().
	 * 
	 * @param	Columns 				Number of columns for the matrix
	 * @param	Rows					Number of rows for the matrix
	 * @param	SmoothingIterations 	How many times do you want to "smooth" the caev - the higher the smoother, but slower
	 * @param	WallRatio 				Chance for a tile to become a wall - the closer the value is to 1.0, the more walls there are
	 * @return	A cave string that is usable by FlxTilemap.loadMap()</haxe_doc>
		</generateCaveString>
		<generateInitialMatrix set="method" line="96" static="1">
			<f a="Columns:Rows">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<haxe_doc>* Creates a matrix (2-dimensional array of Ints) of an empty cave consisting of zeros only.
	 * 
	 * @param	Columns 	Number of columns for the matrix
	 * @param	Rows		Number of rows for the matrix
	 * @return 	Spits out a matrix that is columns * rows big, initiated with zeros</haxe_doc>
		</generateInitialMatrix>
		<countNumWallsNeighbors set="method" line="120" static="1">
			<f a="Matrix:PosX:PosY:?Distance" v=":::1">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* @param	Matrix		Matrix of data (0 = empty, 1 = wall)
	 * @param	PosX		Column we are examining
	 * @param	PosY		Row we are exampining
	 * @param	Distance	Radius of how far to check for neighbors
	 * @return	Number of walls around the target, including itself</haxe_doc>
		</countNumWallsNeighbors>
		<runCelluarAutomata set="method" line="150" static="1">
			<f a="InMatrix:OutMatrix">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Use the 4-5 rule to smooth cells</haxe_doc>
		</runCelluarAutomata>
		<haxe_doc>* This class uses the cellular automata algorithm
 * to generate very sexy caves.
 * (Coded by Eddie Lee, October 16, 2010)</haxe_doc>
	</class>
	<class path="flixel.addons.tile.FlxRayCastTilemap" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/tile/FlxRayCastTilemap.hx">
		<extends path="flixel.tile.FlxTilemap"/>
		<rayCast public="1" set="method" line="33">
			<f a="Start:Direction:?Result:?ResultInTiles:?MaxTilesToCheck" v="::null:null:-1">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Casts a ray from the start point until it hits either a filled tile, or the edge of the tilemap
	*
	* If the starting point is outside the bounding box of the tilemap,
	* it will not cast the ray, and place the end point at the start point.
	*
	* Warning: If your ray is completely horizontal or vertical, make sure your x or y values are exactly zero.
	* Otherwise you may suffer the wrath of floating point rounding error!
	*
	* Algorithm based on
	* http://www.metanetsoftware.com/technique/tutorialB.html
	* http://www.cse.yorku.ca/~amana/research/grid.pdf
	* http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_4_Spatial_Subdivisions.shtml
	*
	* @param 	Start    			The starting point of the ray
	* @param 	Direction   		The direction to shoot the ray. Does not need to be normalized
	* @param 	Result   			Where the resulting point is stored, in (x,y) coordinates
	* @param 	ResultInTiles  		A point containing the tile that was hit, in tile coordinates (optional)
	* @param 	MaxTilesToCheck 	The maximum number of tiles you want the ray to pass. -1 means go across the entire tilemap. Only change this if you know what you're doing!
	* @return   true if hit a filled tile, false if it hit the end of the tilemap
	*</haxe_doc>
		</rayCast>
		<inTileRange public="1" set="method" line="207"><f a="TileX:TileY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></inTileRange>
		<tileAt public="1" set="method" line="212"><f a="CoordX:CoordY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></tileAt>
		<tileIndexAt public="1" set="method" line="217"><f a="CoordX:CoordY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></tileIndexAt>
		<getTileIndex public="1" set="method" line="230">
			<f a="X:Y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* @param X in tiles
	* @param Y in tiles
	* @return</haxe_doc>
		</getTileIndex>
		<coordsToTileX public="1" set="method" line="235"><f a="CoordX">
	<x path="Float"/>
	<x path="Float"/>
</f></coordsToTileX>
		<coordsToTileY public="1" set="method" line="240"><f a="CoordY">
	<x path="Float"/>
	<x path="Float"/>
</f></coordsToTileY>
		<indexToCoordX public="1" set="method" line="245"><f a="Index">
	<x path="Int"/>
	<x path="Float"/>
</f></indexToCoordX>
		<indexToCoordY public="1" set="method" line="250"><f a="Index">
	<x path="Int"/>
	<x path="Float"/>
</f></indexToCoordY>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* @author greglieberman</haxe_doc>
	</class>
	<class path="flixel.addons.tile.FlxTileAnimation" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/tile/FlxTileAnimation.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* String name of the animation (e.g. "walk")</haxe_doc>
		</name>
		<delay public="1">
			<x path="Float"/>
			<haxe_doc>* Seconds between frames (basically the framerate)</haxe_doc>
		</delay>
		<frames public="1">
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* A list of frames stored as int objects</haxe_doc>
		</frames>
		<looped public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the animation is looped</haxe_doc>
		</looped>
		<framesData public="1" set="null">
			<c path="Array"><d/></c>
			<haxe_doc>* An array of dynamic elements that let you add arbritary data to each frame</haxe_doc>
		</framesData>
		<frameRate public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Animation frameRate - the speed in frames per second that the animation should play at.</haxe_doc>
		</frameRate>
		<destroy public="1" set="method" line="52">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<set_frameRate set="method" line="58"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameRate>
		<new public="1" set="method" line="40">
			<f a="Name:Frames:?FrameRate:?Looped:?FramesData" v="::0:true:null">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	Name		What this animation should be called (e.g. "run")
	 * @param	Frames		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3)
	 * @param	FrameRate	The speed in frames per second that the animation should play at (e.g. 40)
	 * @param	Looped		Whether or not the animation is looped or just plays once
	 * @param	FramesData	An array of dynamic elements that let you add arbritary data to each frame</haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.tile.FlxTileSpecial" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/tile/FlxTileSpecial.hx">
		<extends path="flixel.FlxBasic"/>
		<ROTATE_0 public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></ROTATE_0>
		<ROTATE_90 public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></ROTATE_90>
		<ROTATE_270 public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></ROTATE_270>
		<tileID public="1">
			<x path="Int"/>
			<haxe_doc>* The id of this tile in the tileset</haxe_doc>
		</tileID>
		<flipHorizontally public="1"><x path="Bool"/></flipHorizontally>
		<flipVertically public="1"><x path="Bool"/></flipVertically>
		<rotate public="1"><x path="Int"/></rotate>
		<_tmp_flipH><x path="Bool"/></_tmp_flipH>
		<_tmp_flipV><x path="Bool"/></_tmp_flipV>
		<_tmp_rot><x path="Int"/></_tmp_rot>
		<_matrix><c path="flash.geom.Matrix"/></_matrix>
		<_animation><c path="flixel.addons.tile.FlxTileAnimation"/></_animation>
		<_currFrame><x path="Int"/></_currFrame>
		<_lastFrame><x path="Int"/></_lastFrame>
		<_currTileId><x path="Int"/></_currTileId>
		<_currAnimParam><t path="flixel.addons.tile.AnimParams"/></_currAnimParam>
		<_frameTimer><x path="Float"/></_frameTimer>
		<destroy public="1" set="method" line="78" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="96" override="1"><f a=""><x path="Void"/></f></update>
		<isSpecial public="1" get="inline" set="null" line="134"><f a=""><x path="Bool"/></f></isSpecial>
		<isFlipped public="1" get="inline" set="null" line="139"><f a=""><x path="Bool"/></f></isFlipped>
		<hasAnimation public="1" get="inline" set="null" line="144"><f a=""><x path="Bool"/></f></hasAnimation>
		<addAnimation public="1" set="method" line="199">
			<f a="tiles:?frameRate:?framesData" v=":30:null">
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<c path="Array"><t path="flixel.addons.tile.AnimParams"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add an animation to this special tile
	 * @param	tiles		An array with the tilesetID of each frame
	 * @param	frameRate	The speed of the animation in frames per second (Default: 30)</haxe_doc>
		</addAnimation>
		<getCurrentTileId public="1" set="method" line="208">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the current tileID of this tile in the tileset
	 * @return The current tileID</haxe_doc>
		</getCurrentTileId>
		<getAnimationTilesId public="1" set="method" line="217">
			<f a=""><c path="Array"><x path="Int"/></c></f>
			<haxe_doc>* Get the animation tiles id if any
	 * @return	An array of ids or null</haxe_doc>
		</getAnimationTilesId>
		<getMatrix public="1" set="method" line="233">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.geom.Matrix"/>
			</f>
			<haxe_doc>* Calculates and return the matrix
	 * @param	width	the tile width
	 * @param	height	the tile height
	 * @return	The matrix calculated</haxe_doc>
		</getMatrix>
		<new public="1" set="method" line="56"><f a="TilesetId:FlipHorizontal:FlipVertical:Rotate">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="flixel.addons.tile.AnimParams" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/tile/FlxTileSpecial.hx" module="flixel.addons.tile.FlxTileSpecial"><a>
	<rotate><x path="Int"/></rotate>
	<flipVertical><x path="Bool"/></flipVertical>
	<flipHorizontal><x path="Bool"/></flipHorizontal>
</a></typedef>
	<class path="flixel.addons.tile.FlxTilemapExt" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/tile/FlxTilemapExt.hx">
		<extends path="flixel.tile.FlxTilemap"/>
		<SLOPE_FLOOR_LEFT public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></SLOPE_FLOOR_LEFT>
		<SLOPE_FLOOR_RIGHT public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></SLOPE_FLOOR_RIGHT>
		<SLOPE_CEIL_LEFT public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></SLOPE_CEIL_LEFT>
		<SLOPE_CEIL_RIGHT public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></SLOPE_CEIL_RIGHT>
		<_snapping><x path="Int"/></_snapping>
		<_slopePoint><c path="flixel.util.FlxPoint"/></_slopePoint>
		<_objPoint><c path="flixel.util.FlxPoint"/></_objPoint>
		<_slopeFloorLeft><c path="Array"><x path="Int"/></c></_slopeFloorLeft>
		<_slopeFloorRight><c path="Array"><x path="Int"/></c></_slopeFloorRight>
		<_slopeCeilLeft><c path="Array"><x path="Int"/></c></_slopeCeilLeft>
		<_slopeCeilRight><c path="Array"><x path="Int"/></c></_slopeCeilRight>
		<MATRIX><c path="flash.geom.Matrix"/></MATRIX>
		<_specialTiles><c path="Array"><c path="flixel.addons.tile.FlxTileSpecial"/></c></_specialTiles>
		<alpha public="1" set="accessor"><x path="Float"/></alpha>
		<set_alpha set="method" line="58"><f a="alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<destroy public="1" set="method" line="91" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="122" override="1"><f a=""><x path="Void"/></f></update>
		<drawTilemap set="method" line="143" override="1">
			<f a="Buffer:Camera">
				<c path="flixel.tile.FlxTilemapBuffer"/>
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* THIS IS A COPY FROM FlxTilemap BUT IT DEALS WITH FLIPPED AND ROTATED TILES
	 * Internal function that actually renders the tilemap to the tilemap buffer.  Called by draw().
	 * @param	Buffer		The FlxTilemapBuffer you are rendering to.
	 * @param	Camera		The related FlxCamera, mainly for scroll values.</haxe_doc>
		</drawTilemap>
		<setSpecialTiles public="1" set="method" line="331">
			<f a="tiles">
				<c path="Array"><c path="flixel.addons.tile.FlxTileSpecial"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the special tiles (rotated or flipped)
	 * @param	tiles	An Array with all the FlxTileSpecial</haxe_doc>
		</setSpecialTiles>
		<getRectangleFromTileset set="method" line="378"><f a="id">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getRectangleFromTileset>
		<draw public="1" set="method" line="404" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* THIS IS A COPY FROM FlxTilemap
	 * I've only swapped lines 386 and 387 to give DrawTilemap() a chance to set the buffer dirty
	 * ---
	 * Draws the tilemap buffers to the cameras.</haxe_doc>
		</draw>
		<overlapsWithCallback public="1" set="method" line="471" override="1">
			<f a="Object:?Callback:?FlipCallbackParams:?Position" v=":null:false:null">
				<c path="flixel.FlxObject"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* THIS IS A COPY FROM FlxTilemap BUT IT SOLVES SLOPE COLLISION TOO
	 * Checks if the Object overlaps any tiles with any collision flags set,
	 * and calls the specified callback function (if there is one).
	 * Also calls the tile's registered callback if the filter matches.
	 *
	 * @param 	Object 				The FlxObject you are checking for overlaps against.
	 * @param 	Callback 			An optional function that takes the form "myCallback(Object1:FlxObject,Object2:FlxObject)", where Object1 is a FlxTile object, and Object2 is the object passed in in the first parameter of this method.
	 * @param 	FlipCallbackParams 	Used to preserve A-B list ordering from FlxObject.separate() - returns the FlxTile object as the second parameter instead.
	 * @param 	Position 			Optional, specify a custom position for the tilemap (useful for overlapsAt()-type funcitonality).
	 *
	 * @return Whether there were overlaps, or if a callback was specified, whatever the return value of the callback was.</haxe_doc>
		</overlapsWithCallback>
		<setClouds public="1" set="method" line="586">
			<f a="?Clouds" v="null">
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the tiles that are treated as "clouds" or blocks that are only solid from the top.
	 * 
	 * @param 	Clouds	An array containing the numbers of the tiles to be treated as clouds.</haxe_doc>
		</setClouds>
		<setSlopes public="1" set="method" line="605">
			<f a="?LeftFloorSlopes:?RightFloorSlopes:?LeftCeilSlopes:?RightCeilSlopes" v="null:null:null:null">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the slope arrays, which define which tiles are treated as slopes.
	 * 
	 * @param 	LeftFloorSlopes 	An array containing the numbers of the tiles to be treated as floor tiles with a slope on the left.
	 * @param 	RightFloorSlopes	An array containing the numbers of the tiles to be treated as floor tiles with a slope on the right.
	 * @param 	LeftCeilSlopes		An array containing the numbers of the tiles to be treated as ceiling tiles with a slope on the left.
	 * @param 	RightCeilSlopes		An array containing the numbers of the tiles to be treated as ceiling tiles with a slope on the right.</haxe_doc>
		</setSlopes>
		<fixSlopePoint set="method" line="632">
			<f a="Slope">
				<c path="flixel.tile.FlxTile"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Bounds the slope point to the slope
	 * 
	 * @param 	Slope 	The slope to fix the slopePoint for</haxe_doc>
		</fixSlopePoint>
		<onCollideFloorSlope set="method" line="644">
			<f a="Slope:Object">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Ss called if an object collides with a floor slope
	 * 
	 * @param 	Slope	The floor slope
	 * @param	Object 	The object that collides with that slope</haxe_doc>
		</onCollideFloorSlope>
		<onCollideCeilSlope set="method" line="667">
			<f a="Slope:Object">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Is called if an object collides with a ceiling slope
	 * 
	 * @param 	Slope 	The ceiling slope
	 * @param 	Object 	The object that collides with that slope</haxe_doc>
		</onCollideCeilSlope>
		<solveCollisionSlopeFloorLeft set="method" line="690">
			<f a="Slope:Object">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Solves collision against a left-sided floor slope
	 * 
	 * @param 	Slope 	The slope to check against
	 * @param 	Object 	The object that collides with the slope</haxe_doc>
		</solveCollisionSlopeFloorLeft>
		<solveCollisionSlopeFloorRight set="method" line="718">
			<f a="Slope:Object">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Solves collision against a right-sided floor slope
	 * 
	 * @param 	Slope 	The slope to check against
	 * @param 	Object 	The object that collides with the slope</haxe_doc>
		</solveCollisionSlopeFloorRight>
		<solveCollisionSlopeCeilLeft set="method" line="746">
			<f a="Slope:Obj">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Solves collision against a left-sided ceiling slope
	 * 
	 * @param 	Slope 	The slope to check against
	 * @param 	Obj 	The object that collides with the slope</haxe_doc>
		</solveCollisionSlopeCeilLeft>
		<solveCollisionSlopeCeilRight set="method" line="774">
			<f a="Slope:Obj">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Solves collision against a right-sided ceiling slope
	 * 
	 * @param 	Slope 	The slope to check against
	 * @param 	Obj 	The object that collides with the slope</haxe_doc>
		</solveCollisionSlopeCeilRight>
		<setSlopeProperties set="method" line="800">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal helper function for setting the tiles currently held in the slope arrays to use slope collision.
	 * Note that if you remove items from a slope, this function will not unset the slope property.</haxe_doc>
		</setSlopeProperties>
		<checkArrays set="method" line="826">
			<f a="TileIndex">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Internal helper function for comparing a tile to the slope arrays to see if a tile should be treated as a slope.
	 * 
	 * @param 	TileIndex	The Tile Index number of the Tile you want to check.
	 * @return	Returns true if the tile is listed in one of the slope arrays. Otherwise returns false.</haxe_doc>
		</checkArrays>
		<new public="1" set="method" line="74"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Extended FlxTilemap class that provides collision detection against slopes
 * Based on the original by Dirk Bunk.
 * ---
 * Also add support to flipped / rotated tiles.
 * @author Peter Christiansen
 * @author MrCdK
 * @link https://github.com/TheTurnipMaster/SlopeDemo</haxe_doc>
	</class>
	<class path="flixel.addons.ui.Anchor" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/Anchor.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<LEFT public="1" get="inline" set="null" line="15" static="1"><c path="String"/></LEFT>
		<RIGHT public="1" get="inline" set="null" line="16" static="1"><c path="String"/></RIGHT>
		<TOP public="1" get="inline" set="null" line="17" static="1"><c path="String"/></TOP>
		<BOTTOM public="1" get="inline" set="null" line="18" static="1"><c path="String"/></BOTTOM>
		<CENTER public="1" get="inline" set="null" line="19" static="1"><c path="String"/></CENTER>
		<x public="1"><c path="flixel.addons.ui.AnchorPoint"/></x>
		<y public="1"><c path="flixel.addons.ui.AnchorPoint"/></y>
		<destroy public="1" set="method" line="27"><f a=""><x path="Void"/></f></destroy>
		<anchorThing public="1" set="method" line="32"><f a="thing:destination">
	<c path="flixel.FlxObject"/>
	<c path="flixel.FlxObject"/>
	<x path="Void"/>
</f></anchorThing>
		<new public="1" set="method" line="21"><f a="XOff:YOff:XSide:YSide:XFlush:YFlush">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A class that describes how some object should be positioned relative to another
 * 
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.AnchorPoint" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/AnchorPoint.hx">
		<offset public="1"><x path="Float"/></offset>
		<side public="1"><c path="String"/></side>
		<flush public="1"><c path="String"/></flush>
		<new public="1" set="method" line="13"><f a="Offset:Side:Flush">
	<x path="Float"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.group.FlxTypedSpriteGroup" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/group/FlxTypedSpriteGroup.hx">
		<extends path="flixel.FlxSprite"/>
		<transformChildren_flash_display_BlendMode public="1" set="method" line="559">
			<f a="Function:Value">
				<f a=":">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<e path="flash.display.BlendMode"/>
					<x path="Void"/>
				</f>
				<e path="flash.display.BlendMode"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</transformChildren_flash_display_BlendMode>
		<transformChildren_Array_flixel_FlxCamera public="1" set="method" line="559">
			<f a="Function:Value">
				<f a=":">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<c path="Array"><c path="flixel.FlxCamera"/></c>
					<x path="Void"/>
				</f>
				<c path="Array"><c path="flixel.FlxCamera"/></c>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</transformChildren_Array_flixel_FlxCamera>
		<multiTransformChildren_Float public="1" set="method" line="582">
			<f a="FunctionArray:ValueArray">
				<c path="Array"><f a=":">
	<c path="flixel.group.FlxTypedSpriteGroup.T"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</multiTransformChildren_Float>
		<transformChildren_flixel_util_FlxPoint public="1" set="method" line="559">
			<f a="Function:Value">
				<f a=":">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<c path="flixel.util.FlxPoint"/>
					<x path="Void"/>
				</f>
				<c path="flixel.util.FlxPoint"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</transformChildren_flixel_util_FlxPoint>
		<transformChildren_Int public="1" set="method" line="559">
			<f a="Function:Value">
				<f a=":">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</transformChildren_Int>
		<transformChildren_Bool public="1" set="method" line="559">
			<f a="Function:Value">
				<f a=":">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</transformChildren_Bool>
		<transformChildren_Float public="1" set="method" line="559">
			<f a="Function:Value">
				<f a=":">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</transformChildren_Float>
		<group public="1">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.group.FlxTypedSpriteGroup.T"/></c>
			<haxe_doc>* The actual group which holds all sprites</haxe_doc>
		</group>
		<members public="1" get="accessor" set="null">
			<c path="Array"><c path="flixel.group.FlxTypedSpriteGroup.T"/></c>
			<haxe_doc>* The link to a group's members array</haxe_doc>
		</members>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The number of entries in the members array. For performance and safety you should check this 
	 * variable instead of members.length unless you really know what you're doing!</haxe_doc>
		</length>
		<maxSize public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The maximum capacity of this group. Default is 0, meaning no max capacity, and the group can just grow.</haxe_doc>
		</maxSize>
		<_skipTransformChildren>
			<x path="Bool"/>
			<haxe_doc>* Optimization to allow setting position of group without transforming children twice.</haxe_doc>
		</_skipTransformChildren>
		<_isDrawnDebug>
			<x path="Bool"/>
			<haxe_doc>* Just a helper variable to check if this group has already been drawn on debug layer</haxe_doc>
		</_isDrawnDebug>
		<_sprites>
			<c path="Array"><c path="flixel.FlxSprite"/></c>
			<haxe_doc>* Array of all the FlxSprites that exist in this group for 
	 * optimization purposes / static typing on cpp targets.</haxe_doc>
		</_sprites>
		<initVars set="method" line="78" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This method is used for initialization of variables of complex types.
	 * Don't forget to call super.initVars() if you'll override this method, 
	 * or you'll get null object error and app will crash</haxe_doc>
		</initVars>
		<destroy public="1" set="method" line="97" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* WARNING: This will remove this object entirely. Use kill() if you want to disable it temporarily only and reset() it later to revive it.
	 * Override this function to null out variables manually or call destroy() on class members if necessary. Don't forget to call super.destroy()!</haxe_doc>
		</destroy>
		<clone public="1" set="method" line="117" override="1">
			<f a="?NewSprite" v="null">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.group.FlxTypedSpriteGroup.T"/></c>
			</f>
			<haxe_doc>* Recursive cloning method: it will create copy of this group which will hold copies of all sprites
	 * 
	 * @param	NewSprite	optional sprite group to copy to
	 * @return	copy of this sprite group</haxe_doc>
		</clone>
		<isOnScreen public="1" set="method" line="143" override="1">
			<f a="?Camera" v="null">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check and see if any sprite in this group is currently on screen.
	 * 
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether the object is on screen or not.</haxe_doc>
		</isOnScreen>
		<overlapsPoint public="1" set="method" line="165" override="1">
			<f a="point:?InScreenSpace:?Camera" v=":false:null">
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if a point in 2D world space overlaps any FlxSprite object from this group.
	 * 
	 * @param	Point			The point in world space you want to check.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this group.</haxe_doc>
		</overlapsPoint>
		<pixelsOverlapPoint public="1" set="method" line="188" override="1">
			<f a="point:?Mask:?Camera" v=":255:null">
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if a point in 2D world space overlaps any of FlxSprite object's current displayed pixels.
	 * This check is ALWAYS made in screen space, and always takes scroll factors into account.
	 * 
	 * @param	Point		The point in world space you want to check.
	 * @param	Mask		Used in the pixel hit test to determine what counts as solid.
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.</haxe_doc>
		</pixelsOverlapPoint>
		<update public="1" set="method" line="202" override="1"><f a=""><x path="Void"/></f></update>
		<draw public="1" set="method" line="212" override="1"><f a=""><x path="Void"/></f></draw>
		<replaceColor public="1" set="method" line="228" override="1">
			<f a="Color:NewColor:?FetchPositions" v="::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			</f>
			<haxe_doc>* Replaces all pixels with specified Color with NewColor pixels. This operation is applied to every nested sprite from this group
	 * 
	 * @param	Color				Color to replace
	 * @param	NewColor			New color
	 * @param	FetchPositions		Whether we need to store positions of pixels which colors were replaced
	 * @return	Array replaced pixels positions</haxe_doc>
		</replaceColor>
		<add public="1" set="method" line="258">
			<f a="Sprite">
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<haxe_doc>* Adds a new FlxSprite subclass to the group.
	 * 
	 * @param	Object		The sprite or sprite group you want to add to the group.
	 * @return	The same object that was passed in.</haxe_doc>
		</add>
		<recycle public="1" get="inline" set="null" line="277">
			<f a="?ObjectClass:?ContructorArgs:?Force" v="null:null:false">
				<x path="Class"><c path="flixel.group.FlxTypedSpriteGroup.T"/></x>
				<c path="Array"><d/></c>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Recycling is designed to help you reuse game objects without always re-allocating or "newing" them.
	 * 
	 * @param	ObjectClass		The class type you want to recycle (e.g. FlxSprite, EvilRobot, etc). Do NOT "new" the class in the parameter!
	 * @param 	ContructorArgs  An array of arguments passed into a newly object if there aren't any dead members to recycle. 
	 * @param 	Force           Force the object to be an ObjectClass and not a super class of ObjectClass. 
	 * @return	A reference to the object that was created.  Don't forget to cast it back to the Class you want (e.g. myObject = myGroup.recycle(myObjectClass) as myObjectClass;).</haxe_doc>
		</recycle>
		<remove public="1" set="method" line="289">
			<f a="Object:?Splice" v=":false">
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<haxe_doc>* Removes specified sprite from the group.
	 * 
	 * @param	Object	The FlxSprite you want to remove.
	 * @param	Splice	Whether the object should be cut from the array entirely or not.
	 * @return	The removed object.</haxe_doc>
		</remove>
		<replace public="1" get="inline" set="null" line="301">
			<f a="OldObject:NewObject">
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<haxe_doc>* Replaces an existing FlxSprite with a new one.
	 * 
	 * @param	OldObject	The object you want to replace.
	 * @param	NewObject	The new object you want to use instead.
	 * @return	The new object.</haxe_doc>
		</replace>
		<sort public="1" get="inline" set="null" line="313">
			<f a="Function:?Order" v=":-1">
				<f a="::">
					<x path="Int"/>
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Int"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Call this function to sort the group according to a particular value and order. For example, to sort game objects for Zelda-style 
	 * overlaps you might call myGroup.sort(FlxSort.byY, FlxSort.ASCENDING) at the bottom of your FlxState.update() override.
	 * 
	 * @param	Function	The sorting function to use - you can use one of the premade ones in FlxSort or write your own using FlxSort.byValues() as a backend
	 * @param	Order		A FlxGroup constant that defines the sort order.  Possible values are FlxSort.ASCENDING (default) and FlxSort.DESCENDING.</haxe_doc>
		</sort>
		<setAll public="1" get="inline" set="null" line="325">
			<f a="VariableName:Value:?Recurse" v="::true">
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Go through and set the specified variable to the specified value on all members of the group.
	 * 
	 * @param	VariableName	The string representation of the variable name you want to modify, for example "visible" or "scrollFactor".
	 * @param	Value			The value you want to assign to that variable.
	 * @param	Recurse			Default value is true, meaning if setAll() encounters a member that is a group, it will call setAll() on that group rather than modifying its variable.</haxe_doc>
		</setAll>
		<callAll public="1" get="inline" set="null" line="337">
			<f a="FunctionName:?Args:?Recurse" v=":null:true">
				<c path="String"/>
				<c path="Array"><d/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Go through and call the specified function on all members of the group.
	 * Currently only works on functions that have no required parameters.
	 * 
	 * @param	FunctionName	The string representation of the function you want to call on each object, for example "kill()" or "init()".
	 * @param	Recurse			Default value is true, meaning if callAll() encounters a member that is a group, it will call callAll() on that group rather than calling the group's function.</haxe_doc>
		</callAll>
		<getFirstAvailable public="1" get="inline" set="null" line="350">
			<f a="?ObjectClass:?Force" v="null:false">
				<x path="Class"><c path="flixel.group.FlxTypedSpriteGroup.T"/></x>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<haxe_doc>* Call this function to retrieve the first object with exists == false in the group.
	 * This is handy for recycling in general, e.g. respawning enemies.
	 * 
	 * @param	ObjectClass		An optional parameter that lets you narrow the results to instances of this particular class.
	 * @param 	Force           Force the object to be an ObjectClass and not a super class of ObjectClass. 
	 * @return	A FlxSprite currently flagged as not existing.</haxe_doc>
		</getFirstAvailable>
		<getFirstNull public="1" get="inline" set="null" line="361">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to retrieve the first index set to 'null'.
	 * Returns -1 if no index stores a null object.
	 * 
	 * @return	An Int indicating the first null slot in the group.</haxe_doc>
		</getFirstNull>
		<getFirstExisting public="1" get="inline" set="null" line="372">
			<f a=""><c path="flixel.group.FlxTypedSpriteGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with exists == true in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A FlxSprite currently flagged as existing.</haxe_doc>
		</getFirstExisting>
		<getFirstAlive public="1" get="inline" set="null" line="383">
			<f a=""><c path="flixel.group.FlxTypedSpriteGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with dead == false in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A FlxSprite currently flagged as not dead.</haxe_doc>
		</getFirstAlive>
		<getFirstDead public="1" get="inline" set="null" line="394">
			<f a=""><c path="flixel.group.FlxTypedSpriteGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with dead == true in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A FlxSprite currently flagged as dead.</haxe_doc>
		</getFirstDead>
		<countLiving public="1" get="inline" set="null" line="404">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to find out how many members of the group are not dead.
	 * 
	 * @return	The number of FlxSprites flagged as not dead.  Returns -1 if group is empty.</haxe_doc>
		</countLiving>
		<countDead public="1" get="inline" set="null" line="414">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to find out how many members of the group are dead.
	 * 
	 * @return	The number of FlxSprites flagged as dead.  Returns -1 if group is empty.</haxe_doc>
		</countDead>
		<getRandom public="1" get="inline" set="null" line="426">
			<f a="?StartIndex:?Length" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<haxe_doc>* Returns a member at random from the group.
	 * 
	 * @param	StartIndex	Optional offset off the front of the array. Default value is 0, or the beginning of the array.
	 * @param	Length		Optional restriction on the number of values you want to randomly select from.
	 * @return	A FlxSprite from the members list.</haxe_doc>
		</getRandom>
		<forEach public="1" get="inline" set="null" line="436">
			<f a="Function">
				<f a="">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies a function to all members
	 * 
	 * @param   Function   A function that modifies one element at a time</haxe_doc>
		</forEach>
		<forEachAlive public="1" get="inline" set="null" line="446">
			<f a="Function">
				<f a="">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies a function to all alive members
	 * 
	 * @param   Function   A function that modifies one element at a time</haxe_doc>
		</forEachAlive>
		<forEachDead public="1" get="inline" set="null" line="456">
			<f a="Function">
				<f a="">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies a function to all dead members
	 * 
	 * @param   Function   A function that modifies one element at a time</haxe_doc>
		</forEachDead>
		<forEachExists public="1" get="inline" set="null" line="466">
			<f a="Function">
				<f a="">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies a function to all existing members
	 * 
	 * @param   Function   A function that modifies one element at a time</haxe_doc>
		</forEachExists>
		<forEachOfType public="1" params="K" get="inline" set="null" line="477">
			<f a="ObjectClass:Function">
				<x path="Class"><c path="forEachOfType.K"/></x>
				<f a="">
					<c path="forEachOfType.K"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Applies a function to all members of type Class<K>
	 * 
	 * @param   ObjectClass   A class that objects will be checked against before Function is applied, ex: FlxSprite
	 * @param   Function      A function that modifies one element at a time]]></haxe_doc>
		</forEachOfType>
		<clear public="1" get="inline" set="null" line="486">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove all instances of FlxSprite from the list.
	 * WARNING: does not destroy() or kill() any of these objects!</haxe_doc>
		</clear>
		<kill public="1" set="method" line="495" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Calls kill on the group's members and then on the group itself. 
	 * You can revive this group later via revive() after this.</haxe_doc>
		</kill>
		<revive public="1" set="method" line="504" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Revives the group.</haxe_doc>
		</revive>
		<reset public="1" set="method" line="517" override="1">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function for the sort process.
	 * 
	 * @param 	Obj1	The first object being sorted.
	 * @param	Obj2	The second object being sorted.
	 * @return	An integer value: -1 (Obj1 before Obj2), 0 (same), or 1 (Obj1 after Obj2).</haxe_doc>
		</reset>
		<setPosition public="1" set="method" line="538" override="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function to set the coordinates of this object.
	 * Handy since it only requires one line of code.
	 * 
	 * @param	X	The new x position
	 * @param	Y	The new y position</haxe_doc>
		</setPosition>
		<transformChildren public="1" params="V" set="method" line="559">
			<f a="Function:Value">
				<f a=":">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<c path="transformChildren.V"/>
					<x path="Void"/>
				</f>
				<c path="transformChildren.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Handy function that allows you to quickly transform one property of sprites in this group at a time.
	 * 
	 * @param 	Function 	Function to transform the sprites. Example: function(s:FlxSprite, v:Dynamic) { s.acceleration.x = v; s.makeGraphic(10,10,0xFF000000); }
	 * @param 	Value  		Value which will passed to lambda function</haxe_doc>
		</transformChildren>
		<multiTransformChildren public="1" params="V" set="method" line="582">
			<f a="FunctionArray:ValueArray">
				<c path="Array"><f a=":">
	<c path="flixel.group.FlxTypedSpriteGroup.T"/>
	<c path="multiTransformChildren.V"/>
	<x path="Void"/>
</f></c>
				<c path="Array"><c path="multiTransformChildren.V"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Handy function that allows you to quickly transform multiple properties of sprites in this group at a time.
	 * 
	 * @param	FunctionArray	Array of functions to transform sprites in this group.
	 * @param	ValueArray		Array of values which will be passed to lambda functions</haxe_doc>
		</multiTransformChildren>
		<set_cameras set="method" line="611" override="1"><f a="Value">
	<c path="Array"><c path="flixel.FlxCamera"/></c>
	<c path="Array"><c path="flixel.FlxCamera"/></c>
</f></set_cameras>
		<set_exists set="method" line="618" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_exists>
		<set_visible set="method" line="625" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_active set="method" line="632" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_active>
		<set_alive set="method" line="639" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_alive>
		<set_x set="method" line="646" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="657" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_angle set="method" line="668" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<set_alpha set="method" line="678" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_facing set="method" line="697" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_facing>
		<set_flipX set="method" line="704" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipX>
		<set_flipY set="method" line="711" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipY>
		<set_moves set="method" line="718" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_moves>
		<set_immovable set="method" line="725" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_immovable>
		<set_solid set="method" line="732" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_solid>
		<set_color set="method" line="739" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<set_blend set="method" line="746" override="1"><f a="Value">
	<e path="flash.display.BlendMode"/>
	<e path="flash.display.BlendMode"/>
</f></set_blend>
		<set_pixelPerfectRender set="method" line="753" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pixelPerfectRender>
		<set_width set="method" line="763" override="1">
			<f a="Value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</set_width>
		<get_width set="method" line="768" override="1"><f a=""><x path="Float"/></f></get_width>
		<set_height set="method" line="798" override="1">
			<f a="Value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</set_height>
		<get_height set="method" line="803" override="1"><f a=""><x path="Float"/></f></get_height>
		<get_length get="inline" set="null" line="832"><f a=""><x path="Int"/></f></get_length>
		<get_maxSize get="inline" set="null" line="837"><f a=""><x path="Int"/></f></get_maxSize>
		<set_maxSize get="inline" set="null" line="842"><f a="Size">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxSize>
		<get_members get="inline" set="null" line="847"><f a=""><c path="Array"><c path="flixel.group.FlxTypedSpriteGroup.T"/></c></f></get_members>
		<xTransform get="inline" set="null" line="854"><f a="Sprite:X">
	<c path="flixel.FlxSprite"/>
	<x path="Float"/>
	<x path="Void"/>
</f></xTransform>
		<yTransform get="inline" set="null" line="855"><f a="Sprite:Y">
	<c path="flixel.FlxSprite"/>
	<x path="Float"/>
	<x path="Void"/>
</f></yTransform>
		<angleTransform get="inline" set="null" line="856"><f a="Sprite:Angle">
	<c path="flixel.FlxSprite"/>
	<x path="Float"/>
	<x path="Void"/>
</f></angleTransform>
		<alphaTransform get="inline" set="null" line="857"><f a="Sprite:Alpha">
	<c path="flixel.FlxSprite"/>
	<x path="Float"/>
	<x path="Void"/>
</f></alphaTransform>
		<facingTransform get="inline" set="null" line="858"><f a="Sprite:Facing">
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<x path="Void"/>
</f></facingTransform>
		<flipXTransform get="inline" set="null" line="859"><f a="Sprite:FlipX">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></flipXTransform>
		<flipYTransform get="inline" set="null" line="860"><f a="Sprite:FlipY">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></flipYTransform>
		<movesTransform get="inline" set="null" line="861"><f a="Sprite:Moves">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></movesTransform>
		<pixelPerfectTransform get="inline" set="null" line="862"><f a="Sprite:PixelPerfect">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></pixelPerfectTransform>
		<gColorTransform get="inline" set="null" line="863"><f a="Sprite:Color">
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<x path="Void"/>
</f></gColorTransform>
		<blendTransform get="inline" set="null" line="864"><f a="Sprite:Blend">
	<c path="flixel.FlxSprite"/>
	<e path="flash.display.BlendMode"/>
	<x path="Void"/>
</f></blendTransform>
		<immovableTransform get="inline" set="null" line="865"><f a="Sprite:Immovable">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></immovableTransform>
		<visibleTransform get="inline" set="null" line="866"><f a="Sprite:Visible">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></visibleTransform>
		<activeTransform get="inline" set="null" line="867"><f a="Sprite:Active">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></activeTransform>
		<solidTransform get="inline" set="null" line="868"><f a="Sprite:Solid">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></solidTransform>
		<aliveTransform get="inline" set="null" line="869"><f a="Sprite:Alive">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></aliveTransform>
		<existsTransform get="inline" set="null" line="870"><f a="Sprite:Exists">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></existsTransform>
		<camerasTransform get="inline" set="null" line="871"><f a="Sprite:Cameras">
	<c path="flixel.FlxSprite"/>
	<c path="Array"><c path="flixel.FlxCamera"/></c>
	<x path="Void"/>
</f></camerasTransform>
		<offsetTransform get="inline" set="null" line="873"><f a="Sprite:Offset">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></offsetTransform>
		<originTransform get="inline" set="null" line="874"><f a="Sprite:Origin">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></originTransform>
		<scaleTransform get="inline" set="null" line="875"><f a="Sprite:Scale">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></scaleTransform>
		<scrollFactorTransform get="inline" set="null" line="876"><f a="Sprite:ScrollFactor">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></scrollFactorTransform>
		<offsetCallback get="inline" set="null" line="879"><f a="Offset">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></offsetCallback>
		<originCallback get="inline" set="null" line="880"><f a="Origin">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></originCallback>
		<scaleCallback get="inline" set="null" line="881"><f a="Scale">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></scaleCallback>
		<scrollFactorCallback get="inline" set="null" line="882"><f a="ScrollFactor">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></scrollFactorCallback>
		<loadGraphicFromSprite public="1" set="method" line="891" override="1">
			<f a="Sprite">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return this sprite group</haxe_doc>
		</loadGraphicFromSprite>
		<loadGraphic public="1" set="method" line="903" override="1">
			<f a="Graphic:?Animated:?Width:?Height:?Unique:?Key" v=":false:0:0:false:null">
				<d/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return this sprite group</haxe_doc>
		</loadGraphic>
		<loadRotatedGraphic public="1" set="method" line="912" override="1">
			<f a="Graphic:?Rotations:?Frame:?AntiAliasing:?AutoBuffer:?Key" v=":16:-1:false:false:null">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return this sprite group</haxe_doc>
		</loadRotatedGraphic>
		<makeGraphic public="1" set="method" line="924" override="1">
			<f a="Width:Height:?Color:?Unique:?Key" v="::-1:false:null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return this sprite group</haxe_doc>
		</makeGraphic>
		<loadGraphicFromTexture public="1" set="method" line="936" override="1">
			<f a="Data:?Unique:?FrameName" v=":false:null">
				<d/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return this sprite group</haxe_doc>
		</loadGraphicFromTexture>
		<loadRotatedGraphicFromTexture public="1" set="method" line="948" override="1">
			<f a="Data:Image:?Rotations:?AntiAliasing:?AutoBuffer" v="::16:false:false">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return this sprite group</haxe_doc>
		</loadRotatedGraphicFromTexture>
		<set_pixels set="method" line="960" override="1">
			<f a="Value">
				<c path="flash.display.BitmapData"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return the BitmapData passed in as parameter</haxe_doc>
		</set_pixels>
		<set_frame set="method" line="969" override="1">
			<f a="Value">
				<c path="flixel.system.layer.frames.FlxFrame"/>
				<c path="flixel.system.layer.frames.FlxFrame"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return the FlxFrame passed in as parameter</haxe_doc>
		</set_frame>
		<get_pixels set="method" line="978" override="1">
			<f a=""><c path="flash.display.BitmapData"/></f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return WARNING: returns null</haxe_doc>
		</get_pixels>
		<calcFrame get="inline" set="null" line="988" override="1">
			<f a="?RunOnCpp" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function to update the current animation frame.
	 * 
	 * @param	RunOnCpp	Whether the frame should also be recalculated if we're on a non-flash target</haxe_doc>
		</calcFrame>
		<resetHelpers get="inline" set="null" line="996" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</resetHelpers>
		<stamp public="1" get="inline" set="null" line="1001" override="1">
			<f a="Brush:?X:?Y" v=":0:0">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</stamp>
		<updateColorTransform get="inline" set="null" line="1006" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</updateColorTransform>
		<updateFrameData public="1" get="inline" set="null" line="1011" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</updateFrameData>
		<new public="1" set="method" line="66">
			<f a="?X:?Y:?MaxSize" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	X			The initial X position of the group
	 * @param	Y			The initial Y position of the group
	 * @param	MaxSize		Maximum amount of members allowed</haxe_doc>
		</new>
		<haxe_doc>* FlxSpriteGroup is a special FlxGroup that can be treated like 
 * a single sprite even if it's made up of several member sprites.</haxe_doc>
	</class>
	<class path="flixel.group.FlxSpriteGroup" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/group/FlxSpriteGroup.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<new public="1" set="method" line="16">
			<f a="?X:?Y:?MaxSize" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	X			The initial X position of the group
	 * @param	Y			The initial Y position of the group
	 * @param	MaxSize		Maximum amount of members allowed</haxe_doc>
		</new>
		<haxe_doc>* FlxSpriteGroup is a special FlxGroup that can be treated like 
 * a single sprite even if it's made up of several member sprites.</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxButtonPlus" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/ui/FlxButtonPlus.hx">
		<extends path="flixel.group.FlxSpriteGroup"/>
		<NORMAL public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></NORMAL>
		<HIGHLIGHT public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></HIGHLIGHT>
		<PRESSED public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></PRESSED>
		<borderColor public="1">
			<x path="Int"/>
			<haxe_doc>* The 1px thick border color that is drawn around this button</haxe_doc>
		</borderColor>
		<offColor public="1">
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* The color gradient of the button in its in-active (not hovered over) state</haxe_doc>
		</offColor>
		<onColor public="1">
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* The color gradient of the button in its hovered state</haxe_doc>
		</onColor>
		<onClickCallback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called when the button is clicked.</haxe_doc>
		</onClickCallback>
		<enterCallback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called when the button is hovered over</haxe_doc>
		</enterCallback>
		<leaveCallback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called when the mouse leaves a hovered button (but didn't click)</haxe_doc>
		</leaveCallback>
		<buttonNormal public="1" set="accessor"><c path="flixel.addons.display.FlxExtendedSprite"/></buttonNormal>
		<buttonHighlight public="1" set="accessor"><c path="flixel.addons.display.FlxExtendedSprite"/></buttonHighlight>
		<textNormal public="1" set="accessor"><c path="flixel.text.FlxText"/></textNormal>
		<textHighlight public="1" set="accessor"><c path="flixel.text.FlxText"/></textHighlight>
		<text public="1" get="null" set="accessor">
			<c path="String"/>
			<haxe_doc>* If this button has text, set this to change the value</haxe_doc>
		</text>
		<_status>
			<x path="Int"/>
			<haxe_doc>* Shows the current state of the button.</haxe_doc>
		</_status>
		<_initialized>
			<x path="Bool"/>
			<haxe_doc>* Whether or not the button has initialized itself yet.</haxe_doc>
		</_initialized>
		<loadButtonGraphic public="1" set="method" line="153">
			<f a="Normal:Highlight">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you wish to replace the two buttons (normal and hovered-over) with FlxSprites, then pass them here.
	 * Note: The pixel data is extract from the passed FlxSprites and assigned locally, it doesn't actually use the sprites
	 * or keep a reference to them.
	 * 
	 * @param	Normal		The FlxSprite to use when the button is in-active (not hovered over)
	 * @param	Highlight	The FlxSprite to use when the button is hovered-over by the mouse</haxe_doc>
		</loadButtonGraphic>
		<update public="1" set="method" line="171" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game loop automatically, handles mouseover and click detection.</haxe_doc>
		</update>
		<updateButton set="method" line="191">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Basic button update logic</haxe_doc>
		</updateButton>
		<destroy public="1" set="method" line="261" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* WARNING: This will remove this object entirely. Use kill() if you 
	 * want to disable it temporarily only and reset() it later to revive it.
	 * Called by the game state when state is changed (if this object belongs to the state)</haxe_doc>
		</destroy>
		<onMouseUp set="method" line="283">
			<f a="E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function for handling the actual callback call (for UI thread dependent calls like FlxStringUtil.openURL()).</haxe_doc>
		</onMouseUp>
		<updateInactiveButtonColors public="1" set="method" line="294">
			<f a="Colors">
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you want to change the color of this button in its in-active (not hovered over) state, then pass a new array of color values</haxe_doc>
		</updateInactiveButtonColors>
		<updateActiveButtonColors public="1" set="method" line="333">
			<f a="Colors">
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you want to change the color of this button in its active (hovered over) state, then pass a new array of color values</haxe_doc>
		</updateActiveButtonColors>
		<set_text set="method" line="370"><f a="NewText">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<set_buttonNormal get="inline" set="null" line="381"><f a="Value">
	<c path="flixel.addons.display.FlxExtendedSprite"/>
	<c path="flixel.addons.display.FlxExtendedSprite"/>
</f></set_buttonNormal>
		<set_buttonHighlight get="inline" set="null" line="400"><f a="Value">
	<c path="flixel.addons.display.FlxExtendedSprite"/>
	<c path="flixel.addons.display.FlxExtendedSprite"/>
</f></set_buttonHighlight>
		<set_textNormal get="inline" set="null" line="419"><f a="Value">
	<c path="flixel.text.FlxText"/>
	<c path="flixel.text.FlxText"/>
</f></set_textNormal>
		<set_textHighlight get="inline" set="null" line="438"><f a="Value">
	<c path="flixel.text.FlxText"/>
	<c path="flixel.text.FlxText"/>
</f></set_textHighlight>
		<new public="1" set="method" line="90">
			<f a="?X:?Y:?Callback:?Label:?Width:?Height" v="0:0:null:null:100:20">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxButton object with a gray background
	 * and a callback function on the UI thread.
	 * 
	 * @param	X			The X position of the button.
	 * @param	Y			The Y position of the button.
	 * @param	Callback	The function to call whenever the button is clicked.
	 * @param	Label		Text to display on the button
	 * @param	Width		The width of the button.
	 * @param	Height		The height of the button.</haxe_doc>
		</new>
		<haxe_doc>* A simple button class that calls a function when clicked by the mouse.
 * 
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxClickArea" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/ui/FlxClickArea.hx">
		<extends path="flixel.FlxObject"/>
		<status public="1">
			<x path="Int"/>
			<haxe_doc>* Shows the current state of the button, either NORMAL, 
	 * HIGHLIGHT or PRESSED</haxe_doc>
		</status>
		<onUp public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called when the button is released.
	 * We recommend assigning your main button behavior to this function
	 * via the FlxClickArea constructor.</haxe_doc>
		</onUp>
		<_pressed>
			<x path="Bool"/>
			<haxe_doc>* Tracks whether or not the button is currently pressed.</haxe_doc>
		</_pressed>
		<_initialized>
			<x path="Bool"/>
			<haxe_doc>* Whether or not the button has initialized itself yet.</haxe_doc>
		</_initialized>
		<destroy public="1" set="method" line="70" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game state when state is changed (if this object belongs to the state)</haxe_doc>
		</destroy>
		<update public="1" set="method" line="91" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game loop automatically, handles mouseover and click detection.</haxe_doc>
		</update>
		<updateButton set="method" line="114">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Basic button update logic</haxe_doc>
		</updateButton>
		<updateButtonStatus set="method" line="159">
			<f a="Point:Camera:JustPressed">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Updates status and handles the onDown and onOver logic (callback function).</haxe_doc>
		</updateButtonStatus>
		<onMouseUp set="method" line="183">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function for handling the actual callback call (for UI thread dependent calls like FlxStringUtil.openURL()).</haxe_doc>
		</onMouseUp>
		<new public="1" set="method" line="50">
			<f a="?X:?Y:?Width:?Height:?OnUp" v="0:0:80:20:null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxClickArea object
	 * and a callback function on the UI thread.
	 * 
	 * @param	X			The X position of the button.
	 * @param	Y			The Y position of the button.
	 * @param   Width		Width of the area
	 * @param 	Height		Height of the area
	 * @param	OnUp		The function to call whenever the button is clicked.</haxe_doc>
		</new>
		<haxe_doc>* Trimmed-down button, invisible click area, only responds to onUP</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxInputText" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxInputText.hx">
		<extends path="flixel.text.FlxText"/>
		<NO_FILTER public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></NO_FILTER>
		<ONLY_ALPHA public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></ONLY_ALPHA>
		<ONLY_NUMERIC public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></ONLY_NUMERIC>
		<ONLY_ALPHANUMERIC public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></ONLY_ALPHANUMERIC>
		<CUSTOM_FILTER public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></CUSTOM_FILTER>
		<ALL_CASES public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></ALL_CASES>
		<UPPER_CASE public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></UPPER_CASE>
		<LOWER_CASE public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></LOWER_CASE>
		<BACKSPACE_ACTION public="1" get="inline" set="null" line="42" static="1"><c path="String"/></BACKSPACE_ACTION>
		<DELETE_ACTION public="1" get="inline" set="null" line="43" static="1"><c path="String"/></DELETE_ACTION>
		<ENTER_ACTION public="1" get="inline" set="null" line="44" static="1"><c path="String"/></ENTER_ACTION>
		<INPUT_ACTION public="1" get="inline" set="null" line="45" static="1"><c path="String"/></INPUT_ACTION>
		<customFilterPattern public="1" set="accessor">
			<c path="EReg"/>
			<haxe_doc>* This regular expression will filter out (remove) everything that matches. 
	* Automatically sets filterMode = FlxInputText.CUSTOM_FILTER.</haxe_doc>
		</customFilterPattern>
		<set_customFilterPattern public="1" set="method" line="52"><f a="cfp">
	<c path="EReg"/>
	<c path="EReg"/>
</f></set_customFilterPattern>
		<callback public="1">
			<f a=":">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A function called whenever the value changes from user input, or enter is pressed</haxe_doc>
		</callback>
		<background public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the textbox has a background</haxe_doc>
		</background>
		<caretColor public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The caret's color. Has the same color as the text by default.</haxe_doc>
		</caretColor>
		<set_caretColor public="1" set="method" line="73"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_caretColor>
		<caretWidth public="1" set="accessor"><x path="Int"/></caretWidth>
		<set_caretWidth public="1" set="method" line="81"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_caretWidth>
		<params public="1" set="accessor"><c path="Array"><d/></c></params>
		<passwordMode public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the textfield is a password textfield</haxe_doc>
		</passwordMode>
		<hasFocus public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the text box is the active object on the screen.</haxe_doc>
		</hasFocus>
		<caretIndex public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The position of the selection cursor. An index of 0 means the carat is before the character at index 0.</haxe_doc>
		</caretIndex>
		<forceCase public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The Case that's being enforced. Either ALL_CASES, UPPER_CASE or LOWER_CASE.</haxe_doc>
		</forceCase>
		<maxLength public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Set the maximum length for the field (e.g. "3" 
	 * for Arcade type hi-score initials). 0 means unlimited.</haxe_doc>
		</maxLength>
		<lines public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Change the amount of lines that are allowed.</haxe_doc>
		</lines>
		<filterMode public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Defines what text to filter. It can be NO_FILTER, ONLY_ALPHA, ONLY_NUMERIC, ONLY_ALPHA_NUMERIC or CUSTOM_FILTER
	 * (Remember to append "FlxInputText." as a prefix to those constants)</haxe_doc>
		</filterMode>
		<fieldBorderColor public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The color of the fieldBorders</haxe_doc>
		</fieldBorderColor>
		<fieldBorderThickness public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The thickness of the fieldBorders</haxe_doc>
		</fieldBorderThickness>
		<backgroundColor public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The color of the background of the textbox.</haxe_doc>
		</backgroundColor>
		<backgroundSprite>
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* A FlxSprite representing the background sprite</haxe_doc>
		</backgroundSprite>
		<_caretTimer>
			<c path="flixel.util.FlxTimer"/>
			<haxe_doc>* A timer for the flashing caret effect.</haxe_doc>
		</_caretTimer>
		<caret>
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* A FlxSprite representing the flashing caret when editing text.</haxe_doc>
		</caret>
		<fieldBorderSprite>
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* A FlxSprite representing the fieldBorders.</haxe_doc>
		</fieldBorderSprite>
		<_charBoundaries><c path="Array"><c path="flixel.util.FlxRect"/></c></_charBoundaries>
		<destroy public="1" set="method" line="211" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory</haxe_doc>
		</destroy>
		<draw public="1" set="method" line="236" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Draw the caret in addition to the text.</haxe_doc>
		</draw>
		<drawSprite set="method" line="256">
			<f a="Sprite">
				<c path="flixel.FlxSprite"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function that makes sure sprites are drawn up even though they haven't been added.
	 * @param	Sprite		The Sprite to be drawn.</haxe_doc>
		</drawSprite>
		<update public="1" set="method" line="269" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Check for mouse input every tick.</haxe_doc>
		</update>
		<onKeyDown set="method" line="293">
			<f a="e">
				<c path="flash.events.KeyboardEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handles keypresses generated on the stage.</haxe_doc>
		</onKeyDown>
		<onChange set="method" line="359"><f a="action">
	<c path="String"/>
	<x path="Void"/>
</f></onChange>
		<insertSubstring set="method" line="375">
			<f a="Original:Insert:Index">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Inserts a substring into a string at a specific index
	 * 
	 * @param	Insert			The string to have something inserted into
	 * @param	Insert			The string to insert
	 * @param	Index			The index to insert at
	 * @return					Returns the joined string for chaining.</haxe_doc>
		</insertSubstring>
		<getCaretIndexFromPoint set="method" line="394">
			<f a="Landing">
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Gets the index of a character in this box at a point
	 * @param	Landing			The point to check for.
	 * @return					The index of the character hit by the point. 
	 * 							Returns -1 if the point is not found.</haxe_doc>
		</getCaretIndexFromPoint>
		<getCharIndexAtPoint set="method" line="437"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getCharBoundaries set="method" line="455"><f a="charIndex">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<set_text set="method" line="465" override="1"><f a="Text">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<prepareCharBoundaries set="method" line="492"><f a="numChars">
	<x path="Int"/>
	<x path="Void"/>
</f></prepareCharBoundaries>
		<calcFrame set="method" line="523" override="1">
			<f a="?RunOnCpp" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws the frame of animation for the input text.
	 * 
	 * @param	RunOnCpp	Whether the frame should also be recalculated if we're on a non-flash target</haxe_doc>
		</calcFrame>
		<toggleCaret set="method" line="607">
			<f a="timer">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Turns the caret on/off for the caret flashing animation.</haxe_doc>
		</toggleCaret>
		<filter set="method" line="616">
			<f a="text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Checks an input string against the current 
	 * filter and returns a filtered string</haxe_doc>
		</filter>
		<set_params set="method" line="644"><f a="p">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_params>
		<set_x set="method" line="656" override="1"><f a="X">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="669" override="1"><f a="Y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_hasFocus set="method" line="682"><f a="newFocus">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_hasFocus>
		<set_caretIndex set="method" line="710"><f a="newCaretIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></set_caretIndex>
		<set_forceCase set="method" line="785"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_forceCase>
		<set_size set="method" line="792" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_size>
		<set_maxLength set="method" line="799"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxLength>
		<set_lines set="method" line="809"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_lines>
		<get_passwordMode set="method" line="827"><f a=""><x path="Bool"/></f></get_passwordMode>
		<set_passwordMode set="method" line="832"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_passwordMode>
		<set_filterMode set="method" line="839"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_filterMode>
		<set_fieldBorderColor set="method" line="846"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fieldBorderColor>
		<set_fieldBorderThickness set="method" line="853"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fieldBorderThickness>
		<set_backgroundColor set="method" line="860"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_backgroundColor>
		<new public="1" set="method" line="177">
			<f a="?X:?Y:?Width:?Text:?size:?TextColor:?BackgroundColor:?EmbeddedFont" v="0:0:150:null:8:-16777216:-1:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	X				The X position of the text.
	 * @param	Y				The Y position of the text.
	 * @param	Width			The width of the text object (height is determined automatically).
	 * @param	Text			The actual text you would like to display initially.
	 * @param   size			Initial size of the font	 
	 * @param	TextColor		The color of the text
	 * @param	BackgroundColor	The color of the background (FlxColor.TRANSPARENT for no background color)
	 * @param	EmbeddedFont	Whether this text field uses embedded fonts or not</haxe_doc>
		</new>
		<haxe_doc>* FlxInputText v1.11, ported to Haxe
 * @author larsiusprime, (Lars Doucet)
 * @link http://github.com/haxeflixel/flixel-ui
 * 
 * FlxInputText v1.10, Input text field extension for Flixel
 * @author Gama11, Mr_Walrus, nitram_cero (Martín Sebastián Wain)
 * @link http://forums.flixel.org/index.php/topic,272.0.html
 * 
 * Copyright (c) 2009 Martín Sebastián Wain
 * License: Creative Commons Attribution 3.0 United States
 * @link http://creativecommons.org/licenses/by/3.0/us/</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxSlider" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/ui/FlxSlider.hx">
		<extends path="flixel.group.FlxSpriteGroup"/>
		<body public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* The horizontal line in the background.</haxe_doc>
		</body>
		<handle public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* The dragable handle - loadGraphic() to change its graphic.</haxe_doc>
		</handle>
		<minLabel public="1">
			<c path="flixel.text.FlxText"/>
			<haxe_doc>* The text under the left border - equals minValue by default.</haxe_doc>
		</minLabel>
		<maxLabel public="1">
			<c path="flixel.text.FlxText"/>
			<haxe_doc>* The text under the right border - equals maxValue by default.</haxe_doc>
		</maxLabel>
		<nameLabel public="1">
			<c path="flixel.text.FlxText"/>
			<haxe_doc>* A text above the slider that displays its name.</haxe_doc>
		</nameLabel>
		<valueLabel public="1">
			<c path="flixel.text.FlxText"/>
			<haxe_doc>* A text under the slider that displays the current value.</haxe_doc>
		</valueLabel>
		<value public="1">
			<x path="Float"/>
			<haxe_doc>* Stores the current value of the variable - updated each frame.</haxe_doc>
		</value>
		<minValue public="1">
			<x path="Float"/>
			<haxe_doc>* Mininum value the variable can be changed to.</haxe_doc>
		</minValue>
		<maxValue public="1">
			<x path="Float"/>
			<haxe_doc>* Maximum value the variable can be changed to.</haxe_doc>
		</maxValue>
		<decimals public="1">
			<x path="Int"/>
			<haxe_doc>* How many decimals the variable can have at max. Default is zero,
	 * or "only whole numbers".</haxe_doc>
		</decimals>
		<clickSound public="1">
			<c path="String"/>
			<haxe_doc>* Sound that's played whenever the slider is clicked.</haxe_doc>
		</clickSound>
		<hoverSound public="1">
			<c path="String"/>
			<haxe_doc>* Sound that's played whenever the slider is hovered over.</haxe_doc>
		</hoverSound>
		<hoverAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha value the slider uses when it's hovered over. 1 to turn the effect off.</haxe_doc>
		</hoverAlpha>
		<callback public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A function to be called when the slider was used. 
	 * The current relativePos is passed as an argument.</haxe_doc>
		</callback>
		<setVariable public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the slider sets the variable it tracks. Can be useful to deactivate this in conjunction with callbacks.</haxe_doc>
		</setVariable>
		<expectedPos public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The expected position of the handle based on the current variable value.</haxe_doc>
		</expectedPos>
		<relativePos public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The position of the handle relative to the slider / max value.</haxe_doc>
		</relativePos>
		<varString public="1" set="accessor">
			<c path="String"/>
			<haxe_doc>* Stores the variable the slider controls.</haxe_doc>
		</varString>
		<_bounds>
			<c path="flixel.util.FlxRect"/>
			<haxe_doc>* The dragable area for the handle. Is configured automatically.</haxe_doc>
		</_bounds>
		<_width>
			<x path="Int"/>
			<haxe_doc>* The width of the slider.</haxe_doc>
		</_width>
		<_height>
			<x path="Int"/>
			<haxe_doc>* The height of the slider - make sure to call createSlider() if you
	 * want to change this.</haxe_doc>
		</_height>
		<_thickness>
			<x path="Int"/>
			<haxe_doc>* The thickness of the slider - make sure to call createSlider() if you
	 * want to change this.</haxe_doc>
		</_thickness>
		<_color>
			<x path="Int"/>
			<haxe_doc>* The color of the slider - make sure to call createSlider() if you
	 * want to change this.</haxe_doc>
		</_color>
		<_handleColor>
			<x path="Int"/>
			<haxe_doc>* The color of the handle - make sure to call createSlider() if you
	 * want to change this.</haxe_doc>
		</_handleColor>
		<_object>
			<d/>
			<haxe_doc>* Stores a reference to parent object.</haxe_doc>
		</_object>
		<_lastPos>
			<x path="Float"/>
			<haxe_doc>* Helper var for callbacks.</haxe_doc>
		</_lastPos>
		<_justClicked>
			<x path="Bool"/>
			<haxe_doc>* Helper variable to avoid the clickSound playing every frame.</haxe_doc>
		</_justClicked>
		<_justHovered>
			<x path="Bool"/>
			<haxe_doc>* Helper variable to avoid the hoverSound playing every frame.</haxe_doc>
		</_justHovered>
		<createSlider set="method" line="197">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Initially creates the slider with all its objects.</haxe_doc>
		</createSlider>
		<update public="1" set="method" line="245" override="1"><f a=""><x path="Void"/></f></update>
		<updateValue set="method" line="319">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function that is called whenever the slider is used to either update the variable tracked or call the Callback function.</haxe_doc>
		</updateValue>
		<setTexts public="1" set="method" line="345">
			<f a="Name:?Value:?Min:?Max:?Size" v=":true:null:null:8">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handy function for changing the textfields.
	 *
	 * @param 	Name 		Text of nameLabel - null to hide
	 * @param 	Value	 	Whether to show the valueText or not
	 * @param 	Min 		Text of minLabel - null to hide
	 * @param 	Max 		Text of maxLabel - null to hide
	 * @param 	Size 		Size to use for the texts</haxe_doc>
		</setTexts>
		<destroy public="1" set="method" line="395" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cleaning up memory.</haxe_doc>
		</destroy>
		<get_expectedPos set="method" line="409"><f a=""><x path="Float"/></f></get_expectedPos>
		<get_relativePos set="method" line="426"><f a=""><x path="Float"/></f></get_relativePos>
		<set_varString set="method" line="439"><f a="Value">
	<c path="String"/>
	<c path="String"/>
</f></set_varString>
		<new public="1" set="method" line="157">
			<f a="Object:VarString:?X:?Y:?MinValue:?MaxValue:?Width:?Height:?Thickness:?Color:?HandleColor" v="::0:0:0:10:100:15:3:-16777216:-8224126">
				<d/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxSlider.
	 *
	 * @param	Object 			Reference to the parent object of the variable
	 * @param	VarString 		Variable that the slider controls
	 * @param	X				x Position
	 * @param	Y 				y Position
	 * @param	MinValue 		Mininum value the variable can be changed to
	 * @param	MaxValue 		Maximum value the variable can be changed to
	 * @param	Width 			Width of the slider
	 * @param	Height 			Height of the slider
	 * @param	Thickness 		Thickness of the slider
	 * @param	Color 			Color of the slider background and all texts except for valueText showing the current value
	 * @param	HandleColor 	Color of the slider handle and the valueText showing the current value</haxe_doc>
		</new>
		<haxe_doc>* A slider GUI element for float and integer manipulation. 
 * @author Gama11</haxe_doc>
	</class>
	<class path="flixel.interfaces.IFlxBasic" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/interfaces/IFlxBasic.hx" interface="1">
		<ID public="1"><x path="Int"/></ID>
		<active public="1" set="accessor"><x path="Bool"/></active>
		<visible public="1" set="accessor"><x path="Bool"/></visible>
		<alive public="1" set="accessor"><x path="Bool"/></alive>
		<exists public="1" set="accessor"><x path="Bool"/></exists>
		<draw public="1" set="method"><f a=""><x path="Void"/></f></draw>
		<update public="1" set="method"><f a=""><x path="Void"/></f></update>
		<destroy public="1" set="method"><f a=""><x path="Void"/></f></destroy>
		<kill public="1" set="method"><f a=""><x path="Void"/></f></kill>
		<revive public="1" set="method"><f a=""><x path="Void"/></f></revive>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
	</class>
	<class path="flixel.interfaces.IFlxSprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/interfaces/IFlxSprite.hx" interface="1">
		<extends path="flixel.interfaces.IFlxBasic"/>
		<x public="1" set="accessor"><x path="Float"/></x>
		<y public="1" set="accessor"><x path="Float"/></y>
		<alpha public="1" set="accessor"><x path="Float"/></alpha>
		<angle public="1" set="accessor"><x path="Float"/></angle>
		<facing public="1" set="accessor"><x path="Int"/></facing>
		<moves public="1" set="accessor"><x path="Bool"/></moves>
		<immovable public="1" set="accessor"><x path="Bool"/></immovable>
		<offset public="1" set="null"><c path="flixel.util.FlxPoint"/></offset>
		<origin public="1" set="null"><c path="flixel.util.FlxPoint"/></origin>
		<scale public="1" set="null"><c path="flixel.util.FlxPoint"/></scale>
		<velocity public="1" set="null"><c path="flixel.util.FlxPoint"/></velocity>
		<maxVelocity public="1" set="null"><c path="flixel.util.FlxPoint"/></maxVelocity>
		<acceleration public="1" set="null"><c path="flixel.util.FlxPoint"/></acceleration>
		<drag public="1" set="null"><c path="flixel.util.FlxPoint"/></drag>
		<scrollFactor public="1" set="null"><c path="flixel.util.FlxPoint"/></scrollFactor>
		<reset public="1" set="method"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<setPosition public="1" set="method"><f a="?X:?Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<haxe_doc>* The interface for properties of FlxSprite
  * It makes possible to add FlxSpriteGroup to FlxSpriteGroup</haxe_doc>
	</class>
	<class path="flixel.addons.ui.interfaces.IFlxUIWidget" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/interfaces/IFlxUIWidget.hx" interface="1">
		<extends path="flixel.interfaces.IFlxSprite"/>
		<id public="1"><c path="String"/></id>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<height public="1" get="accessor" set="accessor"><x path="Float"/></height>
		<broadcastToFlxUI public="1"><x path="Bool"/></broadcastToFlxUI>
		<haxe_doc>* ...
 * @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIGroup" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIGroup.hx">
		<extends path="flixel.group.FlxSpriteGroup"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<id public="1">
			<c path="String"/>
			<haxe_doc>*PUBLIC VARS*</haxe_doc>
		</id>
		<broadcastToFlxUI public="1"><x path="Bool"/></broadcastToFlxUI>
		<autoBounds public="1">
			<x path="Bool"/>
			<haxe_doc>*PUBLIC GETTER/SETTERS*</haxe_doc>
		</autoBounds>
		<destroy public="1" set="method" line="35" override="1"><f a=""><x path="Void"/></f></destroy>
		<add public="1" set="method" line="39" override="1"><f a="Object">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.FlxSprite"/>
</f></add>
		<remove public="1" set="method" line="47" override="1"><f a="Object:?Splice" v=":false">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<c path="flixel.FlxSprite"/>
</f></remove>
		<hasThis public="1" set="method" line="55"><f a="Object">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
</f></hasThis>
		<calcBounds public="1" set="method" line="65"><f a=""><x path="Void"/></f></calcBounds>
		<floorAll public="1" set="method" line="99">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Floor the positions of all children</haxe_doc>
		</floorAll>
		<new public="1" set="method" line="30">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>*PUBLIC FUNCTIONS*</haxe_doc>
		</new>
		<haxe_doc>* A cheap extension of FlxUIGroup that lets you move all the children around
 * without having to call reset()
 * @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.interfaces.IEventGetter" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/interfaces/IEventGetter.hx" interface="1">
		<getEvent public="1" set="method"><f a="name:sender:data:?params">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<d/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></getEvent>
		<getRequest public="1" set="method"><f a="name:sender:data:?params">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></getRequest>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUI" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUI.hx">
		<extends path="flixel.addons.ui.FlxUIGroup"/>
		<implements path="flixel.addons.ui.interfaces.IEventGetter"/>
		<event public="1" set="method" line="107" static="1">
			<f a="name:sender:data:?params" v=":::null">
				<c path="String"/>
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
				<d/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>*EVENT HANDLING*</haxe_doc>
		</event>
		<forceFocus public="1" set="method" line="122" static="1">
			<f a="b:thing">
				<x path="Bool"/>
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Static-level function used to force giving a certain widget focus (useful for e.g. enforcing overlap logic)
	 * @param	b
	 * @param	thing</haxe_doc>
		</forceFocus>
		<getLeafUIState set="method" line="135" static="1">
			<f a=""><c path="flixel.addons.ui.interfaces.IFlxUIState"/></f>
			<haxe_doc>* Drill down to the current state or sub-state, and ensure it is an IFlxUIState (FlxUIState or FlxUISubState)
	 * @return</haxe_doc>
		</getLeafUIState>
		<request public="1" set="method" line="160" static="1">
			<f a="name:sender:data:?params" v=":::null">
				<c path="String"/>
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>* Broadcasts an event to the current FlxUIState/FlxUISubState, and expects data in return
	 * @param	name	string identifier of the event -- each IFlxUIWidget has a set of string constants
	 * @param	sender	the IFlxUIWidget that sent this event
	 * @param	data	non-array data (boolean for a checkbox, string for a radiogroup, etc)
	 * @param	?params	(optional) user-specified array of arbitrary data
	 * @return	some sort of arbitrary data from the recipient</haxe_doc>
		</request>
		<_delta get="inline" set="null" line="705" static="1">
			<f a="thing:?X:?Y" v=":0:0">
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to thing.x and/or thing.y with wrappers depending on type
	 * @param	thing
	 * @param	X
	 * @param	Y</haxe_doc>
		</_delta>
		<_center get="inline" set="null" line="716" static="1">
			<f a="thing:?X:?Y" v=":true:true">
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
			</f>
			<haxe_doc>* Centers thing in x axis with wrappers depending on type
	 * @param	thing
	 * @param	amt</haxe_doc>
		</_center>
		<consolidateData public="1" set="method" line="1342" static="1"><f a="data:definition">
	<c path="haxe.xml.Fast"/>
	<c path="haxe.xml.Fast"/>
	<c path="haxe.xml.Fast"/>
</f></consolidateData>
		<_loadBitmapRect get="inline" set="null" line="2085" static="1"><f a="source:rect_str">
	<c path="String"/>
	<c path="String"/>
	<c path="flash.display.BitmapData"/>
</f></_loadBitmapRect>
		<getParams get="inline" set="null" line="2723" static="1">
			<f a="data">
				<c path="haxe.xml.Fast"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>* Parses params out of xml and loads them in the correct type
	 * @param	data</haxe_doc>
		</getParams>
		<do_safe_input_delay public="1"><x path="Bool"/></do_safe_input_delay>
		<safe_input_delay_time public="1"><x path="Float"/></safe_input_delay_time>
		<failed public="1"><x path="Bool"/></failed>
		<failed_by public="1"><x path="Float"/></failed_by>
		<tongue public="1" get="accessor" set="accessor"><c path="flixel.addons.ui.interfaces.IFireTongue"/></tongue>
		<get_tongue set="method" line="55"><f a=""><c path="flixel.addons.ui.interfaces.IFireTongue"/></f></get_tongue>
		<set_tongue set="method" line="56"><f a="t">
	<c path="flixel.addons.ui.interfaces.IFireTongue"/>
	<c path="flixel.addons.ui.interfaces.IFireTongue"/>
</f></set_tongue>
		<focus public="1" set="accessor"><c path="flixel.addons.ui.interfaces.IFlxUIWidget"/></focus>
		<set_focus set="method" line="64"><f a="widget">
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
</f></set_focus>
		<getTextFallback public="1"><f a="::">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></getTextFallback>
		<_ptr_tongue><c path="flixel.addons.ui.interfaces.IFireTongue"/></_ptr_tongue>
		<_data><c path="haxe.xml.Fast"/></_data>
		<_tongueSet set="method" line="84">
			<f a="list:tongue">
				<c path="Array"><c path="flixel.FlxSprite"/></c>
				<c path="flixel.addons.ui.interfaces.IFireTongue"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Make sure to recursively propogate the tongue pointer down to all my members</haxe_doc>
		</_tongueSet>
		<callEvent public="1" set="method" line="170"><f a="id:sender:data:?params" v=":::null">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<d/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></callEvent>
		<getEvent public="1" set="method" line="174"><f a="id:sender:data:?params" v=":::null">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<d/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></getEvent>
		<getRequest public="1" set="method" line="180"><f a="id:sender:data:?params" v=":::null">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></getRequest>
		<onFocus public="1" set="method" line="205"><f a="widget">
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Void"/>
</f></onFocus>
		<setWidgetSuppression set="method" line="214"><f a="asset:butNotThisOne:?suppressed" v="::true">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setWidgetSuppression>
		<onFocusLost public="1" set="method" line="240">
			<f a="widget">
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This causes FlxUI to respond to a specific widget losing focus
	 * @param	widget</haxe_doc>
		</onFocusLost>
		<setSuperIndex public="1" set="method" line="256">
			<f a="flxUI">
				<c path="flixel.addons.ui.FlxUI"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a pointer to another FlxUI for the purposes of indexing
	 * @param	flxUI</haxe_doc>
		</setSuperIndex>
		<update public="1" set="method" line="260" override="1"><f a=""><x path="Void"/></f></update>
		<removeAsset public="1" set="method" line="280">
			<f a="key:?destroy" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
			</f>
			<haxe_doc>* Removes an asset
	 * @param	key the asset to remove
	 * @param	destroy whether to destroy it
	 * @return	the asset, or null if destroy=true</haxe_doc>
		</removeAsset>
		<addAsset public="1" set="method" line="301">
			<f a="asset:key:?group_id:?recursive" v="::'':false">
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Adds an asset to this UI, and optionally puts it in a group
	 * @param	asset	the IFlxUIWidget asset you want to add
	 * @param	key		unique key for this asset. If it already exists, this fails.
	 * @param	group_id string id of group inside this FlxUI you want to add it to.
	 * @param	recursive whether to recursively search through sub-ui's</haxe_doc>
		</addAsset>
		<replaceAsset public="1" set="method" line="326">
			<f a="key:replace:?center_x:?center_y:?destroy_old" v="::true:true:true">
				<c path="String"/>
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
			</f>
			<haxe_doc><![CDATA[* Replaces an asset, both in terms of location & group position
	 * @param	key the string id of the original
	 * @param	replace the replacement object
	 * @param 	destroy_old kills the original if true
	 * @return	the old asset, or null if destroy_old=true]]></haxe_doc>
		</replaceAsset>
		<destroy public="1" set="method" line="368" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove all the references and pointers, then destroy everything</haxe_doc>
		</destroy>
		<load public="1" set="method" line="395">
			<f a="data">
				<c path="haxe.xml.Fast"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Main setup function - pass in a Fast(xml) object 
	 * to set up your FlxUI
	 * @param	data</haxe_doc>
		</load>
		<_postLoad set="method" line="507"><f a="data">
	<c path="haxe.xml.Fast"/>
	<x path="Void"/>
</f></_postLoad>
		<currMode public="1" get="accessor" set="accessor"><c path="String"/></currMode>
		<get_currMode set="method" line="544"><f a=""><c path="String"/></f></get_currMode>
		<set_currMode set="method" line="545"><f a="m">
	<c path="String"/>
	<c path="String"/>
</f></set_currMode>
		<setMode public="1" set="method" line="553">
			<f a="mode_id:?target_id" v=":''">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a mode for this UI. This lets you show/hide stuff basically. 
	 * @param	mode_id The mode you want, say, "empty" or "play" for a save slot
	 * @param	target_id UI element to target - "" for the UI itself, otherwise the id of an element that is itself a FlxUI</haxe_doc>
		</setMode>
		<showThing set="method" line="600"><f a="id:?b" v=":true">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></showThing>
		<getGroup public="1" set="method" line="627">
			<f a="key:?recursive" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="flixel.addons.ui.FlxUIGroup"/>
			</f>
			<haxe_doc>****UTILITY FUNCTIONS********</haxe_doc>
		</getGroup>
		<getFlxText public="1" set="method" line="635"><f a="key:?recursive" v=":true">
	<c path="String"/>
	<x path="Bool"/>
	<c path="flixel.text.FlxText"/>
</f></getFlxText>
		<hasAsset public="1" set="method" line="645"><f a="key:?recursive" v=":true">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></hasAsset>
		<getAsset public="1" set="method" line="655"><f a="key:?recursive" v=":true">
	<c path="String"/>
	<x path="Bool"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
</f></getAsset>
		<getMode public="1" set="method" line="663"><f a="key:?recursive" v=":true">
	<c path="String"/>
	<x path="Bool"/>
	<c path="haxe.xml.Fast"/>
</f></getMode>
		<getLabelStyleFromDefinition public="1" set="method" line="671"><f a="key:?recursive" v=":true">
	<c path="String"/>
	<x path="Bool"/>
	<c path="flixel.addons.ui.ButtonLabelStyle"/>
</f></getLabelStyleFromDefinition>
		<getDefinition public="1" set="method" line="683"><f a="key:?recursive" v=":true">
	<c path="String"/>
	<x path="Bool"/>
	<c path="haxe.xml.Fast"/>
</f></getDefinition>
		<_group_index>
			<x path="Map">
				<c path="String"/>
				<c path="flixel.addons.ui.FlxUIGroup"/>
			</x>
			<haxe_doc>*PRIVATE*</haxe_doc>
		</_group_index>
		<_asset_index><x path="Map">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
</x></_asset_index>
		<_definition_index><x path="Map">
	<c path="String"/>
	<c path="haxe.xml.Fast"/>
</x></_definition_index>
		<_mode_index><x path="Map">
	<c path="String"/>
	<c path="haxe.xml.Fast"/>
</x></_mode_index>
		<_curr_mode><c path="String"/></_curr_mode>
		<_ptr><c path="flixel.addons.ui.interfaces.IEventGetter"/></_ptr>
		<_superIndexUI><c path="flixel.addons.ui.FlxUI"/></_superIndexUI>
		<_safe_input_delay_elapsed><x path="Float"/></_safe_input_delay_elapsed>
		<_failure_checks><c path="Array"><c path="haxe.xml.Fast"/></c></_failure_checks>
		<replaceInGroup set="method" line="745">
			<f a="original:replace:?splice" v="::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Replace an object in whatever group it is in
	 * @param	original the original object
	 * @param	replace	the replacement object
	 * @param	splice if replace is null, whether to splice the entry</haxe_doc>
		</replaceInGroup>
		<applyNodeConditionals set="method" line="795">
			<f a="info">
				<c path="haxe.xml.Fast"/>
				<c path="haxe.xml.Fast"/>
			</f>
			<haxe_doc>**********LOADING FUNCTIONS************</haxe_doc>
		</applyNodeConditionals>
		<applyNodeChanges set="method" line="816">
			<f a="data:nodeName">
				<c path="haxe.xml.Fast"/>
				<c path="String"/>
				<c path="haxe.xml.Fast"/>
			</f>
			<haxe_doc>* Make any necessary changes to data/definition xml objects (such as for locale or haxedef settings)
	 * @param	data		Fast xml data
	 * @param	nodeName	name of the node, "locale", or "haxedef"</haxe_doc>
		</applyNodeChanges>
		<_loadThing set="method" line="861"><f a="type:data">
	<c path="String"/>
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
</f></_loadThing>
		<_loadX get="inline" set="null" line="907"><f a="data:?default_" v=":0">
	<c path="haxe.xml.Fast"/>
	<x path="Float"/>
	<x path="Float"/>
</f></_loadX>
		<_loadY get="inline" set="null" line="911"><f a="data:?default_" v=":0">
	<c path="haxe.xml.Fast"/>
	<x path="Float"/>
	<x path="Float"/>
</f></_loadY>
		<_loadWidth set="method" line="915"><f a="data:?default_:?str" v=":10:'width'">
	<c path="haxe.xml.Fast"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Float"/>
</f></_loadWidth>
		<_loadHeight set="method" line="920"><f a="data:?default_:?str" v=":10:'height'">
	<c path="haxe.xml.Fast"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Float"/>
</f></_loadHeight>
		<_loadCompass set="method" line="925"><f a="data:?str" v=":'resize_point'">
	<c path="haxe.xml.Fast"/>
	<c path="String"/>
	<c path="flixel.util.FlxPoint"/>
</f></_loadCompass>
		<_changeParamsThing set="method" line="942"><f a="data">
	<c path="haxe.xml.Fast"/>
	<x path="Void"/>
</f></_changeParamsThing>
		<_changeThing set="method" line="961"><f a="data">
	<c path="haxe.xml.Fast"/>
	<x path="Void"/>
</f></_changeThing>
		<_alignThing set="method" line="1014"><f a="data">
	<c path="haxe.xml.Fast"/>
	<x path="Void"/>
</f></_alignThing>
		<_doAlign set="method" line="1072"><f a="objects:axis:spacing:resize:bounds">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></_doAlign>
		<_checkFailure set="method" line="1147"><f a="data">
	<c path="haxe.xml.Fast"/>
	<x path="Bool"/>
</f></_checkFailure>
		<_resizeThing set="method" line="1210"><f a="fo_r:bounds">
	<c path="flixel.addons.ui.interfaces.IResizable"/>
	<a>
		<min_width><x path="Float"/></min_width>
		<min_height><x path="Float"/></min_height>
		<max_width><x path="Float"/></max_width>
		<max_height><x path="Float"/></max_height>
	</a>
	<x path="Void"/>
</f></_resizeThing>
		<_postLoadThing set="method" line="1237"><f a="type:data">
	<c path="String"/>
	<c path="haxe.xml.Fast"/>
	<x path="Void"/>
</f></_postLoadThing>
		<_loadTileTest set="method" line="1269"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.FlxUITileTest"/>
</f></_loadTileTest>
		<_loadText set="method" line="1304"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
</f></_loadText>
		<_loadRadioGroup set="method" line="1379"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.FlxUIRadioGroup"/>
</f></_loadRadioGroup>
		<_loadCheckBox set="method" line="1446"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.FlxUICheckBox"/>
</f></_loadCheckBox>
		<_loadDropDownMenu set="method" line="1492"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.FlxUIDropDownMenu"/>
</f></_loadDropDownMenu>
		<_loadTest set="method" line="1605"><f a="data">
	<c path="haxe.xml.Fast"/>
	<x path="Bool"/>
</f></_loadTest>
		<_loadLayout set="method" line="1648"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.FlxUI"/>
</f></_loadLayout>
		<_loadTabMenu set="method" line="1662"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.FlxUITabMenu"/>
</f></_loadTabMenu>
		<_loadNumericStepper set="method" line="1771"><f a="data:?setCallback" v=":true">
	<c path="haxe.xml.Fast"/>
	<x path="Bool"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
</f></_loadNumericStepper>
		<_loadButton set="method" line="1814"><f a="data:?setCallback:?isToggle:?load_code" v=":true:false:''">
	<c path="haxe.xml.Fast"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
</f></_loadButton>
		<_loadRegion set="method" line="2093"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.FlxUIRegion"/>
</f></_loadRegion>
		<_load9SliceSprite set="method" line="2099"><f a="data:?load_code" v=":''">
	<c path="haxe.xml.Fast"/>
	<c path="String"/>
	<c path="flixel.addons.ui.FlxUI9SliceSprite"/>
</f></_load9SliceSprite>
		<_loadTileRule get="inline" set="null" line="2145"><f a="data">
	<c path="haxe.xml.Fast"/>
	<x path="Int"/>
</f></_loadTileRule>
		<_loadLine set="method" line="2156"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.FlxUISprite"/>
</f></_loadLine>
		<_loadSprite set="method" line="2195"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.FlxUISprite"/>
</f></_loadSprite>
		<thisWidth set="method" line="2229"><f a=""><x path="Int"/></f></thisWidth>
		<thisHeight set="method" line="2237"><f a=""><x path="Int"/></f></thisHeight>
		<_getAnchorPos set="method" line="2245"><f a="thing:axis:str">
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
</f></_getAnchorPos>
		<calcMaxMinSize set="method" line="2310"><f a="data:?width:?height" v=":null:null">
	<c path="haxe.xml.Fast"/>
	<d/>
	<d/>
	<t path="flixel.addons.ui.MaxMinSize"/>
</f></calcMaxMinSize>
		<_getDataSize set="method" line="2376"><f a="target:str:?default_" v="::0">
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
</f></_getDataSize>
		<_getOperation set="method" line="2423">
			<f a="str">
				<c path="String"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc><![CDATA[* Give me a string like "thing.right+10" and I'll return ["+",10]
	 * Only accepts one operator and operand at max!
	 * The operand MUST be a number.
	 * @param	string of format: <value><operator><operand>
	 * @return [<value>:String,<operator>:String,<operand>:Float]]]></haxe_doc>
		</_getOperation>
		<_doOperation set="method" line="2444"><f a="value:operator:operand">
	<x path="Float"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
</f></_doOperation>
		<_getStretch set="method" line="2455"><f a="index:target:str">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
</f></_getStretch>
		<_loadPosition set="method" line="2533"><f a="data:thing">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Void"/>
</f></_loadPosition>
		<_loadBorder set="method" line="2613"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.BorderDef"/>
</f></_loadBorder>
		<_loadColor set="method" line="2652"><f a="data:?colorName:?_default" v=":'color':-1">
	<c path="haxe.xml.Fast"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_loadColor>
		<_loadFontDef set="method" line="2662"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="flixel.addons.ui.FontDef"/>
</f></_loadFontDef>
		<_loadFontFace set="method" line="2669"><f a="data">
	<c path="haxe.xml.Fast"/>
	<c path="String"/>
</f></_loadFontFace>
		<_onFinishLoad set="method" line="2678"><f a=""><x path="Void"/></f></_onFinishLoad>
		<getText public="1" set="method" line="2695">
			<f a="flag:?context:?safe:?code" v=":'data':true:''">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>********UTILITY FUNCTIONS**********</haxe_doc>
		</getText>
		<formatFromCode set="method" line="2708"><f a="str:code">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></formatFromCode>
		<formatButtonText set="method" line="2743"><f a="data:button">
	<c path="haxe.xml.Fast"/>
	<d/>
	<x path="Void"/>
</f></formatButtonText>
		<new public="1" set="method" line="189">
			<f a="?data:?ptr:?superIndex_:?tongue_" v="null:null:null:null">
				<c path="haxe.xml.Fast"/>
				<c path="flixel.addons.ui.interfaces.IEventGetter"/>
				<c path="flixel.addons.ui.FlxUI"/>
				<c path="flixel.addons.ui.interfaces.IFireTongue"/>
				<x path="Void"/>
			</f>
			<haxe_doc>*PUBLIC FUNCTIONS*</haxe_doc>
		</new>
		<haxe_doc>* A simple xml-driven user interface
 * 
 * Usage example:
 *	_ui = new FlxUI(U.xml("save_slot"),this);
 *	add(_ui);
 * 
 * @author Lars Doucet</haxe_doc>
	</class>
	<typedef path="flixel.addons.ui.UIEventCallback" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUI.hx" module="flixel.addons.ui.FlxUI"><f a=":::">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<d/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></typedef>
	<typedef path="flixel.addons.ui.NamedBool" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUI.hx" module="flixel.addons.ui.FlxUI"><a>
	<value><x path="Bool"/></value>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="flixel.addons.ui.NamedInt" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUI.hx" module="flixel.addons.ui.FlxUI"><a>
	<value><x path="Int"/></value>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="flixel.addons.ui.NamedFloat" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUI.hx" module="flixel.addons.ui.FlxUI"><a>
	<value><x path="Float"/></value>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="flixel.addons.ui.NamedString" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUI.hx" module="flixel.addons.ui.FlxUI"><a>
	<value><c path="String"/></value>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="flixel.addons.ui.MaxMinSize" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUI.hx" module="flixel.addons.ui.FlxUI"><a>
	<min_width><x path="Float"/></min_width>
	<min_height><x path="Float"/></min_height>
	<max_width><x path="Float"/></max_width>
	<max_height><x path="Float"/></max_height>
</a></typedef>
	<class path="flixel.addons.ui.FlxUISprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUISprite.hx">
		<extends path="flixel.FlxSprite"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<broadcastToFlxUI public="1"><x path="Bool"/></broadcastToFlxUI>
		<id public="1"><c path="String"/></id>
		<ptr_owner public="1"><d/></ptr_owner>
		<recycled public="1"><x path="Bool"/></recycled>
		<recycle public="1" set="method" line="29"><f a="data">
	<d/>
	<x path="Void"/>
</f></recycle>
		<destroy public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="24"><f a="?X:?Y:?SimpleGraphic" v="0:0:null">
	<x path="Float"/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Cheap extension of FlxSprite
 * @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.interfaces.IResizable" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/interfaces/IResizable.hx" interface="1">
		<resize public="1" set="method"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<height public="1" get="accessor" set="accessor"><x path="Float"/></height>
		<haxe_doc>* ...
 * @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUI9SliceSprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUI9SliceSprite.hx">
		<extends path="flixel.addons.ui.FlxUISprite"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<implements path="flixel.addons.ui.interfaces.IResizable"/>
		<bitmapsCreated line="20" static="1"><x path="Int"/></bitmapsCreated>
		<_canvas static="1"><c path="flash.display.Sprite"/></_canvas>
		<useSectionCache line="25" static="1"><x path="Bool"/></useSectionCache>
		<sectionCache static="1"><x path="Map">
	<c path="String"/>
	<c path="flash.display.BitmapData"/>
</x></sectionCache>
		<_staticPoint line="38" static="1"><c path="flash.geom.Point"/></_staticPoint>
		<_staticRect line="39" static="1"><c path="flash.geom.Rectangle"/></_staticRect>
		<_staticRect2 line="40" static="1"><c path="flash.geom.Rectangle"/></_staticRect2>
		<_staticPointZero line="42" static="1"><c path="flash.geom.Point"/></_staticPointZero>
		<_staticMatrix line="43" static="1"><c path="flash.geom.Matrix"/></_staticMatrix>
		<_staticFlxRect line="45" static="1"><c path="flixel.util.FlxRect"/></_staticFlxRect>
		<_staticFlxRect2 line="46" static="1"><c path="flixel.util.FlxRect"/></_staticFlxRect2>
		<TILE_NONE public="1" get="inline" set="null" line="49" static="1"><x path="Int"/></TILE_NONE>
		<TILE_BOTH public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></TILE_BOTH>
		<TILE_H public="1" get="inline" set="null" line="51" static="1"><x path="Int"/></TILE_H>
		<TILE_V public="1" get="inline" set="null" line="52" static="1"><x path="Int"/></TILE_V>
		<_staticRects static="1"><x path="Map">
	<c path="String"/>
	<c path="flixel.util.FlxRect"/>
</x></_staticRects>
		<getRectFromString public="1" get="inline" set="null" line="167" static="1"><f a="str">
	<c path="String"/>
	<c path="flash.geom.Rectangle"/>
</f></getRectFromString>
		<getRectIntsFromString public="1" get="inline" set="null" line="180" static="1"><f a="str">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></getRectIntsFromString>
		<paintScale9 public="1" set="method" line="206" static="1">
			<f a="g:assetID:scale9:rc:?tile:?smooth:?raw" v="::::0:false:null">
				<c path="flash.display.BitmapData"/>
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<c path="flixel.util.FlxRect"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Does the actual drawing for a 9-slice scaled graphic
	 * @param	g the graphics object for drawing to (ie, sprite.graphic)
	 * @param	assetID id of bitmapdata asset you are scaling
	 * @param	scale9 int array defining 2 points that define the grid as [x1,y1,x2,y2] (upper-interior-left, lower-interior-right)
	 * @param	rc rectangle object defining how big you want to scale it to
	 * @param	tile if a bit is false, scale those pieces, if true, tile them (default both false)
	 * @param 	smooth whether to smooth when scaling or not (default false)
	 * @param 	raw raw pixels supplied, if any</haxe_doc>
		</paintScale9>
		<paintCompoundBitmap public="1" set="method" line="268" static="1"><f a="g:assetID:sourceRects:targetRect:?tile:?smooth:?raw" v="::::0:false:null">
	<c path="flash.display.BitmapData"/>
	<c path="String"/>
	<x path="Map">
		<c path="String"/>
		<c path="flixel.util.FlxRect"/>
	</x>
	<c path="flixel.util.FlxRect"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></paintCompoundBitmap>
		<paintBitmapSection public="1" set="method" line="334" static="1"><f a="g:assetId:src:dst:?srcData:?tile:?smooth:?raw" v="::::null:0:false:null">
	<c path="flash.display.BitmapData"/>
	<c path="String"/>
	<c path="flixel.util.FlxRect"/>
	<c path="flixel.util.FlxRect"/>
	<c path="flash.display.BitmapData"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></paintBitmapSection>
		<bitmapFillRect set="method" line="391" static="1"><f a="g:dst:section:?tile:?smooth_" v=":::0:false">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.display.BitmapData"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></bitmapFillRect>
		<_bmpCanvas><c path="flash.display.BitmapData"/></_bmpCanvas>
		<_slice9><c path="Array"><x path="Int"/></c></_slice9>
		<_tile><x path="Int"/></_tile>
		<_smooth><x path="Bool"/></_smooth>
		<_asset_id><c path="String"/></_asset_id>
		<_raw_pixels><c path="flash.display.BitmapData"/></_raw_pixels>
		<resize_ratio public="1" set="accessor"><x path="Float"/></resize_ratio>
		<set_resize_ratio set="method" line="101"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_resize_ratio>
		<resize_point public="1" set="accessor"><c path="flixel.util.FlxPoint"/></resize_point>
		<set_resize_point set="method" line="104"><f a="r">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
</f></set_resize_point>
		<resize public="1" set="method" line="113"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method" line="70">
			<f a="X:Y:Graphic:Rect:?Slice9:?Tile:?Smooth:?Id:?Ratio:?Resize_point" v="::::null:0:false:'':-1:null">
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<c path="flash.geom.Rectangle"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* @param	X	X position of final sprite
	 * @param	Y	Y position of final sprite
	 * @param	Graphic	Asset
	 * @param	Rect	Width/Height of the final scaled sprite
	 * @param	slice9	[x1,y1,x2,y2] : 2 points (upper-left middle and lower-right middle) that define the 9-slice grid
	 * @param	tile	Whether to tile the middle pieces or stretch them (default is false --> stretch)
	 * @param	smooth	When stretching, whether to smooth middle pieces (default false)
	 * @param 	id	if Graphic is a BitmapData, manually specify its original source id, if any
	 * @param   ratio	Resize ratio to force, if desired (W/H)
	 * @param]]></haxe_doc>
		</new>
		<haxe_doc>* @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIAssets" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIAssets.hx">
		<IMG_BUTTON public="1" get="inline" set="null" line="6" static="1"><c path="String"/></IMG_BUTTON>
		<IMG_BUTTON_ARROW_DOWN public="1" get="inline" set="null" line="7" static="1"><c path="String"/></IMG_BUTTON_ARROW_DOWN>
		<IMG_BUTTON_ARROW_LEFT public="1" get="inline" set="null" line="8" static="1"><c path="String"/></IMG_BUTTON_ARROW_LEFT>
		<IMG_BUTTON_ARROW_RIGHT public="1" get="inline" set="null" line="9" static="1"><c path="String"/></IMG_BUTTON_ARROW_RIGHT>
		<IMG_BUTTON_ARROW_UP public="1" get="inline" set="null" line="10" static="1"><c path="String"/></IMG_BUTTON_ARROW_UP>
		<IMG_BUTTON_THIN public="1" get="inline" set="null" line="11" static="1"><c path="String"/></IMG_BUTTON_THIN>
		<IMG_BUTTON_TOGGLE public="1" get="inline" set="null" line="12" static="1"><c path="String"/></IMG_BUTTON_TOGGLE>
		<IMG_BUTTON_SIZE public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></IMG_BUTTON_SIZE>
		<IMG_CHECK_MARK public="1" get="inline" set="null" line="16" static="1"><c path="String"/></IMG_CHECK_MARK>
		<IMG_CHECK_BOX public="1" get="inline" set="null" line="17" static="1"><c path="String"/></IMG_CHECK_BOX>
		<IMG_CHROME public="1" get="inline" set="null" line="18" static="1"><c path="String"/></IMG_CHROME>
		<IMG_CHROME_LIGHT public="1" get="inline" set="null" line="19" static="1"><c path="String"/></IMG_CHROME_LIGHT>
		<IMG_CHROME_FLAT public="1" get="inline" set="null" line="20" static="1"><c path="String"/></IMG_CHROME_FLAT>
		<IMG_CHROME_INSET public="1" get="inline" set="null" line="21" static="1"><c path="String"/></IMG_CHROME_INSET>
		<IMG_RADIO public="1" get="inline" set="null" line="22" static="1"><c path="String"/></IMG_RADIO>
		<IMG_RADIO_DOT public="1" get="inline" set="null" line="23" static="1"><c path="String"/></IMG_RADIO_DOT>
		<IMG_TAB public="1" get="inline" set="null" line="24" static="1"><c path="String"/></IMG_TAB>
		<IMG_TAB_BACK public="1" get="inline" set="null" line="25" static="1"><c path="String"/></IMG_TAB_BACK>
		<IMG_BOX public="1" get="inline" set="null" line="26" static="1"><c path="String"/></IMG_BOX>
		<IMG_DROPDOWN public="1" get="inline" set="null" line="27" static="1"><c path="String"/></IMG_DROPDOWN>
		<IMG_PLUS public="1" get="inline" set="null" line="28" static="1"><c path="String"/></IMG_PLUS>
		<IMG_MINUS public="1" get="inline" set="null" line="29" static="1"><c path="String"/></IMG_MINUS>
		<IMG_HILIGHT public="1" get="inline" set="null" line="30" static="1"><c path="String"/></IMG_HILIGHT>
		<IMG_INVIS public="1" get="inline" set="null" line="31" static="1"><c path="String"/></IMG_INVIS>
		<IMG_SWATCH public="1" get="inline" set="null" line="32" static="1"><c path="String"/></IMG_SWATCH>
		<IMG_FINGER_SMALL public="1" get="inline" set="null" line="34" static="1"><c path="String"/></IMG_FINGER_SMALL>
		<IMG_FINGER_BIG public="1" get="inline" set="null" line="35" static="1"><c path="String"/></IMG_FINGER_BIG>
		<SLICE9_BUTTON public="1" get="inline" set="null" line="38" static="1"><c path="String"/></SLICE9_BUTTON>
		<SLICE9_BUTTON_THIN public="1" get="inline" set="null" line="39" static="1"><c path="String"/></SLICE9_BUTTON_THIN>
		<SLICE9_BUTTON_TOGGLE public="1" get="inline" set="null" line="40" static="1"><c path="String"/></SLICE9_BUTTON_TOGGLE>
		<SLICE9_TAB public="1" get="inline" set="null" line="41" static="1"><c path="String"/></SLICE9_TAB>
		<XML_DEFAULTS_ID public="1" get="inline" set="null" line="44" static="1"><c path="String"/></XML_DEFAULTS_ID>
		<XML_DEFAULT_POPUP_ID public="1" get="inline" set="null" line="45" static="1"><c path="String"/></XML_DEFAULT_POPUP_ID>
		<XML_DEFAULT_LOADING_SCREEN_ID public="1" get="inline" set="null" line="46" static="1"><c path="String"/></XML_DEFAULT_LOADING_SCREEN_ID>
		<index_size public="1" line="48" static="1"><x path="Map">
	<c path="String"/>
	<c path="Array"><x path="Float"/></c>
</x></index_size>
	</class>
	<class path="flixel.ui.FlxTypedButton" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxTypedButton.hx">
		<extends path="flixel.FlxSprite"/>
		<label public="1" set="accessor">
			<c path="flixel.ui.FlxTypedButton.T"/>
			<haxe_doc>* The label that appears on the button. Can be any FlxSprite.</haxe_doc>
		</label>
		<labelOffsets public="1">
			<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			<haxe_doc>* What offsets the label should have for each status.</haxe_doc>
		</labelOffsets>
		<labelAlphas public="1">
			<c path="Array"><x path="Float"/></c>
			<haxe_doc>* What alpha value the label should have for each status. Default is [0.8, 1.0, 0.5].</haxe_doc>
		</labelAlphas>
		<allowSwiping public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether you can press the button simply by releasing the touch / mouse button over it (default).
	 * If false, the input has to be pressed while hovering over the button.</haxe_doc>
		</allowSwiping>
		<allowHighlightOnMobile public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to allow the HIHGLIGHT frame of the button graphic to be used on mobile 
	 * (false by default, the NORMAL graphic is used instead then).</haxe_doc>
		</allowHighlightOnMobile>
		<status public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Shows the current state of the button, either FlxButton.NORMAL, 
	 * FlxButton.HIGHLIGHT or FlxButton.PRESSED.</haxe_doc>
		</status>
		<onUp public="1" set="null">
			<c path="flixel.ui._FlxTypedButton.FlxButtonEvent"/>
			<haxe_doc>* The properties of this button's onUp event (callback function, sound).</haxe_doc>
		</onUp>
		<onDown public="1" set="null">
			<c path="flixel.ui._FlxTypedButton.FlxButtonEvent"/>
			<haxe_doc>* The properties of this button's onDown event (callback function, sound).</haxe_doc>
		</onDown>
		<onOver public="1" set="null">
			<c path="flixel.ui._FlxTypedButton.FlxButtonEvent"/>
			<haxe_doc>* The properties of this button's onOver event (callback function, sound).</haxe_doc>
		</onOver>
		<onOut public="1" set="null">
			<c path="flixel.ui._FlxTypedButton.FlxButtonEvent"/>
			<haxe_doc>* The properties of this button's onOut event (callback function, sound).</haxe_doc>
		</onOut>
		<_pressedTouch>
			<c path="flixel.input.touch.FlxTouch"/>
			<haxe_doc>* The touch currently pressing this button, if none, it's null. Needed to check for its release.</haxe_doc>
		</_pressedTouch>
		<_pressedMouse>
			<x path="Bool"/>
			<haxe_doc>* Whether this button is currently being pressed by the mouse. Needed to check for its release.</haxe_doc>
		</_pressedMouse>
		<destroy public="1" set="method" line="108" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game state when state is changed (if this object belongs to the state)</haxe_doc>
		</destroy>
		<update public="1" set="method" line="132" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game loop automatically, handles mouseover and click detection.</haxe_doc>
		</update>
		<draw public="1" set="method" line="163" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just draws the button graphic and text label to the screen.</haxe_doc>
		</draw>
		<drawDebug public="1" set="method" line="178" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Helper function to draw the debug graphic for the label as well.</haxe_doc>
		</drawDebug>
		<updateButton set="method" line="193">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Basic button update logic - searches for overlaps with touches and
	 * the mouse cursor and calls updateStatus()</haxe_doc>
		</updateButton>
		<updateStatus set="method" line="241">
			<f a="Overlap:JustPressed:Pressed:?Touch" v=":::null">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates the button status by calling the respective event handler function.
	 * 
	 * @param	Overlap			Whether there was any overlap with this button
	 * @param	JustPressed		Whether the input (touch or mouse) was just pressed
	 * @param	Pressed			Whether the input (touch or mouse) is pressed
	 * @param	Touch			A FlxTouch, if this was called from an overlap with one</haxe_doc>
		</updateStatus>
		<onUpEventListener set="method" line="286">
			<f a="E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Using an event listener is necessary for security reasons on flash - 
	 * certain things like opening a new window are only allowed when they are user-initiated.</haxe_doc>
		</onUpEventListener>
		<onUpHandler set="method" line="298">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function that handles the onUp event.</haxe_doc>
		</onUpHandler>
		<onDownHandler set="method" line="310">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function that handles the onDown event.</haxe_doc>
		</onDownHandler>
		<onOverHandler set="method" line="320">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function that handles the onOver event.</haxe_doc>
		</onOverHandler>
		<onOutHandler set="method" line="330">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function that handles the onOut event.</haxe_doc>
		</onOutHandler>
		<set_label set="method" line="337"><f a="Value">
	<c path="flixel.ui.FlxTypedButton.T"/>
	<c path="flixel.ui.FlxTypedButton.T"/>
</f></set_label>
		<set_status set="method" line="348"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_status>
		<set_x set="method" line="357" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="368" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<new public="1" set="method" line="81">
			<f a="?X:?Y:?OnClick" v="0:0:null">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxTypedButton object with a gray background.
	 * 
	 * @param	X			The X position of the button.
	 * @param	Y			The Y position of the button.
	 * @param	OnClick		The function to call whenever the button is clicked.</haxe_doc>
		</new>
		<haxe_doc>* A simple button class that calls a function when clicked by the mouse.</haxe_doc>
	</class>
	<class path="flixel.addons.ui.interfaces.ICursorPointable" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/interfaces/ICursorPointable.hx" interface="1"><haxe_doc>* The cursor can point to one of these
 * @author Lars Doucet</haxe_doc></class>
	<class path="flixel.addons.ui.interfaces.IHasParams" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/interfaces/IHasParams.hx" interface="1">
		<params public="1" set="accessor"><c path="Array"><d/></c></params>
		<set_params set="method"><f a="p">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_params>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.interfaces.IFlxUIClickable" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/interfaces/IFlxUIClickable.hx" interface="1">
		<skipButtonUpdate public="1" set="accessor"><x path="Bool"/></skipButtonUpdate>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUITypedButton" params="T" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUITypedButton.hx">
		<extends path="flixel.ui.FlxTypedButton"><c path="flixel.addons.ui.FlxUITypedButton.T"/></extends>
		<implements path="flixel.addons.ui.interfaces.ICursorPointable"/>
		<implements path="flixel.addons.ui.interfaces.IHasParams"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIClickable"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<implements path="flixel.addons.ui.interfaces.IResizable"/>
		<CLICK_EVENT public="1" get="inline" set="null" line="56" static="1"><c path="String"/></CLICK_EVENT>
		<OVER_EVENT public="1" get="inline" set="null" line="57" static="1"><c path="String"/></OVER_EVENT>
		<DOWN_EVENT public="1" get="inline" set="null" line="58" static="1"><c path="String"/></DOWN_EVENT>
		<OUT_EVENT public="1" get="inline" set="null" line="59" static="1"><c path="String"/></OUT_EVENT>
		<id public="1"><c path="String"/></id>
		<resize_ratio public="1"><x path="Float"/></resize_ratio>
		<resize_point public="1"><c path="flixel.util.FlxPoint"/></resize_point>
		<tile public="1"><x path="Int"/></tile>
		<has_toggle public="1"><x path="Bool"/></has_toggle>
		<toggled public="1"><x path="Bool"/></toggled>
		<broadcastToFlxUI public="1"><x path="Bool"/></broadcastToFlxUI>
		<up_color public="1"><x path="Int"/></up_color>
		<over_color public="1"><x path="Int"/></over_color>
		<down_color public="1"><x path="Int"/></down_color>
		<up_toggle_color public="1"><x path="Int"/></up_toggle_color>
		<over_toggle_color public="1"><x path="Int"/></over_toggle_color>
		<down_toggle_color public="1"><x path="Int"/></down_toggle_color>
		<up_visible public="1"><x path="Bool"/></up_visible>
		<over_visible public="1"><x path="Bool"/></over_visible>
		<down_visible public="1"><x path="Bool"/></down_visible>
		<up_toggle_visible public="1"><x path="Bool"/></up_toggle_visible>
		<over_toggle_visible public="1"><x path="Bool"/></over_toggle_visible>
		<down_toggle_visible public="1"><x path="Bool"/></down_toggle_visible>
		<round_labels public="1"><x path="Bool"/></round_labels>
		<skipButtonUpdate public="1" set="accessor"><x path="Bool"/></skipButtonUpdate>
		<set_skipButtonUpdate set="method" line="62"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_skipButtonUpdate>
		<params public="1" set="accessor"><c path="Array"><d/></c></params>
		<set_params set="method" line="68"><f a="p">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_params>
		<destroy public="1" set="method" line="73" override="1"><f a=""><x path="Void"/></f></destroy>
		<setAllLabelOffsets public="1" set="method" line="112">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set all 3 sets of labelOffsets at once
	 * @param	X
	 * @param	Y</haxe_doc>
		</setAllLabelOffsets>
		<update public="1" set="method" line="117" override="1"><f a=""><x path="Void"/></f></update>
		<resize public="1" set="method" line="144"><f a="W:H">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<loadGraphicsMultiple public="1" set="method" line="193">
			<f a="assets:?Key" v=":''">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Provide a list of assets, load states from each one
	 * @param	assets
	 * @param   key string key for caching (optional)</haxe_doc>
		</loadGraphicsMultiple>
		<loadGraphicsUpOverDown public="1" set="method" line="232">
			<f a="asset:?for_toggle:?key" v=":false:null">
				<d/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Provide one combined asset, load all 3 state frames from it and infer the width/height
	 * @param	asset graphic to load
	 * @param   for_toggle whether this is for a toggle button or not
	 * @param   key string key for caching (optional)</haxe_doc>
		</loadGraphicsUpOverDown>
		<loadGraphicSlice9 public="1" set="method" line="293">
			<f a="?assets:?W:?H:?slice9:?Tile:?Resize_Ratio:?isToggle:?src_w:?src_h:?frame_indeces" v="null:80:20:null:0:-1:false:0:0:null">
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Graphics chopping functions</haxe_doc>
		</loadGraphicSlice9>
		<autoCenterLabel public="1" set="method" line="511">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets labelOffset to center the label horizontally and vertically</haxe_doc>
		</autoCenterLabel>
		<setCenterLabelOffset public="1" set="method" line="536"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setCenterLabelOffset>
		<forceStateHandler public="1" set="method" line="541"><f a="event">
	<c path="String"/>
	<x path="Void"/>
</f></forceStateHandler>
		<grabButtonFrame public="1" set="method" line="566">
			<f a="all_frames:button_state:?for_toggle:?src_w:?src_h" v="::false:0:0">
				<c path="flash.display.BitmapData"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>*UTILITY FUNCTIONS*</haxe_doc>
		</grabButtonFrame>
		<combineToggleBitmaps public="1" set="method" line="595">
			<f a="normal:toggle">
				<c path="flash.display.BitmapData"/>
				<c path="flash.display.BitmapData"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Combines two stacked button images for a toggle button
	 * @param	normal
	 * @param	toggle
	 * @return</haxe_doc>
		</combineToggleBitmaps>
		<assembleButtonFrames public="1" set="method" line="615">
			<f a="upB:overB:downB">
				<c path="flash.display.BitmapData"/>
				<c path="flash.display.BitmapData"/>
				<c path="flash.display.BitmapData"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Give me three bitmapdatas and I'll return an assembled button bitmapdata for you.
	 * If overB or downB are missing, it will not include those frames.
	 * @param	upB
	 * @param	overB
	 * @param	downB
	 * @return</haxe_doc>
		</assembleButtonFrames>
		<updateButton public="1" set="method" line="643" override="1"><f a=""><x path="Void"/></f></updateButton>
		<onUpHandler set="method" line="649" override="1"><f a=""><x path="Void"/></f></onUpHandler>
		<onDownHandler set="method" line="664" override="1"><f a=""><x path="Void"/></f></onDownHandler>
		<onOverHandler set="method" line="676" override="1"><f a=""><x path="Void"/></f></onOverHandler>
		<onOutHandler set="method" line="688" override="1"><f a=""><x path="Void"/></f></onOutHandler>
		<set_x set="method" line="700" override="1"><f a="NewX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="716" override="1"><f a="NewY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<_no_graphic>
			<x path="Bool"/>
			<haxe_doc>*******PRIVATE**********</haxe_doc>
		</_no_graphic>
		<_src_w><x path="Int"/></_src_w>
		<_src_h><x path="Int"/></_src_h>
		<_frame_indeces><c path="Array"><x path="Int"/></c></_frame_indeces>
		<_slice9_arrays><c path="Array"><c path="Array"><x path="Int"/></c></c></_slice9_arrays>
		<_slice9_assets><c path="Array"><c path="String"/></c></_slice9_assets>
		<_centerLabelOffset><c path="flixel.util.FlxPoint"/></_centerLabelOffset>
		<new public="1" set="method" line="85">
			<f a="?X:?Y:?OnClick" v="0:0:null">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxUITypedButton object with a gray background.
	 * 
	 * @param	X			The X position of the button.
	 * @param	Y			The Y position of the button.
	 * @param	OnClick		The function to call whenever the button is clicked.</haxe_doc>
		</new>
	</class>
	<class path="flixel.addons.ui.interfaces.IFlxUIButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/interfaces/IFlxUIButton.hx" interface="1">
		<extends path="flixel.interfaces.IFlxDestroyable"/>
		<extends path="flixel.addons.ui.interfaces.IHasParams"/>
		<extends path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<up_color public="1"><x path="Int"/></up_color>
		<over_color public="1"><x path="Int"/></over_color>
		<down_color public="1"><x path="Int"/></down_color>
		<up_toggle_color public="1"><x path="Int"/></up_toggle_color>
		<over_toggle_color public="1"><x path="Int"/></over_toggle_color>
		<down_toggle_color public="1"><x path="Int"/></down_toggle_color>
		<up_visible public="1"><x path="Bool"/></up_visible>
		<over_visible public="1"><x path="Bool"/></over_visible>
		<down_visible public="1"><x path="Bool"/></down_visible>
		<up_toggle_visible public="1"><x path="Bool"/></up_toggle_visible>
		<over_toggle_visible public="1"><x path="Bool"/></over_toggle_visible>
		<down_toggle_visible public="1"><x path="Bool"/></down_toggle_visible>
		<resize_ratio public="1"><x path="Float"/></resize_ratio>
		<resize_point public="1"><c path="flixel.util.FlxPoint"/></resize_point>
		<autoCenterLabel public="1" set="method"><f a=""><x path="Void"/></f></autoCenterLabel>
		<loadGraphicSlice9 public="1" set="method"><f a="?assets:?W:?H:?slice9:?Tile:?Resize_Ratio:?isToggle:?src_w:?src_h:?frame_indeces">
	<c path="Array"><c path="String"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="Array"><x path="Int"/></c></c>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></loadGraphicSlice9>
		<loadGraphicsMultiple public="1" set="method"><f a="assets:?Key">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></loadGraphicsMultiple>
		<loadGraphicsUpOverDown public="1" set="method"><f a="asset:?for_toggle:?key">
	<d/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></loadGraphicsUpOverDown>
		<forceStateHandler public="1" set="method"><f a="event">
	<c path="String"/>
	<x path="Void"/>
</f></forceStateHandler>
		<haxe_doc>* This interface keeps me from having to use a Dynamic variable to point to a value holding a FlxUITypedButton 
 * that could be either a FlxUIButton or a FlxUISpriteButton
 * @author larsiusprime</haxe_doc>
	</class>
	<class path="flixel.addons.ui.interfaces.ILabeled" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/interfaces/ILabeled.hx" interface="1">
		<getLabel public="1" set="method"><f a=""><c path="flixel.addons.ui.FlxUIText"/></f></getLabel>
		<setLabel public="1" set="method"><f a="t">
	<c path="flixel.addons.ui.FlxUIText"/>
	<c path="flixel.addons.ui.FlxUIText"/>
</f></setLabel>
		<haxe_doc>* ...
 * @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIButton.hx">
		<extends path="flixel.addons.ui.FlxUITypedButton"><c path="flixel.addons.ui.FlxUIText"/></extends>
		<implements path="flixel.addons.ui.interfaces.IFlxUIButton"/>
		<implements path="flixel.addons.ui.interfaces.ILabeled"/>
		<_noIconGraphicsBkup><c path="flash.display.BitmapData"/></_noIconGraphicsBkup>
		<up_style public="1"><c path="flixel.addons.ui.ButtonLabelStyle"/></up_style>
		<over_style public="1"><c path="flixel.addons.ui.ButtonLabelStyle"/></over_style>
		<down_style public="1"><c path="flixel.addons.ui.ButtonLabelStyle"/></down_style>
		<up_toggle_style public="1"><c path="flixel.addons.ui.ButtonLabelStyle"/></up_toggle_style>
		<over_toggle_style public="1"><c path="flixel.addons.ui.ButtonLabelStyle"/></over_toggle_style>
		<down_toggle_style public="1"><c path="flixel.addons.ui.ButtonLabelStyle"/></down_toggle_style>
		<setLabel public="1" set="method" line="59">
			<f a="t">
				<c path="flixel.addons.ui.FlxUIText"/>
				<c path="flixel.addons.ui.FlxUIText"/>
			</f>
			<haxe_doc>For ILabeled:</haxe_doc>
		</setLabel>
		<getLabel public="1" set="method" line="60"><f a=""><c path="flixel.addons.ui.FlxUIText"/></f></getLabel>
		<resize public="1" set="method" line="64" override="1">
			<f a="W:H">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>For IResizable:</haxe_doc>
		</resize>
		<addIcon public="1" set="method" line="72"><f a="icon:?X:?Y:?center" v=":0:0:true">
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addIcon>
		<removeIcon public="1" set="method" line="92"><f a=""><x path="Void"/></f></removeIcon>
		<changeIcon public="1" set="method" line="107"><f a="newIcon">
	<c path="flixel.FlxSprite"/>
	<x path="Void"/>
</f></changeIcon>
		<destroy public="1" set="method" line="113" override="1"><f a=""><x path="Void"/></f></destroy>
		<resetHelpers set="method" line="124" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>********PRIVATE*******</haxe_doc>
		</resetHelpers>
		<onDownHandler set="method" line="136" override="1"><f a=""><x path="Void"/></f></onDownHandler>
		<onOverHandler set="method" line="160" override="1"><f a=""><x path="Void"/></f></onOverHandler>
		<onOutHandler set="method" line="184" override="1"><f a=""><x path="Void"/></f></onOutHandler>
		<onUpHandler set="method" line="208" override="1"><f a=""><x path="Void"/></f></onUpHandler>
		<new public="1" set="method" line="46">
			<f a="?X:?Y:?Label:?OnClick" v="0:0:null:null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxUIButton.
	 * 
	 * @param	X			The X position of the button.
	 * @param	Y			The Y position of the button.
	 * @param	Label		The text that you want to appear on the button.
	 * @param	OnClick		The function to call whenever the button is clicked.</haxe_doc>
		</new>
		<haxe_doc>* This class extends FlxUITypedButton and has a Text label, and is thus
 * most analagous to the regular FlxButton
 * 
 * Like all FlxUITypedButton's, it can work as a toggle button, and load
 * 9-slice sprites for its button images, and be dynamically resized 
 * accordingly.
 * 
 * Furthermore, you have the ability to set the text's coloring for each
 * state just by adjusting a few public variables</haxe_doc>
	</class>
	<class path="flixel.addons.ui.ButtonLabelStyle" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIButton.hx" module="flixel.addons.ui.FlxUIButton">
		<font public="1"><c path="flixel.addons.ui.FontDef"/></font>
		<border public="1"><c path="flixel.addons.ui.BorderDef"/></border>
		<color public="1"><t path="Null"><x path="Int"/></t></color>
		<align public="1"><c path="String"/></align>
		<apply public="1" set="method" line="247"><f a="f">
	<c path="flixel.text.FlxText"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="240"><f a="?Font:?Align:?Color:?Border" v="null:null:null:null">
	<c path="flixel.addons.ui.FontDef"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="flixel.addons.ui.BorderDef"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.addons.ui.FlxUICheckBox" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUICheckBox.hx">
		<extends path="flixel.addons.ui.FlxUIGroup"/>
		<implements path="flixel.addons.ui.interfaces.ICursorPointable"/>
		<implements path="flixel.addons.ui.interfaces.IHasParams"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIClickable"/>
		<implements path="flixel.addons.ui.interfaces.ILabeled"/>
		<CLICK_EVENT public="1" get="inline" set="null" line="41" static="1"><c path="String"/></CLICK_EVENT>
		<box public="1"><c path="flixel.FlxSprite"/></box>
		<mark public="1"><c path="flixel.FlxSprite"/></mark>
		<button public="1"><c path="flixel.addons.ui.FlxUIButton"/></button>
		<max_width public="1"><x path="Float"/></max_width>
		<checked public="1" set="accessor"><x path="Bool"/></checked>
		<params public="1" set="accessor"><c path="Array"><d/></c></params>
		<textIsClickable public="1"><x path="Bool"/></textIsClickable>
		<checkbox_dirty public="1"><x path="Bool"/></checkbox_dirty>
		<textX public="1" set="accessor"><x path="Float"/></textX>
		<textY public="1" set="accessor"><x path="Float"/></textY>
		<box_space public="1"><x path="Float"/></box_space>
		<skipButtonUpdate public="1" set="accessor"><x path="Bool"/></skipButtonUpdate>
		<callback public="1"><f a=""><x path="Void"/></f></callback>
		<set_skipButtonUpdate set="method" line="43"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_skipButtonUpdate>
		<set_params set="method" line="48"><f a="p">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_params>
		<set_color set="method" line="59" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<setLabel public="1" set="method" line="136">
			<f a="t">
				<c path="flixel.addons.ui.FlxUIText"/>
				<c path="flixel.addons.ui.FlxUIText"/>
			</f>
			<haxe_doc>For ILabeled:</haxe_doc>
		</setLabel>
		<getLabel public="1" set="method" line="137"><f a=""><c path="flixel.addons.ui.FlxUIText"/></f></getLabel>
		<set_visible set="method" line="139" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<anchorTime set="method" line="146"><f a="f">
	<c path="flixel.util.FlxTimer"/>
	<x path="Void"/>
</f></anchorTime>
		<set_textX set="method" line="150"><f a="n">
	<x path="Float"/>
	<x path="Float"/>
</f></set_textX>
		<set_textY set="method" line="156"><f a="n">
	<x path="Float"/>
	<x path="Float"/>
</f></set_textY>
		<anchorLabelX public="1" set="method" line="162"><f a=""><x path="Void"/></f></anchorLabelX>
		<anchorLabelY public="1" set="method" line="168"><f a=""><x path="Void"/></f></anchorLabelY>
		<destroy public="1" set="method" line="174" override="1"><f a=""><x path="Void"/></f></destroy>
		<text public="1" get="accessor" set="accessor"><c path="String"/></text>
		<get_text set="method" line="192"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="193"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<update public="1" set="method" line="200" override="1"><f a=""><x path="Void"/></f></update>
		<set_checked set="method" line="219">
			<f a="b">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>***GETTER/SETTER*</haxe_doc>
		</set_checked>
		<_clickCheck set="method" line="226">
			<f a=""><x path="Void"/></f>
			<haxe_doc>***PRIVATE****</haxe_doc>
		</_clickCheck>
		<new public="1" set="method" line="67"><f a="?X:?Y:?Box:?Check:?Label:?LabelW:?Params:?Callback" v="0:0:null:null:null:100:null:null">
	<x path="Float"/>
	<x path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIColorSwatch" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIColorSwatch.hx">
		<extends path="flixel.addons.ui.FlxUIButton"/>
		<CLICK_EVENT public="1" get="inline" set="null" line="27" static="1"><c path="String"/></CLICK_EVENT>
		<multiColored public="1" set="accessor"><x path="Bool"/></multiColored>
		<hilight public="1" set="accessor"><x path="Int"/></hilight>
		<midtone public="1" set="accessor"><x path="Int"/></midtone>
		<shadowMid public="1" set="accessor"><x path="Int"/></shadowMid>
		<shadowDark public="1" set="accessor"><x path="Int"/></shadowDark>
		<colors public="1" set="accessor"><c path="flixel.addons.ui.SwatchData"/></colors>
		<callback public="1"><f a=""><x path="Void"/></f></callback>
		<set_color set="method" line="31" override="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>SETTERS</haxe_doc>
		</set_color>
		<destroy public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></destroy>
		<setColorAtIndex public="1" set="method" line="49">
			<f a="Color:index">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a color at a specific index in the swatch
	 * @param	Color
	 * @param	index</haxe_doc>
		</setColorAtIndex>
		<set_colors set="method" line="62"><f a="Colors">
	<c path="flixel.addons.ui.SwatchData"/>
	<c path="flixel.addons.ui.SwatchData"/>
</f></set_colors>
		<set_multiColored set="method" line="87">
			<f a="b">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* If true, the swatch will draw itself dynamically based on the four colors provided</haxe_doc>
		</set_multiColored>
		<set_hilight set="method" line="93"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_hilight>
		<set_midtone set="method" line="100"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_midtone>
		<set_shadowMid set="method" line="107"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_shadowMid>
		<set_shadowDark set="method" line="114"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_shadowDark>
		<equalsSwatch public="1" set="method" line="163"><f a="swatch">
	<c path="flixel.addons.ui.SwatchData"/>
	<x path="Bool"/>
</f></equalsSwatch>
		<getRawDifferenceSwatch public="1" set="method" line="167"><f a="swatch">
	<c path="flixel.addons.ui.SwatchData"/>
	<x path="Int"/>
</f></getRawDifferenceSwatch>
		<refreshColor public="1" set="method" line="171"><f a=""><x path="Void"/></f></refreshColor>
		<_origKey><c path="String"/></_origKey>
		<_skipRefresh><x path="Bool"/></_skipRefresh>
		<onClick set="method" line="272"><f a=""><x path="Void"/></f></onClick>
		<colorKey public="1" set="method" line="286"><f a=""><c path="String"/></f></colorKey>
		<new public="1" set="method" line="131">
			<f a="X:Y:?Color:?Colors:?Asset:?Callback:?Width:?Height" v="::16777215:null:null:null:-1:-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="flixel.addons.ui.SwatchData"/>
				<d/>
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new color swatch that can store and display a color value
	 * @param	X
	 * @param	Y
	 * @param	?Color			Single color for the swatch
	 * @param	?Colors			Multiple colors for the swatch
	 * @param	?Asset			An asset for the swatch graphic (optional)
	 * @param	?Callback		Function to call when clicked</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIColorSwatchSelecter" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIColorSwatchSelecter.hx">
		<extends path="flixel.addons.ui.FlxUIGroup"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIClickable"/>
		<CLICK_EVENT public="1" get="inline" set="null" line="13" static="1"><c path="String"/></CLICK_EVENT>
		<spacingH public="1" set="accessor"><x path="Float"/></spacingH>
		<spacingV public="1" set="accessor"><x path="Float"/></spacingV>
		<maxColumns public="1" set="accessor"><x path="Float"/></maxColumns>
		<set_spacingH set="method" line="19"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_spacingH>
		<set_spacingV set="method" line="25"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_spacingV>
		<set_maxColumns set="method" line="31"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxColumns>
		<skipButtonUpdate public="1" set="accessor"><x path="Bool"/></skipButtonUpdate>
		<set_skipButtonUpdate set="method" line="38"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_skipButtonUpdate>
		<update public="1" set="method" line="144" override="1"><f a=""><x path="Void"/></f></update>
		<updateLayout public="1" set="method" line="152"><f a=""><x path="Void"/></f></updateLayout>
		<changeColors public="1" set="method" line="184"><f a="list">
	<c path="Array"><c path="flixel.addons.ui.SwatchData"/></c>
	<x path="Void"/>
</f></changeColors>
		<selectedSwatch public="1" get="accessor" set="null"><c path="flixel.addons.ui.FlxUIColorSwatch"/></selectedSwatch>
		<get_selectedSwatch set="method" line="256"><f a=""><c path="flixel.addons.ui.FlxUIColorSwatch"/></f></get_selectedSwatch>
		<destroyed><x path="Bool"/></destroyed>
		<destroy public="1" set="method" line="260" override="1"><f a=""><x path="Void"/></f></destroy>
		<selectCallback set="method" line="267"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></selectCallback>
		<selectByIndex public="1" set="method" line="280"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></selectByIndex>
		<selectByColor public="1" set="method" line="285"><f a="Color">
	<x path="Int"/>
	<x path="Void"/>
</f></selectByColor>
		<selectByColors public="1" set="method" line="300"><f a="Data:?PickClosest" v=":true">
	<c path="flixel.addons.ui.SwatchData"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></selectByColors>
		<selectByName public="1" set="method" line="332"><f a="Name">
	<c path="String"/>
	<x path="Void"/>
</f></selectByName>
		<unselect public="1" set="method" line="347"><f a=""><x path="Void"/></f></unselect>
		<updateSelected set="method" line="352"><f a=""><x path="Void"/></f></updateSelected>
		<_selectedSwatch><c path="flixel.addons.ui.FlxUIColorSwatch"/></_selectedSwatch>
		<_selectionSprite><c path="flixel.FlxSprite"/></_selectionSprite>
		<_dirtyLayout><x path="Bool"/></_dirtyLayout>
		<new public="1" set="method" line="65">
			<f a="X:Y:?SelectionSprite:?list_colors:?list_data:?list_swatches:?SpacingH:?SpacingV:?MaxColumns" v="::null:null:null:null:2:2:-1">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxSprite"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><c path="flixel.addons.ui.SwatchData"/></c>
				<c path="Array"><c path="flixel.addons.ui.FlxUIColorSwatch"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A handy little group for selecting color swatches from
	 * @param	X					X location
	 * @param	Y					Y location
	 * @param	?SelectionSprite	The selection box sprite (optional, auto-generated if not supplied)
	 * @param	?list_colors		A list of single-colors to generate swatches from. 1st of 3 alternatives.
	 * @param	?list_data			A list of swatch data to generate swatches from. 2nd of 3 alternatives.
	 * @param	?list_swatches		A list of the actual swatch widgets themselves. 3rd of 3 alternatives.
	 * @param	SpacingH			Horizontal spacing between swatches
	 * @param	SpacingV			Vertical spacing between swatches
	 * @param	MaxColumns			Number of horizontal swatches in a row before a line break</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author larsiusprime</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUICursor" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUICursor.hx">
		<extends path="flixel.addons.ui.FlxUISprite"/>
		<KEYS_DEFAULT_TAB public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></KEYS_DEFAULT_TAB>
		<KEYS_DEFAULT_WASD public="1" get="inline" set="null" line="49" static="1"><x path="Int"/></KEYS_DEFAULT_WASD>
		<KEYS_DEFAULT_ARROWS public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></KEYS_DEFAULT_ARROWS>
		<KEYS_DEFAULT_NUMPAD public="1" get="inline" set="null" line="51" static="1"><x path="Int"/></KEYS_DEFAULT_NUMPAD>
		<INPUT_NONE public="1" get="inline" set="null" line="61" static="1"><x path="Int"/></INPUT_NONE>
		<INPUT_KEYS public="1" get="inline" set="null" line="62" static="1"><x path="Int"/></INPUT_KEYS>
		<INPUT_GAMEPAD public="1" get="inline" set="null" line="63" static="1"><x path="Int"/></INPUT_GAMEPAD>
		<callback public="1"><f a=":">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Void"/>
</f></callback>
		<wrap public="1"><x path="Bool"/></wrap>
		<location public="1" set="accessor"><x path="Int"/></location>
		<set_location set="method" line="29"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_location>
		<keysUp public="1"><c path="Array"><c path="flixel.addons.ui.MultiKey"/></c></keysUp>
		<keysDown public="1"><c path="Array"><c path="flixel.addons.ui.MultiKey"/></c></keysDown>
		<keysLeft public="1"><c path="Array"><c path="flixel.addons.ui.MultiKey"/></c></keysLeft>
		<keysRight public="1"><c path="Array"><c path="flixel.addons.ui.MultiKey"/></c></keysRight>
		<keysClick public="1"><c path="Array"><c path="flixel.addons.ui.MultiKey"/></c></keysClick>
		<anchor public="1"><c path="flixel.addons.ui.Anchor"/></anchor>
		<dispatchEvents public="1"><x path="Bool"/></dispatchEvents>
		<inputMethod public="1"><x path="Int"/></inputMethod>
		<destroy public="1" set="method" line="104" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="132" override="1"><f a=""><x path="Void"/></f></update>
		<addWidget public="1" set="method" line="137"><f a="widget">
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Void"/>
</f></addWidget>
		<removeWidget public="1" set="method" line="157"><f a="widget">
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Bool"/>
</f></removeWidget>
		<setDefaultKeys public="1" set="method" line="173">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the default key layout quickly using a constant. 
	 * @param	code	KEYS_DEFAULT_TAB, ..._WASD, etc, combine with "|" operator</haxe_doc>
		</setDefaultKeys>
		<_widgets>
			<c path="Array"><c path="flixel.addons.ui.interfaces.IFlxUIWidget"/></c>
			<haxe_doc>**PRIVATE**</haxe_doc>
		</_widgets>
		<_newMouse><c path="flixel.addons.ui.FlxUIMouse"/></_newMouse>
		<_clickPressed><x path="Bool"/></_clickPressed>
		<_sortXY set="method" line="210"><f a="a:b">
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Int"/>
</f></_sortXY>
		<_addToKeys set="method" line="218"><f a="keys:m">
	<c path="Array"><c path="flixel.addons.ui.MultiKey"/></c>
	<c path="flixel.addons.ui.MultiKey"/>
	<x path="Void"/>
</f></_addToKeys>
		<_clearKeys set="method" line="232"><f a=""><x path="Void"/></f></_clearKeys>
		<_newKeys set="method" line="240"><f a=""><x path="Void"/></f></_newKeys>
		<_checkKeys set="method" line="248"><f a=""><x path="Void"/></f></_checkKeys>
		<_getWidgetPoint set="method" line="297"><f a=""><c path="flixel.util.FlxPoint"/></f></_getWidgetPoint>
		<_doMouseMove set="method" line="324"><f a="?pt" v="null">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></_doMouseMove>
		<_doPress set="method" line="358"><f a="?pt" v="null">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></_doPress>
		<_doRelease set="method" line="390"><f a="?pt" v="null">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></_doRelease>
		<_doInput set="method" line="433"><f a="X:Y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_doInput>
		<_updateCursor set="method" line="551"><f a=""><x path="Void"/></f></_updateCursor>
		<new public="1" set="method" line="75">
			<f a="Callback:?InputMethod:?DefaultKeys:?Asset" v=":1:1:null">
				<f a=":">
					<c path="String"/>
					<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>*****************************</haxe_doc>
		</new>
		<haxe_doc>* Cursor object that you can use to "click" on interface elements using a keyboard or gamepad
 * TODO: need to support gamepad and/or deal with absence of mouse
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIDropDownMenu" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIDropDownMenu.hx">
		<extends path="flixel.addons.ui.FlxUIGroup"/>
		<implements path="flixel.addons.ui.interfaces.IHasParams"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIClickable"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<CLICK_EVENT public="1" get="inline" set="null" line="94" static="1"><c path="String"/></CLICK_EVENT>
		<makeStrIdLabelArray public="1" set="method" line="374" static="1">
			<f a="StringArray:?UseIndexID" v=":false">
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.addons.ui.StrIdLabel"/></c>
			</f>
			<haxe_doc>* Helper function to easily create a data list for a dropdown menu from an array of strings.
	 * 
	 * @param	StringArray		The strings to use as data - used for both label and string ID.
	 * @param	UseIndexID		Whether to use the integer index of the current string as ID.
	 * @return	The StrIDLabel array ready to be used in FlxUIDropDownMenu's constructor</haxe_doc>
		</makeStrIdLabelArray>
		<skipButtonUpdate public="1" set="accessor"><x path="Bool"/></skipButtonUpdate>
		<set_skipButtonUpdate set="method" line="25"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_skipButtonUpdate>
		<selectedId public="1" get="accessor" set="accessor"><c path="String"/></selectedId>
		<selectedLabel public="1" get="accessor" set="accessor"><c path="String"/></selectedLabel>
		<_selectedId><c path="String"/></_selectedId>
		<_selectedLabel><c path="String"/></_selectedLabel>
		<get_selectedId set="method" line="37"><f a=""><c path="String"/></f></get_selectedId>
		<set_selectedId set="method" line="38"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></set_selectedId>
		<get_selectedLabel set="method" line="58"><f a=""><c path="String"/></f></get_selectedLabel>
		<set_selectedLabel set="method" line="59"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></set_selectedLabel>
		<header public="1">
			<c path="flixel.addons.ui.FlxUIDropDownHeader"/>
			<haxe_doc>* The header of this dropdown menu.</haxe_doc>
		</header>
		<list public="1">
			<c path="Array"><c path="flixel.addons.ui.FlxUIButton"/></c>
			<haxe_doc>* The list of items that is shown when the toggle button is clicked.</haxe_doc>
		</list>
		<dropPanel public="1">
			<c path="flixel.addons.ui.FlxUI9SliceSprite"/>
			<haxe_doc>* The background for the list.</haxe_doc>
		</dropPanel>
		<params public="1" set="accessor"><c path="Array"><d/></c></params>
		<set_params set="method" line="89"><f a="p">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_params>
		<callback public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></callback>
		<setData public="1" set="method" line="183">
			<f a="DataList">
				<c path="Array"><c path="flixel.addons.ui.StrIdLabel"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the contents with a new data list
	 * Replaces the old content with the new content
	 * @param	DataList</haxe_doc>
		</setData>
		<selectSomething set="method" line="235"><f a="id:label">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></selectSomething>
		<makeListButton set="method" line="241"><f a="i:Label:Name">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.addons.ui.FlxUIButton"/>
</f></makeListButton>
		<changeLabelByIndex public="1" set="method" line="274"><f a="i:NewLabel">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></changeLabelByIndex>
		<changeLabelById public="1" set="method" line="281"><f a="id:NewLabel">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></changeLabelById>
		<getBtnByIndex public="1" set="method" line="288"><f a="i">
	<x path="Int"/>
	<c path="flixel.addons.ui.FlxUIButton"/>
</f></getBtnByIndex>
		<getBtnById public="1" set="method" line="295"><f a="id">
	<c path="String"/>
	<c path="flixel.addons.ui.FlxUIButton"/>
</f></getBtnById>
		<update public="1" set="method" line="304" override="1"><f a=""><x path="Void"/></f></update>
		<destroy public="1" set="method" line="319" override="1"><f a=""><x path="Void"/></f></destroy>
		<showList set="method" line="335"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></showList>
		<onDropdown set="method" line="347"><f a=""><x path="Void"/></f></onDropdown>
		<onClickItem set="method" line="352"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></onClickItem>
		<new public="1" set="method" line="112">
			<f a="?X:?Y:DataList:?Callback:?Header:?DropPanel:?ButtonList:?UIControlCallback" v="0:0::null:null:null:null:null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><c path="flixel.addons.ui.StrIdLabel"/></c>
				<f a="">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<c path="flixel.addons.ui.FlxUIDropDownHeader"/>
				<c path="flixel.addons.ui.FlxUI9SliceSprite"/>
				<c path="Array"><c path="flixel.addons.ui.FlxUIButton"/></c>
				<f a=":">
					<x path="Bool"/>
					<c path="flixel.addons.ui.FlxUIDropDownMenu"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* This creates a new dropdown menu.
	 * 
	 * @param	X					x position of the dropdown menu
	 * @param	Y					y position of the dropdown menu
	 * @param	DataList			The data to be displayed
	 * @param	Callback			Optional Callback
	 * @param	Header				The header of this dropdown menu
	 * @param	DropPanel			Optional 9-slice-background for actual drop down menu 
	 * @param	ButtonList			Optional list of buttons to be used for the corresponding entry in DataList
	 * @param	UIControlCallback	Used internally by FlxUI</haxe_doc>
		</new>
		<haxe_doc>* larsiusprime
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIDropDownHeader" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIDropDownMenu.hx" module="flixel.addons.ui.FlxUIDropDownMenu">
		<extends path="flixel.addons.ui.FlxUIGroup"/>
		<background public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* The background of the header.</haxe_doc>
		</background>
		<text public="1">
			<c path="flixel.addons.ui.FlxUIText"/>
			<haxe_doc>* The text that displays the currently selected item.</haxe_doc>
		</text>
		<button public="1">
			<c path="flixel.addons.ui.FlxUISpriteButton"/>
			<haxe_doc>* The button that toggles the visibility of the dropdown panel.</haxe_doc>
		</button>
		<destroy public="1" set="method" line="457" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="416">
			<f a="?Width:?Background:?Text:?Button" v="120:null:null:null">
				<x path="Int"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.addons.ui.FlxUIText"/>
				<c path="flixel.addons.ui.FlxUISpriteButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new dropdown header to be used in a FlxUIDropDownMenu.
	 * 
	 * @param	Width	Width of the dropdown - only relevant when no back sprite was specified
	 * @param	Back	Optional sprite to be placed in the background
	 * @param 	Text	Optional text that displays the current value
	 * @param	Button	Optional button that toggles the dropdown list</haxe_doc>
		</new>
		<haxe_doc>* Header for a FlxUIDropDownMenu</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIInputText" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIInputText.hx">
		<extends path="flixel.addons.ui.FlxInputText"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<implements path="flixel.addons.ui.interfaces.IResizable"/>
		<CHANGE_EVENT public="1" get="inline" set="null" line="17" static="1"><c path="String"/></CHANGE_EVENT>
		<ENTER_EVENT public="1" get="inline" set="null" line="18" static="1"><c path="String"/></ENTER_EVENT>
		<DELETE_EVENT public="1" get="inline" set="null" line="19" static="1"><c path="String"/></DELETE_EVENT>
		<INPUT_EVENT public="1" get="inline" set="null" line="20" static="1"><c path="String"/></INPUT_EVENT>
		<id public="1"><c path="String"/></id>
		<broadcastToFlxUI public="1"><x path="Bool"/></broadcastToFlxUI>
		<resize public="1" set="method" line="23"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<onChange set="method" line="29" override="1"><f a="action">
	<c path="String"/>
	<x path="Void"/>
</f></onChange>
		<new public="1" set="method" line="11"><f a="?X:?Y:?Width:?Text:?size:?TextColor:?BackgroundColor:?EmbeddedFont">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIList" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIList.hx">
		<extends path="flixel.addons.ui.FlxUIGroup"/>
		<STACK_HORIZONTAL public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></STACK_HORIZONTAL>
		<STACK_VERTICAL public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></STACK_VERTICAL>
		<scrollIndex public="1" set="accessor"><x path="Int"/></scrollIndex>
		<set_scrollIndex public="1" set="method" line="19"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollIndex>
		<stacking public="1" set="accessor"><x path="Int"/></stacking>
		<set_stacking public="1" set="method" line="27"><f a="Stacking">
	<x path="Int"/>
	<x path="Int"/>
</f></set_stacking>
		<spacing public="1" set="accessor"><x path="Float"/></spacing>
		<set_spacing public="1" set="method" line="35"><f a="Spacing">
	<x path="Float"/>
	<x path="Float"/>
</f></set_spacing>
		<prevButtonOffset public="1"><c path="flixel.util.FlxPoint"/></prevButtonOffset>
		<nextButtonOffset public="1"><c path="flixel.util.FlxPoint"/></nextButtonOffset>
		<prevButton public="1"><c path="flixel.addons.ui.interfaces.IFlxUIButton"/></prevButton>
		<nextButton public="1"><c path="flixel.addons.ui.interfaces.IFlxUIButton"/></nextButton>
		<moreString public="1" set="accessor"><c path="String"/></moreString>
		<set_moreString public="1" set="method" line="48"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></set_moreString>
		<destroy public="1" set="method" line="136" override="1"><f a=""><x path="Void"/></f></destroy>
		<setSize public="1" set="method" line="146" override="1"><f a="W:H">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSize>
		<_skipRefresh>
			<x path="Bool"/>
			<haxe_doc>**PRIVATE**</haxe_doc>
		</_skipRefresh>
		<getMoreString set="method" line="164"><f a="i">
	<x path="Int"/>
	<c path="String"/>
</f></getMoreString>
		<set_visible set="method" line="172" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<onClick set="method" line="179"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></onClick>
		<refreshList set="method" line="184"><f a=""><x path="Void"/></f></refreshList>
		<get_width set="method" line="279" override="1"><f a=""><x path="Float"/></f></get_width>
		<get_height set="method" line="283" override="1"><f a=""><x path="Float"/></f></get_height>
		<set_width set="method" line="287" override="1"><f a="W">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="293" override="1"><f a="H">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<new public="1" set="method" line="70">
			<f a="?X:?Y:?Widgets:?W:?H:?MoreString:?Stacking:?Spacing:?PrevButtonOffset:?NextButtonOffset:?PrevButton:?NextButton" v="0:0:null:0:0:'<X> more...':1:0:null:null:null:null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><c path="flixel.addons.ui.interfaces.IFlxUIWidget"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.addons.ui.interfaces.IFlxUIButton"/>
				<c path="flixel.addons.ui.interfaces.IFlxUIButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a scrollable list of widgets
	 * @param	X			X position of the list
	 * @param	Y			Y position of the list
	 * @param	?Widgets	List of widgets themselves (optional)
	 * @param	W			Width of the invisible "canvas" available for putting widgets in before we have to scroll to see more
	 * @param	H			Height of the invisible "canvas" available for putting widgets in before we have to scroll to see more
	 * @param	?MoreString	String that says "<X> more..." in your language (must use <X> variable!)
	 * @param	?Stacking	How to stack the widgets? STACK_HORIZONTAL or STACK_VERTICAL
	 * @param	?Spacing	Space between widgets 
	 * @param	PrevButtonOffset	Offset for Scroll - Button
	 * @param	NextButtonOffset	Offset for Scroll + Button
	 * @param	PrevButton	Button to Scroll -
	 * @param	NextButton	Button to Scroll +]]></haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.interfaces.IFlxUIState" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/interfaces/IFlxUIState.hx" interface="1">
		<extends path="flixel.addons.ui.interfaces.IEventGetter"/>
		<forceFocus public="1" set="method"><f a="b:thing">
	<x path="Bool"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Void"/>
</f></forceFocus>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUISubState" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUISubState.hx">
		<extends path="flixel.FlxSubState"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIState"/>
		<destroyed public="1"><x path="Bool"/></destroyed>
		<_xml_id><c path="String"/></_xml_id>
		<_ui><c path="flixel.addons.ui.FlxUI"/></_ui>
		<_tongue><c path="flixel.addons.ui.interfaces.IFireTongue"/></_tongue>
		<reload_ui_on_resize public="1"><x path="Bool"/></reload_ui_on_resize>
		<_reload><x path="Bool"/></_reload>
		<_reload_countdown><x path="Int"/></_reload_countdown>
		<getTextFallback public="1"><f a="::">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></getTextFallback>
		<forceScrollFactor public="1" set="method" line="45"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></forceScrollFactor>
		<forceFocus public="1" set="method" line="57"><f a="b:thing">
	<x path="Bool"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Void"/>
</f></forceFocus>
		<create public="1" set="method" line="67" override="1"><f a=""><x path="Void"/></f></create>
		<onResize public="1" set="method" line="95" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<update public="1" set="method" line="101" override="1"><f a=""><x path="Void"/></f></update>
		<destroy public="1" set="method" line="116" override="1"><f a=""><x path="Void"/></f></destroy>
		<getEvent public="1" set="method" line="128"><f a="id:sender:data:?params" v=":::null">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<d/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></getEvent>
		<getRequest public="1" set="method" line="132"><f a="id:sender:data:?params" v=":::null">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></getRequest>
		<getText public="1" set="method" line="137"><f a="Flag:?Context:?Safe" v=":'ui':true">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></getText>
		<reloadUI set="method" line="147"><f a=""><x path="Void"/></f></reloadUI>
		<new public="1" set="method" line="40"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This is a simple extension of FlxState that does two things:
 * 1) It implements the IEventGetter interface
 * 2) Automatically creates a FlxUI objects from a single string id
 * 
 * Usage:
	 * Create a class that extends FlxUIState, override create, and 
	 * before you call super.create(), set _xml_id to the string id
	 * of the corresponding UI xml file (leave off the extension).
 * 
 * @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIPopup" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIPopup.hx">
		<extends path="flixel.addons.ui.FlxUISubState"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<CLICK_EVENT public="1" get="inline" set="null" line="63" static="1"><c path="String"/></CLICK_EVENT>
		<id public="1"><c path="String"/></id>
		<broadcastToFlxUI public="1"><x path="Bool"/></broadcastToFlxUI>
		<immovable public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>STUBS TO MAKE THE INTERFACE HAPPY:</haxe_doc>
		</immovable>
		<set_immovable set="method" line="20"><f a="Immovable">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_immovable>
		<angle public="1" set="accessor"><x path="Float"/></angle>
		<facing public="1" set="accessor"><x path="Int"/></facing>
		<moves public="1" set="accessor"><x path="Bool"/></moves>
		<offset public="1" set="accessor"><c path="flixel.util.FlxPoint"/></offset>
		<origin public="1" set="accessor"><c path="flixel.util.FlxPoint"/></origin>
		<scale public="1" set="accessor"><c path="flixel.util.FlxPoint"/></scale>
		<velocity public="1"><c path="flixel.util.FlxPoint"/></velocity>
		<maxVelocity public="1"><c path="flixel.util.FlxPoint"/></maxVelocity>
		<acceleration public="1"><c path="flixel.util.FlxPoint"/></acceleration>
		<drag public="1"><c path="flixel.util.FlxPoint"/></drag>
		<scrollFactor public="1" set="accessor"><c path="flixel.util.FlxPoint"/></scrollFactor>
		<set_x set="method" line="33"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="34"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_width set="method" line="35"><f a=""><x path="Float"/></f></get_width>
		<get_height set="method" line="36"><f a=""><x path="Float"/></f></get_height>
		<set_width set="method" line="37"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="38"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<set_angle set="method" line="39"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<set_alpha set="method" line="40"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_facing set="method" line="41"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_facing>
		<set_moves set="method" line="42"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_moves>
		<set_offset set="method" line="43"><f a="Value">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
</f></set_offset>
		<set_origin set="method" line="44"><f a="Value">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
</f></set_origin>
		<set_scale set="method" line="45"><f a="Value">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
</f></set_scale>
		<set_scrollFactor set="method" line="46"><f a="Value">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
</f></set_scrollFactor>
		<reset public="1" set="method" line="47"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<setPosition public="1" set="method" line="48"><f a="?X:?Y" v="0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<x public="1" set="accessor"><x path="Float"/></x>
		<y public="1" set="accessor"><x path="Float"/></y>
		<params public="1"><c path="Array"><d/></c></params>
		<alpha public="1" set="accessor"><x path="Float"/></alpha>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<height public="1" get="accessor" set="accessor"><x path="Float"/></height>
		<_width><x path="Float"/></_width>
		<_height><x path="Float"/></_height>
		<create public="1" set="method" line="67" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>**********************************</haxe_doc>
		</create>
		<quickSetup public="1" set="method" line="94">
			<f a="title:body:button_labels">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assuming you use the default format, puts this information in the popup.
	 * This function ONLY works if you are using the default_popup.xml, OR your
	 * custom xml contains the following assets:
		 * 2 texts, ids: "title","body"
		 * 3 buttons, ids: "btn0","btn1","btn2"
		 * 3 modes, ids: "1btn","2btn","3btn"
	 * @param	title title text
	 * @param	body body text  
	 * @param	button_labels up to three button labels - if fewer, shows less buttons</haxe_doc>
		</quickSetup>
		<getEvent public="1" set="method" line="103" override="1"><f a="id:sender:data:?eventParams" v=":::null">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></getEvent>
		<castParent set="method" line="132"><f a=""><c path="flixel.addons.ui.interfaces.IFlxUIState"/></f></castParent>
		<_quickSetupParams><a>
	<title><c path="String"/></title>
	<button_labels><c path="Array"><c path="String"/></c></button_labels>
	<body><c path="String"/></body>
</a></_quickSetupParams>
		<myGetTextFallback set="method" line="140"><f a="flag:?context:?safe" v=":'ui':true">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></myGetTextFallback>
		<_doQuickSetup set="method" line="153"><f a=""><x path="Void"/></f></_doQuickSetup>
		<_doQuickSetupButtons set="method" line="171"><f a=""><x path="Void"/></f></_doQuickSetupButtons>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUILoadingScreen" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUILoadingScreen.hx">
		<extends path="flixel.addons.ui.FlxUIPopup"/>
		<PROGRESS public="1" get="inline" set="null" line="18" static="1"><c path="String"/></PROGRESS>
		<FINISHED public="1" get="inline" set="null" line="19" static="1"><c path="String"/></FINISHED>
		<CANCELLED public="1" get="inline" set="null" line="20" static="1"><c path="String"/></CANCELLED>
		<ACCEPTED public="1" get="inline" set="null" line="21" static="1"><c path="String"/></ACCEPTED>
		<invisibleTime public="1"><x path="Float"/></invisibleTime>
		<body public="1" get="accessor" set="accessor"><c path="String"/></body>
		<get_body set="method" line="26"><f a=""><c path="String"/></f></get_body>
		<set_body set="method" line="33"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></set_body>
		<title public="1" get="accessor" set="accessor"><c path="String"/></title>
		<get_title set="method" line="43"><f a=""><c path="String"/></f></get_title>
		<set_title set="method" line="52"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></set_title>
		<canCancel public="1" set="accessor"><x path="Bool"/></canCancel>
		<set_canCancel set="method" line="62"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_canCancel>
		<progress public="1" get="accessor" set="accessor"><x path="Float"/></progress>
		<get_progress set="method" line="79"><f a=""><x path="Float"/></f></get_progress>
		<set_progress set="method" line="80"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_progress>
		<set public="1" set="method" line="100"><f a="progress_:?body_:?title_:?canCancel_" v=":null:null:false">
	<x path="Float"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></set>
		<create public="1" set="method" line="108" override="1"><f a=""><x path="Void"/></f></create>
		<getEvent public="1" set="method" line="133" override="1"><f a="name:sender:data:?params" v=":::null">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<d/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></getEvent>
		<update public="1" set="method" line="156" override="1"><f a=""><x path="Void"/></f></update>
		<myGetTextFallback set="method" line="171" override="1"><f a="flag:?context:?safe" v=":'ui':true">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></myGetTextFallback>
		<_doQuickSetupButtons set="method" line="179" override="1"><f a=""><x path="Void"/></f></_doQuickSetupButtons>
		<_timeSpentAlive><x path="Float"/></_timeSpentAlive>
		<_currTimer><c path="flixel.util.FlxTimer"/></_currTimer>
		<_task><f a=""><x path="Float"/></f></_task>
		<_sleepTime><x path="Float"/></_sleepTime>
		<_closeOnFinished><x path="Bool"/></_closeOnFinished>
		<_progress><x path="Float"/></_progress>
		<_bar><c path="flixel.addons.ui.FlxUI9SliceSprite"/></_bar>
		<_bar_back><c path="flixel.addons.ui.FlxUI9SliceSprite"/></_bar_back>
		<_title><c path="flixel.addons.ui.FlxUIText"/></_title>
		<_body><c path="flixel.addons.ui.FlxUIText"/></_body>
		<_body_temp_txt><c path="String"/></_body_temp_txt>
		<_title_temp_txt><c path="String"/></_title_temp_txt>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A simple loading screen -- you must drive the churning of tasks externally
 * 
 * @author larsiusprime</haxe_doc>
	</class>
	<class path="flixel.interfaces.IFlxInput" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/interfaces/IFlxInput.hx" interface="1">
		<reset public="1" set="method"><f a=""><x path="Void"/></f></reset>
		<update set="method"><f a=""><x path="Void"/></f></update>
		<onFocus set="method"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost set="method"><f a=""><x path="Void"/></f></onFocusLost>
		<destroy public="1" set="method"><f a=""><x path="Void"/></f></destroy>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.input.mouse.FlxMouse" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/mouse/FlxMouse.hx">
		<extends path="flixel.util.FlxPoint"/>
		<implements path="flixel.interfaces.IFlxInput"/>
		<wheel public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Current "delta" value of mouse wheel. If the wheel was just scrolled up, 
	 * it will have a positive value and vice versa. Otherwise the value will be 0.</haxe_doc>
		</wheel>
		<screenX public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Current X position of the mouse pointer on the screen.</haxe_doc>
		</screenX>
		<screenY public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Current Y position of the mouse pointer on the screen.</haxe_doc>
		</screenY>
		<cursorContainer public="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* A display container for the mouse cursor. It is a child of FlxGame and 
	 * sits at the right "height". Not used on flash with the native cursor API.</haxe_doc>
		</cursorContainer>
		<visible public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Used to toggle the visiblity of the mouse cursor - works on both 
	 * the flixel and the system cursor, depending on which one is active.</haxe_doc>
		</visible>
		<useSystemCursor public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Tells flixel to use the default system mouse cursor instead of custom Flixel mouse cursors.</haxe_doc>
		</useSystemCursor>
		<pressed public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* If the left mouse button is currently pressed.</haxe_doc>
		</pressed>
		<justPressed public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the mouse was just pressed.</haxe_doc>
		</justPressed>
		<justReleased public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the mouse was just released.</haxe_doc>
		</justReleased>
		<pressedRight public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the right mouse button is pressed.</haxe_doc>
		</pressedRight>
		<justPressedRight public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the right mouse button has just been pressed.</haxe_doc>
		</justPressedRight>
		<justReleasedRight public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the right mouse button has just been released.</haxe_doc>
		</justReleasedRight>
		<pressedMiddle public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the middle mouse button is pressed.</haxe_doc>
		</pressedMiddle>
		<justPressedMiddle public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the middle mouse button was just pressed.</haxe_doc>
		</justPressedMiddle>
		<justReleasedMiddle public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the middle mouse button was just released.</haxe_doc>
		</justReleasedMiddle>
		<_leftButton>
			<c path="flixel.input.mouse.FlxMouseButton"/>
			<haxe_doc>* The left mouse button.</haxe_doc>
		</_leftButton>
		<_middleButton>
			<c path="flixel.input.mouse.FlxMouseButton"/>
			<haxe_doc>* The middle mouse button.</haxe_doc>
		</_middleButton>
		<_rightButton>
			<c path="flixel.input.mouse.FlxMouseButton"/>
			<haxe_doc>* The right mouse button.</haxe_doc>
		</_rightButton>
		<_cursor>
			<c path="flash.display.Bitmap"/>
			<haxe_doc>* This is just a reference to the current cursor image, if there is one.</haxe_doc>
		</_cursor>
		<_cursorBitmapData><c path="flash.display.BitmapData"/></_cursorBitmapData>
		<_wheelUsed><x path="Bool"/></_wheelUsed>
		<_visibleWhenFocusLost><x path="Bool"/></_visibleWhenFocusLost>
		<_lastX>
			<x path="Int"/>
			<haxe_doc>* Helper variables for recording purposes.</haxe_doc>
		</_lastX>
		<_lastY><x path="Int"/></_lastY>
		<_lastWheel><x path="Int"/></_lastWheel>
		<_point><c path="flixel.util.FlxPoint"/></_point>
		<_globalScreenPosition><c path="flixel.util.FlxPoint"/></_globalScreenPosition>
		<_stage><c path="flash.display.Stage"/></_stage>
		<load public="1" set="method" line="160">
			<f a="?Graphic:?Scale:?XOffset:?YOffset" v="null:1:0:0">
				<d/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper variables for flash native cursors</haxe_doc>
		</load>
		<unload public="1" set="method" line="234">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload the current cursor graphic. If the current cursor is visible,
	 * then the default system cursor is loaded up to replace the old one.</haxe_doc>
		</unload>
		<getWorldPosition public="1" set="method" line="318">
			<f a="?Camera:?point" v="null:null">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the world position of the mouse on any given camera. NOTE: FlxG.mouse.x and 
	 * FlxG.mouse.y store the world position of the mouse cursor on the main camera.
	 * 
	 * @param   Camera  If unspecified, FlxG.camera is used instead.
	 * @param   point   An existing point object to store the results (if you don't want a new one created).
	 * @return  The mouse's location in world space.</haxe_doc>
		</getWorldPosition>
		<getScreenPosition public="1" set="method" line="341">
			<f a="?Camera:?point" v="null:null">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the screen position of the mouse on any given camera. NOTE: FlxG.mouse.screenX 
	 * and Mouse.screenY also store the screen position of the mouse cursor on the main camera.
	 * 
	 * @param   Camera  If unspecified, FlxG.camera is used instead.
	 * @param   point   An existing point object to store the results (if you don't want a new one created).
	 * @return  The mouse's location in screen space.</haxe_doc>
		</getScreenPosition>
		<destroy public="1" set="method" line="360" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Clean up memory. Internal use only.</haxe_doc>
		</destroy>
		<setGlobalScreenPositionUnsafe public="1" get="inline" set="null" line="405">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Directly set the underyling screen position variable. WARNING! You should never use
	 * this unless you are trying to manually dispatch low-level mouse events to the stage.</haxe_doc>
		</setGlobalScreenPositionUnsafe>
		<reset public="1" set="method" line="413">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the just pressed/just released flags and sets mouse to not pressed.</haxe_doc>
		</reset>
		<update set="method" line="466">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the mouse pointer's position in the game world.
	 * Also updates the just pressed/just released flags.</haxe_doc>
		</update>
		<onFocus set="method" line="505">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called from the main Event.ACTIVATE that is dispatched in FlxGame</haxe_doc>
		</onFocus>
		<onFocusLost set="method" line="519">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called from the main Event.DEACTIVATE that is dispatched in FlxGame</haxe_doc>
		</onFocusLost>
		<onGameStart set="method" line="534">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</onGameStart>
		<updateCursor set="method" line="545">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Helper function to update the cursor used by update() and playback().
	 * Updates the x, y, screenX, and screenY variables based on the default camera.</haxe_doc>
		</updateCursor>
		<onMouseWheel set="method" line="559">
			<f a="FlashEvent">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * 
	 * @param   FlashEvent   Flash mouse event.</haxe_doc>
		</onMouseWheel>
		<onMouseLeave get="inline" set="null" line="580">
			<f a="E">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* We're detecting the mouse leave event to prevent a bug where `pressed` remains true 
	 * for the middle and right mouse button when pressed and dragged outside the window.
	 * 
	 * @param   E   Flash event.</haxe_doc>
		</onMouseLeave>
		<get_pressed get="inline" set="null" line="587"><f a=""><x path="Bool"/></f></get_pressed>
		<get_justPressed get="inline" set="null" line="588"><f a=""><x path="Bool"/></f></get_justPressed>
		<get_justReleased get="inline" set="null" line="589"><f a=""><x path="Bool"/></f></get_justReleased>
		<get_pressedRight get="inline" set="null" line="592"><f a=""><x path="Bool"/></f></get_pressedRight>
		<get_justPressedRight get="inline" set="null" line="593"><f a=""><x path="Bool"/></f></get_justPressedRight>
		<get_justReleasedRight get="inline" set="null" line="594"><f a=""><x path="Bool"/></f></get_justReleasedRight>
		<get_pressedMiddle get="inline" set="null" line="596"><f a=""><x path="Bool"/></f></get_pressedMiddle>
		<get_justPressedMiddle get="inline" set="null" line="597"><f a=""><x path="Bool"/></f></get_justPressedMiddle>
		<get_justReleasedMiddle get="inline" set="null" line="598"><f a=""><x path="Bool"/></f></get_justReleasedMiddle>
		<showSystemCursor set="method" line="604">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Show the default system cursor, if Flash 10.2 return to AUTO</haxe_doc>
		</showSystemCursor>
		<hideSystemCursor set="method" line="617">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Hide the system cursor, if Flash 10.2 return to default</haxe_doc>
		</hideSystemCursor>
		<set_useSystemCursor set="method" line="635"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useSystemCursor>
		<set_visible set="method" line="648"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<record set="method" line="693">
			<f a=""><c path="flixel.system.replay.MouseRecord"/></f>
			<haxe_doc>Replay functions</haxe_doc>
		</record>
		<playback set="method" line="706"><f a="Record">
	<c path="flixel.system.replay.MouseRecord"/>
	<x path="Void"/>
</f></playback>
		<new set="method" line="427">
			<f a="CursorContainer">
				<c path="flash.display.Sprite"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* @param   CursorContainer   The cursor container sprite passed by FlxGame</haxe_doc>
		</new>
		<haxe_doc>* This class helps contain and track the mouse pointer in your game.
 * Automatically accounts for parallax scrolling, etc.</haxe_doc>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.addons.ui.FlxUIMouse" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIMouse.hx">
		<extends path="flixel.input.mouse.FlxMouse"/>
		<updateGlobalScreenPosition public="1"><x path="Bool"/></updateGlobalScreenPosition>
		<update set="method" line="25" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the mouse pointer's position in the game world.
	 * Also updates the just pressed/just released flags.</haxe_doc>
		</update>
		<new public="1" set="method" line="16"><f a="CursorContainer">
	<c path="flash.display.Sprite"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A customized extension to FlxMouse that lets us add in accessibility stuff
 * like using the keyboard to control mouse moving/clicking
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUINumericStepper" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUINumericStepper.hx">
		<extends path="flixel.addons.ui.FlxUIGroup"/>
		<implements path="flixel.addons.ui.interfaces.IHasParams"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIClickable"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<STACK_VERTICAL public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></STACK_VERTICAL>
		<STACK_HORIZONTAL public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></STACK_HORIZONTAL>
		<CLICK_EVENT public="1" get="inline" set="null" line="33" static="1"><c path="String"/></CLICK_EVENT>
		<EDIT_EVENT public="1" get="inline" set="null" line="34" static="1"><c path="String"/></EDIT_EVENT>
		<CHANGE_EVENT public="1" get="inline" set="null" line="35" static="1"><c path="String"/></CHANGE_EVENT>
		<button_plus><c path="flixel.addons.ui.FlxUITypedButton"><c path="flixel.FlxSprite"/></c></button_plus>
		<button_minus><c path="flixel.addons.ui.FlxUITypedButton"><c path="flixel.FlxSprite"/></c></button_minus>
		<text_field><c path="flixel.text.FlxText"/></text_field>
		<stepSize public="1"><x path="Float"/></stepSize>
		<decimals public="1" set="accessor"><x path="Int"/></decimals>
		<min public="1" set="accessor"><x path="Float"/></min>
		<max public="1" set="accessor"><x path="Float"/></max>
		<value public="1" set="accessor"><x path="Float"/></value>
		<stack public="1" set="accessor"><x path="Int"/></stack>
		<params public="1" set="accessor"><c path="Array"><d/></c></params>
		<set_params set="method" line="38"><f a="p">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_params>
		<skipButtonUpdate public="1" set="accessor"><x path="Bool"/></skipButtonUpdate>
		<set_skipButtonUpdate set="method" line="44"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_skipButtonUpdate>
		<set_color set="method" line="52" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<set_min set="method" line="65"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_min>
		<set_max set="method" line="71"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_max>
		<set_value set="method" line="77"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></set_value>
		<set_decimals set="method" line="87"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_decimals>
		<set_stack set="method" line="94"><f a="s">
	<x path="Int"/>
	<x path="Int"/>
</f></set_stack>
		<decimalize get="inline" set="null" line="132"><f a="f:digits">
	<x path="Float"/>
	<x path="Int"/>
	<c path="String"/>
</f></decimalize>
		<_onInputTextEvent set="method" line="207"><f a="text:action">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></_onInputTextEvent>
		<_onPlus set="method" line="217"><f a=""><x path="Void"/></f></_onPlus>
		<_onMinus set="method" line="223"><f a=""><x path="Void"/></f></_onMinus>
		<_doCallback set="method" line="229"><f a="event_name">
	<c path="String"/>
	<x path="Void"/>
</f></_doCallback>
		<new public="1" set="method" line="152">
			<f a="?X:?Y:?StepSize:?DefaultValue:?Min:?Max:?Decimals:?Stack:?TextField:?ButtonPlus:?ButtonMinus" v="0:0:1:0:-999:999:0:1:null:null:null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.text.FlxText"/>
				<c path="flixel.addons.ui.FlxUITypedButton"><c path="flixel.FlxSprite"/></c>
				<c path="flixel.addons.ui.FlxUITypedButton"><c path="flixel.FlxSprite"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* This creates a new dropdown menu.
	 * 
	 * @param	X					x position of the dropdown menu
	 * @param	Y					y position of the dropdown menu
	 * @param	StepSize			How big is the step
	 * @param	DefaultValue		Optional default numerical value for the stepper to display
	 * @param	Min					Optional Minimum values for the stepper
	 * @param	Max					Optional Maximum and Minimum values for the stepper
	 * @param	Decimals			Optional # of decimal places
	 * @param	Stack				Stacking method
	 * @param	TextField			Optional text field
	 * @param	ButtonPlus			Optional button to use for plus
	 * @param	ButtonMinus			Optional button to use for minus</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIRadioGroup" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIRadioGroup.hx">
		<extends path="flixel.addons.ui.FlxUIGroup"/>
		<implements path="flixel.addons.ui.interfaces.IHasParams"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIClickable"/>
		<CLICK_EVENT public="1" get="inline" set="null" line="19" static="1"><c path="String"/></CLICK_EVENT>
		<clickable public="1" get="accessor" set="accessor"><x path="Bool"/></clickable>
		<selectedId public="1" get="accessor" set="accessor"><c path="String"/></selectedId>
		<selectedLabel public="1" get="accessor" set="accessor"><c path="String"/></selectedLabel>
		<selectedIndex public="1" get="accessor" set="accessor"><x path="Int"/></selectedIndex>
		<skipButtonUpdate public="1" set="accessor"><x path="Bool"/></skipButtonUpdate>
		<set_skipButtonUpdate set="method" line="22"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_skipButtonUpdate>
		<callback public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></callback>
		<params public="1" set="accessor"><c path="Array"><d/></c></params>
		<set_params set="method" line="34"><f a="p">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_params>
		<loadGraphics public="1" set="method" line="66"><f a="Box:Dot">
	<d/>
	<d/>
	<x path="Void"/>
</f></loadGraphics>
		<destroy public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></destroy>
		<updateLabel public="1" set="method" line="94"><f a="i:label_">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
</f></updateLabel>
		<updateId public="1" set="method" line="105"><f a="i:id_">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
</f></updateId>
		<show public="1" set="method" line="111"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></show>
		<updateRadios public="1" set="method" line="117"><f a="ids_:labels_">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></updateRadios>
		<get_clickable set="method" line="128">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>*GETTER / SETTER*</haxe_doc>
		</get_clickable>
		<set_clickable set="method" line="129"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clickable>
		<get_selectedIndex set="method" line="137"><f a=""><x path="Int"/></f></get_selectedIndex>
		<set_selectedIndex set="method" line="138"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_selectedIndex>
		<get_selectedLabel set="method" line="151"><f a=""><c path="String"/></f></get_selectedLabel>
		<set_selectedLabel set="method" line="152"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></set_selectedLabel>
		<get_selectedId set="method" line="165"><f a=""><c path="String"/></f></get_selectedId>
		<set_selectedId set="method" line="166"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></set_selectedId>
		<setLineScroll public="1" set="method" line="188">
			<f a="scroll:max_items">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* If you want to show only a portion of the radio group, scrolled line-by-line
	 * This will scroll the "pane" by that amount and return how many lines are above/below
	 * the currently visible pane
	 * @param	scroll How many lines DOWN you have scrolled
	 * @param	max_items Max amount of lines visible
	 * @return a FlxPoint of off-pane radio lines : (count_above,count_below)</haxe_doc>
		</setLineScroll>
		<_box_asset>
			<d/>
			<haxe_doc>*GETTER / SETTER*</haxe_doc>
		</_box_asset>
		<_dot_asset><d/></_dot_asset>
		<_labels><c path="Array"><c path="String"/></c></_labels>
		<_ids><c path="Array"><c path="String"/></c></_ids>
		<_label_width><x path="Int"/></_label_width>
		<_width><x path="Int"/></_width>
		<_height><x path="Int"/></_height>
		<_y_space><x path="Float"/></_y_space>
		<_selected><x path="Int"/></_selected>
		<_clickable><x path="Bool"/></_clickable>
		<_list_radios><c path="Array"><c path="flixel.addons.ui.FlxUICheckBox"/></c></_list_radios>
		<_refreshRadios set="method" line="237">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Create the radio elements if necessary, and/or just refresh them</haxe_doc>
		</_refreshRadios>
		<_onCheckBoxEvent set="method" line="273"><f a="checkBox">
	<c path="flixel.addons.ui.FlxUICheckBox"/>
	<x path="Void"/>
</f></_onCheckBoxEvent>
		<_onClick set="method" line="277"><f a="checkBox:doCallback">
	<c path="flixel.addons.ui.FlxUICheckBox"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></_onClick>
		<new public="1" set="method" line="52">
			<f a="X:Y:ids_:labels_:?callback_:?y_space_:?width_:?height_:?label_width_" v="::::null:25:100:20:100">
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="String"/></c>
				<f a="">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a set of radio buttons
	 * @param	X				X location
	 * @param	Y				Y location
	 * @param	ids_			list of string identifiers
	 * @param	labels_			list of string labels for each button (what the user sees)
	 * @param	callback_		optional callback expecting a string identifier of selected radio button
	 * @param	y_space_		vertical space between buttons
	 * @param	width_			maximum width of a button
	 * @param	height_			height of a button
	 * @param	label_width_	maximum width of a label</haxe_doc>
		</new>
		<haxe_doc>* @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIRegion" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIRegion.hx">
		<extends path="flixel.FlxSprite"/>
		<implements path="flixel.addons.ui.interfaces.IResizable"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<broadcastToFlxUI public="1"><x path="Bool"/></broadcastToFlxUI>
		<id public="1"><c path="String"/></id>
		<destroy public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></destroy>
		<resize public="1" set="method" line="33"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method" line="19"><f a="?X:?Y:?W:?H" v="0:0:16:16">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A scalable object with width and height that isn't used for display purposes
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUISlider" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUISlider.hx">
		<extends path="flixel.addons.ui.FlxSlider"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<CHANGE_EVENT public="1" get="inline" set="null" line="15" static="1"><c path="String"/></CHANGE_EVENT>
		<id public="1"><c path="String"/></id>
		<broadcastToFlxUI public="1"><x path="Bool"/></broadcastToFlxUI>
		<new public="1" set="method" line="9"><f a="Object:VarString:?X:?Y:?MinValue:?MaxValue:?Width:?Height:?Thickness:?Color:?HandleColor">
	<d/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUISpriteButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUISpriteButton.hx">
		<extends path="flixel.addons.ui.FlxUITypedButton"><c path="flixel.FlxSprite"/></extends>
		<implements path="flixel.addons.ui.interfaces.IFlxUIButton"/>
		<resize public="1" set="method" line="41" override="1">
			<f a="W:H">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>For IResizable:</haxe_doc>
		</resize>
		<autoCenterLabel public="1" set="method" line="47" override="1"><f a=""><x path="Void"/></f></autoCenterLabel>
		<new public="1" set="method" line="25">
			<f a="?X:?Y:?Asset:?OnClick" v="0:0:null:null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxSprite"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxUISpriteButton.
	 * 
	 * @param	X				The X position of the button.
	 * @param	Y				The Y position of the button.
	 * @param	Label			The text that you want to appear on the button.
	 * @param	OnClick			The function to call whenever the button is clicked.</haxe_doc>
		</new>
		<haxe_doc>* This class extends FlxUISpriteButton and has a Sprite "label"
 * 
 * Like all FlxUITypedButton's, it can work as a toggle button, and load
 * 9-slice sprites for its button images, and be dynamically resized 
 * accordingly.</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIState" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIState.hx">
		<extends path="flixel.FlxState"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIState"/>
		<implements path="flixel.addons.ui.interfaces.IEventGetter"/>
		<static_tongue public="1" line="36" static="1"><c path="flixel.addons.ui.interfaces.IFireTongue"/></static_tongue>
		<destroyed public="1"><x path="Bool"/></destroyed>
		<cursor public="1"><c path="flixel.addons.ui.FlxUICursor"/></cursor>
		<_xml_id><c path="String"/></_xml_id>
		<_makeCursor><x path="Bool"/></_makeCursor>
		<_ui><c path="flixel.addons.ui.FlxUI"/></_ui>
		<_tongue><c path="flixel.addons.ui.interfaces.IFireTongue"/></_tongue>
		<reload_ui_on_resize public="1"><x path="Bool"/></reload_ui_on_resize>
		<_reload><x path="Bool"/></_reload>
		<_reload_countdown><x path="Int"/></_reload_countdown>
		<getTextFallback public="1"><f a="::">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></getTextFallback>
		<create public="1" set="method" line="53" override="1"><f a=""><x path="Void"/></f></create>
		<resizeScreen public="1" set="method" line="97"><f a="?width:?height" v="800:600">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resizeScreen>
		<onResize public="1" set="method" line="105" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<update public="1" set="method" line="111" override="1"><f a=""><x path="Void"/></f></update>
		<destroy public="1" set="method" line="127" override="1"><f a=""><x path="Void"/></f></destroy>
		<forceFocus public="1" set="method" line="139"><f a="b:thing">
	<x path="Bool"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Void"/>
</f></forceFocus>
		<onCursorEvent public="1" set="method" line="153"><f a="code:target">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<x path="Void"/>
</f></onCursorEvent>
		<getEvent public="1" set="method" line="158"><f a="id:sender:data:?params" v=":::null">
	<c path="String"/>
	<d/>
	<d/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></getEvent>
		<getRequest public="1" set="method" line="162"><f a="id:sender:data:?params" v=":::null">
	<c path="String"/>
	<d/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></getRequest>
		<getText public="1" set="method" line="167"><f a="Flag:?Context:?Safe" v=":'ui':true">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></getText>
		<reloadUI set="method" line="177"><f a=""><x path="Void"/></f></reloadUI>
		<new public="1" set="method" line="48"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This is a simple extension of FlxState that does two things:
 * 1) It implements the IFlxUIState interface
 * 2) Automatically creates a FlxUI objects from a single string id
 * 
 * Usage:
	 * Create a class that extends FlxUIState, override create, and 
	 * before you call super.create(), set _xml_id to the string id
	 * of the corresponding UI xml file (leave off the extension).
 * 
 * @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUITabMenu" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUITabMenu.hx">
		<extends path="flixel.addons.ui.FlxUIGroup"/>
		<implements path="flixel.addons.ui.interfaces.IEventGetter"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIClickable"/>
		<implements path="flixel.addons.ui.interfaces.IResizable"/>
		<CLICK_EVENT public="1" get="inline" set="null" line="22" static="1"><c path="String"/></CLICK_EVENT>
		<STACK_FRONT public="1" get="inline" set="null" line="24" static="1"><c path="String"/></STACK_FRONT>
		<STACK_BACK public="1" get="inline" set="null" line="25" static="1"><c path="String"/></STACK_BACK>
		<getEvent public="1" set="method" line="28">
			<f a="name:sender:data:?params" v=":::null">
				<c path="String"/>
				<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
				<d/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>To make IEventGetter happy</haxe_doc>
		</getEvent>
		<getRequest public="1" set="method" line="32"><f a="name:sender:data:?params" v=":::null">
	<c path="String"/>
	<c path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></getRequest>
		<skipButtonUpdate public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>For IFlxUIClickable</haxe_doc>
		</skipButtonUpdate>
		<set_skipButtonUpdate set="method" line="40"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_skipButtonUpdate>
		<get_width set="method" line="61" override="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>For IResizable</haxe_doc>
		</get_width>
		<get_height set="method" line="65" override="1"><f a=""><x path="Float"/></f></get_height>
		<resize public="1" set="method" line="73"><f a="W:H">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<selected_tab public="1" get="accessor" set="accessor"><x path="Int"/></selected_tab>
		<get_selected_tab set="method" line="88"><f a=""><x path="Int"/></f></get_selected_tab>
		<set_selected_tab set="method" line="89"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></set_selected_tab>
		<selected_tab_id public="1" get="accessor" set="accessor"><c path="String"/></selected_tab_id>
		<get_selected_tab_id set="method" line="95"><f a=""><c path="String"/></f></get_selected_tab_id>
		<set_selected_tab_id set="method" line="96"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></set_selected_tab_id>
		<destroy public="1" set="method" line="169" override="1"><f a=""><x path="Void"/></f></destroy>
		<getTab public="1" set="method" line="178"><f a="?id:?index" v="null:null">
	<c path="String"/>
	<x path="Int"/>
	<c path="flixel.addons.ui.FlxUIButton"/>
</f></getTab>
		<getTabGroup public="1" set="method" line="194"><f a="?id:?index" v="null:null">
	<c path="String"/>
	<x path="Int"/>
	<c path="flixel.addons.ui.FlxUIGroup"/>
</f></getTabGroup>
		<addGroup public="1" set="method" line="211"><f a="g">
	<c path="flixel.addons.ui.FlxUIGroup"/>
	<x path="Void"/>
</f></addGroup>
		<_onTabEvent set="method" line="236"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></_onTabEvent>
		<showTabId public="1" set="method" line="243"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></showTabId>
		<_back>
			<c path="flixel.FlxSprite"/>
			<haxe_doc>*PRIVATE*</haxe_doc>
		</_back>
		<_tabs><c path="Array"><c path="flixel.addons.ui.FlxUIButton"/></c></_tabs>
		<_tab_groups><c path="Array"><c path="flixel.addons.ui.FlxUIGroup"/></c></_tab_groups>
		<_stretch_tabs><x path="Bool"/></_stretch_tabs>
		<_tab_spacing><t path="Null"><x path="Float"/></t></_tab_spacing>
		<_tab_stacking><c path="Array"><c path="String"/></c></_tab_stacking>
		<_tab_offset><c path="flixel.util.FlxPoint"/></_tab_offset>
		<_selected_tab_id><c path="String"/></_selected_tab_id>
		<_selected_tab><x path="Int"/></_selected_tab>
		<stackTabs set="method" line="277"><f a=""><x path="Void"/></f></stackTabs>
		<sortTabs set="method" line="318"><f a="a:b">
	<c path="flixel.addons.ui.FlxUIButton"/>
	<c path="flixel.addons.ui.FlxUIButton"/>
	<x path="Int"/>
</f></sortTabs>
		<showTabInt set="method" line="327"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></showTabInt>
		<_showOnlyGroup set="method" line="337"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></_showOnlyGroup>
		<getFirstTab set="method" line="347"><f a=""><c path="flixel.addons.ui.FlxUIButton"/></f></getFirstTab>
		<distributeTabs set="method" line="355"><f a=""><x path="Void"/></f></distributeTabs>
		<new public="1" set="method" line="103">
			<f a="?back_:?tabs_:?tab_ids_and_labels_:?tab_offset:?stretch_tabs:?tab_spacing:?tab_stacking" v="null:null:null:null:false:null:null">
				<c path="flixel.FlxSprite"/>
				<c path="Array"><c path="flixel.addons.ui.FlxUIButton"/></c>
				<c path="Array"><a>
	<label><c path="String"/></label>
	<id><c path="String"/></id>
</a></c>
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>*PUBLIC*</haxe_doc>
		</new>
		<haxe_doc>* @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FlxUIText" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIText.hx">
		<extends path="flixel.text.FlxText"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<implements path="flixel.addons.ui.interfaces.IResizable"/>
		<broadcastToFlxUI public="1"><x path="Bool"/></broadcastToFlxUI>
		<id public="1"><c path="String"/></id>
		<resize public="1" set="method" line="18"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method" line="12"><f a="?X:?Y:?FieldWidth:?Text:?Size:?EmbeddedFont">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Simple extension to the basic text field class.
 * @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.FontDef" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIText.hx" module="flixel.addons.ui.FlxUIText">
		<name public="1"><c path="String"/></name>
		<size public="1"><t path="Null"><x path="Int"/></t></size>
		<style public="1"><c path="String"/></style>
		<apply public="1" set="method" line="37"><f a="f">
	<c path="flixel.text.FlxText"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="31"><f a="Name:?Size:?Style" v=":null:null">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.addons.ui.BorderDef" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUIText.hx" module="flixel.addons.ui.FlxUIText">
		<style public="1"><x path="Int"/></style>
		<color public="1"><x path="Int"/></color>
		<size public="1"><x path="Int"/></size>
		<quality public="1"><x path="Float"/></quality>
		<apply public="1" set="method" line="57"><f a="f">
	<c path="flixel.text.FlxText"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="50"><f a="Style:Color:?Size:?Quality" v="::1:1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.addons.ui.FlxUITileTest" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/FlxUITileTest.hx">
		<extends path="flixel.addons.ui.FlxUISprite"/>
		<implements path="flixel.addons.ui.interfaces.IFlxUIWidget"/>
		<implements path="flixel.addons.ui.interfaces.IResizable"/>
		<widthInTiles public="1" get="accessor" set="null"><x path="Int"/></widthInTiles>
		<heightInTiles public="1" get="accessor" set="null"><x path="Int"/></heightInTiles>
		<tileWidth public="1" set="null"><x path="Int"/></tileWidth>
		<tileHeight public="1" set="null"><x path="Int"/></tileHeight>
		<get_widthInTiles set="method" line="19"><f a=""><x path="Int"/></f></get_widthInTiles>
		<get_heightInTiles set="method" line="20"><f a=""><x path="Int"/></f></get_heightInTiles>
		<_tilesWide><x path="Int"/></_tilesWide>
		<_tilesTall><x path="Int"/></_tilesTall>
		<_color1><x path="Int"/></_color1>
		<_color2><x path="Int"/></_color2>
		<floorToEven public="1"><x path="Bool"/></floorToEven>
		<makeTiles set="method" line="45"><f a="tileWidth:tileHeight:tilesWide:tilesTall:?color1:?color2" v="::::-8355712:-3881788">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></makeTiles>
		<resize public="1" set="method" line="71"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method" line="29"><f a="X:Y:TileWidth:TileHeight:tilesWide:tilesTall:?color1:?color2" v="::::::-8355712:-3881788">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* This is mostly just for testing purposes, it is NOT a replacement for FlxTileMap
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.MultiKey" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/MultiKey.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<key public="1"><x path="Int"/></key>
		<combos public="1"><c path="Array"><x path="Int"/></c></combos>
		<forbiddens public="1"><c path="Array"><x path="Int"/></c></forbiddens>
		<destroy public="1" set="method" line="25"><f a=""><x path="Void"/></f></destroy>
		<justPressed public="1" set="method" line="38">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Was the main key JUST pressed, AND are all of the combo keys currently pressed? (and none of the forbiddens?)
	 * @return</haxe_doc>
		</justPressed>
		<justReleased public="1" set="method" line="51">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Was the main key JUST released, AND are no forbidden keys currently pressed? (Ignore whether combos were just released)
	 * @return</haxe_doc>
		</justReleased>
		<pressed public="1" set="method" line="64">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Is the main key and all of the combo keys currently pressed? (and none of the forbiddens?)
	 * @return</haxe_doc>
		</pressed>
		<equals public="1" set="method" line="72"><f a="other">
	<c path="flixel.addons.ui.MultiKey"/>
	<x path="Bool"/>
</f></equals>
		<_justReleased>
			<x path="Bool"/>
			<haxe_doc>*******PRIVATE*******</haxe_doc>
		</_justReleased>
		<passCombosAndForbiddens set="method" line="111">
			<f a="?comboValue:?forbiddenValue" v="true:false">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check Combo/Forbidden values. Default--are combos all pressed, AND are forbiddens all NOT pressed?
	 * @return</haxe_doc>
		</passCombosAndForbiddens>
		<checkCombos set="method" line="116"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></checkCombos>
		<checkForbiddens set="method" line="130"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></checkForbiddens>
		<new public="1" set="method" line="18"><f a="Key:?Combos:?Forbiddens" v=":null:null">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Makes it easier to check if, say, SHIFT+Tab is being pressed rather than just Tab by itself
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.StrIdLabel" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/StrIdLabel.hx">
		<sortByLabel public="1" set="method" line="22" static="1"><f a="a:b">
	<c path="flixel.addons.ui.StrIdLabel"/>
	<c path="flixel.addons.ui.StrIdLabel"/>
	<x path="Int"/>
</f></sortByLabel>
		<sortById public="1" set="method" line="28" static="1"><f a="a:b">
	<c path="flixel.addons.ui.StrIdLabel"/>
	<c path="flixel.addons.ui.StrIdLabel"/>
	<x path="Int"/>
</f></sortById>
		<id public="1"><c path="String"/></id>
		<label public="1"><c path="String"/></label>
		<copy public="1" set="method" line="18"><f a=""><c path="flixel.addons.ui.StrIdLabel"/></f></copy>
		<new public="1" set="method" line="12"><f a="?Id:?Label" v="'':''">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author</haxe_doc>
	</class>
	<class path="flixel.addons.ui.SwatchData" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/SwatchData.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<name public="1"><c path="String"/></name>
		<colors public="1"><c path="Array"><x path="Int"/></c></colors>
		<hilight public="1" get="accessor" set="accessor"><x path="Int"/></hilight>
		<midtone public="1" get="accessor" set="accessor"><x path="Int"/></midtone>
		<shadowMid public="1" get="accessor" set="accessor"><x path="Int"/></shadowMid>
		<shadowDark public="1" get="accessor" set="accessor"><x path="Int"/></shadowDark>
		<setColor public="1" set="method" line="19"><f a="i:Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></setColor>
		<getColor public="1" set="method" line="25"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></getColor>
		<get_hilight set="method" line="34">
			<f a=""><x path="Int"/></f>
			<haxe_doc>GETTERs/SETTERS</haxe_doc>
		</get_hilight>
		<set_hilight set="method" line="37"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_hilight>
		<get_midtone set="method" line="43"><f a=""><x path="Int"/></f></get_midtone>
		<set_midtone set="method" line="46"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_midtone>
		<get_shadowMid set="method" line="52"><f a=""><x path="Int"/></f></get_shadowMid>
		<set_shadowMid set="method" line="55"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_shadowMid>
		<get_shadowDark set="method" line="61"><f a=""><x path="Int"/></f></get_shadowDark>
		<set_shadowDark set="method" line="64"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_shadowDark>
		<destroy public="1" set="method" line="70"><f a=""><x path="Void"/></f></destroy>
		<copy public="1" set="method" line="88"><f a=""><c path="flixel.addons.ui.SwatchData"/></f></copy>
		<toString public="1" set="method" line="94"><f a=""><c path="String"/></f></toString>
		<getRawDifference public="1" set="method" line="115"><f a="?other:?otherColors" v="null:null">
	<c path="flixel.addons.ui.SwatchData"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
</f></getRawDifference>
		<doColorsEqual public="1" set="method" line="159"><f a="?other:?otherColors" v="null:null">
	<c path="flixel.addons.ui.SwatchData"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Bool"/>
</f></doColorsEqual>
		<getRGBdelta set="method" line="186"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getRGBdelta>
		<new public="1" set="method" line="79"><f a="Name:?Colors" v=":null">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Lars A. Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.U" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/U.hx">
		<xml_str public="1" set="method" line="39" static="1">
			<f a="data:att:?lower_case:?default_str" v="::false:''">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Safety wrapper for reading a string attribute from xml
	 * @param	data the Xml object
	 * @param	att the name of the attribute
	 * @param	lower_case force lower_case or not
	 * @param   what to return if it is ""
	 * @return  the attribute as a string if it exists, otherwise returns ""</haxe_doc>
		</xml_str>
		<perc_to_float public="1" set="method" line="55" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* If a string is a number that ends with a % sign, it will return a normalized percent float (0-100% = 0.0-1.0)
	 * @param  str a percentage value, such as "5%" or "236.214%"
	 * @return a normalized float, or NaN if not valid input</haxe_doc>
		</perc_to_float>
		<isStrNum public="1" set="method" line="71" static="1"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></isStrNum>
		<isStrInt public="1" set="method" line="82" static="1"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></isStrInt>
		<isStrFloat public="1" set="method" line="93" static="1"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></isStrFloat>
		<xml_f public="1" set="method" line="112" static="1">
			<f a="data:att:?default_" v="::0">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Safety wrapper for reading a float attribute from xml
	 * @param	data the Xml object
	 * @param	att the name of the attribute
	 * @param 	default_ what to return if the value doesn't exist
	 * @return  the attribute as a float if it exists, otherwise returns 0</haxe_doc>
		</xml_f>
		<xml_i public="1" set="method" line="126" static="1">
			<f a="data:att:?default_" v="::0">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Safety wrapper for reading an int attribute from xml
	 * @param	data the Xml object
	 * @param	att the name of the attribute
	 * @param 	default_ what to return if the value doesn't exist
	 * @return  the attribute as an int if it exists, otherwise returns 0</haxe_doc>
		</xml_i>
		<xml_bool public="1" set="method" line="140" static="1">
			<f a="data:att:?default_" v="::false">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Safety wrapper for reading a bool attribute from xml
	 * @param	data the Xml object
	 * @param	att the name of the attribute
	 * @param   what to return if the value doesn't exist
	 * @return  true if att is "true" (case-insensitive) or "1", otherwise false</haxe_doc>
		</xml_bool>
		<xml_gfx public="1" get="inline" set="null" line="152" static="1"><f a="data:att:?test" v="::true">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></xml_gfx>
		<center public="1" get="inline" set="null" line="184" static="1">
			<f a="fb1:fb2:?centerX:?centerY" v="::true:true">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Center fb2 on fb1's center point
	 * @param	fb1	a FlxObject (does not move)
	 * @param	fb2 a FlxObject (center on fb1)
	 * @param 	centerX center X axis?
	 * @param 	centerY center Y axis?</haxe_doc>
		</center>
		<test_int public="1" get="inline" set="null" line="202" static="1"><f a="i1:test:i2">
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></test_int>
		<test_float public="1" get="inline" set="null" line="215" static="1"><f a="f1:test:f2">
	<x path="Float"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></test_float>
		<padDigits public="1" get="inline" set="null" line="266" static="1">
			<f a="i:d">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a numeric string with leading zeroes
	 * @param	i any integer
	 * @param	d how many digits
	 * @return  i's value as a string padded with zeroes, exactly d digits in length</haxe_doc>
		</padDigits>
		<parseHex public="1" get="inline" set="null" line="297" static="1">
			<f a="str:?cast32Bit:?safe:?default_color" v=":false:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Parses hex string to equivalent integer, with safety checks
	 * @param	hex_str string in format 0xRRGGBB or 0xAARRGGBB
	 * @param	cast32Bit add an alpha channel if none is given
	 * @param	safe don't throw errors, just return -1
	 * @param 	default_color what to return if safe is true and it fails
	 * @return integer value</haxe_doc>
		</parseHex>
		<hexChar2dec public="1" get="inline" set="null" line="333" static="1">
			<f a="hex_char">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Parses an individual hexadecimal string character to the equivalent decimal integer value
	 * @param	hex_char hexadecimal character (1-length string)
	 * @return  decimal value of hex_char</haxe_doc>
		</hexChar2dec>
		<hex2dec get="inline" set="null" line="356" static="1">
			<f a="hex_str">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Parses hex string to equivalent integer
	 * @param	hex_str string in format RRGGBB or AARRGGBB (no "0x")
	 * @return integer value</haxe_doc>
		</hex2dec>
		<hex2rgb public="1" get="inline" set="null" line="376" static="1">
			<f a="hex">
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Parses hex pixel value into a 3-length array of [r,g,b] ints
	 * @param	hex
	 * @return</haxe_doc>
		</hex2rgb>
		<rgb2hex public="1" get="inline" set="null" line="390" static="1">
			<f a="r:g:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the hex pixel value of 3 r, g, b ints
	 * @param	r
	 * @param	g
	 * @param	b
	 * @return</haxe_doc>
		</rgb2hex>
		<interpolate public="1" get="inline" set="null" line="402" static="1">
			<f a="hex1:hex2:amt">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns a color somewhere between the given two. 
	 * @param	hex1 A hexadecimal color
	 * @param	hex2 A hexadecimal color
	 * @param	amt 0=100% hex1, 1=100% hex2, 0.5=50% of each
	 * @return</haxe_doc>
		</interpolate>
		<getLocList public="1" get="inline" set="null" line="438" static="1"><f a="xmin:ymin:xmax:ymax">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="flixel.util.FlxPoint"/></c>
</f></getLocList>
		<disposeXML public="1" get="inline" set="null" line="447" static="1"><f a="thing">
	<d/>
	<x path="Void"/>
</f></disposeXML>
		<copyFast public="1" get="inline" set="null" line="461" static="1"><f a="fast">
	<c path="haxe.xml.Fast"/>
	<c path="haxe.xml.Fast"/>
</f></copyFast>
		<copyXml public="1" get="inline" set="null" line="465" static="1"><f a="data">
	<c path="Xml"/>
	<c path="Xml"/>
</f></copyXml>
		<readXml public="1" set="method" line="470" static="1"><f a="path">
	<c path="String"/>
	<c path="Xml"/>
</f></readXml>
		<readFast public="1" set="method" line="478" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.xml.Fast"/>
</f></readFast>
		<writeXml public="1" set="method" line="487" static="1"><f a="data:path:?wrapData:?addHeader" v="::true:true">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></writeXml>
		<getXML public="1" set="method" line="516" static="1"><f a="str:?folder" v=":''">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></getXML>
		<json public="1" set="method" line="524" static="1"><f a="str:?extension:?dir" v=":'json':'assets/json/'">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></json>
		<field public="1" set="method" line="533" static="1"><f a="object:field:?_default" v="::null">
	<d/>
	<c path="String"/>
	<d/>
	<d/>
</f></field>
		<xml public="1" set="method" line="545" static="1"><f a="id:?extension:?getFast:?dir" v=":'xml':true:'assets/xml/'">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
	<d/>
</f></xml>
		<clearArraySoft public="1" set="method" line="566" static="1">
			<f a="array">
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* This will remove an array structure, but will leave its contents untouched.
	 * This can lead to memory leaks! Only use this when you want an array gone but
	 * you still need the original elements and know what you're doing.
	 * @param	array</haxe_doc>
		</clearArraySoft>
		<clearArray public="1" set="method" line="580" static="1">
			<f a="array">
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* This will MURDER an array, removing all traces of both it and its contents
	 * @param	array</haxe_doc>
		</clearArray>
		<destroyThing public="1" set="method" line="590" static="1"><f a="thing">
	<d/>
	<x path="Void"/>
</f></destroyThing>
		<fontStr public="1" get="inline" set="null" line="607" static="1"><f a="str:?style" v=":''">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fontStr>
		<font public="1" get="inline" set="null" line="611" static="1"><f a="str:?style" v=":''">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></font>
		<_font get="inline" set="null" line="619" static="1"><f a="str:?style" v=":''">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></_font>
		<fsx public="1" get="inline" set="null" line="635" static="1"><f a="data">
	<d/>
	<c path="flixel.addons.ui.FlxUISprite"/>
</f></fsx>
		<fs public="1" get="inline" set="null" line="639" static="1"><f a="data">
	<d/>
	<c path="flixel.FlxSprite"/>
</f></fs>
		<FU public="1" set="method" line="643" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></FU>
		<checkHaxedef public="1" set="method" line="647" static="1"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></checkHaxedef>
		<copy_shallow_arr public="1" set="method" line="702" static="1"><f a="src">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></copy_shallow_arr>
		<copy_shallow_arr_i public="1" set="method" line="715" static="1"><f a="src">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></copy_shallow_arr_i>
		<copy_shallow_arr_str public="1" set="method" line="725" static="1"><f a="src">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></copy_shallow_arr_str>
		<FU_ public="1" set="method" line="735" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></FU_>
		<blendModeFromString public="1" set="method" line="747" static="1"><f a="str">
	<c path="String"/>
	<e path="flash.display.BlendMode"/>
</f></blendModeFromString>
		<gfx public="1" set="method" line="773" static="1"><f a="id:?dir1:?dir2:?dir3:?dir4:?suppressError" v=":'':'':'':'':false">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></gfx>
		<bmpToCSVLayer public="1" set="method" line="836" static="1">
			<f a="color_index:bd">
				<x path="Int"/>
				<c path="flash.display.BitmapData"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts a PNG file to a comma-separated string.
	* pixels that match color_index are flagged
	* others are ignored
	* must be a PERFECT MATCH
	* 
	* @param   color_index   The matching color index
	* 
	* @return	A comma-separated string containing the level data in a FlxTilemap-friendly format.</haxe_doc>
		</bmpToCSVLayer>
		<get_gfx public="1" set="method" line="878" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></get_gfx>
		<sfx public="1" get="inline" set="null" line="886" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></sfx>
		<intStr_to_arr public="1" get="inline" set="null" line="906" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Converts a comma and hyphen list string of numbers to an int array
	 * @param	str input, ex: "1,2,3", "2-4", "1,2,3,5-10"
	 * @return int array, ex: [1,2,3], [2,3,4], [1,2,3,5,6,7,8,9,10]</haxe_doc>
		</intStr_to_arr>
		<intStr_to_arrStr public="1" get="inline" set="null" line="936" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>* Converts a comma and hyphen list string of numbers to a String array
	 * @param	str input, ex: "1,2,3", "2-4", "1,2,3,5-10"
	 * @return int array, ex: [1,2,3], [2,3,4], [1,2,3,5,6,7,8,9,10]</haxe_doc>
		</intStr_to_arrStr>
		<dirStr public="1" get="inline" set="null" line="960" static="1"><f a="XX:YY">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></dirStr>
		<obj_direction public="1" get="inline" set="null" line="979" static="1"><f a="a:b">
	<c path="flixel.FlxObject"/>
	<c path="flixel.FlxObject"/>
	<c path="flixel.util.FlxPoint"/>
</f></obj_direction>
		<circle_test public="1" get="inline" set="null" line="993" static="1"><f a="x1:y1:r1:x2:y2:r2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></circle_test>
		<point_circle_test public="1" get="inline" set="null" line="1001" static="1"><f a="x:y:cx:cy:r">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></point_circle_test>
		<aabb_test_mult public="1" get="inline" set="null" line="1008" static="1"><f a="a:b:?multA:?multB" v="::1:1">
	<c path="flixel.FlxObject"/>
	<c path="flixel.FlxObject"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></aabb_test_mult>
		<aabb_test public="1" get="inline" set="null" line="1033" static="1"><f a="a:b">
	<c path="flixel.FlxObject"/>
	<c path="flixel.FlxObject"/>
	<x path="Bool"/>
</f></aabb_test>
		<bitStringDimensions public="1" get="inline" set="null" line="1057" static="1">
			<f a="str">
				<c path="String"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc>* Get the dimensions of a bit string
	 * @param	str
	 * @return</haxe_doc>
		</bitStringDimensions>
		<splitBitString public="1" get="inline" set="null" line="1075" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Splits a binary string with endlines into a big long int array
	 * @param	str
	 * @return</haxe_doc>
		</splitBitString>
		<getShortTextFromFlxKeyText public="1" set="method" line="1091" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></getShortTextFromFlxKeyText>
		<getFlxKeyTextFromShortText public="1" set="method" line="1161" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></getFlxKeyTextFromShortText>
		<formatXml public="1" set="method" line="1230" static="1"><f a="_xml">
	<c path="Xml"/>
	<c path="String"/>
</f></formatXml>
		<strCase public="1" set="method" line="1269" static="1"><f a="str:code">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></strCase>
		<haxe_doc>* Utility functions, inlined where possible
 * @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.ui.interfaces.IFireTongue" params="" file="C:\HaxeToolkit\haxe\lib/flixel-ui/git/flixel/addons/ui/interfaces/IFireTongue.hx" interface="1">
		<get public="1" set="method"><f a="flag:?context:?safe">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></get>
		<locale public="1" get="accessor" set="null"><c path="String"/></locale>
		<get_locale public="1" set="method"><f a=""><c path="String"/></f></get_locale>
		<haxe_doc>* An interface to match FireTongue, so we can use this without making
 * a full dependency
 * @author Lars Doucet</haxe_doc>
	</class>
	<class path="flixel.addons.util.FlxAsyncLoop" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/util/FlxAsyncLoop.hx">
		<extends path="flixel.FlxBasic"/>
		<started public="1" set="null"><x path="Bool"/></started>
		<finished public="1" set="null"><x path="Bool"/></finished>
		<_curIndex><x path="Int"/></_curIndex>
		<_iterationsPerUpdate><x path="Int"/></_iterationsPerUpdate>
		<_iterations><x path="Int"/></_iterations>
		<_callback><f a=""><x path="Void"/></f></_callback>
		<start public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Start the loop (if it's not already started or finished)</haxe_doc>
		</start>
		<update public="1" set="method" line="48" override="1"><f a=""><x path="Void"/></f></update>
		<destroy public="1" set="method" line="66" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="27">
			<f a="Iterations:Callback:?IterationsPerUpdate" v="::100">
				<x path="Int"/>
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates an instance of the FlxAsyncLoop class, used to do a loop while still allowing update() to get called and the screen to refresh.
	 * 
	 * @param	Iterations		How many total times should it loop
	 * @param	Callback		The function that should be called each loop
	 * @param	IterationsPerUpdate	Optional: how many loops before we allow an update() - defaults to 100.</haxe_doc>
		</new>
		<haxe_doc>* Special class for asynchonously performing a loop.
 * @author Timothy Ian Hely / SeiferTim</haxe_doc>
	</class>
	<class path="flixel.addons.util.PNGEncoder" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/util/PNGEncoder.hx">
		<crcTable static="1"><c path="Array"><x path="Int"/></c></crcTable>
		<crcTableComputed static="1"><x path="Bool"/></crcTableComputed>
		<encode public="1" set="method" line="56" static="1">
			<f a="img">
				<c path="flash.display.BitmapData"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<haxe_doc>* Created a PNG image from the specified BitmapData
	 *
	 * @param image The BitmapData that will be converted into the PNG format.
	 * @return a ByteArray representing the PNG encoded image data.
	 * @langversion ActionScript 3.0
	 * @playerversion Flash 9.0
	 * @tiptext</haxe_doc>
		</encode>
		<writeChunk set="method" line="102" static="1"><f a="png:type:data">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></writeChunk>
		<haxe_doc>* Class that converts BitmapData into a valid PNG</haxe_doc>
	</class>
	<class path="flixel.addons.weapon.FlxBullet" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/weapon/FlxBullet.hx">
		<extends path="flixel.FlxSprite"/>
		<accelerates public="1"><x path="Bool"/></accelerates>
		<xAcceleration public="1"><x path="Int"/></xAcceleration>
		<yAcceleration public="1"><x path="Int"/></yAcceleration>
		<rndFactorAngle public="1"><x path="Int"/></rndFactorAngle>
		<rndFactorSpeed public="1"><x path="Int"/></rndFactorSpeed>
		<rndFactorLifeSpan public="1"><x path="Int"/></rndFactorLifeSpan>
		<lifespan public="1"><x path="Float"/></lifespan>
		<_weapon><c path="flixel.addons.weapon.FlxWeapon"/></_weapon>
		<_animated><x path="Bool"/></_animated>
		<_bulletSpeed><x path="Int"/></_bulletSpeed>
		<addAnimation public="1" set="method" line="52">
			<f a="Name:Frames:?FrameRate:?Looped" v="::0:true">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new animation to the sprite.
	 * 
	 * @param	Name		What this animation should be called (e.g. "run").
	 * @param	Frames		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3).
	 * @param	FrameRate	The speed in frames per second that the animation should play at (e.g. 40 fps).
	 * @param	Looped		Whether or not the animation is looped or just plays once.</haxe_doc>
		</addAnimation>
		<fire public="1" set="method" line="59"><f a="FromX:FromY:VelX:VelY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fire>
		<fireAtMouse public="1" set="method" line="79"><f a="FromX:FromY:Speed:?RotateBulletTowards" v=":::true">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></fireAtMouse>
		<fireAtTouch public="1" set="method" line="103"><f a="FromX:FromY:Touch:Speed:?RotateBulletTowards" v="::::true">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.input.touch.FlxTouch"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></fireAtTouch>
		<fireAtPosition public="1" set="method" line="126"><f a="FromX:FromY:ToX:ToY:Speed">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fireAtPosition>
		<fireAtTarget public="1" set="method" line="143"><f a="FromX:FromY:Target:Speed">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fireAtTarget>
		<fireFromAngle public="1" set="method" line="160"><f a="FromX:FromY:FireAngle:Speed">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fireFromAngle>
		<postFire set="method" line="181"><f a=""><x path="Void"/></f></postFire>
		<update public="1" set="method" line="217" override="1"><f a=""><x path="Void"/></f></update>
		<new public="1" set="method" line="34"><f a="Weapon:WeaponID">
	<c path="flixel.addons.weapon.FlxWeapon"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @link http://www.photonstorm.com
 * @link http://www.haxeflixel.com
 * @author Richard Davey / Photon Storm
 * @author Touch added by Impaler / Beeblerox</haxe_doc>
	</class>
	<class path="flixel.addons.weapon.FlxWeapon" params="" file="C:\HaxeToolkit\haxe\lib/flixel-addons/git/flixel/addons/weapon/FlxWeapon.hx">
		<BULLET_UP public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></BULLET_UP>
		<BULLET_DOWN public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></BULLET_DOWN>
		<BULLET_LEFT public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></BULLET_LEFT>
		<BULLET_RIGHT public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></BULLET_RIGHT>
		<BULLET_NORTH_EAST public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></BULLET_NORTH_EAST>
		<BULLET_NORTH_WEST public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></BULLET_NORTH_WEST>
		<BULLET_SOUTH_EAST public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></BULLET_SOUTH_EAST>
		<BULLET_SOUTH_WEST public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></BULLET_SOUTH_WEST>
		<FIRE get="inline" set="null" line="101" static="1"><x path="Int"/></FIRE>
		<FIRE_AT_MOUSE get="inline" set="null" line="102" static="1"><x path="Int"/></FIRE_AT_MOUSE>
		<FIRE_AT_POSITION get="inline" set="null" line="103" static="1"><x path="Int"/></FIRE_AT_POSITION>
		<FIRE_AT_TARGET get="inline" set="null" line="104" static="1"><x path="Int"/></FIRE_AT_TARGET>
		<FIRE_FROM_ANGLE get="inline" set="null" line="105" static="1"><x path="Int"/></FIRE_FROM_ANGLE>
		<FIRE_FROM_PARENT_ANGLE get="inline" set="null" line="106" static="1"><x path="Int"/></FIRE_FROM_PARENT_ANGLE>
		<FIRE_AT_TOUCH get="inline" set="null" line="107" static="1"><x path="Int"/></FIRE_AT_TOUCH>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Internal name for this weapon (i.e. "pulse rifle")</haxe_doc>
		</name>
		<group public="1">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.addons.weapon.FlxBullet"/></c>
			<haxe_doc>* The FlxGroup into which all the bullets for this weapon are drawn. This should be added to your display and collision checked against it.</haxe_doc>
		</group>
		<bulletType>
			<x path="Class"><c path="flixel.addons.weapon.FlxBullet"/></x>
			<haxe_doc>* The bullet class associated with this weapon</haxe_doc>
		</bulletType>
		<bulletID>
			<x path="Int"/>
			<haxe_doc>* Optional ID applied to the bullets. Useful for determining 
	 * what kind of bullet it is in collision functions</haxe_doc>
		</bulletID>
		<nextFire public="1"><x path="Int"/></nextFire>
		<fireRate public="1"><x path="Int"/></fireRate>
		<bulletSpeed public="1"><x path="Int"/></bulletSpeed>
		<bounds public="1"><c path="flixel.util.FlxRect"/></bounds>
		<parent public="1"><c path="flixel.FlxSprite"/></parent>
		<multiShot public="1"><x path="Int"/></multiShot>
		<bulletLifeSpan public="1"><x path="Float"/></bulletLifeSpan>
		<bulletDamage public="1"><x path="Float"/></bulletDamage>
		<bulletElasticity public="1"><x path="Float"/></bulletElasticity>
		<rndFactorAngle public="1"><x path="Int"/></rndFactorAngle>
		<rndFactorSpeed public="1"><x path="Int"/></rndFactorSpeed>
		<rndFactorLifeSpan public="1"><x path="Float"/></rndFactorLifeSpan>
		<rndFactorPosition public="1"><c path="flixel.util.FlxPoint"/></rndFactorPosition>
		<currentBullet public="1">
			<c path="flixel.addons.weapon.FlxBullet"/>
			<haxe_doc>* A reference to the Bullet that was fired</haxe_doc>
		</currentBullet>
		<onPreFireCallback public="1"><f a=""><x path="Void"/></f></onPreFireCallback>
		<onFireCallback public="1"><f a=""><x path="Void"/></f></onFireCallback>
		<onPostFireCallback public="1"><f a=""><x path="Void"/></f></onPostFireCallback>
		<onPreFireSound public="1"><c path="flixel.system.FlxSound"/></onPreFireSound>
		<onFireSound public="1"><c path="flixel.system.FlxSound"/></onFireSound>
		<onPostFireSound public="1"><c path="flixel.system.FlxSound"/></onPostFireSound>
		<_rotateToAngle><x path="Bool"/></_rotateToAngle>
		<_velocity><c path="flixel.util.FlxPoint"/></_velocity>
		<_fireFromPosition><x path="Bool"/></_fireFromPosition>
		<_fireX><x path="Int"/></_fireX>
		<_fireY><x path="Int"/></_fireY>
		<_lastFired><x path="Int"/></_lastFired>
		<_touchTarget><c path="flixel.input.touch.FlxTouch"/></_touchTarget>
		<_fireFromParent><x path="Bool"/></_fireFromParent>
		<_positionOffset><c path="flixel.util.FlxPoint"/></_positionOffset>
		<_directionFromParent><x path="Bool"/></_directionFromParent>
		<_angleFromParent><x path="Bool"/></_angleFromParent>
		<_bulletsFired>
			<x path="Int"/>
			<haxe_doc>* Keeps a tally of how many bullets have been fired by this weapon</haxe_doc>
		</_bulletsFired>
		<_currentMagazine><x path="Int"/></_currentMagazine>
		<_magazineCount><x path="Int"/></_magazineCount>
		<_bulletsPerMagazine><x path="Int"/></_bulletsPerMagazine>
		<_magazineSwapDelay><x path="Int"/></_magazineSwapDelay>
		<_skipParentCollision><x path="Bool"/></_skipParentCollision>
		<_magazineSwapCallback><d/></_magazineSwapCallback>
		<_magazineSwapSound><c path="flixel.system.FlxSound"/></_magazineSwapSound>
		<makePixelBullet public="1" set="method" line="182">
			<f a="Quantity:?Width:?Height:?Color:?OffsetX:?OffsetY" v=":2:2:-1:0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Makes a pixel bullet sprite (rather than an image). You can set the width/height and color of the bullet.
	 * 
	 * @param	Quantity	How many bullets do you need to make? This value should be high enough to cover all bullets you need on-screen *at once* plus probably a few extra spare!
	 * @param	Width		The width (in pixels) of the bullets
	 * @param	Height		The height (in pixels) of the bullets
	 * @param	Color		The color of the bullets. Must be given in 0xAARRGGBB format
	 * @param	OffsetX		When the bullet is fired if you need to offset it on the x axis, for example to line it up with the "nose" of a space ship, set the amount here (positive or negative)
	 * @param	OffsetY		When the bullet is fired if you need to offset it on the y axis, for example to line it up with the "nose" of a space ship, set the amount here (positive or negative)</haxe_doc>
		</makePixelBullet>
		<makeImageBullet public="1" set="method" line="210">
			<f a="Quantity:Image:?OffsetX:?OffsetY:?AutoRotate:?Rotations:?Frame:?AntiAliasing:?AutoBuffer" v="::0:0:false:16:-1:false:false">
				<x path="Int"/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Makes a bullet sprite from the given image. It will use the width/height of the image.
	 * 
	 * @param	Quantity		How many bullets do you need to make? This value should be high enough to cover all bullets you need on-screen *at once* plus probably a few extra spare!
	 * @param	Image			The image used to create the bullet from
	 * @param	OffsetX			When the bullet is fired if you need to offset it on the x axis, for example to line it up with the "nose" of a space ship, set the amount here (positive or negative)
	 * @param	OffsetY			When the bullet is fired if you need to offset it on the y axis, for example to line it up with the "nose" of a space ship, set the amount here (positive or negative)
	 * @param	AutoRotate		When true the bullet sprite will rotate to match the angle of the parent sprite. Call fireFromParentAngle or fromFromAngle to fire it using an angle as the velocity.
	 * @param	Frame			If the image has a single row of square animation frames on it, you can specify which of the frames you want to use here. Default is -1, or "use whole graphic"
	 * @param	Rotations		The number of rotation frames the final sprite should have.  For small sprites this can be quite a large number (360 even) without any problems.
	 * @param	AntiAliasing	Whether to use high quality rotations when creating the graphic. Default is false.
	 * @param	AutoBuffer		Whether to automatically increase the image size to accomodate rotated corners. Default is false. Will create frames that are 150% larger on each axis than the original frame or graphic.</haxe_doc>
		</makeImageBullet>
		<makeAnimatedBullet public="1" set="method" line="254">
			<f a="Quantity:ImageSequence:FrameWidth:FrameHeight:Frames:FrameRate:Looped:?OffsetX:?OffsetY" v=":::::::0:0">
				<x path="Int"/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Makes an animated bullet from the image and frame data given.
	 * 
	 * @param	Quantity		How many bullets do you need to make? This value should be high enough to cover all bullets you need on-screen *at once* plus probably a few extra spare!
	 * @param	ImageSequence	The image used to created the animated bullet from
	 * @param	FrameWidth		The width of each frame in the animation
	 * @param	FrameHeight		The height of each frame in the animation
	 * @param	Frames			An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3)
	 * @param	FrameRate		The speed in frames per second that the animation should play at (e.g. 40 fps)
	 * @param	Looped			Whether or not the animation is looped or just plays once
	 * @param	OffsetX			When the bullet is fired if you need to offset it on the x axis, for example to line it up with the "nose" of a space ship, set the amount here (positive or negative)
	 * @param	OffsetY			When the bullet is fired if you need to offset it on the y axis, for example to line it up with the "nose" of a space ship, set the amount here (positive or negative)</haxe_doc>
		</makeAnimatedBullet>
		<runFire set="method" line="281">
			<f a="Method:?X:?Y:?Target:?Angle" v=":0:0:null:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Internal function that handles the actual firing of the bullets
	 * 
	 * @param	Method
	 * @param	X
	 * @param	Y
	 * @param	Target
	 * @return	True if a bullet was fired or false if one wasn't available. The bullet last fired is stored in FlxWeapon.prevBullet</haxe_doc>
		</runFire>
		<fire public="1" get="inline" set="null" line="389">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Fires a bullet (if one is available). The bullet will be given the velocity defined in setBulletDirection and fired at the rate set in setFireRate.
	 * 
	 * @return	True if a bullet was fired or false if one wasn't available. A reference to the bullet fired is stored in FlxWeapon.currentBullet.</haxe_doc>
		</fire>
		<fireAtMouse public="1" get="inline" set="null" line="400">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Fires a bullet (if one is available) at the mouse coordinates, using the speed set in setBulletSpeed and the rate set in setFireRate.
	 * 
	 * @return	True if a bullet was fired or false if one wasn't available. A reference to the bullet fired is stored in FlxWeapon.currentBullet.</haxe_doc>
		</fireAtMouse>
		<fireAtTouch public="1" set="method" line="413">
			<f a="?Touch" v="null">
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Fires a bullet (if one is available) at the FlxTouch coordinates, using the speed set in setBulletSpeed and the rate set in setFireRate.
	 * 
	 * @param	Touch	The FlxTouch object to fire at, if null use the first available one
	 * @return	True if a bullet was fired or false if one wasn't available. A reference to the bullet fired is stored in FlxWeapon.currentBullet.</haxe_doc>
		</fireAtTouch>
		<fireAtPosition public="1" get="inline" set="null" line="443">
			<f a="X:Y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Fires a bullet (if one is available) at the given x/y coordinates, using the speed set in setBulletSpeed and the rate set in setFireRate.
	 * 
	 * @param	X	The x coordinate (in game world pixels) to fire at
	 * @param	Y	The y coordinate (in game world pixels) to fire at
	 * @return	True if a bullet was fired or false if one wasn't available. A reference to the bullet fired is stored in FlxWeapon.currentBullet.</haxe_doc>
		</fireAtPosition>
		<fireAtTarget public="1" get="inline" set="null" line="454">
			<f a="Target">
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Fires a bullet (if one is available) at the given targets x/y coordinates, using the speed set in setBulletSpeed and the rate set in setFireRate.
	 * 
	 * @param	Target	The FlxSprite you wish to fire the bullet at
	 * @return	True if a bullet was fired or false if one wasn't available. A reference to the bullet fired is stored in FlxWeapon.currentBullet.</haxe_doc>
		</fireAtTarget>
		<fireFromAngle public="1" get="inline" set="null" line="465">
			<f a="Angle">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Fires a bullet (if one is available) based on the given angle
	 * 
	 * @param	Angle	The angle (in degrees) calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * @return	True if a bullet was fired or false if one wasn't available. A reference to the bullet fired is stored in FlxWeapon.currentBullet.</haxe_doc>
		</fireFromAngle>
		<fireFromParentAngle public="1" get="inline" set="null" line="475">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Fires a bullet (if one is available) based on the angle of the Weapons parent
	 * 
	 * @return	True if a bullet was fired or false if one wasn't available. A reference to the bullet fired is stored in FlxWeapon.currentBullet.</haxe_doc>
		</fireFromParentAngle>
		<setParent public="1" set="method" line="488">
			<f a="ParentRef:?OffsetX:?OffsetY:?UseDirection" v=":0:0:false">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Causes the Weapon to fire from the parents x/y value, as seen in Space Invaders and most shoot-em-ups.
	 * 
	 * @param	ParentRef		If this weapon belongs to a parent sprite, specify it here (bullets will fire from the sprites x/y vars as defined below).
	 * @param	OffsetX			When the bullet is fired if you need to offset it on the x axis, for example to line it up with the "nose" of a space ship, set the amount here (positive or negative)
	 * @param	OffsetY			When the bullet is fired if you need to offset it on the y axis, for example to line it up with the "nose" of a space ship, set the amount here (positive or negative)
	 * @param	UseDirection	When fired the bullet direction is based on parent sprites facing value (up/down/left/right)</haxe_doc>
		</setParent>
		<setFiringPosition public="1" set="method" line="512">
			<f a="X:Y:?OffsetX:?OffsetY" v="::0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Causes the Weapon to fire from a fixed x/y position on the screen, like in the game Missile Command.
	 * If set this over-rides a call to setParent (which causes the Weapon to fire from the parents x/y position)
	 * 
	 * @param	X			The x coordinate (in game world pixels) to fire from
	 * @param	Y			The y coordinate (in game world pixels) to fire from
	 * @param	OffsetX		When the bullet is fired if you need to offset it on the x axis, for example to line it up with the "nose" of a space ship, set the amount here (positive or negative)
	 * @param	OffsetY		When the bullet is fired if you need to offset it on the y axis, for example to line it up with the "nose" of a space ship, set the amount here (positive or negative)</haxe_doc>
		</setFiringPosition>
		<setBulletSpeed public="1" set="method" line="528">
			<f a="Speed">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The speed in pixels/sec (sq) that the bullet travels at when fired via fireAtMouse, fireAtPosition or fireAtTarget.
	 * You can update this value in real-time, should you need to speed-up or slow-down your bullets (i.e. collecting a power-up)
	 * 
	 * @param	Speed	The speed it will move, in pixels per second (sq)</haxe_doc>
		</setBulletSpeed>
		<getBulletSpeed public="1" set="method" line="538">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* The speed in pixels/sec (sq) that the bullet travels at when fired via fireAtMouse, fireAtPosition or fireAtTarget.
	 * 
	 * @return	The speed the bullet moves at, in pixels per second (sq)</haxe_doc>
		</getBulletSpeed>
		<setFireRate public="1" set="method" line="549">
			<f a="Rate">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the firing rate of the Weapon. By default there is no rate, as it can be controlled by FlxControl.setFireButton.
	 * However if you are firing using the mouse you may wish to set a firing rate.
	 * 
	 * @param	Rate	The delay in milliseconds (ms) between which each bullet is fired, set to zero to clear</haxe_doc>
		</setFireRate>
		<setBulletBounds public="1" set="method" line="560">
			<f a="Bounds">
				<c path="flixel.util.FlxRect"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* When a bullet goes outside of this bounds it will be automatically killed, freeing it up for firing again.
	 * TODO - Needs testing with a scrolling map (when not using single screen display)
	 * 
	 * @param	Bounds	An FlxRect area. Inside this area the bullet should be considered alive, once outside it will be killed.</haxe_doc>
		</setBulletBounds>
		<setBulletDirection public="1" set="method" line="573">
			<f a="Angle:Speed">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the direction the bullet will travel when fired.
	 * You can use one of the consts such as BULLET_UP, BULLET_DOWN or BULLET_NORTH_EAST to set the angle easily.
	 * Speed should be given in pixels/sec (sq) and is the speed at which the bullet travels when fired.
	 * 
	 * @param	angle		The angle of the bullet. In clockwise positive direction: Right = 0, Down = 90, Left = 180, Up = -90. You can use one of the consts such as BULLET_UP, etc
	 * @param	speed		The speed it will move, in pixels per second (sq)</haxe_doc>
		</setBulletDirection>
		<setBulletGravity public="1" set="method" line="585">
			<f a="ForceX:ForceY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets gravity on all currently created bullets
	 * This will update ALL bullets, even those currently "in flight", so be careful about when you call this!
	 * 
	 * @param	ForceX	A positive value applies gravity dragging the bullet to the right. A negative value drags the bullet to the left. Zero disables horizontal gravity.
	 * @param	ForceY	A positive value applies gravity dragging the bullet down. A negative value drags the bullet up. Zero disables vertical gravity.</haxe_doc>
		</setBulletGravity>
		<setBulletAcceleration public="1" set="method" line="603">
			<f a="AccelerationX:AccelerationY:SpeedMaxX:SpeedMaxY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you'd like your bullets to accelerate to their top speed rather than be launched already at it, then set the acceleration value here.
	 * If you've previously set the acceleration then setting it to zero will cancel the effect.
	 * This will update ALL bullets, even those currently "in flight", so be careful about when you call this!
	 * 
	 * @param	AccelerationX		Acceleration speed in pixels per second to apply to the sprites horizontal movement, set to zero to cancel. Negative values move left, positive move right.
	 * @param	AccelerationY		Acceleration speed in pixels per second to apply to the sprites vertical movement, set to zero to cancel. Negative values move up, positive move down.
	 * @param	SpeedMaxX			The maximum speed in pixels per second in which the sprite can move horizontally
	 * @param	SpeedMaxY			The maximum speed in pixels per second in which the sprite can move vertically</haxe_doc>
		</setBulletAcceleration>
		<setBulletOffset public="1" set="method" line="631">
			<f a="OffsetX:OffsetY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* When the bullet is fired from a parent (or fixed position) it will do so from their x/y coordinate.
	 * Often you need to align a bullet with the sprite, i.e. to make it look like it came out of the "nose" of a space ship.
	 * Use this offset x/y value to achieve that effect.
	 * 
	 * @param	OffsetX		The x coordinate offset to add to the launch location (positive or negative)
	 * @param	OffsetY		The y coordinate offset to add to the launch location (positive or negative)</haxe_doc>
		</setBulletOffset>
		<setBulletRandomFactor public="1" set="method" line="645">
			<f a="?RandomAngle:?RandomSpeed:?RandomPosition:?RandomLifeSpan" v="0:0:null:0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* To make the bullet apply a random factor to either its angle, speed, or both when fired, set these values. Can create a nice "scatter gun" effect.
	 * 
	 * @param 	RandomAngle		The +- value applied to the angle when fired. For example 20 means the bullet can fire up to 20 degrees under or over its angle when fired.
	 * @param	RandomSpeed		The +- value applied to the speed when fired. For example 20 means the bullet can fire up to 20 px/sec slower or faster when fired.
	 * @param 	RandomPosition  The +- value applied to the firing location when fired (fire spread).
	 * @param 	RandomLifeSpan  The +- value applied to the bulletLifeSpan when fired. For example passing 2 when bulletLifeSpan is 3, means the bullet can live up to 5 seconds, minimum of 1.</haxe_doc>
		</setBulletRandomFactor>
		<setBulletLifeSpan public="1" set="method" line="664">
			<f a="Lifespan">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If the bullet should have a fixed life span use this function to set it.
	 * The bullet will be killed once it passes this lifespan, if still alive and in bounds.
	 * 
	 * @param	Lifespan  The lifespan of the bullet, given in seconds.</haxe_doc>
		</setBulletLifeSpan>
		<setBulletElasticity public="1" set="method" line="674">
			<f a="Elasticity">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The elasticity of the fired bullet controls how much it rebounds off collision surfaces.
	 * 
	 * @param	Elasticity	The elasticity of the bullet between 0 and 1 (0 being no rebound, 1 being 100% force rebound). Set to zero to disable.</haxe_doc>
		</setBulletElasticity>
		<getFreeBullet set="method" line="684">
			<f a=""><c path="flixel.addons.weapon.FlxBullet"/></f>
			<haxe_doc>* Internal function that returns the next available bullet from the pool (if any)
	 * 
	 * @return	A FlxBullet</haxe_doc>
		</getFreeBullet>
		<setPreFireCallback public="1" set="method" line="716">
			<f a="?Callback:?Sound" v="null:null">
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets a pre-fire callback function and sound. These are played immediately before the bullet is fired.
	 * 
	 * @param	Callback	The function to call
	 * @param	Sound		A FlxSound to play</haxe_doc>
		</setPreFireCallback>
		<setFireCallback public="1" set="method" line="728">
			<f a="?Callback:?Sound" v="null:null">
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets a fire callback function and sound. These are played immediately as the bullet is fired.
	 * 
	 * @param	Callback	The function to call
	 * @param	Sound		A FlxSound to play</haxe_doc>
		</setFireCallback>
		<setPostFireCallback public="1" set="method" line="740">
			<f a="?Callback:?Sound" v="null:null">
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets a post-fire callback function and sound. These are played immediately after the bullet is fired.
	 * 
	 * @param	Callback	The function to call
	 * @param	Sound		An FlxSound to play</haxe_doc>
		</setPostFireCallback>
		<bulletsOverlap public="1" get="inline" set="null" line="753">
			<f a="ObjectOrGroup:?NotifyCallBack:?SkipParent" v=":null:true">
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Checks to see if the bullets are overlapping the specified object or group
	 * 
	 * @param  ObjectOrGroup  	The group or object to check if bullets collide
	 * @param  NotifyCallBack  	A function that will get called if a bullet overlaps an object
	 * @param  SkipParent    	Don't trigger colision notifies with the parent of this object</haxe_doc>
		</bulletsOverlap>
		<shouldBulletHit set="method" line="762"><f a="Object:Bullet">
	<c path="flixel.FlxObject"/>
	<c path="flixel.FlxObject"/>
	<x path="Bool"/>
</f></shouldBulletHit>
		<onBulletHit set="method" line="779"><f a="Object:Bullet">
	<c path="flixel.FlxObject"/>
	<c path="flixel.FlxObject"/>
	<x path="Void"/>
</f></onBulletHit>
		<new public="1" set="method" line="151">
			<f a="Name:?ParentRef:?BulletType:?BulletID" v=":null:null:0">
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
				<x path="Class"><c path="flixel.addons.weapon.FlxBullet"/></x>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates the FlxWeapon class which will fire your bullets.
	 * You should call one of the makeBullet functions to visually create the bullets.
	 * Then either use setDirection with fire() or one of the fireAt functions to launch them.
	 * 
	 * @param	Name		The name of your weapon (i.e. "lazer" or "shotgun"). For your internal reference really, but could be displayed in-game.
	 * @param	ParentRef	If this weapon belongs to a parent sprite, specify it here (bullets will fire from the sprites x/y vars as defined below).
	 * @param	BulletType	Class of the bullet to be associated with this FlxWeapon, must inherit FlxBullet
	 * @param	BulletID	An optional ID for the bullet. Can be accessed through FlxBullet.ID</haxe_doc>
		</new>
		<haxe_doc>* A Weapon can only fire 1 type of bullet. But it can fire many of them at once (in different directions if needed) via createBulletPattern
 * A Player could fire multiple Weapons at the same time however, if you need to layer them up
 * 
 * @version 1.3 - October 9th 2011
 * @link http://www.photonstorm.com
 * @link http://www.haxeflixel.com
 * @author Richard Davey / Photon Storm
 * @author Touch added by Impaler / Beeblerox
 * 
 * TODO: Angled bullets
 * TODO: Baked Rotation support for angled bullets
 * TODO: Bullet death styles (particle effects)
 * TODO: Bullet trails - blur FX style and Missile Command "draw lines" style? (could be another FX plugin)
 * TODO: Homing Missiles
 * TODO: Bullet uses random sprite from sprite sheet (for rainbow style bullets), or cycles through them in sequence?
 * TODO: Some Weapon base classes like shotgun, lazer, etc?</haxe_doc>
	</class>
	<class path="flixel.animation.FlxBaseAnimation" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/animation/FlxBaseAnimation.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<parent public="1">
			<c path="flixel.animation.FlxAnimationController"/>
			<haxe_doc>* Animation controller this animation belongs to</haxe_doc>
		</parent>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* String name of the animation (e.g. "walk")</haxe_doc>
		</name>
		<curIndex public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Keeps track of the current index into the tile sheet based on animation or rotation.
	 * Allow access to private var from FlxAnimationController.</haxe_doc>
		</curIndex>
		<set_curIndex set="method" line="28"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_curIndex>
		<destroy public="1" set="method" line="46"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="52"><f a=""><x path="Void"/></f></update>
		<clone public="1" set="method" line="54"><f a="Parent">
	<c path="flixel.animation.FlxAnimationController"/>
	<c path="flixel.animation.FlxBaseAnimation"/>
</f></clone>
		<new public="1" set="method" line="40"><f a="Parent:Name">
	<c path="flixel.animation.FlxAnimationController"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.animation.FlxAnimation" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/animation/FlxAnimation.hx">
		<extends path="flixel.animation.FlxBaseAnimation"/>
		<frameRate public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Animation frameRate - the speed in frames per second that the animation should play at.</haxe_doc>
		</frameRate>
		<curFrame public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Keeps track of the current frame of animation.
	 * This is NOT an index into the tile sheet, but the frame number in the animation object.</haxe_doc>
		</curFrame>
		<numFrames public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Accesor for frames.length</haxe_doc>
		</numFrames>
		<delay public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Seconds between frames (basically the framerate)</haxe_doc>
		</delay>
		<finished public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the current animation has finished.</haxe_doc>
		</finished>
		<paused public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the current animation gets updated or not.</haxe_doc>
		</paused>
		<looped public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the animation is looped</haxe_doc>
		</looped>
		<_frames>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* A list of frames stored as int objects</haxe_doc>
		</_frames>
		<_frameTimer>
			<x path="Float"/>
			<haxe_doc>* Internal, used to time each frame of animation.</haxe_doc>
		</_frameTimer>
		<destroy public="1" set="method" line="77" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<play public="1" set="method" line="84"><f a="?Force:?Frame" v="false:0">
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></play>
		<restart public="1" set="method" line="120"><f a=""><x path="Void"/></f></restart>
		<stop public="1" set="method" line="125"><f a=""><x path="Void"/></f></stop>
		<update public="1" set="method" line="131" override="1"><f a=""><x path="Void"/></f></update>
		<clone public="1" set="method" line="151" override="1"><f a="Parent">
	<c path="flixel.animation.FlxAnimationController"/>
	<c path="flixel.animation.FlxAnimation"/>
</f></clone>
		<set_frameRate set="method" line="156"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_frameRate>
		<set_curFrame set="method" line="167"><f a="Frame">
	<x path="Int"/>
	<x path="Int"/>
</f></set_curFrame>
		<get_numFrames get="inline" set="null" line="190"><f a=""><x path="Int"/></f></get_numFrames>
		<new public="1" set="method" line="65">
			<f a="Parent:Name:Frames:?FrameRate:?Looped" v=":::0:true">
				<c path="flixel.animation.FlxAnimationController"/>
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	Name		What this animation should be called (e.g. "run")
	 * @param	Frames		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3)
	 * @param	FrameRate	The speed in frames per second that the animation should play at (e.g. 40)
	 * @param	Looped		Whether or not the animation is looped or just plays once</haxe_doc>
		</new>
		<haxe_doc>* Just a helper structure for the FlxSprite animation system.</haxe_doc>
	</class>
	<class path="flixel.animation.FlxAnimationController" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/animation/FlxAnimationController.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<prefixLength line="73" static="1">
			<x path="Int"/>
			<haxe_doc>* Internal helper constants used for _animations's frame sorting.</haxe_doc>
		</prefixLength>
		<postfixLength line="74" static="1"><x path="Int"/></postfixLength>
		<frameSortFunction set="method" line="785" static="1">
			<f a="frame1:frame2">
				<c path="flixel.system.layer.frames.FlxFrame"/>
				<c path="flixel.system.layer.frames.FlxFrame"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Helper frame sorting function used by addAnimationByPrefixFromTexture() method</haxe_doc>
		</frameSortFunction>
		<curAnim public="1" get="accessor" set="accessor">
			<c path="flixel.animation.FlxAnimation"/>
			<haxe_doc>* Property access for currently playing FlxAnimation (warning: can be null).</haxe_doc>
		</curAnim>
		<frameIndex public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Tell the sprite to change to a specific frame of the _curAnim.</haxe_doc>
		</frameIndex>
		<frameName public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Tell the sprite to change to a frame with specific name.
	 * Useful for sprites with loaded TexturePacker atlas.</haxe_doc>
		</frameName>
		<name public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Gets or sets the currently playing _animations (warning: can be null).</haxe_doc>
		</name>
		<paused public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Pause & resume _curAnim.]]></haxe_doc>
		</paused>
		<finished public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Returns whether an _animations is finished playing.</haxe_doc>
		</finished>
		<frames public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The total number of frames in this image.  WARNING: assumes each row in the sprite sheet is full!</haxe_doc>
		</frames>
		<callback public="1">
			<f a="::">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If assigned, will be called each time the current frame changes.
	 * A function that has 3 parameters: a string name, a frame number, and a frame index.</haxe_doc>
		</callback>
		<_sprite>
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Internal, reference to owner sprite.</haxe_doc>
		</_sprite>
		<_curAnim>
			<c path="flixel.animation.FlxAnimation"/>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Internal, currently playing animation.</haxe_doc>
		</_curAnim>
		<_animations set="null">
			<x path="Map">
				<c path="String"/>
				<c path="flixel.animation.FlxAnimation"/>
			</x>
			<haxe_doc>* Internal, store all the _animations that were added to this sprite.</haxe_doc>
		</_animations>
		<_prerotated><c path="flixel.animation.FlxPrerotatedAnimation"/></_prerotated>
		<update public="1" set="method" line="84"><f a=""><x path="Void"/></f></update>
		<copyFrom public="1" set="method" line="96"><f a="controller">
	<c path="flixel.animation.FlxAnimationController"/>
	<c path="flixel.animation.FlxAnimationController"/>
</f></copyFrom>
		<createPrerotated public="1" set="method" line="120"><f a="?Controller" v="null">
	<c path="flixel.animation.FlxAnimationController"/>
	<x path="Void"/>
</f></createPrerotated>
		<destroyAnimations public="1" set="method" line="127"><f a=""><x path="Void"/></f></destroyAnimations>
		<destroy public="1" set="method" line="133"><f a=""><x path="Void"/></f></destroy>
		<clearPrerotated set="method" line="141"><f a=""><x path="Void"/></f></clearPrerotated>
		<clearAnimations set="method" line="150"><f a=""><x path="Void"/></f></clearAnimations>
		<get public="1" set="method" line="173">
			<f a="Name">
				<c path="String"/>
				<c path="flixel.animation.FlxAnimation"/>
			</f>
			<haxe_doc>* Gets an animation by name
	 * @param	Name		The name of the animation.
	 * @return	Animation	FlxAnimation object with the specified name.</haxe_doc>
		</get>
		<add public="1" set="method" line="185">
			<f a="Name:Frames:?FrameRate:?Looped" v="::30:true">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new _animations to the sprite.
	 * @param	Name		What this animation should be called (e.g. "run").
	 * @param	Frames		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3).
	 * @param	FrameRate	The speed in frames per second that the _animations should play at (e.g. 40 fps).
	 * @param	Looped		Whether or not the _animations is looped or just plays once.</haxe_doc>
		</add>
		<append public="1" set="method" line="213">
			<f a="Name:Frames">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to an existing _animations in the sprite by appending the specified frames to the existing frames.
	 * Use this method when the indices of the frames in the atlas are already known.
	 * The animation must already exist in order to append frames to it. FrameRate and Looped are unchanged.
	 * @param	Name		What the existing _animations is called (e.g. "run").
	 * @param	Frames		An array of numbers indicating what frames to append (e.g. 1, 2, 3).</haxe_doc>
		</append>
		<addByNames public="1" set="method" line="245">
			<f a="Name:FrameNames:?FrameRate:?Looped" v="::30:true">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new _animations to the sprite.
	 * @param	Name			What this _animations should be called (e.g. "run").
	 * @param	FrameNames		An array of image names from atlas indicating what frames to play in what order.
	 * @param	FrameRate		The speed in frames per second that the _animations should play at (e.g. 40 fps).
	 * @param	Looped			Whether or not the _animations is looped or just plays once.</haxe_doc>
		</addByNames>
		<appendByNames public="1" set="method" line="267">
			<f a="Name:FrameNames">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to an existing _animations in the sprite by appending the specified frames to the existing frames.
	 * Use this method when the exact name of each frame from the atlas is known (e.g. "walk00.png", "walk01.png").
	 * The animation must already exist in order to append frames to it. FrameRate and Looped are unchanged.
	 * @param	Name			What the existing _animations is called (e.g. "run").
	 * @param	FrameNames		An array of image names from atlas indicating what frames to append.</haxe_doc>
		</appendByNames>
		<addByStringIndices public="1" set="method" line="292">
			<f a="Name:Prefix:Indices:Postfix:?FrameRate:?Looped" v="::::30:true">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new _animations to the sprite. Should works a little bit faster than addByIndices()
	 * @param	Name			What this _animations should be called (e.g. "run").
	 * @param	Prefix			Common beginning of image names in atlas (e.g. "tiles-")
	 * @param	Indices			An array of strings indicating what frames to play in what order (e.g. ["01", "02", "03"]).
	 * @param	Postfix			Common ending of image names in atlas (e.g. ".png")
	 * @param	FrameRate		The speed in frames per second that the _animations should play at (e.g. 40 fps).
	 * @param	Looped			Whether or not the _animations is looped or just plays once.</haxe_doc>
		</addByStringIndices>
		<appendByStringIndices public="1" set="method" line="316">
			<f a="Name:Prefix:Indices:Postfix">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to an existing _animations in the sprite by appending the specified frames to the existing frames. Should works a little bit faster than appendByIndices().
	 * Use this method when the names of each frame from the atlas share a common prefix and postfix (e.g. "walk00.png", "walk01.png").
	 * The animation must already exist in order to append frames to it. FrameRate and Looped are unchanged.
	 * @param	Name			What the existing _animations is called (e.g. "run").
	 * @param	Prefix			Common beginning of image names in atlas (e.g. "tiles-")
	 * @param	Indices			An array of strings indicating what frames to append (e.g. "01", "02", "03").
	 * @param	Postfix			Common ending of image names in atlas (e.g. ".png")</haxe_doc>
		</appendByStringIndices>
		<addByIndices public="1" set="method" line="341">
			<f a="Name:Prefix:Indices:Postfix:?FrameRate:?Looped" v="::::30:true">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new _animations to the sprite.
	 * @param	Name			What this _animations should be called (e.g. "run").
	 * @param	Prefix			Common beginning of image names in atlas (e.g. "tiles-")
	 * @param	Indices			An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3).
	 * @param	Postfix			Common ending of image names in atlas (e.g. ".png")
	 * @param	FrameRate		The speed in frames per second that the _animations should play at (e.g. 40 fps).
	 * @param	Looped			Whether or not the _animations is looped or just plays once.</haxe_doc>
		</addByIndices>
		<appendByIndices public="1" set="method" line="365">
			<f a="Name:Prefix:Indices:Postfix">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to an existing _animations in the sprite by appending the specified frames to the existing frames.
	 * Use this method when the names of each frame from the atlas share a common prefix and postfix (e.g. "walk00.png", "walk01.png"). Leading zeroes are ignored for matching indices (5 will match "5" and "005").
	 * The animation must already exist in order to append frames to it. FrameRate and Looped are unchanged.
	 * @param	Name			What the existing _animations is called (e.g. "run").
	 * @param	Prefix			Common beginning of image names in atlas (e.g. "tiles-")
	 * @param	Indices			An array of numbers indicating what frames to append (e.g. 1, 2, 3).
	 * @param	Postfix			Common ending of image names in atlas (e.g. ".png")</haxe_doc>
		</appendByIndices>
		<findSpriteFrame set="method" line="387">
			<f a="Prefix:Index:Postfix">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find a sprite frame so that for Prefix = "file"; Indice = 5; Postfix = ".png"
	 * It will find frame with name "file5.png", but if it desn't exist it will try
	 * to find "file05.png" so allowing 99 frames per animation
	 * Returns found frame and null if nothing is found</haxe_doc>
		</findSpriteFrame>
		<addByPrefix public="1" set="method" line="414">
			<f a="Name:Prefix:?FrameRate:?Looped" v="::30:true">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new _animations to the sprite.
	 * @param	Name			What this _animations should be called (e.g. "run").
	 * @param	Prefix			Common beginning of image names in atlas (e.g. "tiles-")
	 * @param	FrameRate		The speed in frames per second that the _animations should play at (e.g. 40 fps).
	 * @param	Looped			Whether or not the _animations is looped or just plays once.</haxe_doc>
		</addByPrefix>
		<appendByPrefix public="1" set="method" line="442">
			<f a="Name:Prefix">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to an existing _animations in the sprite by appending the specified frames to the existing frames.
	 * Use this method when the names of each frame from the atlas share a common prefix (e.g. "walk00.png", "walk01.png"). Frames are sorted numerically while ignoring postfixes (e.g. ".png", ".gif").
	 * The animation must already exist in order to append frames to it. FrameRate and Looped are unchanged.
	 * @param	Name			What the existing _animations is called (e.g. "run").
	 * @param	Prefix			Common beginning of image names in atlas (e.g. "tiles-")</haxe_doc>
		</appendByPrefix>
		<play public="1" set="method" line="471">
			<f a="AnimName:?Force:?Frame" v=":false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Plays an existing _animations (e.g. "run").
	 * If you call an _animations that is already playing it will be ignored.
	 * @param	AnimName	The string name of the _animations you want to play.
	 * @param	Force		Whether to force the _animations to restart.
	 * @param	Frame		The frame number in _animations you want to start from (0 by default). If you pass negative value then it will start from random frame</haxe_doc>
		</play>
		<pause public="1" get="inline" set="null" line="499">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pauses current _animations</haxe_doc>
		</pause>
		<resume public="1" get="inline" set="null" line="510">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resumes current _animations if it's exist</haxe_doc>
		</resume>
		<getByName public="1" get="inline" set="null" line="521">
			<f a="Name">
				<c path="String"/>
				<c path="flixel.animation.FlxAnimation"/>
			</f>
			<haxe_doc>* Gets the FlxAnim object with the specified name.</haxe_doc>
		</getByName>
		<randomFrame public="1" set="method" line="530">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Tell the sprite to change to a random frame of _animations
	 * Useful for instantiating particles or other weird things.</haxe_doc>
		</randomFrame>
		<fireCallback get="inline" set="null" line="540"><f a=""><x path="Void"/></f></fireCallback>
		<byNamesHelper set="method" line="553">
			<f a="AddTo:FrameNames">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Private helper method for add- and appendByNames. Gets frames and appends them to AddTo.</haxe_doc>
		</byNamesHelper>
		<byStringIndicesHelper set="method" line="570">
			<f a="AddTo:Prefix:Indices:Postfix">
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Private helper method for add- and appendByStringIndices. Gets frames and appends them to AddTo.</haxe_doc>
		</byStringIndicesHelper>
		<byIndicesHelper set="method" line="587">
			<f a="AddTo:Prefix:Indices:Postfix">
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Private helper method for add- and appendByIndices. Finds frames and appends them to AddTo.</haxe_doc>
		</byIndicesHelper>
		<byPrefixHelper set="method" line="603">
			<f a="AddTo:AnimFrames:Prefix">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><c path="flixel.system.layer.frames.FlxFrame"/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Private helper method for add- and appendByPrefix. Sorts frames and appends them to AddTo.</haxe_doc>
		</byPrefixHelper>
		<findByPrefix set="method" line="622">
			<f a="AnimFrames:Prefix">
				<c path="Array"><c path="flixel.system.layer.frames.FlxFrame"/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Private helper method for add- and appendByPrefix. Finds frames with the given prefix and appends them to AnimFrames.</haxe_doc>
		</findByPrefix>
		<set_frameIndex set="method" line="634"><f a="Frame">
	<x path="Int"/>
	<x path="Int"/>
</f></set_frameIndex>
		<get_frameName get="inline" set="null" line="650"><f a=""><c path="String"/></f></get_frameName>
		<set_frameName set="method" line="655"><f a="Value">
	<c path="String"/>
	<c path="String"/>
</f></set_frameName>
		<get_name set="method" line="678">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Gets the name of the currently playing _animations (warning: can be null)</haxe_doc>
		</get_name>
		<set_name set="method" line="692">
			<f a="AnimName">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Plays a specified _animations (same as calling play)
	 * @param	AnimName	The name of the _animations you want to play.</haxe_doc>
		</set_name>
		<get_curAnim get="inline" set="null" line="701">
			<f a=""><c path="flixel.animation.FlxAnimation"/></f>
			<haxe_doc>* Gets the currently playing _animations (warning: can return null).</haxe_doc>
		</get_curAnim>
		<set_curAnim get="inline" set="null" line="715">
			<f a="Anim">
				<c path="flixel.animation.FlxAnimation"/>
				<c path="flixel.animation.FlxAnimation"/>
			</f>
			<haxe_doc>* Plays a specified _animations (same as calling play)
	 * @param	AnimName	The name of the _animations you want to play.</haxe_doc>
		</set_curAnim>
		<get_paused get="inline" set="null" line="728"><f a=""><x path="Bool"/></f></get_paused>
		<set_paused get="inline" set="null" line="738"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_paused>
		<get_finished get="inline" set="null" line="747"><f a=""><x path="Bool"/></f></get_finished>
		<set_finished get="inline" set="null" line="757"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_finished>
		<get_frames get="inline" set="null" line="767"><f a=""><x path="Int"/></f></get_frames>
		<getFrameIndex public="1" get="inline" set="null" line="777">
			<f a="Frame">
				<c path="flixel.system.layer.frames.FlxFrame"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Helper function used for finding index of FlxFrame in _framesData's frames array
	 * @param	Frame	FlxFrame to find
	 * @return	position of specified FlxFrame object.</haxe_doc>
		</getFrameIndex>
		<new public="1" set="method" line="78"><f a="Sprite">
	<c path="flixel.FlxSprite"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.animation.FlxPrerotatedAnimation" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/animation/FlxPrerotatedAnimation.hx">
		<extends path="flixel.animation.FlxBaseAnimation"/>
		<PREROTATED public="1" get="inline" set="null" line="11" static="1"><c path="String"/></PREROTATED>
		<rotations><x path="Int"/></rotations>
		<baked><x path="Float"/></baked>
		<angle public="1" set="accessor"><x path="Float"/></angle>
		<set_angle set="method" line="26"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<set_curIndex set="method" line="46" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_curIndex>
		<clone public="1" set="method" line="58" override="1"><f a="Parent">
	<c path="flixel.animation.FlxAnimationController"/>
	<c path="flixel.animation.FlxPrerotatedAnimation"/>
</f></clone>
		<new public="1" set="method" line="17"><f a="Parent:Baked">
	<c path="flixel.animation.FlxAnimationController"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.atlas.FlxAtlas" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/atlas/FlxAtlas.hx">
		<root public="1">
			<c path="flixel.atlas.FlxNode"/>
			<haxe_doc>* Root node of atlas</haxe_doc>
		</root>
		<name public="1"><c path="String"/></name>
		<nodes public="1"><x path="Map">
	<c path="String"/>
	<c path="flixel.atlas.FlxNode"/>
</x></nodes>
		<atlasBitmapData public="1"><c path="flash.display.BitmapData"/></atlasBitmapData>
		<borderX public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Offsets between nodes in atlas</haxe_doc>
		</borderX>
		<borderY public="1" set="null"><x path="Int"/></borderY>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Total width of atlas</haxe_doc>
		</width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Total height of atlas</haxe_doc>
		</height>
		<_tempStorage><c path="Array"><t path="flixel.atlas.TempAtlasObj"/></c></_tempStorage>
		<addNode public="1" set="method" line="75">
			<f a="Graphic:?Key" v=":null">
				<d/>
				<c path="String"/>
				<c path="flixel.atlas.FlxNode"/>
			</f>
			<haxe_doc>* Simply adds new node to atlas.
	 * @param	data	image to store
	 * @param	key		image name
	 * @return			added node</haxe_doc>
		</addNode>
		<getRegionFor public="1" set="method" line="179">
			<f a="nodeName">
				<c path="String"/>
				<c path="flixel.util.loaders.TextureRegion"/>
			</f>
			<haxe_doc>* Generates TextureRegion object for node with specified name
	 * @param	nodeName	name of the node to generate TextureRegion object for
	 * @return	Generated TextureRegion</haxe_doc>
		</getRegionFor>
		<getTextureData public="1" set="method" line="201">
			<f a=""><c path="flixel.util.loaders.TexturePackerData"/></f>
			<haxe_doc>* Generates TexturePackerData object for this atlas. Where each frame represents one of the inserted images
	 * @return TexturePackerData for this atlas</haxe_doc>
		</getTextureData>
		<hasNodeWithName public="1" set="method" line="238">
			<f a="nodeName">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if atlas already contains node with the same name
	 * @param	nodeName	node name to check
	 * @return				true if atlas already contains node with the name</haxe_doc>
		</hasNodeWithName>
		<getNode public="1" set="method" line="248">
			<f a="key">
				<c path="String"/>
				<c path="flixel.atlas.FlxNode"/>
			</f>
			<haxe_doc>* Gets node by it's name
	 * @param	key		node name to search
	 * @return	node with searched name. Null if atlas doesn't contain node with a such name</haxe_doc>
		</getNode>
		<addNodes public="1" set="method" line="264">
			<f a="bitmaps:keys">
				<c path="Array"><c path="flash.display.BitmapData"/></c>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Optimized version of method for adding multiple nodes to atlas. Uses less atlas' area
	 * @param	bitmaps		BitmapData's to insert
	 * @param	keys		Names of these bitmapData's
	 * @return				true if ALL nodes were added successfully.</haxe_doc>
		</addNodes>
		<indexOf set="method" line="293"><f a="bitmaps:bmd">
	<c path="Array"><c path="flash.display.BitmapData"/></c>
	<c path="flash.display.BitmapData"/>
	<x path="Int"/>
</f></indexOf>
		<bitmapSorter set="method" line="306"><f a="bmd1:bmd2">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
	<x path="Int"/>
</f></bitmapSorter>
		<createQueue public="1" set="method" line="335">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates new "queue" for adding new nodes</haxe_doc>
		</createQueue>
		<addToQueue public="1" set="method" line="345">
			<f a="data:key">
				<c path="flash.display.BitmapData"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds new object to queue for later creation of new node
	 * @param	data	bitmapData to hold
	 * @param	key		"name" of bitmapData</haxe_doc>
		</addToQueue>
		<generateAtlasFromQueue public="1" set="method" line="358">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Adds all objects in "queue" to existing atlas. Doesn't erase any node</haxe_doc>
		</generateAtlasFromQueue>
		<destroy public="1" set="method" line="377">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroys atlas. Use only if you want to clear memory and don't need this atlas anymore</haxe_doc>
		</destroy>
		<clear public="1" set="method" line="390">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears all data in atlas. Use it when you want reuse this atlas</haxe_doc>
		</clear>
		<deleteSubtree set="method" line="401"><f a="node">
	<c path="flixel.atlas.FlxNode"/>
	<x path="Void"/>
</f></deleteSubtree>
		<findNodeToInsert set="method" line="412"><f a="insertWidth:insertHeight">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flixel.atlas.FlxNode"/>
</f></findNodeToInsert>
		<get_width get="inline" set="null" line="463"><f a=""><x path="Int"/></f></get_width>
		<get_height get="inline" set="null" line="468"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="57">
			<f a="name:width:height:?borderX:?borderY" v=":::1:1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Atlas constructor
	 * @param	width		atlas width
	 * @param	height		atlas height
	 * @param	borderX		horizontal distance between nodes
	 * @param	borderY		vertical distance between nodes</haxe_doc>
		</new>
		<haxe_doc>* Atlas class
 * @author Zaphod</haxe_doc>
	</class>
	<typedef path="flixel.atlas.TempAtlasObj" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/atlas/FlxAtlas.hx" module="flixel.atlas.FlxAtlas"><a>
	<keyStr><c path="String"/></keyStr>
	<bmd><c path="flash.display.BitmapData"/></bmd>
</a></typedef>
	<class path="flixel.atlas.FlxNode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/atlas/FlxNode.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<left public="1"><c path="flixel.atlas.FlxNode"/></left>
		<right public="1"><c path="flixel.atlas.FlxNode"/></right>
		<rect public="1"><c path="flash.geom.Rectangle"/></rect>
		<point public="1"><c path="flash.geom.Point"/></point>
		<key public="1"><c path="String"/></key>
		<filled public="1"><x path="Bool"/></filled>
		<x public="1" get="accessor" set="null"><x path="Int"/></x>
		<y public="1" get="accessor" set="null"><x path="Int"/></y>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<isEmpty public="1" get="accessor" set="null"><x path="Bool"/></isEmpty>
		<destroy public="1" get="inline" set="null" line="37"><f a=""><x path="Void"/></f></destroy>
		<canPlace public="1" get="inline" set="null" line="45"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></canPlace>
		<get_isEmpty get="inline" set="null" line="50"><f a=""><x path="Bool"/></f></get_isEmpty>
		<get_x get="inline" set="null" line="55"><f a=""><x path="Int"/></f></get_x>
		<get_y get="inline" set="null" line="60"><f a=""><x path="Int"/></f></get_y>
		<get_width get="inline" set="null" line="65"><f a=""><x path="Int"/></f></get_width>
		<get_height get="inline" set="null" line="70"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="27"><f a="rect:?filled:?key" v=":false:''">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Atlas Node holds BitmapData and it's position on Atlas
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.util.FlxPool_flixel_effects_FlxFlicker" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxPool.hx">
		<_pool><c path="Array"><c path="flixel.effects.FlxFlicker"/></c></_pool>
		<_class><x path="Class"><c path="flixel.effects.FlxFlicker"/></x></_class>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<get public="1" set="method" line="23"><f a=""><c path="flixel.effects.FlxFlicker"/></f></get>
		<put public="1" set="method" line="33"><f a="obj">
	<c path="flixel.effects.FlxFlicker"/>
	<x path="Void"/>
</f></put>
		<putUnsafe public="1" set="method" line="43"><f a="obj">
	<c path="flixel.effects.FlxFlicker"/>
	<x path="Void"/>
</f></putUnsafe>
		<preAllocate public="1" set="method" line="52"><f a="numObjects">
	<x path="Int"/>
	<x path="Void"/>
</f></preAllocate>
		<clear public="1" set="method" line="60"><f a=""><c path="Array"><c path="flixel.effects.FlxFlicker"/></c></f></clear>
		<get_length get="inline" set="null" line="67"><f a=""><x path="Int"/></f></get_length>
		<new public="1" set="method" line="17"><f a="classObj">
	<x path="Class"><c path="flixel.effects.FlxFlicker"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.effects.FlxFlicker" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/effects/FlxFlicker.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<_pool line="15" static="1"><c path="flixel.util.FlxPool_flixel_effects_FlxFlicker"/></_pool>
		<_boundObjects line="20" static="1">
			<x path="Map">
				<c path="flixel.FlxObject"/>
				<c path="flixel.effects.FlxFlicker"/>
			</x>
			<haxe_doc>* Internal map for looking up which objects are currently flickering and getting their flicker data.</haxe_doc>
		</_boundObjects>
		<flicker public="1" set="method" line="33" static="1">
			<f a="Object:?Duration:?Interval:?EndVisibility:?ForceRestart:?CompletionCallback:?ProgressCallback" v=":1:0.04f:true:true:null:null">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* A simple flicker effect for sprites using a ping-pong tween by toggling visibility.
	 * 
	 * @param  Object            The sprite.
	 * @param  Duration        How long to flicker for.
	 * @param  Interval          In what interval to toggle visibility. Set to FlxG.elapsed if <= 0!
	 * @param  EndVisibility    Force the visible value when the flicker completes, useful with fast repetitive use.
	 * @param  ForceRestart    Force the flicker to restart from beginnig, discarding the flickering effect already in progress if there is one.
	 * @param  ?CompletionCallback An optional callback that will be triggered when a flickering has finished.
	 * @param  ?ProgressCallback   An optional callback that will be triggered when visibility is toggled.]]></haxe_doc>
		</flicker>
		<isFlickering public="1" set="method" line="62" static="1">
			<f a="Object">
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether the object is flickering or not.
	* @param  Object The object to test.</haxe_doc>
		</isFlickering>
		<stopFlickering public="1" set="method" line="71" static="1">
			<f a="Object">
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops flickering of the object. Also it will make the object visible.
	* @param  Object The object to stop flickering.</haxe_doc>
		</stopFlickering>
		<object public="1" set="null">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* The flickering object.</haxe_doc>
		</object>
		<endVisibility public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* The final visibility of the object after flicker is complete.</haxe_doc>
		</endVisibility>
		<timer public="1" set="null">
			<c path="flixel.util.FlxTimer"/>
			<haxe_doc>* The flicker timer. You can check how many seconds has passed since flickering started etc.</haxe_doc>
		</timer>
		<completionCallback public="1" set="null">
			<f a="">
				<c path="flixel.effects.FlxFlicker"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The callback that will be triggered after flicker has completed.</haxe_doc>
		</completionCallback>
		<progressCallback public="1" set="null">
			<f a="">
				<c path="flixel.effects.FlxFlicker"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The callback that will be triggered every time object visiblity is changed.</haxe_doc>
		</progressCallback>
		<duration public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The duration of the flicker.</haxe_doc>
		</duration>
		<interval public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The interval of the flicker.</haxe_doc>
		</interval>
		<destroy public="1" set="method" line="118">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Nullifies the references to prepare object for reuse and avoid memory leaks.</haxe_doc>
		</destroy>
		<start set="method" line="135">
			<f a="Object:Duration:Interval:EndVisibility:?CompletionCallback:?ProgressCallback" v="::::null:null">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Starts flickering behavior.
	* @param  Object
	* @param  Duration
	* @param  Interval
	* @param  EndVisibility
	* @param  ?CompletionCallback
	* @param  ?ProgressCallback</haxe_doc>
		</start>
		<stop set="method" line="149">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prematurely ends flickering.</haxe_doc>
		</stop>
		<release set="method" line="159">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unbinds the object from flicker and releases it into pool for reuse.</haxe_doc>
		</release>
		<flickerProgress set="method" line="168">
			<f a="Timer">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Just a helper function for flicker() to update object's visibility.</haxe_doc>
		</flickerProgress>
		<new set="method" line="191">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal constructor. Use static methods.</haxe_doc>
		</new>
		<haxe_doc>* The retro flickering effect with callbacks.
* You can use this as a mixin in any FlxObject subclass or by calling the static functions.
* @author pixelomatic</haxe_doc>
	</class>
	<class path="flixel.effects.FlxSpriteFilter" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/effects/FlxSpriteFilter.hx">
		<helperRect public="1" line="26" static="1"><c path="flash.geom.Rectangle"/></helperRect>
		<helperPoint public="1" line="27" static="1"><c path="flash.geom.Point"/></helperPoint>
		<sprite public="1"><c path="flixel.FlxSprite"/></sprite>
		<backupGraphics public="1">
			<c path="flixel.util.loaders.CachedGraphics"/>
			<haxe_doc>* Stores a copy of pixels before any bitmap filter is applied, this is necessary for native targets where bitmap filters only show when applied 
	 * directly to pixels, so a backup is needed to clear filters when removeFilter() is called or when filters are reapplied during calcFrame().</haxe_doc>
		</backupGraphics>
		<backupRegion public="1"><c path="flixel.system.layer.Region"/></backupRegion>
		<filters public="1">
			<c path="Array"><c path="flash.filters.BitmapFilter"/></c>
			<haxe_doc>* An array that contains each filter object currently associated with this sprite.</haxe_doc>
		</filters>
		<frameWidth public="1"><x path="Int"/></frameWidth>
		<frameHeight public="1"><x path="Int"/></frameHeight>
		<widthInc public="1"><x path="Int"/></widthInc>
		<heightInc public="1"><x path="Int"/></heightInc>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<pixels public="1"><c path="flash.display.BitmapData"/></pixels>
		<destroy public="1" set="method" line="105"><f a=""><x path="Void"/></f></destroy>
		<setClipping set="method" line="121">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets this sprite clipping width and height, the current graphic is centered
	 * at the middle.
	 * 
	 * @param	width	The new sprite width.
	 * @param	height	The new sprite height.</haxe_doc>
		</setClipping>
		<regenBitmapData set="method" line="146"><f a="?fill" v="true">
	<x path="Bool"/>
	<x path="Void"/>
</f></regenBitmapData>
		<addFilter public="1" set="method" line="186">
			<f a="filter:?regenPixels" v=":true">
				<c path="flash.filters.BitmapFilter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a filter to this sprite, the sprite becomes unique and won't share its graphics with other sprites.
	 * Note that for effects like outer glow, or drop shadow, updating the sprite clipping
	 * area may be required, use widthInc or heightInc to increase the sprite area.
	 * 
	 * @param	filter		The filter to be added.</haxe_doc>
		</addFilter>
		<applyFilters public="1" set="method" line="200">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this to update the sprite when filters are changed.
	 * Its also called automatically when adding a new filter.</haxe_doc>
		</applyFilters>
		<removeFilter public="1" set="method" line="219">
			<f a="filter:?regenPixels" v=":true">
				<c path="flash.filters.BitmapFilter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes a filter from the sprite.
	 * 
	 * @param	filter	The filter to be removed.</haxe_doc>
		</removeFilter>
		<removeAllFilters public="1" set="method" line="238">
			<f a="?regenPixels" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes all filters from the sprite, additionally you may call loadGraphic() after removing
	 * the filters to reuse cached graphics/bitmaps and stop this sprite from being unique.</haxe_doc>
		</removeAllFilters>
		<new public="1" set="method" line="62">
			<f a="Sprite:?WidthIncrease:?HeightIncrease" v=":0:0">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new filter for a FlxSprite.
	 * 
	 * @param   Sprite           The FlxSprite to add the filter to.
	 * @param   WidthIncrease    How much to increase the graphic's width (useful for things like BlurFilter that need space outside the actual graphic).
	 * @param   HeightIncrease   How much to increase the graphic's height (useful for things like BlurFilter that need space outside the actual graphic).</haxe_doc>
		</new>
		<haxe_doc>* This class allows you to add sprite filters to FlxSprites
 * Create a new instance and pass it an FlxSprite then add new bitmapFilters using addFilter()
 * 
 * To refresh the filters applied to a sprite use applyFilters().
 * 
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.effects.particles.FlxTypedEmitter" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/effects/particles/FlxTypedEmitter.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></extends>
		<xPosition public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* The x position range of the emitter in world space.</haxe_doc>
		</xPosition>
		<yPosition public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* The y position range of emitter in world space.</haxe_doc>
		</yPosition>
		<xVelocity public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* The x velocity range of a particle.
	 * The default value is (-100,-100).</haxe_doc>
		</xVelocity>
		<yVelocity public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* The y velocity range of a particle.
	 * The default value is (100,100).</haxe_doc>
		</yVelocity>
		<particleDrag public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* The X and Y drag component of particles launched from the emitter.</haxe_doc>
		</particleDrag>
		<rotation public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* The minimum and maximum possible angular velocity of a particle.  The default value is (-360, 360).
	 * NOTE: rotating particles are more expensive to draw than non-rotating ones!</haxe_doc>
		</rotation>
		<acceleration public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Sets the acceleration member of each particle to this value on launch.</haxe_doc>
		</acceleration>
		<on public="1">
			<x path="Bool"/>
			<haxe_doc>* Determines whether the emitter is currently emitting particles.
	 * It is totally safe to directly toggle this.</haxe_doc>
		</on>
		<frequency public="1">
			<x path="Float"/>
			<haxe_doc>* How often a particle is emitted (if emitter is started with Explode == false).</haxe_doc>
		</frequency>
		<life public="1"><c path="flixel.effects.particles.Bounds"><x path="Float"/></c></life>
		<startScale public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* Sets start scale range (when particle emits)</haxe_doc>
		</startScale>
		<endScale public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* Sets end scale range (when particle dies)</haxe_doc>
		</endScale>
		<startAlpha public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* Sets start alpha range (when particle emits)</haxe_doc>
		</startAlpha>
		<endAlpha public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* Sets end alpha range (when particle emits)</haxe_doc>
		</endAlpha>
		<startRed public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* Sets start red color component range (when particle emits)</haxe_doc>
		</startRed>
		<startGreen public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* Sets start green color component range (when particle emits)</haxe_doc>
		</startGreen>
		<startBlue public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* Sets start blue color component range (when particle emits)</haxe_doc>
		</startBlue>
		<endRed public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* Sets end red color component range (when particle emits)</haxe_doc>
		</endRed>
		<endGreen public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* Sets end green color component range (when particle emits)</haxe_doc>
		</endGreen>
		<endBlue public="1">
			<c path="flixel.effects.particles.Bounds"><x path="Float"/></c>
			<haxe_doc>* Sets end blue color component range (when particle emits)</haxe_doc>
		</endBlue>
		<blend public="1">
			<e path="flash.display.BlendMode"/>
			<haxe_doc>* Sets particle's blend mode. null by default.
	 * Warning: expensive on flash target</haxe_doc>
		</blend>
		<bounce public="1">
			<x path="Float"/>
			<haxe_doc>* How much each particle should bounce.  1 = full bounce, 0 = no bounce.</haxe_doc>
		</bounce>
		<_particleClass>
			<x path="Class"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></x>
			<haxe_doc>* Internal variable for tracking the class to create when generating particles.</haxe_doc>
		</_particleClass>
		<_quantity>
			<x path="Int"/>
			<haxe_doc>* Internal helper for deciding how many particles to launch.</haxe_doc>
		</_quantity>
		<_explode>
			<x path="Bool"/>
			<haxe_doc>* Internal helper for the style of particle emission (all at once, or one at a time).</haxe_doc>
		</_explode>
		<_timer>
			<x path="Float"/>
			<haxe_doc>* Internal helper for deciding when to launch particles or kill them.</haxe_doc>
		</_timer>
		<_counter>
			<x path="Int"/>
			<haxe_doc>* Internal counter for figuring out how many particles to launch.</haxe_doc>
		</_counter>
		<_point>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Internal point object, handy for reusing for memory mgmt purposes.</haxe_doc>
		</_point>
		<_waitForKill>
			<x path="Bool"/>
			<haxe_doc>* Internal helper for automatic call the kill() method</haxe_doc>
		</_waitForKill>
		<destroy public="1" set="method" line="184" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<makeParticles public="1" set="method" line="222">
			<f a="Graphics:?Quantity:?bakedRotationAngles:?Multiple:?Collide:?AutoBuffer" v=":50:16:false:0.8f:false">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.effects.particles.FlxTypedEmitter"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></c>
			</f>
			<haxe_doc>* This function generates a new array of particle sprites to attach to the emitter.
	 * 
	 * @param	Graphics		If you opted to not pre-configure an array of FlxParticle objects, you can simply pass in a particle image or sprite sheet.
	 * @param	Quantity		The number of particles to generate when using the "create from image" option.
	 * @param	BakedRotations	How many frames of baked rotation to use (boosts performance).  Set to zero to not use baked rotations.
	 * @param	Multiple		Whether the image in the Graphics param is a single particle or a bunch of particles (if it's a bunch, they need to be square!).
	 * @param	Collide			Whether the particles should be flagged as not 'dead' (non-colliding particles are higher performance).  0 means no collisions, 0-1 controls scale of particle's bounding box.
	 * @param	AutoBuffer		Whether to automatically increase the image size to accomodate rotated corners.  Default is false.  Will create frames that are 150% larger on each axis than the original frame or graphic.
	 * @return	This FlxEmitter instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</makeParticles>
		<update public="1" set="method" line="298" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called automatically by the game loop, decides when to launch particles and when to "die".</haxe_doc>
		</update>
		<kill public="1" set="method" line="373" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Call this function to turn off all the particles and the emitter.</haxe_doc>
		</kill>
		<start public="1" set="method" line="389">
			<f a="?Explode:?Lifespan:?Frequency:?Quantity:?LifespanRange" v="true:0:0.1f:0:0">
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Call this function to start emitting particles.
	 * @param	Explode			Whether the particles should all burst out at once.
	 * @param	Lifespan		How long each particle lives once emitted. 0 = forever.
	 * @param	Frequency		Ignored if Explode is set to true. Frequency is how often to emit a particle. 0 = never emit, 0.1 = 1 particle every 0.1 seconds, 5 = 1 particle every 5 seconds.
	 * @param	Quantity		How many particles to launch. 0 = "all of the particles".
	 * @param	LifespanRange	Max amount to add to the particle's lifespan. Leave it to default (zero), if you want to make particle "live" forever (plus you should set Lifespan parameter to zero too).</haxe_doc>
		</start>
		<emitParticle public="1" set="method" line="410">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function can be used both internally and externally to emit the next particle.</haxe_doc>
		</emitParticle>
		<setSize public="1" set="method" line="572">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A more compact way of setting the width and height of the emitter.
	 * 
	 * @param	Width	The desired width of the emitter (particles are spawned randomly within these dimensions).
	 * @param	Height	The desired height of the emitter.</haxe_doc>
		</setSize>
		<setXSpeed public="1" set="method" line="584">
			<f a="?Min:?Max" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A more compact way of setting the X velocity range of the emitter.
	 * 
	 * @param	Min		The minimum value for this range.
	 * @param	Max		The maximum value for this range.</haxe_doc>
		</setXSpeed>
		<setYSpeed public="1" set="method" line="601">
			<f a="?Min:?Max" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A more compact way of setting the Y velocity range of the emitter.
	 * 
	 * @param	Min		The minimum value for this range.
	 * @param	Max		The maximum value for this range.</haxe_doc>
		</setYSpeed>
		<setRotation public="1" set="method" line="618">
			<f a="?Min:?Max" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A more compact way of setting the angular velocity constraints of the emitter.
	 * 
	 * @param	Min		The minimum value for this range.
	 * @param	Max		The maximum value for this range.</haxe_doc>
		</setRotation>
		<setScale public="1" set="method" line="637">
			<f a="?StartMin:?StartMax:?EndMin:?EndMax" v="1:1:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A more compact way of setting the scale constraints of the emitter.
	 * 
	 * @param	StartMin	The minimum value for particle scale at the start (emission).
	 * @param	StartMax	The maximum value for particle scale at the start (emission).
	 * @param	EndMin		The minimum value for particle scale at the end (death).
	 * @param	EndMax		The maximum value for particle scale at the end (death).</haxe_doc>
		</setScale>
		<setAlpha public="1" set="method" line="663">
			<f a="?StartMin:?StartMax:?EndMin:?EndMax" v="1:1:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A more compact way of setting the alpha constraints of the emitter.
	 * 
	 * @param	StartMin	The minimum value for particle alpha at the start (emission).
	 * @param	StartMax	The maximum value for particle alpha at the start (emission).
	 * @param	EndMin		The minimum value for particle alpha at the end (death).
	 * @param	EndMax		The maximum value for particle alpha at the end (death).</haxe_doc>
		</setAlpha>
		<setColor public="1" set="method" line="698">
			<f a="?Start:?End" v="16777215:16777215">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A more compact way of setting the color constraints of the emitter.
	 * But it's not so flexible as setting values of each color bounds objects.
	 * 
	 * @param	Start		The start particles color at the start (emission).
	 * @param	EndMin		The end particles color at the end (death).</haxe_doc>
		</setColor>
		<at public="1" set="method" line="725">
			<f a="Object">
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the emitter's midpoint to match the midpoint of a FlxObject.
	 * 
	 * @param	Object		The FlxObject that you want to sync up with.</haxe_doc>
		</at>
		<particleClass public="1" get="accessor" set="accessor">
			<x path="Class"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></x>
			<haxe_doc>* Set your own particle class type here. The custom class must extend FlxParticle.
	 * Default is FlxParticle.</haxe_doc>
		</particleClass>
		<get_particleClass set="method" line="739"><f a=""><x path="Class"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></x></f></get_particleClass>
		<set_particleClass set="method" line="744"><f a="Value">
	<x path="Class"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></x>
	<x path="Class"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></x>
</f></set_particleClass>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The width of the emitter.  Particles can be randomly generated from anywhere within this box.</haxe_doc>
		</width>
		<get_width set="method" line="754"><f a=""><x path="Float"/></f></get_width>
		<set_width set="method" line="759"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The height of the emitter.  Particles can be randomly generated from anywhere within this box.</haxe_doc>
		</height>
		<get_height set="method" line="769"><f a=""><x path="Float"/></f></get_height>
		<set_height set="method" line="774"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The x position of this emitter.</haxe_doc>
		</x>
		<get_x set="method" line="784"><f a=""><x path="Float"/></f></get_x>
		<set_x set="method" line="789"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The y position of this emitter.</haxe_doc>
		</y>
		<get_y set="method" line="799"><f a=""><x path="Float"/></f></get_y>
		<set_y set="method" line="804"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<setPosition public="1" get="inline" set="null" line="816">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function to set the coordinates of this object.
	 * Handy since it only requires one line of code.
	 * 
	 * @param	X	The new x position
	 * @param	Y	The new y position</haxe_doc>
		</setPosition>
		<gravity public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Sets the acceleration.y member of each particle to this value on launch.</haxe_doc>
		</gravity>
		<get_gravity set="method" line="827"><f a=""><x path="Float"/></f></get_gravity>
		<set_gravity set="method" line="832"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gravity>
		<minRotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The minimum possible angular velocity of a particle. The default value is -360.
	 * NOTE: rotating particles are more expensive to draw than non-rotating ones!</haxe_doc>
		</minRotation>
		<get_minRotation set="method" line="843"><f a=""><x path="Float"/></f></get_minRotation>
		<set_minRotation set="method" line="848"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_minRotation>
		<maxRotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The maximum possible angular velocity of a particle. The default value is 360.
	 * NOTE: rotating particles are more expensive to draw than non-rotating ones!</haxe_doc>
		</maxRotation>
		<get_maxRotation set="method" line="859"><f a=""><x path="Float"/></f></get_maxRotation>
		<set_maxRotation set="method" line="864"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxRotation>
		<lifespan public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* How long each particle lives once it is emitted.
	 * Set lifespan to 'zero' for particles to live forever.</haxe_doc>
		</lifespan>
		<get_lifespan set="method" line="875"><f a=""><x path="Float"/></f></get_lifespan>
		<set_lifespan set="method" line="880"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_lifespan>
		<new public="1" set="method" line="152">
			<f a="?X:?Y:?Size" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxTypedEmitter object at a specific position.
	 * Does NOT automatically generate or attach particles!
	 * 
	 * @param	X		The X position of the emitter.
	 * @param	Y		The Y position of the emitter.
	 * @param	Size	Optional, specifies a maximum capacity for this emitter.</haxe_doc>
		</new>
		<haxe_doc>* FlxTypedEmitter is a lightweight particle emitter.
 * It can be used for one-time explosions or for
 * continuous fx like rain and fire.  FlxEmitter
 * is not optimized or anything; all it does is launch
 * FlxParticle objects out at set intervals
 * by setting their positions and velocities accordingly.
 * It is easy to use and relatively efficient,
 * relying on FlxGroup's RECYCLE POWERS.</haxe_doc>
	</class>
	<class path="flixel.effects.particles.FlxEmitter" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/effects/particles/FlxEmitter.hx">
		<extends path="flixel.effects.particles.FlxTypedEmitter"><c path="flixel.effects.particles.FlxParticle"/></extends>
		<new public="1" set="method" line="23">
			<f a="?X:?Y:?Size" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxEmitter object at a specific position.
	 * Does NOT automatically generate or attach particles!
	 * 
	 * @param	X		The X position of the emitter.
	 * @param	Y		The Y position of the emitter.
	 * @param	Size	Optional, specifies a maximum capacity for this emitter.</haxe_doc>
		</new>
		<haxe_doc>* FlxEmitter is a lightweight particle emitter.
 * It can be used for one-time explosions or for
 * continuous fx like rain and fire.  FlxEmitter
 * is not optimized or anything; all it does is launch
 * FlxParticle objects out at set intervals
 * by setting their positions and velocities accordingly.
 * It is easy to use and relatively efficient,
 * relying on FlxGroup's RECYCLE POWERS.</haxe_doc>
	</class>
	<class path="flixel.effects.particles.FlxTypedEmitterExt" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/effects/particles/FlxTypedEmitterExt.hx">
		<extends path="flixel.effects.particles.FlxTypedEmitter"><c path="flixel.effects.particles.FlxTypedEmitterExt.T"/></extends>
		<angle public="1">
			<x path="Float"/>
			<haxe_doc>* 	Launch Direction.</haxe_doc>
		</angle>
		<distance public="1">
			<x path="Float"/>
			<haxe_doc>* 	Distance to travel.</haxe_doc>
		</distance>
		<angleRange public="1">
			<x path="Float"/>
			<haxe_doc>* 	Random amount to add to the particle's direction.</haxe_doc>
		</angleRange>
		<distanceRange public="1">
			<x path="Float"/>
			<haxe_doc>* 	Random amount to add to the particle's distance.</haxe_doc>
		</distanceRange>
		<setMotion public="1" set="method" line="58">
			<f a="Angle:Distance:Lifespan:?AngleRange:?DistanceRange:?LifespanRange" v=":::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Defines the motion range for this emitter.
	 * 
	 * @param	Angle			Launch Direction.
	 * @param	Distance		Distance to travel.
	 * @param	Lifespan		Particle duration.
	 * @param	AngleRange		Random amount to add to the particle's direction.
	 * @param	DistanceRange	Random amount to add to the particle's distance.
	 * @param	LifespanRange	Random amount to add to the particle's duration.</haxe_doc>
		</setMotion>
		<setParticleMotion set="method" line="79">
			<f a="Particle:Angle:Distance:?AngleRange:?DistanceRange" v=":::0:0">
				<c path="flixel.effects.particles.FlxTypedEmitterExt.T"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Defines the motion range for a specific particle.
	 * 
	 * @param   Particle		The Particle to set the motion for
	 * @param	Angle			Launch Direction.
	 * @param	Distance		Distance to travel.
	 * @param	Lifespan		Particle duration.
	 * @param	AngleRange		Random amount to add to the particle's direction.
	 * @param	DistanceRange	Random amount to add to the particle's distance.
	 * @param	LifespanRange	Random amount to add to the particle's duration.</haxe_doc>
		</setParticleMotion>
		<start public="1" set="method" line="98" override="1">
			<f a="?Explode:?Lifespan:?Frequency:?Quantity:?LifespanRange" v="true:0:0.1f:0:0">
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Call this function to start emitting particles.
	 * 
	 * @param	Explode			Whether the particles should all burst out at once.
	 * @param	Lifespan		Unused parameter due to class override. Use setMotion to set things like a particle's lifespan.
	 * @param	Frequency		Ignored if Explode is set to true. Frequency is how often to emit a particle. 0 = never emit, 0.1 = 1 particle every 0.1 seconds, 5 = 1 particle every 5 seconds.
	 * @param	Quantity		How many particles to launch. 0 = "all of the particles".
	 * @param	LifespanRange	Max amount to add to the particle's lifespan. Leave it to default (zero), if you want to make particle "live" forever (plus you should set Lifespan parameter to zero too).</haxe_doc>
		</start>
		<emitParticle public="1" set="method" line="129" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function can be used both internally and externally to emit the next particle.</haxe_doc>
		</emitParticle>
		<new public="1" set="method" line="40">
			<f a="?X:?Y:?Size" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxTypedEmitterExt object at a specific position.
	 * Does NOT automatically generate or attach particles!
	 * 
	 * @param	X		The X position of the emitter.
	 * @param	Y		The Y position of the emitter.
	 * @param	Size	Optional, specifies a maximum capacity for this emitter.</haxe_doc>
		</new>
		<haxe_doc>* Extended FlxEmitter that emits particles in a circle (instead of a square).
 * It also provides a new function setMotion to control particle behavior even more.
 * This was inspired by the way Chevy Ray Johnston implemented his particle emitter in Flashpunk.
 * @author Dirk Bunk</haxe_doc>
	</class>
	<class path="flixel.effects.particles.FlxEmitterExt" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/effects/particles/FlxEmitterExt.hx">
		<extends path="flixel.effects.particles.FlxTypedEmitterExt"><c path="flixel.effects.particles.FlxParticle"/></extends>
		<new public="1" set="method" line="19">
			<f a="?X:?Y:?Size" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxEmitterExt object at a specific position.
	 * Does NOT automatically generate or attach particles!
	 * 
	 * @param	X		The X position of the emitter.
	 * @param	Y		The Y position of the emitter.
	 * @param	Size	Optional, specifies a maximum capacity for this emitter.</haxe_doc>
		</new>
		<haxe_doc>* Extended FlxEmitter that emits particles in a circle (instead of a square).
 * It also provides a new function setMotion to control particle behavior even more.
 * This was inspired by the way Chevy Ray Johnston implemented his particle emitter in Flashpunk.
 * @author Dirk Bunk</haxe_doc>
	</class>
	<class path="flixel.interfaces.IFlxParticle" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/interfaces/IFlxParticle.hx" interface="1">
		<extends path="flixel.interfaces.IFlxSprite"/>
		<lifespan public="1"><x path="Float"/></lifespan>
		<friction public="1"><x path="Float"/></friction>
		<useFading public="1"><x path="Bool"/></useFading>
		<useScaling public="1"><x path="Bool"/></useScaling>
		<useColoring public="1"><x path="Bool"/></useColoring>
		<maxLifespan public="1"><x path="Float"/></maxLifespan>
		<startAlpha public="1"><x path="Float"/></startAlpha>
		<rangeAlpha public="1"><x path="Float"/></rangeAlpha>
		<startScale public="1"><x path="Float"/></startScale>
		<rangeScale public="1"><x path="Float"/></rangeScale>
		<startRed public="1"><x path="Float"/></startRed>
		<startGreen public="1"><x path="Float"/></startGreen>
		<startBlue public="1"><x path="Float"/></startBlue>
		<rangeRed public="1"><x path="Float"/></rangeRed>
		<rangeGreen public="1"><x path="Float"/></rangeGreen>
		<rangeBlue public="1"><x path="Float"/></rangeBlue>
		<onEmit public="1" set="method"><f a=""><x path="Void"/></f></onEmit>
	</class>
	<class path="flixel.effects.particles.FlxParticle" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/effects/particles/FlxParticle.hx">
		<extends path="flixel.FlxSprite"/>
		<implements path="flixel.interfaces.IFlxParticle"/>
		<lifespan public="1">
			<x path="Float"/>
			<haxe_doc>* How long this particle lives before it disappears.
	 * NOTE: this is a maximum, not a minimum; the object
	 * could get recycled before its lifespan is up.</haxe_doc>
		</lifespan>
		<friction public="1">
			<x path="Float"/>
			<haxe_doc>* Determines how quickly the particles come to rest on the ground.
	 * Only used if the particle has gravity-like acceleration applied.</haxe_doc>
		</friction>
		<useFading public="1">
			<x path="Bool"/>
			<haxe_doc>* If this is set to true, particles will slowly fade away by
	 * decreasing their alpha value based on their lifespan.</haxe_doc>
		</useFading>
		<useScaling public="1">
			<x path="Bool"/>
			<haxe_doc>* If this is set to true, particles will slowly decrease in scale
	 * based on their lifespan.
	 * WARNING: This severely impacts performance on flash target.</haxe_doc>
		</useScaling>
		<useColoring public="1">
			<x path="Bool"/>
			<haxe_doc>* If this is set to true, particles will change their color
	 * based on their lifespan and start and range color components values.</haxe_doc>
		</useColoring>
		<maxLifespan public="1">
			<x path="Float"/>
			<haxe_doc>* Helper variable for fading, scaling and coloring particle.</haxe_doc>
		</maxLifespan>
		<startAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* Start value for particle's alpha</haxe_doc>
		</startAlpha>
		<rangeAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* Range of alpha change during particle's life</haxe_doc>
		</rangeAlpha>
		<startScale public="1">
			<x path="Float"/>
			<haxe_doc>* Start value for particle's scale.x and scale.y</haxe_doc>
		</startScale>
		<rangeScale public="1">
			<x path="Float"/>
			<haxe_doc>* Range of scale change during particle's life</haxe_doc>
		</rangeScale>
		<startRed public="1">
			<x path="Float"/>
			<haxe_doc>* Start value for particle's red color component</haxe_doc>
		</startRed>
		<startGreen public="1">
			<x path="Float"/>
			<haxe_doc>* Start value for particle's green color component</haxe_doc>
		</startGreen>
		<startBlue public="1">
			<x path="Float"/>
			<haxe_doc>* Start value for particle's blue color component</haxe_doc>
		</startBlue>
		<rangeRed public="1">
			<x path="Float"/>
			<haxe_doc>* Range of red color component change during particle's life</haxe_doc>
		</rangeRed>
		<rangeGreen public="1">
			<x path="Float"/>
			<haxe_doc>* Range of green color component change during particle's life</haxe_doc>
		</rangeGreen>
		<rangeBlue public="1">
			<x path="Float"/>
			<haxe_doc>* Range of blue color component change during particle's life</haxe_doc>
		</rangeBlue>
		<update public="1" set="method" line="105" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The particle's main update logic.  Basically it checks to see if it should
	 * be dead yet, and then has some special bounce behavior if there is some gravity on it.</haxe_doc>
		</update>
		<reset public="1" set="method" line="184" override="1"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<onEmit public="1" set="method" line="197">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Triggered whenever this object is launched by a FlxEmitter.
	 * You can override this to add custom behavior like a sound or AI or something.</haxe_doc>
		</onEmit>
		<new public="1" set="method" line="94">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate a new particle. Like FlxSprite, all meaningful creation
	 * happens during loadGraphic() or makeGraphic() or whatever.</haxe_doc>
		</new>
		<haxe_doc>* This is a simple particle class that extends the default behavior
 * of FlxSprite to have slightly more specialized behavior
 * common to many game scenarios.  You can override and extend this class
 * just like you would FlxSprite. While FlxEmitter
 * used to work with just any old sprite, it now requires a
 * FlxParticle based class.</haxe_doc>
	</class>
	<class path="flixel.effects.particles.Bounds" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/effects/particles/FlxTypedEmitter.hx" module="flixel.effects.particles.FlxTypedEmitter">
		<min public="1"><c path="flixel.effects.particles.Bounds.T"/></min>
		<max public="1"><c path="flixel.effects.particles.Bounds.T"/></max>
		<new public="1" set="method" line="898"><f a="min:?max" v=":null">
	<c path="flixel.effects.particles.Bounds.T"/>
	<c path="flixel.effects.particles.Bounds.T"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Helper object for holding bounds of different variables</haxe_doc>
	</class>
	<class path="flixel.group.FlxTypedGroupIterator" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/group/FlxTypedGroupIterator.hx">
		<_groupMembers><c path="Array"><c path="flixel.group.FlxTypedGroupIterator.T"/></c></_groupMembers>
		<_filter><f a="">
	<c path="flixel.group.FlxTypedGroupIterator.T"/>
	<x path="Bool"/>
</f></_filter>
		<_cursor><x path="Int"/></_cursor>
		<_length><x path="Int"/></_length>
		<next public="1" set="method" line="25"><f a=""><c path="flixel.group.FlxTypedGroupIterator.T"/></f></next>
		<hasNext public="1" set="method" line="30"><f a=""><x path="Bool"/></f></hasNext>
		<new public="1" set="method" line="17"><f a="GroupMembers:?filter" v=":null">
	<c path="Array"><c path="flixel.group.FlxTypedGroupIterator.T"/></c>
	<f a="">
		<c path="flixel.group.FlxTypedGroupIterator.T"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Iterator implementation for groups
 * Support a filter method (used for iteratorAlive, iteratorDead and iteratorExists)
 * @author Masadow</haxe_doc>
	</class>
	<class path="flixel.input.FlxSwipe" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/FlxSwipe.hx">
		<ID public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Either LEFT_MOUSE, MIDDLE_MOUSE or RIGHT_MOUSE, 
	 * or the touchPointID of a FlxTouch.</haxe_doc>
		</ID>
		<startPosition public="1" set="null"><c path="flixel.util.FlxPoint"/></startPosition>
		<endPosition public="1" set="null"><c path="flixel.util.FlxPoint"/></endPosition>
		<distance public="1" get="accessor" set="null"><x path="Float"/></distance>
		<angle public="1" get="accessor" set="null"><x path="Float"/></angle>
		<duration public="1" get="accessor" set="null"><x path="Float"/></duration>
		<_startTimeInTicks><x path="Float"/></_startTimeInTicks>
		<_endTimeInTicks><x path="Float"/></_endTimeInTicks>
		<toString get="inline" set="null" line="42"><f a=""><c path="String"/></f></toString>
		<get_distance get="inline" set="null" line="53"><f a=""><x path="Float"/></f></get_distance>
		<get_angle get="inline" set="null" line="58"><f a=""><x path="Float"/></f></get_angle>
		<get_duration get="inline" set="null" line="63"><f a=""><x path="Float"/></f></get_duration>
		<new set="method" line="33"><f a="ID:StartPosition:EndPosition:StartTimeInTicks">
	<x path="Int"/>
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
		</meta>
	</class>
	<class path="flixel.input.android.FlxAndroidKeyList" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/android/FlxAndroidKeyList.hx">
		<check><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></check>
		<BACK public="1" get="accessor" set="null"><x path="Bool"/></BACK>
		<get_BACK get="inline" set="null" line="17"><f a=""><x path="Bool"/></f></get_BACK>
		<MENU public="1" get="accessor" set="null"><x path="Bool"/></MENU>
		<get_MENU get="inline" set="null" line="18"><f a=""><x path="Bool"/></f></get_MENU>
		<ANY public="1" get="accessor" set="null"><x path="Bool"/></ANY>
		<get_ANY set="method" line="21"><f a=""><x path="Bool"/></f></get_ANY>
		<new public="1" set="method" line="11"><f a="CheckFunction">
	<f a="">
		<c path="String"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for android input.</haxe_doc>
	</class>
	<class path="flixel.input.gamepad.FlxGamepad" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/gamepad/FlxGamepad.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<JUST_RELEASED public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></JUST_RELEASED>
		<RELEASED public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></RELEASED>
		<PRESSED public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></PRESSED>
		<JUST_PRESSED public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></JUST_PRESSED>
		<id public="1"><x path="Int"/></id>
		<buttons public="1"><c path="Array"><c path="flixel.input.gamepad.FlxGamepadButton"/></c></buttons>
		<deadZone public="1">
			<x path="Float"/>
			<haxe_doc>* Gamepad deadzone. Sets the sensibility. 
	 * Less this number the more gamepad is sensible. Should be between 0.0 and 1.0.</haxe_doc>
		</deadZone>
		<hat public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* DPAD</haxe_doc>
		</hat>
		<ball public="1"><c path="flixel.util.FlxPoint"/></ball>
		<dpadUp public="1" get="accessor" set="null"><x path="Bool"/></dpadUp>
		<dpadDown public="1" get="accessor" set="null"><x path="Bool"/></dpadDown>
		<dpadLeft public="1" get="accessor" set="null"><x path="Bool"/></dpadLeft>
		<dpadRight public="1" get="accessor" set="null"><x path="Bool"/></dpadRight>
		<axis>
			<c path="Array"><x path="Float"/></c>
			<haxe_doc>* Axis array is read-only, use "getAxis" function for deadZone checking.</haxe_doc>
		</axis>
		<getButton public="1" set="method" line="71"><f a="ButtonID">
	<x path="Int"/>
	<c path="flixel.input.gamepad.FlxGamepadButton"/>
</f></getButton>
		<update public="1" set="method" line="87">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the key states (for tracking just pressed, just released, etc).</haxe_doc>
		</update>
		<reset public="1" set="method" line="135"><f a=""><x path="Void"/></f></reset>
		<destroy public="1" set="method" line="159"><f a=""><x path="Void"/></f></destroy>
		<checkStatus public="1" set="method" line="180">
			<f a="ButtonID:Status">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check the status of a button
	 * 
	 * @param	ButtonID	Index into _keyList array.
	 * @param	Status		The key state to check for
	 * @return	Whether the provided button has the specified status</haxe_doc>
		</checkStatus>
		<anyPressed public="1" set="method" line="195">
			<f a="ButtonIDArray">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if at least one button from an array of button IDs is pressed.
	 * 
	 * @param	ButtonIDArray	An array of button IDs
	 * @return	Whether at least one of the buttons is pressed</haxe_doc>
		</anyPressed>
		<anyJustPressed public="1" set="method" line="215">
			<f a="ButtonIDArray">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if at least one button from an array of button IDs was just pressed.
	 * 
	 * @param	ButtonArray	An array of button IDs
	 * @return	Whether at least one of the buttons was just pressed</haxe_doc>
		</anyJustPressed>
		<anyJustReleased public="1" set="method" line="235">
			<f a="ButtonIDArray">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if at least one button from an array of button IDs was just released.
	 * 
	 * @param	ButtonArray	An array of button IDs
	 * @return	Whether at least one of the buttons was just released</haxe_doc>
		</anyJustReleased>
		<pressed public="1" set="method" line="255">
			<f a="ButtonID">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if this button is pressed.
	 * 
	 * @param	ButtonID	The button ID.
	 * @return	Whether the button is pressed</haxe_doc>
		</pressed>
		<justPressed public="1" set="method" line="281">
			<f a="ButtonID">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if this button was just pressed.
	 * 
	 * @param	ButtonID	The button ID.
	 * @return	Whether the button was just pressed</haxe_doc>
		</justPressed>
		<justReleased public="1" set="method" line="297">
			<f a="ButtonID">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if this button was just released.
	 * 
	 * @param	ButtonID	The button ID.
	 * @return	Whether the button was just released.</haxe_doc>
		</justReleased>
		<firstPressedButtonID public="1" set="method" line="311">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get the first found ID of the button which is currently pressed.
	 * Returns -1 if no button is pressed.</haxe_doc>
		</firstPressedButtonID>
		<firstJustPressedButtonID public="1" set="method" line="328">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get the first found ID of the button which has been just pressed.
	 * Returns -1 if no button was just pressed.</haxe_doc>
		</firstJustPressedButtonID>
		<firstJustReleasedButtonID public="1" set="method" line="345">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get the first found ID of the button which has been just released.
	 * Returns -1 if no button was just released.</haxe_doc>
		</firstJustReleasedButtonID>
		<getAxis public="1" get="inline" set="null" line="362">
			<f a="AxisID">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Gets the value of the specified axis - DOES NOT WORK WELL ON 
	 * THE FLASH TARGET, use getXAxis() and getYAxis() instead.</haxe_doc>
		</getAxis>
		<getXAxis public="1" get="inline" set="null" line="370">
			<f a="AxisID">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Gets the value of the specified X axis.</haxe_doc>
		</getXAxis>
		<getYAxis public="1" set="method" line="379">
			<f a="AxisID">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Gets the value of the specified Y axis - 
	 * should be used in flash to correct the inverted y axis.</haxe_doc>
		</getYAxis>
		<anyButton public="1" set="method" line="399">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if any buttons are pressed right now.</haxe_doc>
		</anyButton>
		<anyInput public="1" set="method" line="415">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if any buttons are pressed right or Axis, Ball and Hat Moved now.</haxe_doc>
		</anyInput>
		<getAxisValue set="method" line="445"><f a="AxisID">
	<x path="Int"/>
	<x path="Float"/>
</f></getAxisValue>
		<get_dpadUp get="inline" set="null" line="475"><f a=""><x path="Bool"/></f></get_dpadUp>
		<get_dpadDown get="inline" set="null" line="476"><f a=""><x path="Bool"/></f></get_dpadDown>
		<get_dpadLeft get="inline" set="null" line="477"><f a=""><x path="Bool"/></f></get_dpadLeft>
		<get_dpadRight get="inline" set="null" line="478"><f a=""><x path="Bool"/></f></get_dpadRight>
		<new public="1" set="method" line="54"><f a="ID:?GlobalDeadZone" v=":0">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.input.gamepad.FlxGamepadButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/gamepad/FlxGamepadButton.hx">
		<id public="1"><x path="Int"/></id>
		<current public="1"><x path="Int"/></current>
		<last public="1"><x path="Int"/></last>
		<reset public="1" set="method" line="20"><f a=""><x path="Void"/></f></reset>
		<release public="1" set="method" line="26"><f a=""><x path="Void"/></f></release>
		<press public="1" set="method" line="48"><f a=""><x path="Void"/></f></press>
		<new public="1" set="method" line="13"><f a="ID:?Current:?Last" v=":0:0">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.input.gamepad.FlxGamepadManager" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/gamepad/FlxGamepadManager.hx">
		<implements path="flixel.interfaces.IFlxInput"/>
		<firstActive public="1">
			<c path="flixel.input.gamepad.FlxGamepad"/>
			<haxe_doc>* The first accessed gamepad - can be null!</haxe_doc>
		</firstActive>
		<lastActive public="1">
			<c path="flixel.input.gamepad.FlxGamepad"/>
			<haxe_doc>* The last accessed gamepad - can be null!</haxe_doc>
		</lastActive>
		<numActiveGamepads public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* A counter for the number of active gamepads</haxe_doc>
		</numActiveGamepads>
		<globalDeadZone public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* While you can have each joystick use a custom dead zone, setting this will 
	 * set every gamepad to use this deadzone.</haxe_doc>
		</globalDeadZone>
		<_gamepads>
			<c path="Array"><c path="flixel.input.gamepad.FlxGamepad"/></c>
			<haxe_doc>* Storage for all connected joysticks</haxe_doc>
		</_gamepads>
		<getByID public="1" set="method" line="57"><f a="GamepadID">
	<x path="Int"/>
	<c path="flixel.input.gamepad.FlxGamepad"/>
</f></getByID>
		<getActiveGamepadIDs public="1" set="method" line="82">
			<f a="?IDsArray" v="null">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Get array of ids for gamepads with any pressed buttons or moved Axis, Ball and Hat.
	 * 
	 * @param	IDsArray	optional array to fill with ids
	 * @return	array filled with active gamepad ids</haxe_doc>
		</getActiveGamepadIDs>
		<getActiveGamepads public="1" set="method" line="106">
			<f a="?GamepadArray" v="null">
				<c path="Array"><c path="flixel.input.gamepad.FlxGamepad"/></c>
				<c path="Array"><c path="flixel.input.gamepad.FlxGamepad"/></c>
			</f>
			<haxe_doc>* Get array of gamepads with any pressed buttons or moved Axis, Ball and Hat.
	 * 
	 * @param	GamepadArray	optional array to fill with active gamepads
	 * @return	array filled with active gamepads</haxe_doc>
		</getActiveGamepads>
		<getFirstActiveGamepadID public="1" set="method" line="128">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get first found active gamepad id (with any pressed buttons or moved Axis, Ball and Hat).
	 * Returns "-1" if no active gamepad has been found.</haxe_doc>
		</getFirstActiveGamepadID>
		<getFirstActiveGamepad public="1" set="method" line="138">
			<f a=""><c path="flixel.input.gamepad.FlxGamepad"/></f>
			<haxe_doc>* Get first found active gamepad (with any pressed buttons or moved Axis, Ball and Hat).
	 * Returns null if no active gamepad has been found.</haxe_doc>
		</getFirstActiveGamepad>
		<anyButton public="1" set="method" line="154">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if any button was pressed on any Gamepad</haxe_doc>
		</anyButton>
		<anyInput public="1" set="method" line="170">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if any buttons are pressed right or Axis, Ball and Hat Moved on any Gamepad</haxe_doc>
		</anyInput>
		<anyPressed public="1" set="method" line="189">
			<f a="ButtonID">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if this button is pressed on any Gamepad.
	 * 
	 * @param 	ButtonID  The button id (from 0 to 7).
	 * @return 	Whether the button is pressed</haxe_doc>
		</anyPressed>
		<anyJustPressed public="1" set="method" line="208">
			<f a="ButtonID">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if this button was just pressed on any Gamepad.
	 * 
	 * @param 	ButtonID 	The button id (from 0 to 7).
	 * @return 	Whether the button was just pressed</haxe_doc>
		</anyJustPressed>
		<anyJustReleased public="1" set="method" line="227">
			<f a="ButtonID">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if this button is just released on any Gamepad.
	 * 
	 * @param 	ButtonID 	The Button id (from 0 to 7).
	 * @return 	Whether the button is just released.</haxe_doc>
		</anyJustReleased>
		<destroy public="1" set="method" line="244">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Clean up memory. Internal use only.</haxe_doc>
		</destroy>
		<reset public="1" set="method" line="265">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets all the keys on all joys.</haxe_doc>
		</reset>
		<handleButtonDown set="method" line="360"><f a="FlashEvent">
	<c path="openfl.events.JoystickEvent"/>
	<x path="Void"/>
</f></handleButtonDown>
		<handleButtonUp set="method" line="371"><f a="FlashEvent">
	<c path="openfl.events.JoystickEvent"/>
	<x path="Void"/>
</f></handleButtonUp>
		<handleAxisMove set="method" line="382"><f a="FlashEvent">
	<c path="openfl.events.JoystickEvent"/>
	<x path="Void"/>
</f></handleAxisMove>
		<handleBallMove set="method" line="388"><f a="FlashEvent">
	<c path="openfl.events.JoystickEvent"/>
	<x path="Void"/>
</f></handleBallMove>
		<handleHatMove set="method" line="395"><f a="FlashEvent">
	<c path="openfl.events.JoystickEvent"/>
	<x path="Void"/>
</f></handleHatMove>
		<update set="method" line="406">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the key states (for tracking just pressed, just released, etc).</haxe_doc>
		</update>
		<onFocus get="inline" set="null" line="417"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost get="inline" set="null" line="419"><f a=""><x path="Void"/></f></onFocusLost>
		<get_numActiveGamepads set="method" line="424"><f a=""><x path="Int"/></f></get_numActiveGamepads>
		<set_globalDeadZone set="method" line="443">
			<f a="DeadZone">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Facility function to set the deadzone on every available gamepad.
	 * @param	DeadZone	Joystick deadzone. Sets the sensibility. 
	 * 						Less this number the more Joystick is sensible.
	 * 						Should be between 0.0 and 1.0.</haxe_doc>
		</set_globalDeadZone>
		<new set="method" line="277">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</new>
		<haxe_doc>* Manages gamepad input
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.input.gamepad.LogitechButtonID" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/gamepad/LogitechButtonID.hx">
		<ONE public="1" get="inline" set="null" line="80" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to 'X' button on the Xbox 360 controller.</haxe_doc>
		</ONE>
		<TWO public="1" get="inline" set="null" line="84" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to 'A' button on the Xbox 360 controller.</haxe_doc>
		</TWO>
		<THREE public="1" get="inline" set="null" line="88" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to 'B' button on the Xbox 360 controller.</haxe_doc>
		</THREE>
		<FOUR public="1" get="inline" set="null" line="92" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to 'Y' button on the Xbox 360 controller.</haxe_doc>
		</FOUR>
		<FIVE public="1" get="inline" set="null" line="97" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to the left bumper on the Xbox 360 controller.</haxe_doc>
		</FIVE>
		<SIX public="1" get="inline" set="null" line="101" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to the right bumper on the Xbox 360 controller.</haxe_doc>
		</SIX>
		<SEVEN public="1" get="inline" set="null" line="106" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to the left trigger on the Xbox 360 controller.
	 * (it is a bumper though)</haxe_doc>
		</SEVEN>
		<EIGHT public="1" get="inline" set="null" line="111" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to the right trigger on the Xbox 360 controller.
	 * (it is a bumper though)</haxe_doc>
		</EIGHT>
		<NINE public="1" get="inline" set="null" line="116" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to the 'Back' button on the Xbox 360 controller.</haxe_doc>
		</NINE>
		<TEN public="1" get="inline" set="null" line="120" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to the 'Menu' button on the Xbox 360 controller.</haxe_doc>
		</TEN>
		<LEFT_ANALOGUE public="1" get="inline" set="null" line="125" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to the 'left analogue' button on the Xbox 360 controller.</haxe_doc>
		</LEFT_ANALOGUE>
		<RIGHT_ANALOGUE public="1" get="inline" set="null" line="129" static="1">
			<x path="Int"/>
			<haxe_doc>* Placement equivalent to the 'right analogue' button on the Xbox 360 controller.</haxe_doc>
		</RIGHT_ANALOGUE>
		<LEFT_ANALOGUE_X public="1" get="inline" set="null" line="134" static="1">
			<x path="Int"/>
			<haxe_doc>* Axis array indicies</haxe_doc>
		</LEFT_ANALOGUE_X>
		<LEFT_ANALOGUE_Y public="1" get="inline" set="null" line="135" static="1"><x path="Int"/></LEFT_ANALOGUE_Y>
		<RIGHT_ANALOGUE_X public="1" get="inline" set="null" line="137" static="1"><x path="Int"/></RIGHT_ANALOGUE_X>
		<RIGHT_ANALOGUE_Y public="1" get="inline" set="null" line="138" static="1"><x path="Int"/></RIGHT_ANALOGUE_Y>
		<haxe_doc>* Button IDs for Logitech controllers (key codes based on Cordless Rumblepad 2)</haxe_doc>
	</class>
	<class path="flixel.input.gamepad.OUYAButtonID" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/gamepad/OUYAButtonID.hx">
		<O public="1" get="inline" set="null" line="11" static="1">
			<x path="Int"/>
			<haxe_doc>* Button IDs (DPAD values are obtained from FlxGamepad.hat)</haxe_doc>
		</O>
		<U public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></U>
		<Y public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></Y>
		<A public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></A>
		<LB public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></LB>
		<RB public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></RB>
		<LEFT_ANALOGUE public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></LEFT_ANALOGUE>
		<RIGHT_ANALOGUE public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></RIGHT_ANALOGUE>
		<HOME public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></HOME>
		<LEFT_TRIGGER public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></LEFT_TRIGGER>
		<RIGHT_TRIGGER public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></RIGHT_TRIGGER>
		<LEFT_ANALOGUE_X public="1" get="inline" set="null" line="27" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Axis array indicies
	 * 
	 * If TRIGGER axis returns value > 0 then LT is being pressed, and if it's < 0 then RT is being pressed]]></haxe_doc>
		</LEFT_ANALOGUE_X>
		<LEFT_ANALOGUE_Y public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></LEFT_ANALOGUE_Y>
		<RIGHT_ANALOGUE_X public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></RIGHT_ANALOGUE_X>
		<RIGHT_ANALOGUE_Y public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></RIGHT_ANALOGUE_Y>
		<LEFT_TRIGGER_ANALOG public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></LEFT_TRIGGER_ANALOG>
		<RIGHT_TRIGGER_ANALOG public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></RIGHT_TRIGGER_ANALOG>
		<haxe_doc>* Button IDs for OUYA controllers</haxe_doc>
	</class>
	<class path="flixel.input.gamepad.PS3ButtonID" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/gamepad/PS3ButtonID.hx">
		<TRIANGLE_BUTTON public="1" get="inline" set="null" line="8" static="1"><x path="Int"/></TRIANGLE_BUTTON>
		<CIRCLE_BUTTON public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></CIRCLE_BUTTON>
		<X_BUTTON public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></X_BUTTON>
		<SQUARE_BUTTON public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></SQUARE_BUTTON>
		<L1_BUTTON public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></L1_BUTTON>
		<R1_BUTTON public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></R1_BUTTON>
		<L2_BUTTON public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></L2_BUTTON>
		<R2_BUTTON public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></R2_BUTTON>
		<SELECT_BUTTON public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></SELECT_BUTTON>
		<START_BUTTON public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></START_BUTTON>
		<PS_BUTTON public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></PS_BUTTON>
		<LEFT_ANALOGUE_BUTTON public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></LEFT_ANALOGUE_BUTTON>
		<RIGHT_ANALOGUE_BUTTON public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></RIGHT_ANALOGUE_BUTTON>
		<DPAD_UP public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></DPAD_RIGHT>
		<LEFT_ANALOGUE_X public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></LEFT_ANALOGUE_X>
		<LEFT_ANALOGUE_Y public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></LEFT_ANALOGUE_Y>
		<TRIANGLE_BUTTON_PRESSURE public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></TRIANGLE_BUTTON_PRESSURE>
		<CIRCLE_BUTTON_PRESSURE public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></CIRCLE_BUTTON_PRESSURE>
		<X_BUTTON_PRESSURE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></X_BUTTON_PRESSURE>
		<SQUARE_BUTTON_PRESSURE public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></SQUARE_BUTTON_PRESSURE>
		<haxe_doc>* Button IDs for PlayStation 3 controllers</haxe_doc>
	</class>
	<class path="flixel.input.gamepad.PS4ButtonID" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/gamepad/PS4ButtonID.hx">
		<TRIANGLE_BUTTON public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></TRIANGLE_BUTTON>
		<CIRCLE_BUTTON public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></CIRCLE_BUTTON>
		<X_BUTTON public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></X_BUTTON>
		<SQUARE_BUTTON public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></SQUARE_BUTTON>
		<L1_BUTTON public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></L1_BUTTON>
		<R1_BUTTON public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></R1_BUTTON>
		<L2_BUTTON public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></L2_BUTTON>
		<R2_BUTTON public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></R2_BUTTON>
		<SHARE_BUTTON public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></SHARE_BUTTON>
		<START_BUTTON public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></START_BUTTON>
		<PS_BUTTON public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></PS_BUTTON>
		<TOUCHPAD public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></TOUCHPAD>
		<LEFT_ANALOGUE_BUTTON public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></LEFT_ANALOGUE_BUTTON>
		<RIGHT_ANALOGUE_BUTTON public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></RIGHT_ANALOGUE_BUTTON>
		<LEFT_ANALOGUE_X public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></LEFT_ANALOGUE_X>
		<LEFT_ANALOGUE_Y public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></LEFT_ANALOGUE_Y>
		<RIGHT_ANALOGUE_X public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></RIGHT_ANALOGUE_X>
		<RIGHT_ANALOGUE_Y public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></RIGHT_ANALOGUE_Y>
		<L2_BUTTON_Y public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></L2_BUTTON_Y>
		<R2_BUTTON_Y public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></R2_BUTTON_Y>
		<haxe_doc>* Button IDs for PlayStation 4 controllers
 * (D-pad values are obtained from FlxGamepad.hat)</haxe_doc>
	</class>
	<class path="flixel.input.gamepad.XboxButtonID" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/gamepad/XboxButtonID.hx">
		<A public="1" get="inline" set="null" line="62" static="1">
			<x path="Int"/>
			<haxe_doc>* Button IDs (DPAD values are obtained from FlxGamepad.hat)</haxe_doc>
		</A>
		<B public="1" get="inline" set="null" line="63" static="1"><x path="Int"/></B>
		<X public="1" get="inline" set="null" line="64" static="1"><x path="Int"/></X>
		<Y public="1" get="inline" set="null" line="65" static="1"><x path="Int"/></Y>
		<LB public="1" get="inline" set="null" line="66" static="1"><x path="Int"/></LB>
		<RB public="1" get="inline" set="null" line="67" static="1"><x path="Int"/></RB>
		<BACK public="1" get="inline" set="null" line="68" static="1"><x path="Int"/></BACK>
		<START public="1" get="inline" set="null" line="69" static="1"><x path="Int"/></START>
		<LEFT_ANALOGUE public="1" get="inline" set="null" line="70" static="1"><x path="Int"/></LEFT_ANALOGUE>
		<RIGHT_ANALOGUE public="1" get="inline" set="null" line="71" static="1"><x path="Int"/></RIGHT_ANALOGUE>
		<TRIGGER public="1" get="inline" set="null" line="78" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Axis array indicies
	 * 
	 * If TRIGGER axis returns value > 0 then LT is being pressed, and if it's < 0 then RT is being pressed]]></haxe_doc>
		</TRIGGER>
		<LEFT_ANALOGUE_X public="1" get="inline" set="null" line="79" static="1"><x path="Int"/></LEFT_ANALOGUE_X>
		<LEFT_ANALOGUE_Y public="1" get="inline" set="null" line="80" static="1"><x path="Int"/></LEFT_ANALOGUE_Y>
		<RIGHT_ANALOGUE_X public="1" get="inline" set="null" line="81" static="1"><x path="Int"/></RIGHT_ANALOGUE_X>
		<RIGHT_ANALOGUE_Y public="1" get="inline" set="null" line="82" static="1"><x path="Int"/></RIGHT_ANALOGUE_Y>
		<haxe_doc>* Button IDs for Xbox 360 controllers</haxe_doc>
	</class>
	<class path="flixel.input.keyboard.FlxKey" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/keyboard/FlxKey.hx">
		<JUST_RELEASED public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></JUST_RELEASED>
		<RELEASED public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></RELEASED>
		<PRESSED public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></PRESSED>
		<JUST_PRESSED public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></JUST_PRESSED>
		<A public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></A>
		<B public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></B>
		<C public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></C>
		<D public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></D>
		<E public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></E>
		<F public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></F>
		<G public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></G>
		<H public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></H>
		<I public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></I>
		<J public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></J>
		<K public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></K>
		<L public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></L>
		<M public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></M>
		<N public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></N>
		<O public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></O>
		<P public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></P>
		<Q public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></Q>
		<R public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></R>
		<S public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></S>
		<T public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></T>
		<U public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></U>
		<V public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></V>
		<W public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></W>
		<X public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></X>
		<Y public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></Y>
		<Z public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></Z>
		<ZERO public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></ZERO>
		<ONE public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></ONE>
		<TWO public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></TWO>
		<THREE public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></THREE>
		<FOUR public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></FOUR>
		<FIVE public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></FIVE>
		<SIX public="1" get="inline" set="null" line="47" static="1"><x path="Int"/></SIX>
		<SEVEN public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></SEVEN>
		<EIGHT public="1" get="inline" set="null" line="49" static="1"><x path="Int"/></EIGHT>
		<NINE public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></NINE>
		<PAGEUP public="1" get="inline" set="null" line="51" static="1"><x path="Int"/></PAGEUP>
		<PAGEDOWN public="1" get="inline" set="null" line="52" static="1"><x path="Int"/></PAGEDOWN>
		<HOME public="1" get="inline" set="null" line="53" static="1"><x path="Int"/></HOME>
		<END public="1" get="inline" set="null" line="54" static="1"><x path="Int"/></END>
		<INSERT public="1" get="inline" set="null" line="55" static="1"><x path="Int"/></INSERT>
		<ESCAPE public="1" get="inline" set="null" line="56" static="1"><x path="Int"/></ESCAPE>
		<MINUS public="1" get="inline" set="null" line="57" static="1"><x path="Int"/></MINUS>
		<PLUS public="1" get="inline" set="null" line="58" static="1"><x path="Int"/></PLUS>
		<DELETE public="1" get="inline" set="null" line="59" static="1"><x path="Int"/></DELETE>
		<BACKSPACE public="1" get="inline" set="null" line="60" static="1"><x path="Int"/></BACKSPACE>
		<LBRACKET public="1" get="inline" set="null" line="61" static="1"><x path="Int"/></LBRACKET>
		<RBRACKET public="1" get="inline" set="null" line="62" static="1"><x path="Int"/></RBRACKET>
		<BACKSLASH public="1" get="inline" set="null" line="63" static="1"><x path="Int"/></BACKSLASH>
		<CAPSLOCK public="1" get="inline" set="null" line="64" static="1"><x path="Int"/></CAPSLOCK>
		<SEMICOLON public="1" get="inline" set="null" line="65" static="1"><x path="Int"/></SEMICOLON>
		<QUOTE public="1" get="inline" set="null" line="66" static="1"><x path="Int"/></QUOTE>
		<ENTER public="1" get="inline" set="null" line="67" static="1"><x path="Int"/></ENTER>
		<SHIFT public="1" get="inline" set="null" line="68" static="1"><x path="Int"/></SHIFT>
		<COMMA public="1" get="inline" set="null" line="69" static="1"><x path="Int"/></COMMA>
		<PERIOD public="1" get="inline" set="null" line="70" static="1"><x path="Int"/></PERIOD>
		<SLASH public="1" get="inline" set="null" line="71" static="1"><x path="Int"/></SLASH>
		<NUMPADSLASH public="1" get="inline" set="null" line="72" static="1"><x path="Int"/></NUMPADSLASH>
		<GRAVEACCENT public="1" get="inline" set="null" line="73" static="1"><x path="Int"/></GRAVEACCENT>
		<CONTROL public="1" get="inline" set="null" line="74" static="1"><x path="Int"/></CONTROL>
		<ALT public="1" get="inline" set="null" line="75" static="1"><x path="Int"/></ALT>
		<SPACE public="1" get="inline" set="null" line="76" static="1"><x path="Int"/></SPACE>
		<UP public="1" get="inline" set="null" line="77" static="1"><x path="Int"/></UP>
		<DOWN public="1" get="inline" set="null" line="78" static="1"><x path="Int"/></DOWN>
		<LEFT public="1" get="inline" set="null" line="79" static="1"><x path="Int"/></LEFT>
		<RIGHT public="1" get="inline" set="null" line="80" static="1"><x path="Int"/></RIGHT>
		<TAB public="1" get="inline" set="null" line="81" static="1"><x path="Int"/></TAB>
		<F1 public="1" get="inline" set="null" line="82" static="1"><x path="Int"/></F1>
		<F2 public="1" get="inline" set="null" line="83" static="1"><x path="Int"/></F2>
		<F3 public="1" get="inline" set="null" line="84" static="1"><x path="Int"/></F3>
		<F4 public="1" get="inline" set="null" line="85" static="1"><x path="Int"/></F4>
		<F5 public="1" get="inline" set="null" line="86" static="1"><x path="Int"/></F5>
		<F6 public="1" get="inline" set="null" line="87" static="1"><x path="Int"/></F6>
		<F7 public="1" get="inline" set="null" line="88" static="1"><x path="Int"/></F7>
		<F8 public="1" get="inline" set="null" line="89" static="1"><x path="Int"/></F8>
		<F9 public="1" get="inline" set="null" line="90" static="1"><x path="Int"/></F9>
		<F10 public="1" get="inline" set="null" line="91" static="1"><x path="Int"/></F10>
		<F11 public="1" get="inline" set="null" line="92" static="1"><x path="Int"/></F11>
		<F12 public="1" get="inline" set="null" line="93" static="1"><x path="Int"/></F12>
		<NUMPADZERO public="1" get="inline" set="null" line="94" static="1"><x path="Int"/></NUMPADZERO>
		<NUMPADONE public="1" get="inline" set="null" line="95" static="1"><x path="Int"/></NUMPADONE>
		<NUMPADTWO public="1" get="inline" set="null" line="96" static="1"><x path="Int"/></NUMPADTWO>
		<NUMPADTHREE public="1" get="inline" set="null" line="97" static="1"><x path="Int"/></NUMPADTHREE>
		<NUMPADFOUR public="1" get="inline" set="null" line="98" static="1"><x path="Int"/></NUMPADFOUR>
		<NUMPADFIVE public="1" get="inline" set="null" line="99" static="1"><x path="Int"/></NUMPADFIVE>
		<NUMPADSIX public="1" get="inline" set="null" line="100" static="1"><x path="Int"/></NUMPADSIX>
		<NUMPADSEVEN public="1" get="inline" set="null" line="101" static="1"><x path="Int"/></NUMPADSEVEN>
		<NUMPADEIGHT public="1" get="inline" set="null" line="102" static="1"><x path="Int"/></NUMPADEIGHT>
		<NUMPADNINE public="1" get="inline" set="null" line="103" static="1"><x path="Int"/></NUMPADNINE>
		<NUMPADMINUS public="1" get="inline" set="null" line="104" static="1"><x path="Int"/></NUMPADMINUS>
		<NUMPADPLUS public="1" get="inline" set="null" line="105" static="1"><x path="Int"/></NUMPADPLUS>
		<NUMPADPERIOD public="1" get="inline" set="null" line="106" static="1"><x path="Int"/></NUMPADPERIOD>
		<NUMPADMULTIPLY public="1" get="inline" set="null" line="107" static="1"><x path="Int"/></NUMPADMULTIPLY>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of this key.</haxe_doc>
		</name>
		<current public="1">
			<x path="Int"/>
			<haxe_doc>* The current state of this key.</haxe_doc>
		</current>
		<last public="1">
			<x path="Int"/>
			<haxe_doc>* The last state of this key.</haxe_doc>
		</last>
		<new public="1" set="method" line="122"><f a="Name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for keyboard input.</haxe_doc>
	</class>
	<class path="flixel.input.keyboard.FlxKeyList" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/keyboard/FlxKeyList.hx">
		<checkStatus><x path="Int"/></checkStatus>
		<A public="1" get="accessor" set="null"><x path="Bool"/></A>
		<get_A get="inline" set="null" line="19"><f a=""><x path="Bool"/></f></get_A>
		<B public="1" get="accessor" set="null"><x path="Bool"/></B>
		<get_B get="inline" set="null" line="20"><f a=""><x path="Bool"/></f></get_B>
		<C public="1" get="accessor" set="null"><x path="Bool"/></C>
		<get_C get="inline" set="null" line="21"><f a=""><x path="Bool"/></f></get_C>
		<D public="1" get="accessor" set="null"><x path="Bool"/></D>
		<get_D get="inline" set="null" line="22"><f a=""><x path="Bool"/></f></get_D>
		<E public="1" get="accessor" set="null"><x path="Bool"/></E>
		<get_E get="inline" set="null" line="23"><f a=""><x path="Bool"/></f></get_E>
		<F public="1" get="accessor" set="null"><x path="Bool"/></F>
		<get_F get="inline" set="null" line="24"><f a=""><x path="Bool"/></f></get_F>
		<G public="1" get="accessor" set="null"><x path="Bool"/></G>
		<get_G get="inline" set="null" line="25"><f a=""><x path="Bool"/></f></get_G>
		<H public="1" get="accessor" set="null"><x path="Bool"/></H>
		<get_H get="inline" set="null" line="26"><f a=""><x path="Bool"/></f></get_H>
		<I public="1" get="accessor" set="null"><x path="Bool"/></I>
		<get_I get="inline" set="null" line="27"><f a=""><x path="Bool"/></f></get_I>
		<J public="1" get="accessor" set="null"><x path="Bool"/></J>
		<get_J get="inline" set="null" line="28"><f a=""><x path="Bool"/></f></get_J>
		<K public="1" get="accessor" set="null"><x path="Bool"/></K>
		<get_K get="inline" set="null" line="29"><f a=""><x path="Bool"/></f></get_K>
		<L public="1" get="accessor" set="null"><x path="Bool"/></L>
		<get_L get="inline" set="null" line="30"><f a=""><x path="Bool"/></f></get_L>
		<M public="1" get="accessor" set="null"><x path="Bool"/></M>
		<get_M get="inline" set="null" line="31"><f a=""><x path="Bool"/></f></get_M>
		<N public="1" get="accessor" set="null"><x path="Bool"/></N>
		<get_N get="inline" set="null" line="32"><f a=""><x path="Bool"/></f></get_N>
		<O public="1" get="accessor" set="null"><x path="Bool"/></O>
		<get_O get="inline" set="null" line="33"><f a=""><x path="Bool"/></f></get_O>
		<P public="1" get="accessor" set="null"><x path="Bool"/></P>
		<get_P get="inline" set="null" line="34"><f a=""><x path="Bool"/></f></get_P>
		<Q public="1" get="accessor" set="null"><x path="Bool"/></Q>
		<get_Q get="inline" set="null" line="35"><f a=""><x path="Bool"/></f></get_Q>
		<R public="1" get="accessor" set="null"><x path="Bool"/></R>
		<get_R get="inline" set="null" line="36"><f a=""><x path="Bool"/></f></get_R>
		<S public="1" get="accessor" set="null"><x path="Bool"/></S>
		<get_S get="inline" set="null" line="37"><f a=""><x path="Bool"/></f></get_S>
		<T public="1" get="accessor" set="null"><x path="Bool"/></T>
		<get_T get="inline" set="null" line="38"><f a=""><x path="Bool"/></f></get_T>
		<U public="1" get="accessor" set="null"><x path="Bool"/></U>
		<get_U get="inline" set="null" line="39"><f a=""><x path="Bool"/></f></get_U>
		<V public="1" get="accessor" set="null"><x path="Bool"/></V>
		<get_V get="inline" set="null" line="40"><f a=""><x path="Bool"/></f></get_V>
		<W public="1" get="accessor" set="null"><x path="Bool"/></W>
		<get_W get="inline" set="null" line="41"><f a=""><x path="Bool"/></f></get_W>
		<X public="1" get="accessor" set="null"><x path="Bool"/></X>
		<get_X get="inline" set="null" line="42"><f a=""><x path="Bool"/></f></get_X>
		<Y public="1" get="accessor" set="null"><x path="Bool"/></Y>
		<get_Y get="inline" set="null" line="43"><f a=""><x path="Bool"/></f></get_Y>
		<Z public="1" get="accessor" set="null"><x path="Bool"/></Z>
		<get_Z get="inline" set="null" line="44"><f a=""><x path="Bool"/></f></get_Z>
		<ZERO public="1" get="accessor" set="null"><x path="Bool"/></ZERO>
		<get_ZERO get="inline" set="null" line="45"><f a=""><x path="Bool"/></f></get_ZERO>
		<ONE public="1" get="accessor" set="null"><x path="Bool"/></ONE>
		<get_ONE get="inline" set="null" line="46"><f a=""><x path="Bool"/></f></get_ONE>
		<TWO public="1" get="accessor" set="null"><x path="Bool"/></TWO>
		<get_TWO get="inline" set="null" line="47"><f a=""><x path="Bool"/></f></get_TWO>
		<THREE public="1" get="accessor" set="null"><x path="Bool"/></THREE>
		<get_THREE get="inline" set="null" line="48"><f a=""><x path="Bool"/></f></get_THREE>
		<FOUR public="1" get="accessor" set="null"><x path="Bool"/></FOUR>
		<get_FOUR get="inline" set="null" line="49"><f a=""><x path="Bool"/></f></get_FOUR>
		<FIVE public="1" get="accessor" set="null"><x path="Bool"/></FIVE>
		<get_FIVE get="inline" set="null" line="50"><f a=""><x path="Bool"/></f></get_FIVE>
		<SIX public="1" get="accessor" set="null"><x path="Bool"/></SIX>
		<get_SIX get="inline" set="null" line="51"><f a=""><x path="Bool"/></f></get_SIX>
		<SEVEN public="1" get="accessor" set="null"><x path="Bool"/></SEVEN>
		<get_SEVEN get="inline" set="null" line="52"><f a=""><x path="Bool"/></f></get_SEVEN>
		<EIGHT public="1" get="accessor" set="null"><x path="Bool"/></EIGHT>
		<get_EIGHT get="inline" set="null" line="53"><f a=""><x path="Bool"/></f></get_EIGHT>
		<NINE public="1" get="accessor" set="null"><x path="Bool"/></NINE>
		<get_NINE get="inline" set="null" line="54"><f a=""><x path="Bool"/></f></get_NINE>
		<PAGEUP public="1" get="accessor" set="null"><x path="Bool"/></PAGEUP>
		<get_PAGEUP get="inline" set="null" line="55"><f a=""><x path="Bool"/></f></get_PAGEUP>
		<PAGEDOWN public="1" get="accessor" set="null"><x path="Bool"/></PAGEDOWN>
		<get_PAGEDOWN get="inline" set="null" line="56"><f a=""><x path="Bool"/></f></get_PAGEDOWN>
		<HOME public="1" get="accessor" set="null"><x path="Bool"/></HOME>
		<get_HOME get="inline" set="null" line="57"><f a=""><x path="Bool"/></f></get_HOME>
		<END public="1" get="accessor" set="null"><x path="Bool"/></END>
		<get_END get="inline" set="null" line="58"><f a=""><x path="Bool"/></f></get_END>
		<INSERT public="1" get="accessor" set="null"><x path="Bool"/></INSERT>
		<get_INSERT get="inline" set="null" line="59"><f a=""><x path="Bool"/></f></get_INSERT>
		<ESCAPE public="1" get="accessor" set="null"><x path="Bool"/></ESCAPE>
		<get_ESCAPE get="inline" set="null" line="60"><f a=""><x path="Bool"/></f></get_ESCAPE>
		<MINUS public="1" get="accessor" set="null"><x path="Bool"/></MINUS>
		<get_MINUS get="inline" set="null" line="61"><f a=""><x path="Bool"/></f></get_MINUS>
		<PLUS public="1" get="accessor" set="null"><x path="Bool"/></PLUS>
		<get_PLUS get="inline" set="null" line="62"><f a=""><x path="Bool"/></f></get_PLUS>
		<DELETE public="1" get="accessor" set="null"><x path="Bool"/></DELETE>
		<get_DELETE get="inline" set="null" line="63"><f a=""><x path="Bool"/></f></get_DELETE>
		<BACKSPACE public="1" get="accessor" set="null"><x path="Bool"/></BACKSPACE>
		<get_BACKSPACE get="inline" set="null" line="64"><f a=""><x path="Bool"/></f></get_BACKSPACE>
		<LBRACKET public="1" get="accessor" set="null"><x path="Bool"/></LBRACKET>
		<get_LBRACKET get="inline" set="null" line="65"><f a=""><x path="Bool"/></f></get_LBRACKET>
		<RBRACKET public="1" get="accessor" set="null"><x path="Bool"/></RBRACKET>
		<get_RBRACKET get="inline" set="null" line="66"><f a=""><x path="Bool"/></f></get_RBRACKET>
		<BACKSLASH public="1" get="accessor" set="null"><x path="Bool"/></BACKSLASH>
		<get_BACKSLASH get="inline" set="null" line="67"><f a=""><x path="Bool"/></f></get_BACKSLASH>
		<CAPSLOCK public="1" get="accessor" set="null"><x path="Bool"/></CAPSLOCK>
		<get_CAPSLOCK get="inline" set="null" line="68"><f a=""><x path="Bool"/></f></get_CAPSLOCK>
		<SEMICOLON public="1" get="accessor" set="null"><x path="Bool"/></SEMICOLON>
		<get_SEMICOLON get="inline" set="null" line="69"><f a=""><x path="Bool"/></f></get_SEMICOLON>
		<QUOTE public="1" get="accessor" set="null"><x path="Bool"/></QUOTE>
		<get_QUOTE get="inline" set="null" line="70"><f a=""><x path="Bool"/></f></get_QUOTE>
		<ENTER public="1" get="accessor" set="null"><x path="Bool"/></ENTER>
		<get_ENTER get="inline" set="null" line="71"><f a=""><x path="Bool"/></f></get_ENTER>
		<SHIFT public="1" get="accessor" set="null"><x path="Bool"/></SHIFT>
		<get_SHIFT get="inline" set="null" line="72"><f a=""><x path="Bool"/></f></get_SHIFT>
		<COMMA public="1" get="accessor" set="null"><x path="Bool"/></COMMA>
		<get_COMMA get="inline" set="null" line="73"><f a=""><x path="Bool"/></f></get_COMMA>
		<PERIOD public="1" get="accessor" set="null"><x path="Bool"/></PERIOD>
		<get_PERIOD get="inline" set="null" line="74"><f a=""><x path="Bool"/></f></get_PERIOD>
		<SLASH public="1" get="accessor" set="null"><x path="Bool"/></SLASH>
		<get_SLASH get="inline" set="null" line="75"><f a=""><x path="Bool"/></f></get_SLASH>
		<NUMPADSLASH public="1" get="accessor" set="null"><x path="Bool"/></NUMPADSLASH>
		<get_NUMPADSLASH get="inline" set="null" line="76"><f a=""><x path="Bool"/></f></get_NUMPADSLASH>
		<GRAVEACCENT public="1" get="accessor" set="null"><x path="Bool"/></GRAVEACCENT>
		<get_GRAVEACCENT get="inline" set="null" line="77"><f a=""><x path="Bool"/></f></get_GRAVEACCENT>
		<CONTROL public="1" get="accessor" set="null"><x path="Bool"/></CONTROL>
		<get_CONTROL get="inline" set="null" line="78"><f a=""><x path="Bool"/></f></get_CONTROL>
		<ALT public="1" get="accessor" set="null"><x path="Bool"/></ALT>
		<get_ALT get="inline" set="null" line="79"><f a=""><x path="Bool"/></f></get_ALT>
		<SPACE public="1" get="accessor" set="null"><x path="Bool"/></SPACE>
		<get_SPACE get="inline" set="null" line="80"><f a=""><x path="Bool"/></f></get_SPACE>
		<UP public="1" get="accessor" set="null"><x path="Bool"/></UP>
		<get_UP get="inline" set="null" line="81"><f a=""><x path="Bool"/></f></get_UP>
		<DOWN public="1" get="accessor" set="null"><x path="Bool"/></DOWN>
		<get_DOWN get="inline" set="null" line="82"><f a=""><x path="Bool"/></f></get_DOWN>
		<LEFT public="1" get="accessor" set="null"><x path="Bool"/></LEFT>
		<get_LEFT get="inline" set="null" line="83"><f a=""><x path="Bool"/></f></get_LEFT>
		<RIGHT public="1" get="accessor" set="null"><x path="Bool"/></RIGHT>
		<get_RIGHT get="inline" set="null" line="84"><f a=""><x path="Bool"/></f></get_RIGHT>
		<TAB public="1" get="accessor" set="null"><x path="Bool"/></TAB>
		<get_TAB get="inline" set="null" line="85"><f a=""><x path="Bool"/></f></get_TAB>
		<F1 public="1" get="accessor" set="null"><x path="Bool"/></F1>
		<get_F1 get="inline" set="null" line="86"><f a=""><x path="Bool"/></f></get_F1>
		<F2 public="1" get="accessor" set="null"><x path="Bool"/></F2>
		<get_F2 get="inline" set="null" line="87"><f a=""><x path="Bool"/></f></get_F2>
		<F3 public="1" get="accessor" set="null"><x path="Bool"/></F3>
		<get_F3 get="inline" set="null" line="88"><f a=""><x path="Bool"/></f></get_F3>
		<F4 public="1" get="accessor" set="null"><x path="Bool"/></F4>
		<get_F4 get="inline" set="null" line="89"><f a=""><x path="Bool"/></f></get_F4>
		<F5 public="1" get="accessor" set="null"><x path="Bool"/></F5>
		<get_F5 get="inline" set="null" line="90"><f a=""><x path="Bool"/></f></get_F5>
		<F6 public="1" get="accessor" set="null"><x path="Bool"/></F6>
		<get_F6 get="inline" set="null" line="91"><f a=""><x path="Bool"/></f></get_F6>
		<F7 public="1" get="accessor" set="null"><x path="Bool"/></F7>
		<get_F7 get="inline" set="null" line="92"><f a=""><x path="Bool"/></f></get_F7>
		<F8 public="1" get="accessor" set="null"><x path="Bool"/></F8>
		<get_F8 get="inline" set="null" line="93"><f a=""><x path="Bool"/></f></get_F8>
		<F9 public="1" get="accessor" set="null"><x path="Bool"/></F9>
		<get_F9 get="inline" set="null" line="94"><f a=""><x path="Bool"/></f></get_F9>
		<F10 public="1" get="accessor" set="null"><x path="Bool"/></F10>
		<get_F10 get="inline" set="null" line="95"><f a=""><x path="Bool"/></f></get_F10>
		<F11 public="1" get="accessor" set="null"><x path="Bool"/></F11>
		<get_F11 get="inline" set="null" line="96"><f a=""><x path="Bool"/></f></get_F11>
		<F12 public="1" get="accessor" set="null"><x path="Bool"/></F12>
		<get_F12 get="inline" set="null" line="97"><f a=""><x path="Bool"/></f></get_F12>
		<NUMPADONE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADONE>
		<get_NUMPADONE get="inline" set="null" line="98"><f a=""><x path="Bool"/></f></get_NUMPADONE>
		<NUMPADTWO public="1" get="accessor" set="null"><x path="Bool"/></NUMPADTWO>
		<get_NUMPADTWO get="inline" set="null" line="99"><f a=""><x path="Bool"/></f></get_NUMPADTWO>
		<NUMPADTHREE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADTHREE>
		<get_NUMPADTHREE get="inline" set="null" line="100"><f a=""><x path="Bool"/></f></get_NUMPADTHREE>
		<NUMPADFOUR public="1" get="accessor" set="null"><x path="Bool"/></NUMPADFOUR>
		<get_NUMPADFOUR get="inline" set="null" line="101"><f a=""><x path="Bool"/></f></get_NUMPADFOUR>
		<NUMPADFIVE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADFIVE>
		<get_NUMPADFIVE get="inline" set="null" line="102"><f a=""><x path="Bool"/></f></get_NUMPADFIVE>
		<NUMPADSIX public="1" get="accessor" set="null"><x path="Bool"/></NUMPADSIX>
		<get_NUMPADSIX get="inline" set="null" line="103"><f a=""><x path="Bool"/></f></get_NUMPADSIX>
		<NUMPADSEVEN public="1" get="accessor" set="null"><x path="Bool"/></NUMPADSEVEN>
		<get_NUMPADSEVEN get="inline" set="null" line="104"><f a=""><x path="Bool"/></f></get_NUMPADSEVEN>
		<NUMPADEIGHT public="1" get="accessor" set="null"><x path="Bool"/></NUMPADEIGHT>
		<get_NUMPADEIGHT get="inline" set="null" line="105"><f a=""><x path="Bool"/></f></get_NUMPADEIGHT>
		<NUMPADNINE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADNINE>
		<get_NUMPADNINE get="inline" set="null" line="106"><f a=""><x path="Bool"/></f></get_NUMPADNINE>
		<NUMPADZERO public="1" get="accessor" set="null"><x path="Bool"/></NUMPADZERO>
		<get_NUMPADZERO get="inline" set="null" line="107"><f a=""><x path="Bool"/></f></get_NUMPADZERO>
		<NUMPADMINUS public="1" get="accessor" set="null"><x path="Bool"/></NUMPADMINUS>
		<get_NUMPADMINUS get="inline" set="null" line="108"><f a=""><x path="Bool"/></f></get_NUMPADMINUS>
		<NUMPADPLUS public="1" get="accessor" set="null"><x path="Bool"/></NUMPADPLUS>
		<get_NUMPADPLUS get="inline" set="null" line="109"><f a=""><x path="Bool"/></f></get_NUMPADPLUS>
		<NUMPADPERIOD public="1" get="accessor" set="null"><x path="Bool"/></NUMPADPERIOD>
		<get_NUMPADPERIOD get="inline" set="null" line="110"><f a=""><x path="Bool"/></f></get_NUMPADPERIOD>
		<NUMPADMULTIPLY public="1" get="accessor" set="null"><x path="Bool"/></NUMPADMULTIPLY>
		<get_NUMPADMULTIPLY get="inline" set="null" line="111"><f a=""><x path="Bool"/></f></get_NUMPADMULTIPLY>
		<ANY public="1" get="accessor" set="null"><x path="Bool"/></ANY>
		<get_ANY set="method" line="115"><f a=""><x path="Bool"/></f></get_ANY>
		<check public="1" get="inline" set="null" line="134"><f a="keyCode">
	<x path="Int"/>
	<x path="Bool"/>
</f></check>
		<new public="1" set="method" line="14"><f a="CheckStatus">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for keyboard input.
 * Provides optimized key checking using direct array access.</haxe_doc>
	</class>
	<class path="flixel.input.keyboard.FlxKeyboard" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/keyboard/FlxKeyboard.hx">
		<implements path="flixel.interfaces.IFlxInput"/>
		<TOTAL get="inline" set="null" line="22" static="1">
			<x path="Int"/>
			<haxe_doc>* Total amount of keys.</haxe_doc>
		</TOTAL>
		<enabled public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not keyboard input is currently enabled.</haxe_doc>
		</enabled>
		<pressed public="1">
			<c path="flixel.input.keyboard.FlxKeyList"/>
			<haxe_doc>* Helper class to check if a keys is pressed.</haxe_doc>
		</pressed>
		<justPressed public="1">
			<c path="flixel.input.keyboard.FlxKeyList"/>
			<haxe_doc>* Helper class to check if a keys was just pressed.</haxe_doc>
		</justPressed>
		<justReleased public="1">
			<c path="flixel.input.keyboard.FlxKeyList"/>
			<haxe_doc>* Helper class to check if a keys was just released.</haxe_doc>
		</justReleased>
		<_keyList>
			<c path="Array"><c path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* An array of FlxKey objects.</haxe_doc>
		</_keyList>
		<_keyLookup>
			<x path="Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<haxe_doc>* A map for key lookup.</haxe_doc>
		</_keyLookup>
		<_nativeCorrection>
			<x path="Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<haxe_doc>* Function and numpad keycodes on native targets are incorrect, 
	 * this workaround fixes that. Thanks @HaxePunk!
	 * @see https://github.com/openfl/openfl-native/issues/193</haxe_doc>
		</_nativeCorrection>
		<anyPressed public="1" get="inline" set="null" line="67">
			<f a="KeyArray">
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if at least one key from an array of keys is pressed. See FlxG.keys for the key names, pass them in as Strings.
	 * Example: FlxG.keys.anyPressed(["UP", "W", "SPACE"]) - having them in an array is handy for configurable keys!
	 * 
	 * @param	KeyArray 	An array of keys as Strings
	 * @return	Whether at least one of the keys passed in is pressed.</haxe_doc>
		</anyPressed>
		<anyJustPressed public="1" get="inline" set="null" line="79">
			<f a="KeyArray">
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if at least one key from an array of keys was just pressed. See FlxG.keys for the key names, pass them in as Strings.
	 * Example: FlxG.keys.anyJustPressed(["UP", "W", "SPACE"]) - having them in an array is handy for configurable keys!
	 * 
	 * @param	KeyArray 	An array of keys as Strings
	 * @return	Whether at least one of the keys passed was just pressed.</haxe_doc>
		</anyJustPressed>
		<anyJustReleased public="1" get="inline" set="null" line="91">
			<f a="KeyArray">
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if at least one key from an array of keys was just released. See FlxG.keys for the key names, pass them in as Strings.
	 * Example: FlxG.keys.anyJustReleased(["UP", "W", "SPACE"]) - having them in an array is handy for configurable keys!
	 * 
	 * @param	KeyArray 	An array of keys as Strings
	 * @return	Whether at least one of the keys passed was just released.</haxe_doc>
		</anyJustReleased>
		<firstPressed public="1" set="method" line="101">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Get the name of the first key which is currently pressed.
	 * 
	 * @return	The name of the key or "" if none could be found.</haxe_doc>
		</firstPressed>
		<firstJustPressed public="1" set="method" line="118">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Get the name of the first key which has just been pressed.
	 * 
	 * @return	The name of the key or "" if none could be found.</haxe_doc>
		</firstJustPressed>
		<firstJustReleased public="1" set="method" line="135">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Get the name of the first key which has just been released.
	 * 
	 * @return	The name of the key or "" if none could be found.</haxe_doc>
		</firstJustReleased>
		<checkStatus public="1" set="method" line="154">
			<f a="KeyCode:Status">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check the status of a single of key
	 * 
	 * @param	KeyCode		Index into _keyList array.
	 * @param	Status		The key state to check for
	 * @return	Whether the provided key has the specified status</haxe_doc>
		</checkStatus>
		<getKeyCode public="1" get="inline" set="null" line="188">
			<f a="KeyName">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Look up the key code for any given string name of the key or button.
	 * 
	 * @param	KeyName		The String name of the key.
	 * @return	The key code for that key.</haxe_doc>
		</getKeyCode>
		<getIsDown public="1" set="method" line="198">
			<f a=""><c path="Array"><c path="flixel.input.keyboard.FlxKey"/></c></f>
			<haxe_doc><![CDATA[* Get an Array of FlxMapObjects that are in a pressed state
	 * 
	 * @return	Array<FlxMapObject> of keys that are currently pressed.]]></haxe_doc>
		</getIsDown>
		<destroy public="1" set="method" line="215">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<reset public="1" set="method" line="224">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets all the keys.</haxe_doc>
		</reset>
		<addKey set="method" line="393">
			<f a="KeyName:KeyCode">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An internal helper function used to build the key array.
	 * 
	 * @param	KeyName		String name of the key (e.g. "LEFT" or "A")
	 * @param	KeyCode		The numeric Flash code for this key.</haxe_doc>
		</addKey>
		<update set="method" line="402">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the key states (for tracking just pressed, just released, etc).</haxe_doc>
		</update>
		<checkKeyStatus set="method" line="431">
			<f a="KeyArray:Status">
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Helper function to check the status of an array of keys
	 * 
	 * @param	KeyArray	An array of keys as Strings
	 * @param	Status		The key state to check for
	 * @return	Whether at least one of the keys has the specified status</haxe_doc>
		</checkKeyStatus>
		<onKeyUp set="method" line="469">
			<f a="FlashEvent">
				<c path="flash.events.KeyboardEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Event handler so FlxGame can toggle keys.</haxe_doc>
		</onKeyUp>
		<onKeyDown set="method" line="540">
			<f a="FlashEvent">
				<c path="flash.events.KeyboardEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.</haxe_doc>
		</onKeyDown>
		<inKeyArray set="method" line="570">
			<f a="KeyArray:KeyCode">
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* A Helper function to check whether an array of keycodes contains 
	 * a certain key safely (returns false if the array is null).</haxe_doc>
		</inKeyArray>
		<resolveKeyCode get="inline" set="null" line="590"><f a="e">
	<c path="flash.events.KeyboardEvent"/>
	<x path="Int"/>
</f></resolveKeyCode>
		<updateKeyStates get="inline" set="null" line="603">
			<f a="KeyCode:Down">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A helper function to update the key states based on a keycode provided.</haxe_doc>
		</updateKeyStates>
		<onFocus get="inline" set="null" line="634"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost get="inline" set="null" line="636"><f a=""><x path="Void"/></f></onFocusLost>
		<record set="method" line="650">
			<f a=""><c path="Array"><c path="flixel.system.replay.CodeValuePair"/></c></f>
			<haxe_doc>Replay functions</haxe_doc>
		</record>
		<playback set="method" line="680">
			<f a="Record">
				<c path="Array"><c path="flixel.system.replay.CodeValuePair"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Part of the keystroke recording system.
	 * Takes data about key presses and sets it into array.
	 * 
	 * @param	Record	Array of data about key states.</haxe_doc>
		</playback>
		<new set="method" line="237">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</new>
		<haxe_doc>* Keeps track of what keys are pressed and how with handy Bools or strings.</haxe_doc>
		<meta>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
		</meta>
	</class>
	<class path="flixel.input.mouse._FlxMouse.GraphicCursor" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/mouse/FlxMouse.hx" private="1" module="flixel.input.mouse.FlxMouse">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/cursor.png"</e></m>
		</meta>
	</class>
	<class path="flixel.input.mouse.FlxMouseButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/mouse/FlxMouseButton.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<LEFT public="1" get="inline" set="null" line="16" static="1">
			<x path="Int"/>
			<haxe_doc>* These IDs are negative to avoid overlaps with possible touch point IDs.</haxe_doc>
		</LEFT>
		<MIDDLE public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></MIDDLE>
		<RIGHT public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></RIGHT>
		<FAST_PRESS_RELEASE public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></FAST_PRESS_RELEASE>
		<JUST_RELEASED public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></JUST_RELEASED>
		<RELEASED public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></RELEASED>
		<PRESSED public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></PRESSED>
		<JUST_PRESSED public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></JUST_PRESSED>
		<current public="1"><x path="Int"/></current>
		<last public="1"><x path="Int"/></last>
		<_ID><x path="Int"/></_ID>
		<_justPressedPosition><c path="flixel.util.FlxPoint"/></_justPressedPosition>
		<_justPressedTimeInTicks><x path="Float"/></_justPressedTimeInTicks>
		<update public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Upates the last and current state of this mouse button.</haxe_doc>
		</update>
		<destroy public="1" get="inline" set="null" line="71"><f a=""><x path="Void"/></f></destroy>
		<onDown public="1" set="method" line="76"><f a="FlashEvent">
	<c path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></onDown>
		<onUp public="1" set="method" line="130">
			<f a="?FlashEvent" v="null">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param FlashEvent Flash mouse event.</haxe_doc>
		</onUp>
		<reset public="1" get="inline" set="null" line="157">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the just pressed/just released flags and sets mouse to not pressed.</haxe_doc>
		</reset>
		<pressed public="1" get="inline" set="null" line="167">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if the button is pressed.
	 * @return 	Whether the button is pressed.</haxe_doc>
		</pressed>
		<justPressed public="1" get="inline" set="null" line="173">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if the button was just pressed.
	 * @return 	Whether the button was just pressed.</haxe_doc>
		</justPressed>
		<justReleased public="1" get="inline" set="null" line="179">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if the button was just released.
	 * @return 	Whether the button was just released.</haxe_doc>
		</justReleased>
		<new public="1" set="method" line="34"><f a="ID">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.input.touch.FlxTouch" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/touch/FlxTouch.hx">
		<extends path="flixel.util.FlxPoint"/>
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<screenX public="1"><x path="Int"/></screenX>
		<screenY public="1"><x path="Int"/></screenY>
		<touchPointID public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The unique ID of this touch. Example: if there are 3 concurrently active touches 
	 * (and the device supporst that many), they will have the IDs 0, 1 and 2.</haxe_doc>
		</touchPointID>
		<pressed public="1" get="accessor" set="null"><x path="Bool"/></pressed>
		<justPressed public="1" get="accessor" set="null"><x path="Bool"/></justPressed>
		<justReleased public="1" get="accessor" set="null"><x path="Bool"/></justReleased>
		<isActive public="1" get="accessor" set="null"><x path="Bool"/></isActive>
		<_current><x path="Int"/></_current>
		<_last><x path="Int"/></_last>
		<_point><c path="flixel.util.FlxPoint"/></_point>
		<_globalScreenPosition><c path="flixel.util.FlxPoint"/></_globalScreenPosition>
		<_flashPoint><c path="flash.geom.Point"/></_flashPoint>
		<_justPressedPosition><c path="flixel.util.FlxPoint"/></_justPressedPosition>
		<_justPressedTimeInTicks><x path="Float"/></_justPressedTimeInTicks>
		<destroy public="1" set="method" line="48" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<getWorldPosition public="1" set="method" line="70">
			<f a="?Camera:?point" v="null:null">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the world position of the touch on any given camera.
	 * NOTE: Touch.x and Touch.y also store the world position of the touch point on the main camera.
	 * 
	 * @param 	Camera	If unspecified, first/main global camera is used instead.
	 * @param 	point	An existing point object to store the results (if you don't want a new one created). 
	 * @return 	The touch point's location in world space.</haxe_doc>
		</getWorldPosition>
		<getScreenPosition public="1" set="method" line="94">
			<f a="?Camera:?point" v="null:null">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the screen position of the touch on any given camera.
	 * NOTE: Touch.screenX and Touch.screenY also store the screen position of the touch point on the main camera.
	 * 
	 * @param 	Camera	If unspecified, first/main global camera is used instead.
	 * @param 	point		An existing point object to store the results (if you don't want a new one created). 
	 * @return 	The touch point's location in screen space.</haxe_doc>
		</getScreenPosition>
		<overlaps public="1" set="method" line="118">
			<f a="ObjectOrGroup:?Camera" v=":null">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if some FlxObject overlaps this FlxObject or FlxGroup.
	 * If the group has a LOT of things in it, it might be faster to use FlxG.overlaps().
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * 
	 * @param 	ObjectOrGroup The object or group being tested.
	 * @param 	Camera Specify which game camera you want. If null getScreenXY() will just grab the first global camera.
	 * @return 	Whether or not the two objects overlap.</haxe_doc>
		</overlaps>
		<reset public="1" set="method" line="144">
			<f a="X:Y:PointID">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resets the just pressed/just released flags and sets touch to not pressed.</haxe_doc>
		</reset>
		<deactivate public="1" set="method" line="152"><f a=""><x path="Void"/></f></deactivate>
		<update set="method" line="178">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the just pressed/just released flags.</haxe_doc>
		</update>
		<updateCursor set="method" line="204">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for helping to update world coordinates.</haxe_doc>
		</updateCursor>
		<updatePosition set="method" line="221">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Function for updating touch coordinates. Called by the TouchManager.
	 * 
	 * @param	X	stageX touch coordinate
	 * @param	Y	stageY touch coordinate</haxe_doc>
		</updatePosition>
		<get_pressed get="inline" set="null" line="232"><f a=""><x path="Bool"/></f></get_pressed>
		<get_justPressed get="inline" set="null" line="233"><f a=""><x path="Bool"/></f></get_justPressed>
		<get_justReleased get="inline" set="null" line="234"><f a=""><x path="Bool"/></f></get_justReleased>
		<get_isActive get="inline" set="null" line="235"><f a=""><x path="Bool"/></f></get_isActive>
		<new set="method" line="163">
			<f a="?X:?Y:?PointID" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	X			stageX touch coordinate
	 * @param	Y			stageX touch coordinate
	 * @param	PointID		touchPointID of the touch</haxe_doc>
		</new>
		<haxe_doc>* Helper class, contains and track touch points in your game.
 * Automatically accounts for parallax scrolling, etc.</haxe_doc>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="flixel.input.touch.FlxTouchManager" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/input/touch/FlxTouchManager.hx">
		<implements path="flixel.interfaces.IFlxInput"/>
		<maxTouchPoints public="1" line="20" static="1">
			<x path="Int"/>
			<haxe_doc>* The maximum number of concurrent touch points supported by the current device.</haxe_doc>
		</maxTouchPoints>
		<list public="1">
			<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
			<haxe_doc>* All active touches including just created, moving and just released.</haxe_doc>
		</list>
		<_inactiveTouches>
			<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
			<haxe_doc>* Storage for inactive touches (some sort of cache for them).</haxe_doc>
		</_inactiveTouches>
		<_touchesCache>
			<x path="Map">
				<x path="Int"/>
				<c path="flixel.input.touch.FlxTouch"/>
			</x>
			<haxe_doc>* Helper storage for active touches (for faster access)</haxe_doc>
		</_touchesCache>
		<getByID public="1" get="inline" set="null" line="39">
			<f a="TouchPointID">
				<x path="Int"/>
				<c path="flixel.input.touch.FlxTouch"/>
			</f>
			<haxe_doc>* WARNING: can be null if no active touch with the provided ID could be found</haxe_doc>
		</getByID>
		<getFirst public="1" set="method" line="47">
			<f a=""><c path="flixel.input.touch.FlxTouch"/></f>
			<haxe_doc>* Return the first touch if there is one, beware of null</haxe_doc>
		</getFirst>
		<destroy public="1" set="method" line="63">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Clean up memory. Internal use only.</haxe_doc>
		</destroy>
		<justStarted public="1" set="method" line="86">
			<f a="?TouchArray" v="null">
				<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
				<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
			</f>
			<haxe_doc>* Gets all touches which were just started
	 * 
	 * @param	TouchArray	Optional array to fill with touch objects
	 * @return	Array with touches</haxe_doc>
		</justStarted>
		<justReleased public="1" set="method" line="117">
			<f a="?TouchArray" v="null">
				<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
				<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
			</f>
			<haxe_doc>* Gets all touches which were just ended
	 * 
	 * @param	TouchArray	Optional array to fill with touch objects
	 * @return	Array with touches</haxe_doc>
		</justReleased>
		<reset public="1" set="method" line="144">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets all touches to inactive state.</haxe_doc>
		</reset>
		<handleTouchBegin set="method" line="179">
			<f a="FlashEvent">
				<c path="flash.events.TouchEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Event handler so FlxGame can update touches.
	 * 
	 * @param	FlashEvent	A TouchEvent object.</haxe_doc>
		</handleTouchBegin>
		<handleTouchEnd set="method" line="207">
			<f a="FlashEvent">
				<c path="flash.events.TouchEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Event handler so FlxGame can update touches.
	 * 
	 * @param	FlashEvent	A TouchEvent object.</haxe_doc>
		</handleTouchEnd>
		<handleTouchMove set="method" line="229">
			<f a="FlashEvent">
				<c path="flash.events.TouchEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Event handler so FlxGame can update touches.
	 * 
	 * @param	FlashEvent	A TouchEvent object.</haxe_doc>
		</handleTouchMove>
		<add set="method" line="245">
			<f a="Touch">
				<c path="flixel.input.touch.FlxTouch"/>
				<c path="flixel.input.touch.FlxTouch"/>
			</f>
			<haxe_doc>* Internal function for adding new touches to the manager
	 * 
	 * @param	Touch	A new FlxTouch object
	 * @return	The added FlxTouch object</haxe_doc>
		</add>
		<recycle set="method" line="260">
			<f a="X:Y:PointID">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="flixel.input.touch.FlxTouch"/>
			</f>
			<haxe_doc>* Internal function for touch reuse
	 * 
	 * @param	X			stageX touch coordinate
	 * @param	Y			stageY touch coordinate
	 * @param	PointID		id of the touch
	 * @return	A recycled touch object</haxe_doc>
		</recycle>
		<update set="method" line="276">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the touch position in the game world.
	 * Also updates the just pressed/just released flags.</haxe_doc>
		</update>
		<onFocus set="method" line="302"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost set="method" line="304"><f a=""><x path="Void"/></f></onFocusLost>
		<new set="method" line="161">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.interfaces.IFlxSignal" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/interfaces/IFlxSignal.hx" interface="1">
		<extends path="flixel.interfaces.IFlxDestroyable"/>
		<dispatch public="1"><c path="flixel.interfaces.IFlxSignal.T"/></dispatch>
		<add public="1" set="method"><f a="listener">
	<c path="flixel.interfaces.IFlxSignal.T"/>
	<x path="Void"/>
</f></add>
		<addOnce public="1" set="method"><f a="listener">
	<c path="flixel.interfaces.IFlxSignal.T"/>
	<x path="Void"/>
</f></addOnce>
		<remove public="1" set="method"><f a="listener">
	<c path="flixel.interfaces.IFlxSignal.T"/>
	<x path="Void"/>
</f></remove>
		<removeAll public="1" set="method"><f a=""><x path="Void"/></f></removeAll>
		<has public="1" set="method"><f a="listener">
	<c path="flixel.interfaces.IFlxSignal.T"/>
	<x path="Bool"/>
</f></has>
		<haxe_doc>* ...
 * @author Sam Batista</haxe_doc>
	</class>
	<class path="flixel.plugin.MouseEventManager" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/plugin/MouseEventManager.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<_registeredObjects static="1"><c path="Array"><c path="flixel.plugin._MouseEventManager.ObjectMouseData"><c path="flixel.FlxObject"/></c></c></_registeredObjects>
		<_mouseOverObjects static="1"><c path="Array"><c path="flixel.plugin._MouseEventManager.ObjectMouseData"><c path="flixel.FlxObject"/></c></c></_mouseOverObjects>
		<_point static="1"><c path="flixel.util.FlxPoint"/></_point>
		<init public="1" get="inline" set="null" line="45" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* As alternative you can call MouseEventManager.init().</haxe_doc>
		</init>
		<add public="1" params="T" set="method" line="62" static="1">
			<f a="Object:?OnMouseDown:?OnMouseUp:?OnMouseOver:?OnMouseOut:?MouseChildren:?MouseEnabled:?PixelPerfect" v=":null:null:null:null:false:true:true">
				<c path="add.T"/>
				<f a="">
					<c path="add.T"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="add.T"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="add.T"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="add.T"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="add.T"/>
			</f>
			<haxe_doc>* Adds an object to the MouseEventManager registry. Automatically initializes the plugin.
	 *
	 * @param	OnMouseDown		Callback when mouse is pressed down over this object. Must have Object as argument - e.g. onMouseDown(object:FlxObject).
	 * @param	OnMouseUp		Callback when mouse is released over this object. Must have Object as argument - e.g. onMouseDown(object:FlxObject).
	 * @param	OnMouseOver		Callback when mouse is this object. Must have Object as argument - e.g. onMouseDown(object:FlxObject).
	 * @param	OnMouseOut		Callback when mouse moves out of this object. Must have Object as argument - e.g. onMouseDown(object:FlxObject).
	 * @param	MouseChildren	If mouseChildren is enabled, other objects overlaped by this will still receive mouse events.
	 * @param	MouseEnabled	If mouseEnabled this object will receive mouse events.
	 * @param	PixelPerfect	If enabled the collision check will be pixel-perfect. Only works for FlxSprites.</haxe_doc>
		</add>
		<remove public="1" params="T" set="method" line="81" static="1">
			<f a="Object">
				<c path="remove.T"/>
				<c path="remove.T"/>
			</f>
			<haxe_doc>* Removes a sprite from the registry.</haxe_doc>
		</remove>
		<reorder public="1" set="method" line="106" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Reorders the registered objects, using the current object drawing order.
	 * This should be called if you alter the draw/update order of a registered object,
	 * That is, if you alter the position of a registered object inside its FlxGroup.
	 * It may also be called if the objects are not registered by the same order they are
	 * added to FlxGroup.</haxe_doc>
		</reorder>
		<setMouseDownCallback public="1" params="T" set="method" line="122" static="1">
			<f a="Object:OnMouseDown">
				<c path="setMouseDownCallback.T"/>
				<f a="">
					<c path="setMouseDownCallback.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the mouseDown callback associated with an object.
	 *
	 * @param 	OnMouseDown 	Callback when mouse is pressed down over this object. Must have Object as argument - e.g. onMouseDown(object:FlxObject).</haxe_doc>
		</setMouseDownCallback>
		<setMouseUpCallback public="1" params="T" set="method" line="137" static="1">
			<f a="Object:OnMouseUp">
				<c path="setMouseUpCallback.T"/>
				<f a="">
					<c path="setMouseUpCallback.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the mouseUp callback associated with an object.
	 *
	 * @param 	OnMouseUp 	Callback when mouse is released over this object. Must have Object as argument - e.g. onMouseDown(object:FlxObject).</haxe_doc>
		</setMouseUpCallback>
		<setMouseOverCallback public="1" params="T" set="method" line="152" static="1">
			<f a="Object:OnMouseOver">
				<c path="setMouseOverCallback.T"/>
				<f a="">
					<c path="setMouseOverCallback.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the mouseOver callback associated with an object.
	 *
	 * @param 	OnMouseOver 	Callback when mouse is over this object. Must have Object as argument - e.g. onMouseDown(object:FlxObject).</haxe_doc>
		</setMouseOverCallback>
		<setMouseOutCallback public="1" params="T" set="method" line="167" static="1">
			<f a="Object:OnMouseOut">
				<c path="setMouseOutCallback.T"/>
				<f a="">
					<c path="setMouseOutCallback.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the mouseOut callback associated with an object.
	 *
	 * @param 	OnMouseOver 	Callback when mouse is moves out of this object. Must have Object as argument - e.g. onMouseDown(object:FlxObject).</haxe_doc>
		</setMouseOutCallback>
		<setObjectMouseEnabled public="1" params="T" set="method" line="182" static="1">
			<f a="Object:MouseEnabled">
				<c path="setObjectMouseEnabled.T"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables/disables mouse behavior for an object.
	 * 
	 * @param 	MouseEnabled 	Whether this object will be tested for mouse events.</haxe_doc>
		</setObjectMouseEnabled>
		<isObjectMouseEnabled public="1" params="T" set="method" line="195" static="1">
			<f a="Object">
				<c path="isObjectMouseEnabled.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if a registered object is mouseEnabled.</haxe_doc>
		</isObjectMouseEnabled>
		<setObjectMouseChildren public="1" params="T" set="method" line="214" static="1">
			<f a="Object:MouseChildren">
				<c path="setObjectMouseChildren.T"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables/disables mouseChildren for an object.
	 *
	 * @param 	MouseChildren 	Whether this object will allow other overlapping object to receive mouse events.</haxe_doc>
		</setObjectMouseChildren>
		<isObjectMouseChildren public="1" params="T" set="method" line="227" static="1">
			<f a="Object">
				<c path="isObjectMouseChildren.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if an object allows mouseChildren.</haxe_doc>
		</isObjectMouseChildren>
		<traverseFlxGroup set="method" line="241" static="1"><f a="Group:OrderedObjects">
	<c path="flixel.group.FlxGroup"/>
	<c path="Array"><c path="flixel.plugin._MouseEventManager.ObjectMouseData"><d/></c></c>
	<x path="Void"/>
</f></traverseFlxGroup>
		<getRegister params="T" set="method" line="262" static="1"><f a="Object:?Register" v=":null">
	<c path="getRegister.T"/>
	<c path="Array"><c path="flixel.plugin._MouseEventManager.ObjectMouseData"><c path="flixel.FlxObject"/></c></c>
	<c path="flixel.plugin._MouseEventManager.ObjectMouseData"><c path="getRegister.T"/></c>
</f></getRegister>
		<destroy public="1" set="method" line="295" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="302" override="1"><f a=""><x path="Void"/></f></update>
		<clearRegistry set="method" line="387"><f a=""><x path="Void"/></f></clearRegistry>
		<checkOverlap params="T" set="method" line="399"><f a="Register">
	<c path="flixel.plugin._MouseEventManager.ObjectMouseData"><c path="checkOverlap.T"/></c>
	<x path="Bool"/>
</f></checkOverlap>
		<checkOverlapWithPoint params="T" get="inline" set="null" line="428"><f a="Register:Point:Camera">
	<c path="flixel.plugin._MouseEventManager.ObjectMouseData"><c path="checkOverlapWithPoint.T"/></c>
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></checkOverlapWithPoint>
		<checkPixelPerfectOverlap get="inline" set="null" line="440"><f a="Point:Sprite:Camera">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.FlxSprite"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></checkPixelPerfectOverlap>
		<new public="1" set="method" line="280"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Provides mouse event detection for FlxObjects and FlxSprites (pixel-perfect for those).
 * To use it, initialize the manager and register objects / sprites. 
 * 
 * 		FlxG.plugins.add(new MouseEventManager());
 * 		var object = new FlxObject();
 * 		MouseEventManager.add(object, onMouseDown, onMouseUp, onMouseOver, onMouseOut);
 * 
 * Or simply add a new object and this plugin will initialize itself: 
 * 
 *      MouseEventManager.add(object, onMouseDown, onMouseUp, onMouseOver, onMouseOut);
 * 
 * Also implement the callbacks with the object's type as parameters:
 * 
 * 		function onMouseDown(object:FlxObject) {}
 * 		function onMouseUp(object:FlxObject) {}
 * 		function onMouseOver(object:FlxObject) {}
 * 		function onMouseOut(object:FlxObject) {} 
 * 
 * @author TiagoLr (~~~ ProG4mr ~~~)</haxe_doc>
	</class>
	<class path="flixel.plugin._MouseEventManager.ObjectMouseData" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/plugin/MouseEventManager.hx" private="1" module="flixel.plugin.MouseEventManager">
		<object public="1"><c path="flixel.FlxObject"/></object>
		<onMouseDown public="1"><f a="">
	<c path="flixel.plugin._MouseEventManager.ObjectMouseData.T"/>
	<x path="Void"/>
</f></onMouseDown>
		<onMouseUp public="1"><f a="">
	<c path="flixel.plugin._MouseEventManager.ObjectMouseData.T"/>
	<x path="Void"/>
</f></onMouseUp>
		<onMouseOver public="1"><f a="">
	<c path="flixel.plugin._MouseEventManager.ObjectMouseData.T"/>
	<x path="Void"/>
</f></onMouseOver>
		<onMouseOut public="1"><f a="">
	<c path="flixel.plugin._MouseEventManager.ObjectMouseData.T"/>
	<x path="Void"/>
</f></onMouseOut>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<pixelPerfect public="1"><x path="Bool"/></pixelPerfect>
		<sprite public="1"><c path="flixel.FlxSprite"/></sprite>
		<new public="1" set="method" line="462"><f a="object:onMouseDown:onMouseUp:onMouseOver:onMouseOut:mouseChildren:mouseEnabled:pixelPerfect">
	<c path="flixel.plugin._MouseEventManager.ObjectMouseData.T"/>
	<f a="">
		<c path="flixel.plugin._MouseEventManager.ObjectMouseData.T"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="flixel.plugin._MouseEventManager.ObjectMouseData.T"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="flixel.plugin._MouseEventManager.ObjectMouseData.T"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="flixel.plugin._MouseEventManager.ObjectMouseData.T"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system._FlxAssets.FontDefault" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxAssets.hx" private="1" module="flixel.system.FlxAssets">
		<extends path="flash.text.Font"/>
		<resourceName public="1" line="10" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="18"><f a="?filename:?style:?type">
	<c path="String"/>
	<e path="flash.text.FontStyle"/>
	<e path="flash.text.FontType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Fonts</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":font"><e>"assets/fonts/nokiafc22.ttf"</e></m>
		</meta>
	</class>
	<class path="flixel.system._FlxAssets.FontDebugger" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxAssets.hx" private="1" module="flixel.system.FlxAssets">
		<extends path="flash.text.Font"/>
		<resourceName public="1" line="10" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="21"><f a="?filename:?style:?type">
	<c path="String"/>
	<e path="flash.text.FontStyle"/>
	<e path="flash.text.FontType"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":font"><e>"assets/fonts/arial.ttf"</e></m>
		</meta>
	</class>
	<class path="flixel.system.GraphicLogo" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/logo/logo.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.FlxAssets" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxAssets.hx">
		<FONT_DEFAULT public="1" line="95" static="1"><c path="String"/></FONT_DEFAULT>
		<FONT_DEBUGGER public="1" line="96" static="1"><c path="String"/></FONT_DEBUGGER>
		<init public="1" set="method" line="98" static="1"><f a=""><x path="Void"/></f></init>
		<drawLogo public="1" set="method" line="107" static="1"><f a="graph">
	<c path="flash.display.Graphics"/>
	<x path="Void"/>
</f></drawLogo>
		<getBitmapData public="1" get="inline" set="null" line="163" static="1"><f a="id">
	<c path="String"/>
	<c path="flash.display.BitmapData"/>
</f></getBitmapData>
		<getSound public="1" get="inline" set="null" line="168" static="1"><f a="id">
	<c path="String"/>
	<c path="flash.media.Sound"/>
</f></getSound>
	</class>
	<class path="flixel.system.FlxBGSprite" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxBGSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<draw public="1" set="method" line="27" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by game loop, updates then blits or renders current frame of animation to the screen</haxe_doc>
		</draw>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* The main "game object" class, the sprite is a FlxObject
 * with a bunch of graphics options and abilities, like animation and stamping.</haxe_doc>
	</class>
	<abstract path="flixel.system.FlxCollisionType" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxCollisionType.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Types of collidable objects.
 * 
 * Abstracted from an Int type for fast comparrison code:
 * http://nadako.tumblr.com/post/64707798715/cool-feature-of-upcoming-haxe-3-2-enum-abstracts</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="flixel.system._FlxCollisionType.FlxCollisionType_Impl_" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxCollisionType.hx" private="1" module="flixel.system.FlxCollisionType">
	<NONE public="1" get="inline" set="null" line="12" static="1">
		<x path="flixel.system.FlxCollisionType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<OBJECT public="1" get="inline" set="null" line="13" static="1">
		<x path="flixel.system.FlxCollisionType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OBJECT>
	<GROUP public="1" get="inline" set="null" line="14" static="1">
		<x path="flixel.system.FlxCollisionType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GROUP>
	<TILEMAP public="1" get="inline" set="null" line="15" static="1">
		<x path="flixel.system.FlxCollisionType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TILEMAP>
	<SPRITEGROUP public="1" get="inline" set="null" line="16" static="1">
		<x path="flixel.system.FlxCollisionType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPRITEGROUP>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="flixel.system._FlxCollisionType.FlxCollisionType_Impl_" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxCollisionType.hx" private="1" module="flixel.system.FlxCollisionType">
		<NONE public="1" get="inline" set="null" line="12" static="1">
			<x path="flixel.system.FlxCollisionType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<OBJECT public="1" get="inline" set="null" line="13" static="1">
			<x path="flixel.system.FlxCollisionType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OBJECT>
		<GROUP public="1" get="inline" set="null" line="14" static="1">
			<x path="flixel.system.FlxCollisionType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GROUP>
		<TILEMAP public="1" get="inline" set="null" line="15" static="1">
			<x path="flixel.system.FlxCollisionType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TILEMAP>
		<SPRITEGROUP public="1" get="inline" set="null" line="16" static="1">
			<x path="flixel.system.FlxCollisionType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPRITEGROUP>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="flixel.system.FlxList" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxList.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<_NUM_CACHED_FLX_LIST public="1" line="16" static="1">
			<x path="Int"/>
			<haxe_doc>* Pooling mechanism, when FlxLists are destroyed, they get added to this collection, and when they get recycled they get removed.</haxe_doc>
		</_NUM_CACHED_FLX_LIST>
		<_cachedListsHead static="1"><c path="flixel.system.FlxList"/></_cachedListsHead>
		<recycle public="1" set="method" line="22" static="1">
			<f a=""><c path="flixel.system.FlxList"/></f>
			<haxe_doc>* Recycle a cached Linked List, or creates a new one if needed.</haxe_doc>
		</recycle>
		<clearCache public="1" set="method" line="41" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear cached List nodes. You might want to do this when loading new levels (probably not though, no need to clear cache unless you run into memory problems).</haxe_doc>
		</clearCache>
		<object public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Stores a reference to a FlxObject.</haxe_doc>
		</object>
		<next public="1">
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Stores a reference to the next link in the list.</haxe_doc>
		</next>
		<exists public="1"><x path="Bool"/></exists>
		<destroy public="1" set="method" line="73">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<new set="method" line="68">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Private, use recycle instead.</haxe_doc>
		</new>
		<haxe_doc>* A miniature linked list class.
 * Useful for optimizing time-critical or highly repetitive tasks!
 * See FlxQuadTree for how to use it, IF YOU DARE.</haxe_doc>
	</class>
	<class path="flixel.system.FlxQuadTree" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxQuadTree.hx">
		<extends path="flixel.util.FlxRect"/>
		<A_LIST public="1" get="inline" set="null" line="24" static="1">
			<x path="Int"/>
			<haxe_doc>* Flag for specifying that you want to add an object to the A list.</haxe_doc>
		</A_LIST>
		<B_LIST public="1" get="inline" set="null" line="28" static="1">
			<x path="Int"/>
			<haxe_doc>* Flag for specifying that you want to add an object to the B list.</haxe_doc>
		</B_LIST>
		<divisions public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Controls the granularity of the quad tree.  Default is 6 (decent performance on large and small worlds).</haxe_doc>
		</divisions>
		<_min static="1">
			<x path="Int"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_min>
		<_object static="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_object>
		<_objectLeftEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectLeftEdge>
		<_objectTopEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectTopEdge>
		<_objectRightEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectRightEdge>
		<_objectBottomEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectBottomEdge>
		<_list static="1">
			<x path="Int"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_list>
		<_useBothLists static="1">
			<x path="Bool"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_useBothLists>
		<_processingCallback static="1">
			<f a=":">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_processingCallback>
		<_notifyCallback static="1">
			<f a=":">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_notifyCallback>
		<_iterator static="1">
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_iterator>
		<_objectHullX static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_objectHullX>
		<_objectHullY static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_objectHullY>
		<_objectHullWidth static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_objectHullWidth>
		<_objectHullHeight static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_objectHullHeight>
		<_checkObjectHullX static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_checkObjectHullX>
		<_checkObjectHullY static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_checkObjectHullY>
		<_checkObjectHullWidth static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_checkObjectHullWidth>
		<_checkObjectHullHeight static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_checkObjectHullHeight>
		<_NUM_CACHED_QUAD_TREES public="1" line="194" static="1">
			<x path="Int"/>
			<haxe_doc>* Pooling mechanism, turn FlxQuadTree into a linked list, when FlxQuadTrees are destroyed, they get added to the list, and when they get recycled they get removed.</haxe_doc>
		</_NUM_CACHED_QUAD_TREES>
		<_cachedTreesHead static="1"><c path="flixel.system.FlxQuadTree"/></_cachedTreesHead>
		<recycle public="1" set="method" line="216" static="1">
			<f a="X:Y:Width:Height:?Parent" v="::::null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.system.FlxQuadTree"/>
				<c path="flixel.system.FlxQuadTree"/>
			</f>
			<haxe_doc>* Recycle a cached Quad Tree node, or creates a new one if needed.
	 * @param	X			The X-coordinate of the point in space.
	 * @param	Y			The Y-coordinate of the point in space.
	 * @param	Width		Desired width of this node.
	 * @param	Height		Desired height of this node.
	 * @param	Parent		The parent branch or node.  Pass null to create a root.</haxe_doc>
		</recycle>
		<clearCache public="1" set="method" line="233" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear cached Quad Tree nodes. You might want to do this when loading new levels (probably not though, no need to clear cache unless you run into memory problems).</haxe_doc>
		</clearCache>
		<exists public="1"><x path="Bool"/></exists>
		<_canSubdivide>
			<x path="Bool"/>
			<haxe_doc>* Whether this branch of the tree can be subdivided or not.</haxe_doc>
		</_canSubdivide>
		<_headA>
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_headA>
		<_tailA>
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_tailA>
		<_headB>
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_headB>
		<_tailB>
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_tailB>
		<_northWestTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_northWestTree>
		<_northEastTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_northEastTree>
		<_southEastTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_southEastTree>
		<_southWestTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_southWestTree>
		<_leftEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_leftEdge>
		<_rightEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_rightEdge>
		<_topEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_topEdge>
		<_bottomEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_bottomEdge>
		<_halfWidth>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_halfWidth>
		<_halfHeight>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_halfHeight>
		<_midpointX>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_midpointX>
		<_midpointY>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_midpointY>
		<next><c path="flixel.system.FlxQuadTree"/></next>
		<reset public="1" set="method" line="245"><f a="X:Y:Width:Height:?Parent" v="::::null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.system.FlxQuadTree"/>
	<x path="Void"/>
</f></reset>
		<destroy public="1" set="method" line="314" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<load public="1" set="method" line="349">
			<f a="ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback:?ProcessCallback" v=":null:null:null">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Void"/>
				</f>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Bool"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Load objects and/or groups into the quad tree, and register notify and processing callbacks.
	 * @param ObjectOrGroup1	Any object that is or extends FlxObject or FlxGroup.
	 * @param ObjectOrGroup2	Any object that is or extends FlxObject or FlxGroup.  If null, the first parameter will be checked against itself.
	 * @param NotifyCallback	A function with the form myFunction(Object1:FlxObject,Object2:FlxObject):void that is called whenever two objects are found to overlap in world space, and either no ProcessCallback is specified, or the ProcessCallback returns true. 
	 * @param ProcessCallback	A function with the form myFunction(Object1:FlxObject,Object2:FlxObject):Boolean that is called whenever two objects are found to overlap in world space.  The NotifyCallback is only called if this function returns true.  See FlxObject.separate().</haxe_doc>
		</load>
		<add public="1" set="method" line="372">
			<f a="ObjectOrGroup:list">
				<c path="flixel.FlxBasic"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Call this function to add an object to the root of the tree.
	 * This function will recursively add all group members, but
	 * not the groups themselves.
	 * @param	ObjectOrGroup	FlxObjects are just added, FlxGroups are recursed and their applicable members added accordingly.
	 * @param	List			A int flag indicating the list to which you want to add the objects.  Options are A_LIST and B_LIST.</haxe_doc>
		</add>
		<addObject set="method" line="426">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for recursively navigating and creating the tree
	 * while adding objects to the appropriate nodes.</haxe_doc>
		</addObject>
		<addToList set="method" line="517">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for recursively adding objects to leaf lists.</haxe_doc>
		</addToList>
		<execute public="1" set="method" line="567">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* FlxQuadTree's other main function.  Call this after adding objects
	 * using FlxQuadTree.load() to compare the objects that you loaded.
	 * @return	Whether or not any overlaps were found.</haxe_doc>
		</execute>
		<overlapNode set="method" line="620">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* An internal function for comparing an object against the contents of a node.
	 * @return	Whether or not any overlaps were found.</haxe_doc>
		</overlapNode>
		<new set="method" line="201">
			<f a="X:Y:Width:Height:?Parent" v="::::null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.system.FlxQuadTree"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Private, use recycle instead.</haxe_doc>
		</new>
		<haxe_doc>* A fairly generic quad tree structure for rapid overlap checks.
 * FlxQuadTree is also configured for single or dual list operation.
 * You can add items either to its A list or its B list.
 * When you do an overlap check, you can compare the A list to itself,
 * or the A list against the B list.  Handy for different things!</haxe_doc>
	</class>
	<class path="flixel.system.FlxSound" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxSound.hx">
		<extends path="flixel.FlxBasic"/>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X position of this sound in world coordinates.
	 * Only really matters if you are doing proximity/panning stuff.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y position of this sound in world coordinates.
	 * Only really matters if you are doing proximity/panning stuff.</haxe_doc>
		</y>
		<persist public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not this sound should be automatically destroyed when you switch states.</haxe_doc>
		</persist>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The ID3 song name.  Defaults to null.  Currently only works for streamed sounds.</haxe_doc>
		</name>
		<artist public="1">
			<c path="String"/>
			<haxe_doc>* The ID3 artist name.  Defaults to null.  Currently only works for streamed sounds.</haxe_doc>
		</artist>
		<amplitude public="1">
			<x path="Float"/>
			<haxe_doc>* Stores the average wave amplitude of both stereo channels</haxe_doc>
		</amplitude>
		<amplitudeLeft public="1">
			<x path="Float"/>
			<haxe_doc>* Just the amplitude of the left stereo channel</haxe_doc>
		</amplitudeLeft>
		<amplitudeRight public="1">
			<x path="Float"/>
			<haxe_doc>* Just the amplitude of the left stereo channel</haxe_doc>
		</amplitudeRight>
		<autoDestroy public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to call destroy() when the sound has finished.</haxe_doc>
		</autoDestroy>
		<onComplete public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Tracker for sound complete callback. Default is null. If assigend, will be called 
	 * each time when sound reaches its end. Works only on flash and desktop targets.</haxe_doc>
		</onComplete>
		<pan public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Pan amount. -1 = full left, 1 = full right. Proximity based panning overrides this.</haxe_doc>
		</pan>
		<playing public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the sound is currently playing.</haxe_doc>
		</playing>
		<volume public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Set volume to a value between 0 and 1 to change how this sound is.</haxe_doc>
		</volume>
		<time public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The position in runtime of the music playback.</haxe_doc>
		</time>
		<_sound>
			<c path="flash.media.Sound"/>
			<haxe_doc>* Internal tracker for a Flash sound object.</haxe_doc>
		</_sound>
		<_channel>
			<c path="flash.media.SoundChannel"/>
			<haxe_doc>* Internal tracker for a Flash sound channel object.</haxe_doc>
		</_channel>
		<_transform>
			<c path="flash.media.SoundTransform"/>
			<haxe_doc>* Internal tracker for a Flash sound transform object.</haxe_doc>
		</_transform>
		<_paused>
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for whether the sound is paused or not (not the same as stopped).</haxe_doc>
		</_paused>
		<_volume>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for volume.</haxe_doc>
		</_volume>
		<_volumeAdjust>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for total volume adjustment.</haxe_doc>
		</_volumeAdjust>
		<_looped>
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for whether the sound is looping or not.</haxe_doc>
		</_looped>
		<_target>
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Internal tracker for the sound's "target" (for proximity and panning).</haxe_doc>
		</_target>
		<_radius>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for the maximum effective radius of this sound (for proximity and panning).</haxe_doc>
		</_radius>
		<_proximityPan>
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for whether to pan the sound left and right.  Default is false.</haxe_doc>
		</_proximityPan>
		<_alreadyPaused>
			<x path="Bool"/>
			<haxe_doc>* Helper var to prevent the sound from playing after focus was regained when it was already paused.</haxe_doc>
		</_alreadyPaused>
		<reset set="method" line="142">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* An internal function for clearing all the variables used by sounds.</haxe_doc>
		</reset>
		<destroy public="1" set="method" line="170" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="200" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handles fade out, fade in, panning, proximity, and amplitude operations each frame.</haxe_doc>
		</update>
		<kill public="1" set="method" line="253" override="1"><f a=""><x path="Void"/></f></kill>
		<loadEmbedded public="1" set="method" line="268">
			<f a="EmbeddedSound:?Looped:?AutoDestroy:?OnComplete" v=":false:false:null">
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* One of two main setup functions for sounds, this function loads a sound from an embedded MP3.
	 * 
	 * @param	EmbeddedSound	An embedded Class object representing an MP3 file.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * @param	AutoDestroy		Whether or not this FlxSound instance should be destroyed when the sound finishes playing.  Default value is false, but FlxG.sound.play() and FlxG.sound.stream() will set it to true by default.
	 * 
	 * @return	This FlxSound instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadEmbedded>
		<loadStream public="1" set="method" line="303">
			<f a="SoundURL:?Looped:?AutoDestroy:?OnComplete" v=":false:false:null">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* One of two main setup functions for sounds, this function loads a sound from a URL.
	 * 
	 * @param	EmbeddedSound	A string representing the URL of the MP3 file you want to play.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * @param	AutoDestroy		Whether or not this FlxSound instance should be destroyed when the sound finishes playing.  Default value is false, but FlxG.sound.play() and FlxG.sound.stream() will set it to true by default.
	 * 
	 * @return	This FlxSound instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadStream>
		<loadByteArray public="1" set="method" line="326">
			<f a="Bytes:?Looped:?AutoDestroy:?OnComplete" v=":false:false:null">
				<c path="flash.utils.ByteArray"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* One of the main setup functions for sounds, this function loads a sound from a ByteArray.
	 * 
	 * @param	Bytes 			A ByteArray object.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * @param	AutoDestroy		Whether or not this FlxSound instance should be destroyed when the sound finishes playing.  Default value is false, but FlxG.sound.play() and FlxG.sound.stream() will set it to true by default.
	 * @return	This FlxSound instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadByteArray>
		<proximity public="1" set="method" line="356">
			<f a="X:Y:TargetObject:Radius:?Pan" v="::::true">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* Call this function if you want this sound's volume to change
	 * based on distance from a particular FlxObject.
	 *
	 * @param	X			The X position of the sound.
	 * @param	Y			The Y position of the sound.
	 * @param	TargetObject		The object you want to track.
	 * @param	Radius			The maximum distance this sound can travel.
	 * @param	Pan			Whether panning should be used in addition to the volume changes (default: true).
	 * @return	This FlxSound instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</proximity>
		<play public="1" set="method" line="371">
			<f a="?ForceRestart" v="false">
				<x path="Bool"/>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* Call this function to play the sound - also works on paused sounds.
	 * 
	 * @param	ForceRestart	Whether to start the sound over or not.  Default value is false, meaning if the sound is already playing or was paused when you call play(), it will continue playing from its current position, NOT start again from the beginning.</haxe_doc>
		</play>
		<resume public="1" set="method" line="401">
			<f a=""><c path="flixel.system.FlxSound"/></f>
			<haxe_doc>* Unpause a sound.  Only works on sounds that have been paused.</haxe_doc>
		</resume>
		<pause public="1" set="method" line="413">
			<f a=""><c path="flixel.system.FlxSound"/></f>
			<haxe_doc>* Call this function to pause this sound.</haxe_doc>
		</pause>
		<stop public="1" get="inline" set="null" line="428">
			<f a=""><c path="flixel.system.FlxSound"/></f>
			<haxe_doc>* Call this function to stop this sound.</haxe_doc>
		</stop>
		<fadeOut public="1" get="inline" set="null" line="440">
			<f a="?Duration:?To" v="1:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* Helper function that tweens this sound's volume.
	 * 
	 * @param	Duration	The amount of time the fade-out operation should take.
	 * @param	To			The volume to tween to, 0 by default.</haxe_doc>
		</fadeOut>
		<fadeIn public="1" get="inline" set="null" line="453">
			<f a="?Duration:?From:?To" v="1:0:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* Helper function that tweens this sound's volume.
	 * 
	 * @param	Duration	The amount of time the fade-in operation should take.
	 * @param	From		The volume to tween from, 0 by default.
	 * @param	To			The volume to tween to, 1 by default.</haxe_doc>
		</fadeIn>
		<volumeTween set="method" line="459"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></volumeTween>
		<getActualVolume public="1" get="inline" set="null" line="469">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the currently selected "real" volume of the sound (takes fades and proximity into account).
	 * 
	 * @return	The adjusted volume of the sound.</haxe_doc>
		</getActualVolume>
		<setPosition public="1" get="inline" set="null" line="481">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function to set the coordinates of this object.
	 * Sound positioning is used in conjunction with proximity/panning.
	 * 
	 * @param        X        The new x position
	 * @param        Y        The new y position</haxe_doc>
		</setPosition>
		<updateTransform set="method" line="490">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Call after adjusting the volume to update the sound channel's settings.</haxe_doc>
		</updateTransform>
		<startSound set="method" line="502">
			<f a="Position">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An internal helper function used to attempt to start playing the sound and populate the _channel variable.</haxe_doc>
		</startSound>
		<stopped set="method" line="525">
			<f a="?event" v="null">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An internal helper function used to help Flash clean up finished sounds or restart looped sounds.
	 * 
	 * @param	event		An Event object.</haxe_doc>
		</stopped>
		<cleanup set="method" line="550">
			<f a="destroySound:?resetPosition:?resetFading" v=":true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An internal helper function used to help Flash clean up (and potentially re-use) finished sounds. Will stop the current sound and destroy the associated SoundChannel, plus, any other commands ordered by the passed in parameters.
	 * 
	 * @param  destroySound    Whether or not to destroy the sound. If this is true, the position and fading will be reset as well.
	 * @param  resetPosition    Whether or not to reset the position of the sound.
	 * @param  resetFading    Whether or not to reset the current fading variables of the sound.</haxe_doc>
		</cleanup>
		<gotID3 set="method" line="578">
			<f a="?event" v="null">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for ID3 info (i.e. fetching the song name).
	 * @param	event	An Event object.</haxe_doc>
		</gotID3>
		<onFocus set="method" line="587">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</onFocus>
		<onFocusLost set="method" line="596">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
		</onFocusLost>
		<get_playing get="inline" set="null" line="602"><f a=""><x path="Bool"/></f></get_playing>
		<get_volume get="inline" set="null" line="607"><f a=""><x path="Float"/></f></get_volume>
		<set_volume set="method" line="612"><f a="Volume">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<get_pan get="inline" set="null" line="627"><f a=""><x path="Float"/></f></get_pan>
		<set_pan get="inline" set="null" line="632"><f a="pan">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<new public="1" set="method" line="133">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The FlxSound constructor gets all the variables initialized, but NOT ready to play a sound yet.</haxe_doc>
		</new>
		<haxe_doc>* This is the universal flixel sound object, used for streaming, music, and sound effects.</haxe_doc>
	</class>
	<class path="flixel.system.FlxSplash" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/FlxSplash.hx">
		<extends path="flixel.FlxState"/>
		<nextState public="1" static="1"><x path="Class"><c path="flixel.FlxState"/></x></nextState>
		<_sprite><c path="flash.display.Sprite"/></_sprite>
		<_gfx><c path="flash.display.Graphics"/></_gfx>
		<_text><c path="flash.text.TextField"/></_text>
		<_times><c path="Array"><x path="Float"/></c></_times>
		<_colors><c path="Array"><x path="Int"/></c></_colors>
		<_functions><c path="Array"><f a=""><x path="Void"/></f></c></_functions>
		<_curPart><x path="Int"/></_curPart>
		<_cachedBgColor><x path="Int"/></_cachedBgColor>
		<_cachedTimestep><x path="Bool"/></_cachedTimestep>
		<_cachedAutoPause><x path="Bool"/></_cachedAutoPause>
		<create public="1" set="method" line="32" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="80" override="1"><f a=""><x path="Void"/></f></destroy>
		<onResize public="1" set="method" line="91" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<timerCallback set="method" line="106"><f a="Timer">
	<c path="flixel.util.FlxTimer"/>
	<x path="Void"/>
</f></timerCallback>
		<drawGreen set="method" line="121"><f a=""><x path="Void"/></f></drawGreen>
		<drawYellow set="method" line="136"><f a=""><x path="Void"/></f></drawYellow>
		<drawRed set="method" line="148"><f a=""><x path="Void"/></f></drawRed>
		<drawBlue set="method" line="160"><f a=""><x path="Void"/></f></drawBlue>
		<drawLightBlue set="method" line="172"><f a=""><x path="Void"/></f></drawLightBlue>
		<onComplete set="method" line="184"><f a="Tween">
	<c path="flixel.tweens.FlxTween"/>
	<x path="Void"/>
</f></onComplete>
		<new public="1" set="method" line="16"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.debug.Window" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Window.hx">
		<extends path="flash.display.Sprite"/>
		<BG_COLOR public="1" get="inline" set="null" line="33" static="1">
			<x path="Int"/>
			<haxe_doc>* The background color of the window.</haxe_doc>
		</BG_COLOR>
		<HEADER_COLOR public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></HEADER_COLOR>
		<HEADER_ALPHA public="1" get="inline" set="null" line="36" static="1"><x path="Float"/></HEADER_ALPHA>
		<HEADER_HEIGHT public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></HEADER_HEIGHT>
		<WINDOW_AMOUNT line="42" static="1">
			<x path="Int"/>
			<haxe_doc>* How many windows there are currently in total.</haxe_doc>
		</WINDOW_AMOUNT>
		<minSize public="1"><c path="flash.geom.Point"/></minSize>
		<maxSize public="1"><c path="flash.geom.Point"/></maxSize>
		<_width>
			<x path="Int"/>
			<haxe_doc>* Width of the window. Using Sprite.width is super unreliable for some reason!</haxe_doc>
		</_width>
		<_height>
			<x path="Int"/>
			<haxe_doc>* Height of the window. Using Sprite.height is super unreliable for some reason!</haxe_doc>
		</_height>
		<_bounds>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Controls where the window is allowed to be positioned.</haxe_doc>
		</_bounds>
		<_background>
			<c path="flash.display.Bitmap"/>
			<haxe_doc>* Window elements</haxe_doc>
		</_background>
		<_header><c path="flash.display.Bitmap"/></_header>
		<_shadow><c path="flash.display.Bitmap"/></_shadow>
		<_title><c path="flash.text.TextField"/></_title>
		<_handle><c path="flash.display.Bitmap"/></_handle>
		<_closeButton><c path="flixel.system.ui.FlxSystemButton"/></_closeButton>
		<_overHeader>
			<x path="Bool"/>
			<haxe_doc>* Interaction helpers.</haxe_doc>
		</_overHeader>
		<_overHandle><x path="Bool"/></_overHandle>
		<_drag><c path="flash.geom.Point"/></_drag>
		<_dragging><x path="Bool"/></_dragging>
		<_resizing><x path="Bool"/></_resizing>
		<_resizable><x path="Bool"/></_resizable>
		<_id>
			<x path="Int"/>
			<haxe_doc>* The ID of this window.</haxe_doc>
		</_id>
		<destroy public="1" set="method" line="168">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<resize public="1" set="method" line="222">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resize the window.  Subject to pre-specified minimums, maximums, and bounding rectangles.
	 *
	 * @param 	Width	How wide to make the window.
	 * @param 	Height	How tall to make the window.</haxe_doc>
		</resize>
		<reposition public="1" set="method" line="235">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the position of the window.  Subject to pre-specified bounding rectangles.
	 * 
	 * @param 	X	Desired X position of top left corner of the window.
	 * @param 	Y	Desired Y position of top left corner of the window.</haxe_doc>
		</reposition>
		<updateBounds public="1" set="method" line="242"><f a="Bounds">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></updateBounds>
		<toggleVisibility public="1" set="method" line="256"><f a=""><x path="Void"/></f></toggleVisibility>
		<loadSaveData set="method" line="263"><f a=""><x path="Void"/></f></loadSaveData>
		<initSaveData set="method" line="276"><f a=""><x path="Void"/></f></initSaveData>
		<update public="1" set="method" line="287"><f a=""><x path="Void"/></f></update>
		<init set="method" line="294">
			<f a="?E" v="null">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to set up basic mouse listeners..</haxe_doc>
		</init>
		<onMouseMove set="method" line="316">
			<f a="?E" v="null">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mouse movement handler.  Figures out if mouse is over handle or header bar or what.</haxe_doc>
		</onMouseMove>
		<onMouseDown set="method" line="355">
			<f a="?E" v="null">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Figure out if window is being repositioned (clicked on header) or resized (clicked on handle).</haxe_doc>
		</onMouseDown>
		<onMouseUp set="method" line="375">
			<f a="?E" v="null">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* User let go of header bar or handler (or nothing), so turn off drag and resize behaviors.</haxe_doc>
		</onMouseUp>
		<bound public="1" set="method" line="386">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Keep the window within the pre-specified bounding rectangle.</haxe_doc>
		</bound>
		<updateSize set="method" line="398">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the Flash shapes to match the new size, and reposition the header, shadow, and handle accordingly.</haxe_doc>
		</updateSize>
		<close public="1" set="method" line="421"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="96">
			<f a="Title:?Icon:?Width:?Height:?Resizable:?Bounds:?Closable" v=":null:0:0:true:null:false">
				<c path="String"/>
				<c path="flash.display.BitmapData"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new window object.  This Flash-based class is mainly (only?) used by FlxDebugger.
	 * 
	 * @param   Title       The name of the window, displayed in the header bar.
	 * @param   Icon	    The icon to use for the window header.
	 * @param   Width       The initial width of the window.
	 * @param   Height      The initial height of the window.
	 * @param   Resizable   Whether you can change the size of the window with a drag handle.
	 * @param   Bounds      A rectangle indicating the valid screen area for the window.
	 * @param   Closable    Whether this window has a close button that removes the window.</haxe_doc>
		</new>
		<haxe_doc>* A generic, Flash-based window class, created for use in FlxDebugger.</haxe_doc>
	</class>
	<class path="flixel.system.debug.Console" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Console.hx">
		<extends path="flixel.system.debug.Window"/>
		<_DEFAULT_TEXT get="inline" set="null" line="29" static="1">
			<c path="String"/>
			<haxe_doc>* The text that is displayed in the console's input field by default.</haxe_doc>
		</_DEFAULT_TEXT>
		<_HISTORY_MAX get="inline" set="null" line="33" static="1">
			<x path="Int"/>
			<haxe_doc>* The amount of commands that will be saved.</haxe_doc>
		</_HISTORY_MAX>
		<registeredObjects public="1">
			<x path="Map">
				<c path="String"/>
				<d/>
			</x>
			<haxe_doc>* Hash containing all registered Obejects for the set command. You can use the registerObject() 
	 * helper function to register new ones or add them to this Hash directly.</haxe_doc>
		</registeredObjects>
		<registeredFunctions public="1">
			<x path="Map">
				<c path="String"/>
				<d/>
			</x>
			<haxe_doc>* Hash containing all registered Functions for the call command. You can use the registerFunction() 
	 * helper function to register new ones or add them to this Hash directly.</haxe_doc>
		</registeredFunctions>
		<objectStack public="1">
			<c path="Array"><c path="flixel.FlxObject"/></c>
			<haxe_doc>* Internal helper var containing all the FlxObjects created via the create command.</haxe_doc>
		</objectStack>
		<cmdHistory public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* Reference to the array containing the command history.</haxe_doc>
		</cmdHistory>
		<commands public="1">
			<c path="Array"><t path="flixel.system.debug.Command"/></c>
			<haxe_doc>* An array holding all the registered commands.</haxe_doc>
		</commands>
		<_historyIndex>
			<x path="Int"/>
			<haxe_doc>* The history index of the current input.</haxe_doc>
		</_historyIndex>
		<_input>
			<c path="flash.text.TextField"/>
			<haxe_doc>* The input textfield used to enter commands.</haxe_doc>
		</_input>
		<onFocus set="method" line="119"><f a="e">
	<c path="flash.events.FocusEvent"/>
	<x path="Void"/>
</f></onFocus>
		<onFocusLost set="method" line="138"><f a="e">
	<c path="flash.events.FocusEvent"/>
	<x path="Void"/>
</f></onFocusLost>
		<onKeyPress set="method" line="158"><f a="e">
	<c path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></onKeyPress>
		<processCommand set="method" line="197"><f a=""><x path="Void"/></f></processCommand>
		<overrideDefaultSelection set="method" line="252"><f a="e">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></overrideDefaultSelection>
		<getPreviousCommand get="inline" set="null" line="258"><f a=""><c path="String"/></f></getPreviousCommand>
		<getNextCommand get="inline" set="null" line="266"><f a=""><c path="String"/></f></getNextCommand>
		<registerObject public="1" get="inline" set="null" line="283">
			<f a="ObjectAlias:AnyObject">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new object to use for the set command.
	 * 
	 * @param 	ObjectAlias		The name with which you want to access the object.
	 * @param 	AnyObject		The object to register.</haxe_doc>
		</registerObject>
		<registerFunction public="1" get="inline" set="null" line="294">
			<f a="FunctionAlias:Function">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new function to use for the call command.
	 * 
	 * @param 	FunctionAlias	The name with which you want to access the function.
	 * @param 	Function		The function to register.</haxe_doc>
		</registerFunction>
		<addCommand public="1" get="inline" set="null" line="309">
			<f a="Aliases:ProcessFunction:?Help:?ParamHelp:?NumParams:?ParamCutoff" v="::null:null:0:-1">
				<c path="Array"><c path="String"/></c>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a custom command to the console on the debugging screen.
	 * 
	 * @param 	Aliases			An array of accepted aliases for this command.
	 * @param 	ProcessFunction	Function to be called with params when the command is entered.
	 * @param	Help			The description of this command shown in the help command.
	 * @param	ParamHelp		The description of this command's processFunction's params.
	 * @param 	NumParams		The amount of parameters a function has. Require to prevent crashes on Neko.
	 * @param	ParamCutoff		At which parameter to put all remaining params into an array</haxe_doc>
		</addCommand>
		<destroy public="1" set="method" line="318" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<updateSize set="method" line="343" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Adjusts the width and height of the text field accordingly.</haxe_doc>
		</updateSize>
		<new public="1" set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a new console window object.</haxe_doc>
		</new>
		<haxe_doc>* A powerful console for the flixel debugger screen with supports custom commands, registering 
 * objects and functions and saves the last 25 commands used. Inspired by Eric Smith's "CoolConsole".
 * @link http://www.youtube.com/watch?v=QWfpw7elWk8</haxe_doc>
	</class>
	<typedef path="flixel.system.debug.Command" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Console.hx" module="flixel.system.debug.Console"><a>
	<processFunction><d/></processFunction>
	<paramHelp>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</paramHelp>
	<paramCutoff>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</paramCutoff>
	<numParams>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</numParams>
	<help>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</help>
	<aliases><c path="Array"><c path="String"/></c></aliases>
</a></typedef>
	<class path="flixel.system.debug.ConsoleCommands" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/ConsoleCommands.hx">
		<_console>
			<c path="flixel.system.debug.Console"/>
			<haxe_doc>* Reference to the console window.</haxe_doc>
		</_console>
		<_watchingMouse>
			<x path="Bool"/>
			<haxe_doc>* Helper variable for toggling the mouse coords in the watch window.</haxe_doc>
		</_watchingMouse>
		<help set="method" line="62">
			<f a="?Alias" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Commands</haxe_doc>
		</help>
		<close get="inline" set="null" line="100"><f a=""><x path="Void"/></f></close>
		<clearHistory get="inline" set="null" line="105"><f a=""><x path="Void"/></f></clearHistory>
		<resetState get="inline" set="null" line="112"><f a=""><x path="Void"/></f></resetState>
		<switchState set="method" line="118"><f a="ClassName">
	<c path="String"/>
	<x path="Void"/>
</f></switchState>
		<resetGame get="inline" set="null" line="128"><f a=""><x path="Void"/></f></resetGame>
		<create set="method" line="134"><f a="ClassName:?MousePos:?Params" v=":'true':null">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></create>
		<set set="method" line="164"><f a="ObjectAndVariable:NewVariableValue:?WatchName" v="::null">
	<c path="String"/>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></set>
		<fields set="method" line="224"><f a="ObjectAndVariable:?NumSuperClassesToInclude" v=":0">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fields>
		<call set="method" line="258"><f a="FunctionAlias:?Params" v=":null">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></call>
		<listObjects get="inline" set="null" line="325"><f a=""><x path="Void"/></f></listObjects>
		<listFunctions get="inline" set="null" line="330"><f a=""><x path="Void"/></f></listFunctions>
		<watchMouse set="method" line="335"><f a=""><x path="Void"/></f></watchMouse>
		<track set="method" line="351"><f a="ObjectAndVariable">
	<c path="String"/>
	<x path="Void"/>
</f></track>
		<pause set="method" line="357"><f a=""><x path="Void"/></f></pause>
		<new public="1" set="method" line="22"><f a="console">
	<c path="flixel.system.debug.Console"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.debug.ConsoleUtil" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/ConsoleUtil.hx">
		<attemptToCreateInstance_flixel_FlxObject public="1" set="method" line="89" static="1">
			<f a="ClassName:type:?Params" v="::null">
				<c path="String"/>
				<x path="Class"><c path="flixel.FlxObject"/></x>
				<c path="Array"><c path="String"/></c>
				<d/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</attemptToCreateInstance_flixel_FlxObject>
		<attemptToCreateInstance_flixel_FlxState public="1" set="method" line="89" static="1">
			<f a="ClassName:type:?Params" v="::null">
				<c path="String"/>
				<x path="Class"><c path="flixel.FlxState"/></x>
				<c path="Array"><c path="String"/></c>
				<d/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</attemptToCreateInstance_flixel_FlxState>
		<callFunction public="1" set="method" line="23" static="1">
			<f a="Function:Args">
				<d/>
				<c path="Array"><d/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Safely calls a function via Reflection with an array of dynamic arguments. Prevents a crash from happening
	 * if there are too many Arguments (the additional ones are removed and the function is called anyway) or too few
	 * 
	 * @param	Function	The reference to the function to call.
	 * @param	Args		An array of arguments.
	 * @return	Whether or not it was possible to safely call the function.</haxe_doc>
		</callFunction>
		<findCommand public="1" set="method" line="68" static="1">
			<f a="Alias:Commands">
				<c path="String"/>
				<c path="Array"><t path="flixel.system.debug.Command"/></c>
				<t path="flixel.system.debug.Command"/>
			</f>
			<haxe_doc>* Searches for the Command typedef for a given Alias within a Command Array.
	 * 
	 * @param	Alias		The Alias to search for.
	 * @param	Commands	The array of commands to search through
	 * @return	The Command typdef - null if none was found.</haxe_doc>
		</findCommand>
		<attemptToCreateInstance public="1" params="T" set="method" line="89" static="1">
			<f a="ClassName:type:?Params" v="::null">
				<c path="String"/>
				<x path="Class"><c path="attemptToCreateInstance.T"/></x>
				<c path="Array"><c path="String"/></c>
				<d/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Helper function for the create and switchState commands. Attempts to create a  instance of a given class name 
	 * using the given params via Type.createInstance(). Also makes sure the created object is of a certain class.
	 * 
	 * @param	ClassName	The Class name 
	 * @param	type		Which class the created instance has to have
	 * @param	Params		An optional array of constructor params
	 * @return	The created instance, or null</haxe_doc>
		</attemptToCreateInstance>
		<resolveObjectAndVariable public="1" set="method" line="120" static="1">
			<f a="ObjectAndVariable:Object">
				<c path="String"/>
				<d/>
				<t path="flixel.system.debug.PathToVariable"/>
			</f>
			<haxe_doc>* Attempts to find the object which contains the variable to set  from the String 
	 * path, like "FlxG.state.sprite.x" so it can be accessed via Reflection.
	 * 
	 * @param	ObjectAndVariable	The path to the variable as a String, for example array.length
	 * @param	Object	Starting point for the search, has to contain the first object / variable of the first param
	 * @return	A PathToVarible typedef, or null.</haxe_doc>
		</resolveObjectAndVariable>
		<resolveObjectAndVariableFromMap public="1" get="inline" set="null" line="170" static="1">
			<f a="ObjectAndVariable:ObjectMap">
				<c path="String"/>
				<x path="Map">
					<c path="String"/>
					<d/>
				</x>
				<t path="flixel.system.debug.PathToVariable"/>
			</f>
			<haxe_doc>* Helper function for the set command. Attempts to find the object which contains the variable to set
	 * from the String path, like "FlxG.state.sprite.x" so it can be set via Reflection.
	 * 
	 * @param	ObjectAndVariable	The path to the variable as a String, for example array.length
	 * @param	ObjectMap			A Map of registered objects to start the search from
	 * @return	A PathToVarible typedef, or null.</haxe_doc>
		</resolveObjectAndVariableFromMap>
		<getInstanceFieldsAdvanced public="1" set="method" line="189" static="1">
			<f a="cl:?numSuperClassesToInclude" v=":0">
				<x path="Class"><d/></x>
				<x path="Int"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc><![CDATA[* Type.getInstanceFields() returns all fields, including all those from super classes. This function allows
	 * controlling the number of super classes whose fields should still be included in the list using Type.getSuperClass().
	 * 
	 * Example:
	 * 	For a class PlayState with the following inheritance:
	 * 	FlxBasic -> FlxTypedGroup -> FlxGroup -> FlxState -> PlayState 
	 * 		numSuperClassesToInclude == 0 would only return the fields of PlayState itself	
	 * 		numSuperClassesToInclude == 1 would only return the fields of PlayState and FlxState etc...]]></haxe_doc>
		</getInstanceFieldsAdvanced>
		<parseBool public="1" set="method" line="227" static="1">
			<f a="s">
				<c path="String"/>
				<t path="Null"><x path="Bool"/></t>
			</f>
			<haxe_doc>* Attempts to parse a String into a Boolean, returns 
	 * true for "true", false for "false", and null otherwise.
	 * 
	 * @param	s	The String to parse
	 * @return	The parsed Bool</haxe_doc>
		</parseBool>
		<log public="1" get="inline" set="null" line="242" static="1">
			<f a="Text">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shortcut to log a text with the Console LogStyle.
	 * 
	 * @param	Text	The text to log.</haxe_doc>
		</log>
		<haxe_doc>* A set of helper functions used by the console.</haxe_doc>
	</class>
	<typedef path="flixel.system.debug.PathToVariable" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/ConsoleUtil.hx" module="flixel.system.debug.ConsoleUtil">
		<a>
			<variableName><c path="String"/></variableName>
			<object><d/></object>
		</a>
		<haxe_doc>* Data necessary to set a variable via Reflection. Used by the set command / resolveObjectAndVariable().</haxe_doc>
	</typedef>
	<class path="flixel.system.debug.DebuggerUtil" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/DebuggerUtil.hx"><createTextField public="1" set="method" line="26" static="1">
	<f a="?X:?Y:?Color:?Size" v="0:0:-1:12">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Int"/>
		<x path="Int"/>
		<c path="flash.text.TextField"/>
	</f>
	<haxe_doc>* Helper method for textfield creation.
	 *
	 * @param	X		Textfield x position.
	 * @param	Y		Textfield y position.
	 * @param	Color	Textfield color, 0xAARRGGBB.
	 * @param	Size	Textfield size.
	 * @return	New label text field at specified position and format.</haxe_doc>
</createTextField></class>
	<class path="flixel.system.debug._FlxDebugger.GraphicFlixel" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/FlxDebugger.hx" private="1" module="flixel.system.debug.FlxDebugger">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/flixel.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._FlxDebugger.GraphicDrawDebug" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/FlxDebugger.hx" private="1" module="flixel.system.debug.FlxDebugger">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/drawDebug.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicLog" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/log.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicStats" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/stats.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicWatch" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/watch.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicConsole" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/console.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.FlxDebugger" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/FlxDebugger.hx">
		<extends path="flash.display.Sprite"/>
		<GUTTER public="1" get="inline" set="null" line="52" static="1">
			<x path="Int"/>
			<haxe_doc>* Internal, used to space out windows from the edges.</haxe_doc>
		</GUTTER>
		<TOP_HEIGHT public="1" get="inline" set="null" line="56" static="1">
			<x path="Int"/>
			<haxe_doc>* Internal, used to space out windows from the edges.</haxe_doc>
		</TOP_HEIGHT>
		<stats public="1">
			<c path="flixel.system.debug.Stats"/>
			<haxe_doc>* Container for the performance monitor widget.</haxe_doc>
		</stats>
		<log public="1">
			<c path="flixel.system.debug.Log"/>
			<haxe_doc>* Container for the trace output widget.</haxe_doc>
		</log>
		<watch public="1">
			<c path="flixel.system.debug.Watch"/>
			<haxe_doc>* Container for the watch window widget.</haxe_doc>
		</watch>
		<vcr public="1">
			<c path="flixel.system.debug.VCR"/>
			<haxe_doc>* Container for the record, stop and play buttons.</haxe_doc>
		</vcr>
		<console public="1">
			<c path="flixel.system.debug.Console"/>
			<haxe_doc>* Container for console.</haxe_doc>
		</console>
		<hasMouse public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the mouse is currently over one of the debugger windows or not.</haxe_doc>
		</hasMouse>
		<_layout>
			<e path="flixel.system.debug.DebuggerLayout"/>
			<haxe_doc>* Internal, tracks what debugger window layout user has currently selected.</haxe_doc>
		</_layout>
		<_screen>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Internal, stores width and height of the Flash Player window.</haxe_doc>
		</_screen>
		<_screenBounds>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Stores the bounds in which the windows can move.</haxe_doc>
		</_screenBounds>
		<_middleButtons>
			<c path="Array"><c path="flixel.system.ui.FlxSystemButton"/></c>
			<haxe_doc>* Internal, used to store the middle debugger buttons for laying them out.</haxe_doc>
		</_middleButtons>
		<_leftButtons>
			<c path="Array"><c path="flixel.system.ui.FlxSystemButton"/></c>
			<haxe_doc>* Internal, used to store the left debugger buttons for laying them out.</haxe_doc>
		</_leftButtons>
		<_rightButtons>
			<c path="Array"><c path="flixel.system.ui.FlxSystemButton"/></c>
			<haxe_doc>* Internal, used to store the right debugger buttons for laying them out.</haxe_doc>
		</_rightButtons>
		<_topBar>
			<c path="flash.display.Sprite"/>
			<haxe_doc>* The flash Sprite used for the top bar of the debugger ui</haxe_doc>
		</_topBar>
		<_windows><c path="Array"><c path="flixel.system.debug.Window"/></c></_windows>
		<destroy public="1" set="method" line="116">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="172"><f a=""><x path="Void"/></f></update>
		<setLayout public="1" get="inline" set="null" line="185">
			<f a="Layout">
				<e path="flixel.system.debug.DebuggerLayout"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the way the debugger's windows are laid out.
	 * 
	 * @param   Layout   The layout codes can be found in FlxDebugger, for example FlxDebugger.MICRO</haxe_doc>
		</setLayout>
		<resetLayout public="1" set="method" line="195">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Forces the debugger windows to reset to the last specified layout.
	 * The default layout is STANDARD.</haxe_doc>
		</resetLayout>
		<onResize public="1" set="method" line="250"><f a="Width:Height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onResize>
		<updateBounds set="method" line="265"><f a=""><x path="Void"/></f></updateBounds>
		<onStateSwitch public="1" set="method" line="274"><f a=""><x path="Void"/></f></onStateSwitch>
		<hAlignButtons public="1" set="method" line="289">
			<f a="Sprites:?Padding:?Set:?LeftOffset" v=":0:true:0">
				<c path="Array"><c path="flixel.system.ui.FlxSystemButton"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Align an array of debugger buttons, used for the middle and right layouts</haxe_doc>
		</hAlignButtons>
		<resetButtonLayout public="1" set="method" line="310">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Position the debugger buttons</haxe_doc>
		</resetButtonLayout>
		<addButton public="1" set="method" line="331">
			<f a="Position:?Icon:?UpHandler:?ToggleMode:?UpdateLayout" v=":null:null:false:false">
				<e path="flixel.system.debug.ButtonAlignment"/>
				<c path="flash.display.BitmapData"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.system.ui.FlxSystemButton"/>
			</f>
			<haxe_doc>* Create and add a new debugger button.
	 * 
	 * @param   Position       Either LEFT, MIDDLE or RIGHT.
	 * @param   Icon           The icon to use for the button
	 * @param   UpHandler      The function to be called when the button is pressed.
	 * @param   ToggleMode     Whether this is a toggle button or not.
	 * @param   UpdateLayout   Whether to update the button layout.
	 * @return  The added button.</haxe_doc>
		</addButton>
		<removeButton public="1" set="method" line="364">
			<f a="Button:?UpdateLayout" v=":true">
				<c path="flixel.system.ui.FlxSystemButton"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes and destroys a button from the debugger.
	 * 
	 * @param   Button         The FlxSystemButton instance to remove.
	 * @param   UpdateLayout   Whether to update the button layout.</haxe_doc>
		</removeButton>
		<addWindow public="1" get="inline" set="null" line="378"><f a="window">
	<c path="flixel.system.debug.Window"/>
	<c path="flixel.system.debug.Window"/>
</f></addWindow>
		<removeWindow public="1" get="inline" set="null" line="390"><f a="window">
	<c path="flixel.system.debug.Window"/>
	<x path="Void"/>
</f></removeWindow>
		<onMouseOver get="inline" set="null" line="467">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mouse handler that helps with fake "mouse focus" type behavior.</haxe_doc>
		</onMouseOver>
		<onMouseOut get="inline" set="null" line="478">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mouse handler that helps with fake "mouse focus" type behavior.</haxe_doc>
		</onMouseOut>
		<removeButtonFromArray set="method" line="490"><f a="Arr:Button">
	<c path="Array"><c path="flixel.system.ui.FlxSystemButton"/></c>
	<c path="flixel.system.ui.FlxSystemButton"/>
	<x path="Void"/>
</f></removeButtonFromArray>
		<toggleDrawDebug get="inline" set="null" line="499"><f a=""><x path="Void"/></f></toggleDrawDebug>
		<openHomepage get="inline" set="null" line="504"><f a=""><x path="Void"/></f></openHomepage>
		<new set="method" line="406">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Instantiates the debugger overlay.
	 * 
	 * @param   Width    The width of the screen.
	 * @param   Height   The height of the screen.</haxe_doc>
		</new>
		<haxe_doc>* Container for the new debugger overlay. Most of the functionality is in the debug folder widgets,
 * but this class instantiates the widgets and handles their basic formatting and arrangement.</haxe_doc>
	</class>
	<enum path="flixel.system.debug.ButtonAlignment" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<LEFT/>
		<MIDDLE/>
		<RIGHT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flixel.system.debug.DebuggerLayout" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<STANDARD/>
		<MICRO/>
		<BIG/>
		<TOP/>
		<LEFT/>
		<RIGHT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flixel.system.debug.Log" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Log.hx">
		<extends path="flixel.system.debug.Window"/>
		<MAX_LOG_LINES public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></MAX_LOG_LINES>
		<LINE_BREAK get="inline" set="null" line="19" static="1"><c path="String"/></LINE_BREAK>
		<_text><c path="flash.text.TextField"/></_text>
		<_lines><c path="Array"><c path="String"/></c></_lines>
		<destroy public="1" set="method" line="47" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<add public="1" set="method" line="65">
			<f a="Data:Style:?FireOnce" v="::false">
				<c path="Array"><d/></c>
				<c path="flixel.system.debug.LogStyle"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Adds a new line to the log window.
	 * @param 	Data		The data being logged.
	 * @param 	Style		The LogStyle to be used for the log
	 * @param 	FireOnce   	Whether you only want to log the Data in case it hasn't been added already</haxe_doc>
		</add>
		<clear public="1" set="method" line="139"><f a=""><x path="Void"/></f></clear>
		<updateSize set="method" line="151" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Adjusts the width and height of the text field accordingly.</haxe_doc>
		</updateSize>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a log window object.</haxe_doc>
		</new>
		<haxe_doc>* A simple trace output window for use in the debugger overlay.</haxe_doc>
	</class>
	<class path="flixel.system.debug.LogStyle" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/LogStyle.hx">
		<NORMAL public="1" line="12" static="1"><c path="flixel.system.debug.LogStyle"/></NORMAL>
		<WARNING public="1" line="13" static="1"><c path="flixel.system.debug.LogStyle"/></WARNING>
		<ERROR public="1" line="14" static="1"><c path="flixel.system.debug.LogStyle"/></ERROR>
		<NOTICE public="1" line="15" static="1"><c path="flixel.system.debug.LogStyle"/></NOTICE>
		<CONSOLE public="1" line="16" static="1"><c path="flixel.system.debug.LogStyle"/></CONSOLE>
		<prefix public="1">
			<c path="String"/>
			<haxe_doc>* A prefix which is always attached to the start of the logged data.</haxe_doc>
		</prefix>
		<color public="1"><c path="String"/></color>
		<size public="1"><x path="Int"/></size>
		<bold public="1"><x path="Bool"/></bold>
		<italic public="1"><x path="Bool"/></italic>
		<underlined public="1"><x path="Bool"/></underlined>
		<errorSound public="1">
			<c path="String"/>
			<haxe_doc>* A sound to be played when this LogStyle is used.</haxe_doc>
		</errorSound>
		<openConsole public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the console should be forced to open when this LogStyle is used.</haxe_doc>
		</openConsole>
		<callbackFunction public="1">
			<d/>
			<haxe_doc>* A callback function that is called when this LogStyle is used.</haxe_doc>
		</callbackFunction>
		<new public="1" set="method" line="53">
			<f a="?Prefix:?Color:?Size:?Bold:?Italic:?Underlined:?ErrorSound:?OpenConsole:?CallbackFunction" v="'':'FFFFFF':12:false:false:false:null:false:null">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new LogStyle to be used in conjunction with FlxG.log.advanced()
	 * 
	 * @param	Prefix				A prefix which is always attached to the start of the logged data.
	 * @param	Color				The text color.
	 * @param	Size				The text size.
	 * @param 	Bold				Whether the text is bold or not.
	 * @param	Italic				Whether the text is italic or not.
	 * @param	Underlined			Whether the text is underlined or not.
	 * @param	ErrorSound			A sound to be played when this LogStyle is used.
	 * @param	OpenConsole			Whether the console should be forced to open when this LogStyle is used.
	 * @param	CallbackFunction	A callback function that is called when this LogStyle is used.</haxe_doc>
		</new>
		<haxe_doc>* A class that allows you to create a custom style for FlxG.log.advanced(). 
 * Also used internally for the pre-defined styles.</haxe_doc>
	</class>
	<class path="flixel.system.debug._Stats.GraphicMinimizeButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Stats.hx" private="1" module="flixel.system.debug.Stats">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/minimize.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._Stats.GraphicMaximizeButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Stats.hx" private="1" module="flixel.system.debug.Stats">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/maximize.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.Stats" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Stats.hx">
		<extends path="flixel.system.debug.Window"/>
		<UPDATE_DELAY get="inline" set="null" line="33" static="1">
			<x path="Int"/>
			<haxe_doc>* How often to update the stats, in ms. The lower, the more performance-intense!</haxe_doc>
		</UPDATE_DELAY>
		<INITIAL_WIDTH get="inline" set="null" line="37" static="1">
			<x path="Int"/>
			<haxe_doc>* The initial width of the stats window.</haxe_doc>
		</INITIAL_WIDTH>
		<MIN_HEIGHT get="inline" set="null" line="41" static="1">
			<x path="Int"/>
			<haxe_doc>* The minimal height of the window.</haxe_doc>
		</MIN_HEIGHT>
		<FPS_COLOR get="inline" set="null" line="43" static="1"><x path="Int"/></FPS_COLOR>
		<MEMORY_COLOR get="inline" set="null" line="44" static="1"><x path="Int"/></MEMORY_COLOR>
		<DRAW_TIME_COLOR get="inline" set="null" line="45" static="1"><x path="Int"/></DRAW_TIME_COLOR>
		<UPDATE_TIME_COLOR get="inline" set="null" line="46" static="1"><x path="Int"/></UPDATE_TIME_COLOR>
		<LABEL_COLOR public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></LABEL_COLOR>
		<TEXT_SIZE public="1" get="inline" set="null" line="49" static="1"><x path="Int"/></TEXT_SIZE>
		<DECIMALS public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></DECIMALS>
		<_leftTextField><c path="flash.text.TextField"/></_leftTextField>
		<_rightTextField><c path="flash.text.TextField"/></_rightTextField>
		<_itvTime><x path="Int"/></_itvTime>
		<_initTime><x path="Int"/></_initTime>
		<_frameCount><x path="Int"/></_frameCount>
		<_totalCount><x path="Int"/></_totalCount>
		<_currentTime><x path="Int"/></_currentTime>
		<fpsGraph><c path="flixel.system.debug.StatsGraph"/></fpsGraph>
		<memoryGraph><c path="flixel.system.debug.StatsGraph"/></memoryGraph>
		<drawTimeGraph><c path="flixel.system.debug.StatsGraph"/></drawTimeGraph>
		<updateTimeGraph><c path="flixel.system.debug.StatsGraph"/></updateTimeGraph>
		<flashPlayerFramerate><x path="Float"/></flashPlayerFramerate>
		<visibleCount><x path="Int"/></visibleCount>
		<activeCount><x path="Int"/></activeCount>
		<updateTime><x path="Int"/></updateTime>
		<drawTime><x path="Int"/></drawTime>
		<_lastTime><x path="Int"/></_lastTime>
		<_updateTimer><x path="Int"/></_updateTimer>
		<_update><c path="Array"><x path="Int"/></c></_update>
		<_updateMarker><x path="Int"/></_updateMarker>
		<_draw><c path="Array"><x path="Int"/></c></_draw>
		<_drawMarker><x path="Int"/></_drawMarker>
		<_visibleObject><c path="Array"><x path="Int"/></c></_visibleObject>
		<_visibleObjectMarker><x path="Int"/></_visibleObjectMarker>
		<_activeObject><c path="Array"><x path="Int"/></c></_activeObject>
		<_activeObjectMarker><x path="Int"/></_activeObjectMarker>
		<_paused><x path="Bool"/></_paused>
		<_toggleSizeButton><c path="flixel.system.ui.FlxSystemButton"/></_toggleSizeButton>
		<drawCallsCount><x path="Int"/></drawCallsCount>
		<_drawCalls><c path="Array"><x path="Int"/></c></_drawCalls>
		<_drawCallsMarker><x path="Int"/></_drawCallsMarker>
		<start public="1" set="method" line="166">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Starts Stats window update logic</haxe_doc>
		</start>
		<stop public="1" set="method" line="179">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops Stats window</haxe_doc>
		</stop>
		<destroy public="1" set="method" line="187" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="230" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called each frame, but really only updates once every second or so, to save on performance.
	 * Takes all the data in the accumulators and parses it into useful performance data.</haxe_doc>
		</update>
		<updateTexts set="method" line="304"><f a=""><x path="Void"/></f></updateTexts>
		<currentFps public="1" get="inline" set="null" line="324">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Calculates current game fps.</haxe_doc>
		</currentFps>
		<averageFps public="1" get="inline" set="null" line="332">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Calculates average game fps (takes whole time the game is running).</haxe_doc>
		</averageFps>
		<runningTime public="1" get="inline" set="null" line="340">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Application life time.</haxe_doc>
		</runningTime>
		<intervalTime public="1" get="inline" set="null" line="348">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Time since perfomance monitoring started.</haxe_doc>
		</intervalTime>
		<currentMem public="1" get="inline" set="null" line="356">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Current RAM consumtion.</haxe_doc>
		</currentMem>
		<flixelUpdate public="1" set="method" line="366">
			<f a="Time">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* How long updates took.
	 * 
	 * @param 	Time	How long this update took.</haxe_doc>
		</flixelUpdate>
		<flixelDraw public="1" set="method" line="378">
			<f a="Time">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* How long rendering took.
	 * 
	 * @param	Time	How long this render took.</haxe_doc>
		</flixelDraw>
		<activeObjects public="1" set="method" line="390">
			<f a="Count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* How many objects were updated.
	 * 
	 * @param 	Count	How many objects were updated.</haxe_doc>
		</activeObjects>
		<visibleObjects public="1" set="method" line="402">
			<f a="Count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* How many objects were rendered.
	 * 
	 * @param 	Count	How many objects were rendered.</haxe_doc>
		</visibleObjects>
		<drawCalls public="1" set="method" line="415">
			<f a="Drawcalls">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* How many times drawTiles() method was called.
	 * 
	 * @param 	Count	How many times drawTiles() method was called.</haxe_doc>
		</drawCalls>
		<onFocus public="1" set="method" line="426">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Re-enables tracking of the stats.</haxe_doc>
		</onFocus>
		<onFocusLost public="1" set="method" line="434">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pauses tracking of the stats.</haxe_doc>
		</onFocusLost>
		<toggleSize set="method" line="439"><f a=""><x path="Void"/></f></toggleSize>
		<updateSize set="method" line="462" override="1"><f a=""><x path="Void"/></f></updateSize>
		<new public="1" set="method" line="100">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a new window with fps and memory graphs, as well as other useful stats for debugging.</haxe_doc>
		</new>
		<haxe_doc>* A simple performance monitor widget, for use in the debugger overlay.
 * 
 * @author Adam "Atomic" Saltsman
 * @author Anton Karlov</haxe_doc>
	</class>
	<class path="flixel.system.debug.StatsGraph" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/StatsGraph.hx">
		<extends path="flash.display.Sprite"/>
		<AXIS_COLOR get="inline" set="null" line="17" static="1"><x path="Int"/></AXIS_COLOR>
		<AXIS_ALPHA get="inline" set="null" line="18" static="1"><x path="Float"/></AXIS_ALPHA>
		<HISTORY_MAX get="inline" set="null" line="19" static="1"><x path="Int"/></HISTORY_MAX>
		<minLabel public="1"><c path="flash.text.TextField"/></minLabel>
		<curLabel public="1"><c path="flash.text.TextField"/></curLabel>
		<maxLabel public="1"><c path="flash.text.TextField"/></maxLabel>
		<avgLabel public="1"><c path="flash.text.TextField"/></avgLabel>
		<minValue public="1"><x path="Float"/></minValue>
		<maxValue public="1"><x path="Float"/></maxValue>
		<graphColor public="1"><x path="Int"/></graphColor>
		<history public="1"><c path="Array"><x path="Float"/></c></history>
		<_axis><c path="flash.display.Shape"/></_axis>
		<_width><x path="Int"/></_width>
		<_height><x path="Int"/></_height>
		<_unit><c path="String"/></_unit>
		<_labelWidth><x path="Int"/></_labelWidth>
		<_label><c path="String"/></_label>
		<drawAxis set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Redraws the axis of the graph.</haxe_doc>
		</drawAxis>
		<drawGraph set="method" line="99">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Redraws the graph based on the values stored in the history.</haxe_doc>
		</drawGraph>
		<update public="1" set="method" line="117"><f a="Value:?Average" v=":null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<average public="1" set="method" line="140"><f a=""><x path="Float"/></f></average>
		<destroy public="1" set="method" line="149"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="40"><f a="X:Y:Width:Height:GraphColor:Unit:?LabelWidth:?Label" v="::::::45:null">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* This is a helper function for the stats window to draw a graph with given values.</haxe_doc>
	</class>
	<class path="flixel.system.debug.Watch" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Watch.hx">
		<extends path="flixel.system.debug.Window"/>
		<MAX_LOG_LINES get="inline" set="null" line="21" static="1"><x path="Int"/></MAX_LOG_LINES>
		<LINE_HEIGHT get="inline" set="null" line="22" static="1"><x path="Int"/></LINE_HEIGHT>
		<editing public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether a watch entry is currently being edited or not.</haxe_doc>
		</editing>
		<_names><c path="flash.display.Sprite"/></_names>
		<_values><c path="flash.display.Sprite"/></_values>
		<_watching><c path="Array"><c path="flixel.system.debug.WatchEntry"/></c></_watching>
		<_quickWatchList><x path="Map">
	<c path="String"/>
	<c path="flixel.system.debug.WatchEntry"/>
</x></_quickWatchList>
		<destroy public="1" set="method" line="62" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<add public="1" set="method" line="95">
			<f a="AnyObject:VariableName:?DisplayName" v="::null">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a new variable to the watch window. Has some simple code in place to prevent
	 * accidentally watching the same variable twice.
	 * 
	 * @param 	AnyObject		The Object containing the variable you want to track, e.g. this or Player.velocity.
	 * @param 	VariableName	The String name of the variable you want to track, e.g. "width" or "x".
	 * @param 	DisplayName		Optional String that can be displayed in the watch window instead of the basic class-name information.</haxe_doc>
		</add>
		<updateQuickWatch public="1" set="method" line="133">
			<f a="Name:NewValue">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add or update a quickWatch entry to the watch list in the debugger. Extremely useful when called in update() 
	 * functions when there doesn't exist a variable for a value you want to watch - so you won't have to create one.
	 * 
	 * @param	Name		The name of the quickWatch entry, for example "mousePressed".
	 * @param	NewValue	The new value for this entry, for example FlxG.mouse.pressed.</haxe_doc>
		</updateQuickWatch>
		<remove public="1" set="method" line="161">
			<f a="AnyObject:?VariableName:?QuickWatchName" v=":null:null">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a variable from the watch window.
	 * 
	 * @param 	AnyObject		The Object containing the variable you want to remove, e.g. this or Player.velocity.
	 * @param 	VariableName	The String name of the variable you want to remove, e.g. "width" or "x".  If left null, this will remove all variables of that object. 
	 * @param	QuickWatchName	In case you want to remove a quickWatch entry.</haxe_doc>
		</remove>
		<removeEntry set="method" line="192">
			<f a="Entry:Index">
				<c path="flixel.system.debug.WatchEntry"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function to acutally remove an entry.</haxe_doc>
		</removeEntry>
		<removeAll public="1" set="method" line="210">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove everything from the watch window.</haxe_doc>
		</removeAll>
		<update public="1" set="method" line="226" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update all the entries in the watch window.</haxe_doc>
		</update>
		<submit public="1" set="method" line="240">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Force any watch entries currently being edited to submit their changes.</haxe_doc>
		</submit>
		<updateSize set="method" line="255" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the Flash shapes to match the new size, and reposition the header, shadow, and handle accordingly.
	 * Also adjusts the width of the entries and stuff, and makes sure there is room for all the entries.</haxe_doc>
		</updateSize>
		<new public="1" set="method" line="37">
			<f a="?Closable" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new watch window object.</haxe_doc>
		</new>
		<haxe_doc>* A Visual Studio-style "watch" window, for use in the debugger overlay.
 * Track the values of any public variable in real-time, and/or edit their values on the fly.</haxe_doc>
	</class>
	<class path="flixel.system.debug.Tracker" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Tracker.hx">
		<extends path="flixel.system.debug.Watch"/>
		<profiles public="1" static="1">
			<c path="Array"><c path="flixel.system.debug.TrackerProfile"/></c>
			<haxe_doc>* Order matters here, as the last profile is the most releveant - i.e., if the 
	 * FlxSprite profile were added before the one for FlxObject, it would never be selected.</haxe_doc>
		</profiles>
		<objectsBeingTracked public="1" line="52" static="1">
			<c path="Array"><d/></c>
			<haxe_doc>* Stores a reference to all objects for a which a tracker window exists
	 * to prevent the creation of two windows for the same object.</haxe_doc>
		</objectsBeingTracked>
		<_numTrackerWindows line="54" static="1"><x path="Int"/></_numTrackerWindows>
		<addProfile public="1" get="inline" set="null" line="56" static="1"><f a="Profile">
	<c path="flixel.system.debug.TrackerProfile"/>
	<x path="Void"/>
</f></addProfile>
		<findProfile public="1" set="method" line="64" static="1"><f a="Object">
	<d/>
	<c path="flixel.system.debug.TrackerProfile"/>
</f></findProfile>
		<onStateSwitch public="1" set="method" line="79" static="1"><f a=""><x path="Void"/></f></onStateSwitch>
		<initProfiles set="method" line="84" static="1"><f a=""><x path="Void"/></f></initProfiles>
		<_object><d/></_object>
		<destroy public="1" set="method" line="169" override="1"><f a=""><x path="Void"/></f></destroy>
		<findProfileByClass set="method" line="177"><f a="ObjectClass">
	<x path="Class"><d/></x>
	<c path="flixel.system.debug.TrackerProfile"/>
</f></findProfileByClass>
		<initWatchEntries set="method" line="189"><f a="Profile">
	<c path="flixel.system.debug.TrackerProfile"/>
	<x path="Void"/>
</f></initWatchEntries>
		<addExtensions set="method" line="198"><f a="Profile">
	<c path="flixel.system.debug.TrackerProfile"/>
	<x path="Void"/>
</f></addExtensions>
		<addVariables set="method" line="217"><f a="Variables">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></addVariables>
		<new public="1" set="method" line="147"><f a="Profile:Object:?WindowTitle" v="::null">
	<c path="flixel.system.debug.TrackerProfile"/>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.debug.TrackerProfile" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Tracker.hx" module="flixel.system.debug.Tracker">
		<objectClass public="1"><x path="Class"><d/></x></objectClass>
		<variables public="1"><c path="Array"><c path="String"/></c></variables>
		<extensions public="1"><c path="Array"><x path="Class"><d/></x></c></extensions>
		<toString public="1" set="method" line="243"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="236"><f a="ObjectClass:?Variables:?Extensions" v=":null:null">
	<x path="Class"><d/></x>
	<c path="Array"><c path="String"/></c>
	<c path="Array"><x path="Class"><d/></x></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.debug._VCR.GraphicOpen" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/open.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicPause" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/pause.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicPlay" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/play.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicRecordOff" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/record_off.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicRecordOn" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/record_on.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicRestart" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/restart.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicStep" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/step.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicStop" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/stop.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.VCR" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/VCR.hx">
		<runtimeDisplay public="1">
			<c path="flash.text.TextField"/>
			<haxe_doc>* Texfield that displays the runtime display data for a game replay</haxe_doc>
		</runtimeDisplay>
		<runtime public="1"><x path="Int"/></runtime>
		<playbackToggleBtn public="1"><c path="flixel.system.ui.FlxSystemButton"/></playbackToggleBtn>
		<stepBtn public="1"><c path="flixel.system.ui.FlxSystemButton"/></stepBtn>
		<restartBtn public="1"><c path="flixel.system.ui.FlxSystemButton"/></restartBtn>
		<recordBtn public="1"><c path="flixel.system.ui.FlxSystemButton"/></recordBtn>
		<openBtn public="1"><c path="flixel.system.ui.FlxSystemButton"/></openBtn>
		<onPause public="1" get="inline" set="null" line="146">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the user presses the Pause button.
	 * This is different from user-defined pause behavior, or focus lost behavior.
	 * Does NOT pause music playback!!</haxe_doc>
		</onPause>
		<onResume public="1" get="inline" set="null" line="156">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the user presses the Play button.
	 * This is different from user-defined unpause behavior, or focus gained behavior.</haxe_doc>
		</onResume>
		<onStep public="1" set="method" line="166">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the user presses the fast-forward-looking button.
	 * Requests a 1-frame step forward in the game loop.</haxe_doc>
		</onStep>
		<new public="1" set="method" line="59">
			<f a="Debugger">
				<c path="flixel.system.debug.FlxDebugger"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates the "VCR" control panel for debugger pausing, stepping, and recording.</haxe_doc>
		</new>
		<haxe_doc>* This class contains the record, stop, play, and step 1 frame buttons seen on the top edge of the debugger overlay.</haxe_doc>
	</class>
	<class path="flixel.system.debug.WatchEntry" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/WatchEntry.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<object public="1">
			<d/>
			<haxe_doc>* The Object being watched.</haxe_doc>
		</object>
		<field public="1">
			<c path="String"/>
			<haxe_doc>* The member variable of that object.</haxe_doc>
		</field>
		<custom public="1">
			<c path="String"/>
			<haxe_doc>* A custom display name for this object, if there is any.</haxe_doc>
		</custom>
		<nameDisplay public="1">
			<c path="flash.text.TextField"/>
			<haxe_doc>* The Flash TextField object used to display this entry's name.</haxe_doc>
		</nameDisplay>
		<valueDisplay public="1">
			<c path="flash.text.TextField"/>
			<haxe_doc>* The Flash TextField object used to display and edit this entry's value.</haxe_doc>
		</valueDisplay>
		<editing public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the entry is currently being edited or not.</haxe_doc>
		</editing>
		<oldValue public="1">
			<d/>
			<haxe_doc>* The value of the field before it was edited.</haxe_doc>
		</oldValue>
		<_whiteText><c path="flash.text.TextFormat"/></_whiteText>
		<_blackText><c path="flash.text.TextFormat"/></_blackText>
		<quickWatch public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether this entry is a quickWatch or not.</haxe_doc>
		</quickWatch>
		<destroy public="1" set="method" line="156">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<setY public="1" set="method" line="174">
			<f a="Y">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the watch window Y height of the Flash TextField objects.</haxe_doc>
		</setY>
		<updateWidth public="1" set="method" line="183">
			<f a="NameWidth:ValueWidth">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adjust the width of the Flash TextField objects.</haxe_doc>
		</updateWidth>
		<updateValue public="1" set="method" line="207">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Update the variable value on display with the current in-game value.</haxe_doc>
		</updateValue>
		<onMouseUp public="1" set="method" line="225">
			<f a="FlashEvent">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A watch entry was clicked, so flip into edit mode for that entry.
	 * @param	FlashEvent	Flash mouse event.</haxe_doc>
		</onMouseUp>
		<onKeyUp public="1" set="method" line="242">
			<f a="FlashEvent">
				<c path="flash.events.KeyboardEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Check to see if Enter, Tab or Escape were just released.
	 * Enter or Tab submit the change, and Escape cancels it.
	 * @param	FlashEvent	Flash keyboard event.</haxe_doc>
		</onKeyUp>
		<cancel public="1" set="method" line="260">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancel the current edits and stop editing.</haxe_doc>
		</cancel>
		<submit public="1" set="method" line="269">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Submit the current edits and stop editing.</haxe_doc>
		</submit>
		<toString public="1" set="method" line="300"><f a=""><c path="String"/></f></toString>
		<doneEditing set="method" line="310">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Helper function, switches the text field back to display mode.</haxe_doc>
		</doneEditing>
		<new public="1" set="method" line="69">
			<f a="Y:NameWidth:ValueWidth:Obj:Field:?Custom" v=":::::null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new watch entry in the watch window. 
	 * Will be a "quickWatch" when Obj and Field are null, but a Custom name is set.
	 * 
	 * @param 	Y			The initial height in the Watch window.
	 * @param 	NameWidth	The initial width of the name field.
	 * @param 	ValueWidth	The initial width of the value field.
	 * @param 	Obj			The Object containing the variable we want to watch.
	 * @param 	Field		The variable name we want to watch.
	 * @param 	Custom		A custom display name (optional).</haxe_doc>
		</new>
		<haxe_doc>* Helper class for the debugger overlay's Watch window.
 * Handles the display and modification of game variables on the fly.</haxe_doc>
	</class>
	<class path="flixel.system.debug._Window.GraphicWindowHandle" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Window.hx" private="1" module="flixel.system.debug.Window">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/windowHandle.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._Window.GraphicCloseButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/debug/Window.hx" private="1" module="flixel.system.debug.Window">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/close.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.layer.DrawStackItem" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/layer/DrawStackItem.hx">
		<graphics public="1"><c path="flixel.util.loaders.CachedGraphics"/></graphics>
		<drawData public="1"><c path="Array"><x path="Float"/></c></drawData>
		<position public="1"><x path="Int"/></position>
		<next public="1"><c path="flixel.system.layer.DrawStackItem"/></next>
		<colored public="1"><x path="Bool"/></colored>
		<blending public="1"><x path="Int"/></blending>
		<initialized public="1"><x path="Bool"/></initialized>
		<antialiasing public="1"><x path="Bool"/></antialiasing>
		<reset public="1" get="inline" set="null" line="24"><f a=""><x path="Void"/></f></reset>
		<dispose public="1" get="inline" set="null" line="32"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.layer.Region" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/layer/Region.hx">
		<startX public="1"><x path="Int"/></startX>
		<startY public="1"><x path="Int"/></startY>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<tileWidth public="1"><x path="Int"/></tileWidth>
		<tileHeight public="1"><x path="Int"/></tileHeight>
		<spacingX public="1"><x path="Int"/></spacingX>
		<spacingY public="1"><x path="Int"/></spacingY>
		<numTiles public="1" get="accessor" set="null"><x path="Int"/></numTiles>
		<get_numTiles set="method" line="36"><f a=""><x path="Int"/></f></get_numTiles>
		<numRows public="1" get="accessor" set="null"><x path="Int"/></numRows>
		<get_numRows set="method" line="43"><f a=""><x path="Int"/></f></get_numRows>
		<numCols public="1" get="accessor" set="null"><x path="Int"/></numCols>
		<get_numCols set="method" line="57"><f a=""><x path="Int"/></f></get_numCols>
		<clone public="1" set="method" line="69"><f a=""><c path="flixel.system.layer.Region"/></f></clone>
		<new public="1" set="method" line="19"><f a="?startX:?startY:?tileWidth:?tileHeight:?spacingX:?spacingY:?width:?height" v="0:0:0:0:0:0:0:0">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.layer.TileSheetData" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/layer/TileSheetData.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<tileSheet public="1"><c path="flixel.system.layer.TileSheetExt"/></tileSheet>
		<flxSpriteFrames>
			<x path="Map">
				<c path="String"/>
				<c path="flixel.system.layer.frames.FlxSpriteFrames"/>
			</x>
			<haxe_doc>* Storage for all groups of FlxFrames.
	 * WARNING: accessing Map data structure causes string allocations - avoid doing every frame.</haxe_doc>
		</flxSpriteFrames>
		<flxFrames>
			<x path="Map">
				<c path="String"/>
				<c path="flixel.system.layer.frames.FlxFrame"/>
			</x>
			<haxe_doc>* Storage for all FlxFrames in this TileSheetData object.
	 * WARNING: accessing Map data structure causes string allocations - avoid doing every frame.</haxe_doc>
		</flxFrames>
		<frameNames><c path="Array"><c path="String"/></c></frameNames>
		<bitmap public="1"><c path="flash.display.BitmapData"/></bitmap>
		<getFrame public="1" get="inline" set="null" line="51"><f a="name">
	<c path="String"/>
	<c path="flixel.system.layer.frames.FlxFrame"/>
</f></getFrame>
		<getSpriteSheetFrames public="1" set="method" line="56"><f a="region:?origin" v=":null">
	<c path="flixel.system.layer.Region"/>
	<c path="flash.geom.Point"/>
	<c path="flixel.system.layer.frames.FlxSpriteFrames"/>
</f></getSpriteSheetFrames>
		<getSpriteSheetFrameKey public="1" get="inline" set="null" line="125">
			<f a="rect:point">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Hashing Functionality - TODO: use numbers as keys!
	 * 
	 * http://stackoverflow.com/questions/892618/create-a-hashcode-of-two-numbers
	 * http://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier</haxe_doc>
		</getSpriteSheetFrameKey>
		<getKeyForSpriteSheetFrames public="1" get="inline" set="null" line="130"><f a="width:height:startX:startY:endX:endY:xSpacing:ySpacing:pointX:pointY">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
</f></getKeyForSpriteSheetFrames>
		<containsSpriteSheetFrames public="1" set="method" line="135"><f a="width:height:startX:startY:endX:endY:xSpacing:ySpacing:pointX:pointY">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></containsSpriteSheetFrames>
		<addSpriteSheetFrame public="1" set="method" line="144">
			<f a="rect:point">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="flixel.system.layer.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Adds new FlxFrame to this TileSheetData object</haxe_doc>
		</addSpriteSheetFrame>
		<containsFrame public="1" get="inline" set="null" line="170"><f a="key">
	<c path="String"/>
	<x path="Bool"/>
</f></containsFrame>
		<addTileRect public="1" get="inline" set="null" line="176"><f a="tileRect:?point" v=":null">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
</f></addTileRect>
		<destroy public="1" set="method" line="182"><f a=""><x path="Void"/></f></destroy>
		<onContext public="1" set="method" line="211"><f a="bitmap">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></onContext>
		<getTexturePackerFrames public="1" set="method" line="223">
			<f a="data:?startX:?startY" v=":0:0">
				<c path="flixel.util.loaders.TexturePackerData"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.system.layer.frames.FlxSpriteFrames"/>
			</f>
			<haxe_doc>* Parses provided TexturePackerData object and returns generated FlxSpriteFrames object</haxe_doc>
		</getTexturePackerFrames>
		<addTexturePackerFrame set="method" line="250">
			<f a="frameData:?startX:?startY" v=":0:0">
				<c path="flixel.util.loaders.TextureAtlasFrame"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.system.layer.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Parses frame TexturePacker data object and returns it</haxe_doc>
		</addTexturePackerFrame>
		<destroyFrameBitmapDatas public="1" set="method" line="286"><f a=""><x path="Void"/></f></destroyFrameBitmapDatas>
		<new public="1" set="method" line="40"><f a="Bitmap">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Object of this class holds information about single Tilesheet</haxe_doc>
	</class>
	<class path="openfl.display.Tilesheet" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></TILE_TRANS_2x2>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></TILE_BLEND_ADD>
		<TILE_BLEND_MULTIPLY public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></TILE_BLEND_MULTIPLY>
		<TILE_BLEND_SCREEN public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></TILE_BLEND_SCREEN>
		<defaultRatio line="29" static="1"><c path="flash.geom.Point"/></defaultRatio>
		<lime_tilesheet_create line="87" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_tilesheet_create>
		<lime_tilesheet_add_rect line="88" static="1"><f a="::">
	<d/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
</f></lime_tilesheet_add_rect>
		<__bitmap public="1">
			<c path="flash.display.BitmapData"/>
			<meta><m n=":noCompletion"/></meta>
		</__bitmap>
		<__handle public="1">
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<_bitmapHeight><x path="Int"/></_bitmapHeight>
		<_bitmapWidth><x path="Int"/></_bitmapWidth>
		<_tilePoints><c path="Array"><c path="flash.geom.Point"/></c></_tilePoints>
		<_tiles><c path="Array"><c path="flash.geom.Rectangle"/></c></_tiles>
		<_tileUVs><c path="Array"><c path="flash.geom.Rectangle"/></c></_tileUVs>
		<addTileRect public="1" set="method" line="51"><f a="rectangle:?centerPoint" v=":null">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
</f></addTileRect>
		<drawTiles public="1" set="method" line="62"><f a="graphics:tileData:?smooth:?flags:?count" v="::false:0:-1">
	<c path="flash.display.Graphics"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawTiles>
		<getTileCenter public="1" get="inline" set="null" line="69"><f a="index">
	<x path="Int"/>
	<c path="flash.geom.Point"/>
</f></getTileCenter>
		<getTileRect public="1" get="inline" set="null" line="73"><f a="index">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getTileRect>
		<getTileUVs public="1" get="inline" set="null" line="77"><f a="index">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getTileUVs>
		<new public="1" set="method" line="36"><f a="image">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.layer.TileSheetExt" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/layer/TileSheetExt.hx">
		<extends path="openfl.display.Tilesheet"/>
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<_DRAWCALLS public="1" line="13" static="1"><x path="Int"/></_DRAWCALLS>
		<numTiles public="1"><x path="Int"/></numTiles>
		<tileIDs public="1"><x path="Map">
	<c path="String"/>
	<c path="flixel.system.layer._TileSheetExt.RectPointTileID"/>
</x></tileIDs>
		<tileOrder public="1"><c path="Array"><c path="String"/></c></tileOrder>
		<rebuildFromOld public="1" set="method" line="28"><f a="old">
	<c path="flixel.system.layer.TileSheetExt"/>
	<x path="Void"/>
</f></rebuildFromOld>
		<getKey set="method" line="52">
			<f a="rect:?point" v=":null">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Hashing Functionality (TODO: use numbers as Map keys):
	 * 
	 * http://stackoverflow.com/questions/892618/create-a-hashcode-of-two-numbers
	 * http://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier</haxe_doc>
		</getKey>
		<addTileRectID public="1" set="method" line="66">
			<f a="rect:?point" v=":null">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Adds new tileRect to tileSheet object
	 * @return id of added tileRect</haxe_doc>
		</addTileRectID>
		<destroy public="1" set="method" line="83"><f a=""><x path="Void"/></f></destroy>
		<nmeBitmap public="1" get="accessor" set="null"><c path="flash.display.BitmapData"/></nmeBitmap>
		<get_nmeBitmap get="inline" set="null" line="104"><f a=""><c path="flash.display.BitmapData"/></f></get_nmeBitmap>
		<new public="1" set="method" line="20"><f a="bitmap">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.layer._TileSheetExt.RectPointTileID" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/layer/TileSheetExt.hx" private="1" module="flixel.system.layer.TileSheetExt">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<rect public="1"><c path="flash.geom.Rectangle"/></rect>
		<point public="1"><c path="flash.geom.Point"/></point>
		<id public="1"><x path="Int"/></id>
		<destroy public="1" set="method" line="124"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="117"><f a="id:rect:point">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.layer.frames.FlxFrame" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/layer/frames/FlxFrame.hx">
		<POINT public="1" line="16" static="1"><c path="flash.geom.Point"/></POINT>
		<MATRIX public="1" line="17" static="1"><c path="flash.geom.Matrix"/></MATRIX>
		<name public="1"><c path="String"/></name>
		<frame public="1"><c path="flash.geom.Rectangle"/></frame>
		<rotated public="1"><x path="Bool"/></rotated>
		<trimmed public="1"><x path="Bool"/></trimmed>
		<tileID public="1"><x path="Int"/></tileID>
		<additionalAngle public="1"><x path="Float"/></additionalAngle>
		<sourceSize public="1" set="null"><c path="flixel.util.FlxPoint"/></sourceSize>
		<offset public="1" set="null"><c path="flixel.util.FlxPoint"/></offset>
		<center public="1" set="null"><c path="flixel.util.FlxPoint"/></center>
		<_bitmapData><c path="flash.display.BitmapData"/></_bitmapData>
		<_hReversedBitmapData><c path="flash.display.BitmapData"/></_hReversedBitmapData>
		<_vReversedBitmapData><c path="flash.display.BitmapData"/></_vReversedBitmapData>
		<_hvReversedBitmapData><c path="flash.display.BitmapData"/></_hvReversedBitmapData>
		<_tileSheet><c path="flixel.system.layer.TileSheetData"/></_tileSheet>
		<getBitmap public="1" set="method" line="48"><f a=""><c path="flash.display.BitmapData"/></f></getBitmap>
		<getHReversedBitmap public="1" set="method" line="81"><f a=""><c path="flash.display.BitmapData"/></f></getHReversedBitmap>
		<getVReversedBitmap public="1" set="method" line="98"><f a=""><c path="flash.display.BitmapData"/></f></getVReversedBitmap>
		<getHVReversedBitmap public="1" set="method" line="115"><f a=""><c path="flash.display.BitmapData"/></f></getHVReversedBitmap>
		<destroy public="1" set="method" line="132"><f a=""><x path="Void"/></f></destroy>
		<destroyBitmapDatas public="1" set="method" line="145"><f a=""><x path="Void"/></f></destroyBitmapDatas>
		<new public="1" set="method" line="38"><f a="tileSheet">
	<c path="flixel.system.layer.TileSheetData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.layer.frames.FlxSpriteFrames" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/layer/frames/FlxSpriteFrames.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<frames public="1"><c path="Array"><c path="flixel.system.layer.frames.FlxFrame"/></c></frames>
		<framesHash public="1"><x path="Map">
	<c path="String"/>
	<c path="flixel.system.layer.frames.FlxFrame"/>
</x></framesHash>
		<name public="1"><c path="String"/></name>
		<addFrame public="1" set="method" line="18"><f a="frame">
	<c path="flixel.system.layer.frames.FlxFrame"/>
	<x path="Void"/>
</f></addFrame>
		<destroy public="1" set="method" line="24"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="11"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.replay.CodeValuePair" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/replay/CodeValuePair.hx">
		<code public="1"><x path="Int"/></code>
		<value public="1"><x path="Int"/></value>
		<new public="1" set="method" line="12"><f a="?Code:?Value" v="0:0">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.system.replay.FlxReplay" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/replay/FlxReplay.hx">
		<seed public="1">
			<x path="Int"/>
			<haxe_doc>* The random number generator seed value for this recording.</haxe_doc>
		</seed>
		<frame public="1">
			<x path="Int"/>
			<haxe_doc>* The current frame for this recording.</haxe_doc>
		</frame>
		<frameCount public="1">
			<x path="Int"/>
			<haxe_doc>* The number of frames in this recording.</haxe_doc>
		</frameCount>
		<finished public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the replay has finished playing or not.</haxe_doc>
		</finished>
		<_frames>
			<c path="Array"><c path="flixel.system.replay.FrameRecord"/></c>
			<haxe_doc>* Internal container for all the frames in this replay.</haxe_doc>
		</_frames>
		<_capacity>
			<x path="Int"/>
			<haxe_doc>* Internal tracker for max number of frames we can fit before growing the _frames again.</haxe_doc>
		</_capacity>
		<_marker>
			<x path="Int"/>
			<haxe_doc>* Internal helper variable for keeping track of where we are in _frames during recording or replay.</haxe_doc>
		</_marker>
		<destroy public="1" set="method" line="65">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<create public="1" set="method" line="84">
			<f a="Seed">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new gameplay recording.  Requires the current random number generator seed.
	 * 
	 * @param	Seed	The current seed from the random number generator.</haxe_doc>
		</create>
		<load public="1" set="method" line="98">
			<f a="FileContents">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Load replay data from a String object.
	 * Strings can come from embedded assets or external
	 * files loaded through the debugger overlay. 
	 * @param	FileContents	A String object containing a gameplay recording.</haxe_doc>
		</load>
		<save public="1" set="method" line="131">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Save the current recording data off to a String object.
	 * Basically goes through and calls FrameRecord.save() on each frame in the replay.
	 * return	The gameplay recording in simple ASCII format.</haxe_doc>
		</save>
		<recordFrame public="1" set="method" line="149">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Get the current input data from the input managers and store it in a new frame record.</haxe_doc>
		</recordFrame>
		<playNextFrame public="1" set="method" line="189">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Get the current frame record data and load it into the input managers.</haxe_doc>
		</playNextFrame>
		<rewind public="1" set="method" line="223">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Reset the replay back to the first frame.</haxe_doc>
		</rewind>
		<init set="method" line="233">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Common initialization terms used by both create() and load() to set up the replay object.</haxe_doc>
		</init>
		<new public="1" set="method" line="51">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate a new replay object.  Doesn't actually do much until you call create() or load().</haxe_doc>
		</new>
		<haxe_doc>* The replay object both records and replays game recordings,
 * as well as handle saving and loading replays to and from files.
 * Gameplay recordings are essentially a list of keyboard and mouse inputs,
 * but since Flixel is fairly deterministic, we can use these to play back
 * recordings of gameplay with a decent amount of fidelity.</haxe_doc>
	</class>
	<class path="flixel.system.replay.FrameRecord" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/replay/FrameRecord.hx">
		<frame public="1">
			<x path="Int"/>
			<haxe_doc>* Which frame of the game loop this record is from or for.</haxe_doc>
		</frame>
		<keys public="1">
			<c path="Array"><c path="flixel.system.replay.CodeValuePair"/></c>
			<haxe_doc>* An array of simple integer pairs referring to what key is pressed, and what state its in.</haxe_doc>
		</keys>
		<mouse public="1">
			<c path="flixel.system.replay.MouseRecord"/>
			<haxe_doc>* A container for the 4 mouse state integers.</haxe_doc>
		</mouse>
		<create public="1" set="method" line="38">
			<f a="Frame:?Keys:?Mouse" v=":null:null">
				<x path="Float"/>
				<c path="Array"><c path="flixel.system.replay.CodeValuePair"/></c>
				<c path="flixel.system.replay.MouseRecord"/>
				<c path="flixel.system.replay.FrameRecord"/>
			</f>
			<haxe_doc>* Load this frame record with input data from the input managers.
	 * @param Frame		What frame it is.
	 * @param Keys		Keyboard data from the keyboard manager.
	 * @param Mouse		Mouse data from the mouse manager.
	 * @return A reference to this FrameRecord object.</haxe_doc>
		</create>
		<destroy public="1" set="method" line="50">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<save public="1" set="method" line="60">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Save the frame record data to array simple ASCII string.
	 * @return	A String object containing the relevant frame record data.</haxe_doc>
		</save>
		<load public="1" set="method" line="93">
			<f a="Data">
				<c path="String"/>
				<c path="flixel.system.replay.FrameRecord"/>
			</f>
			<haxe_doc>* Load the frame record data from array simple ASCII string.
	 * @param	Data	A String object containing the relevant frame record data.</haxe_doc>
		</load>
		<new public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate array new frame record.</haxe_doc>
		</new>
		<haxe_doc>* Helper class for the new replay system.  Represents all the game inputs for one "frame" or "step" of the game loop.</haxe_doc>
	</class>
	<class path="flixel.system.replay.MouseRecord" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/replay/MouseRecord.hx">
		<extends path="flixel.util.FlxPoint"/>
		<button public="1">
			<x path="Int"/>
			<haxe_doc>* The state of the left mouse button.</haxe_doc>
		</button>
		<wheel public="1">
			<x path="Int"/>
			<haxe_doc>* The state of the mouse wheel.</haxe_doc>
		</wheel>
		<new public="1" set="method" line="27">
			<f a="X:Y:Button:Wheel">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new mouse input record.
	 * 
	 * @param   X        The main X value of the mouse in screen space.
	 * @param   Y        The main Y value of the mouse in screen space.
	 * @param   Button   The state of the left mouse button.
	 * @param   Wheel    The state of the mouse wheel.</haxe_doc>
		</new>
		<haxe_doc>* A helper class for the frame records, part of the replay/demo/recording system.</haxe_doc>
	</class>
	<class path="flixel.system.scaleModes.FillScaleMode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/scaleModes/FillScaleMode.hx">
		<extends path="flixel.system.scaleModes.BaseScaleMode"/>
		<updateGamePosition set="method" line="7" override="1"><f a=""><x path="Void"/></f></updateGamePosition>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.scaleModes.FixedScaleMode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/scaleModes/FixedScaleMode.hx">
		<extends path="flixel.system.scaleModes.BaseScaleMode"/>
		<updateGameSize set="method" line="7" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateGameSize>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.scaleModes.PixelPerfectScaleMode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/scaleModes/PixelPerfectScaleMode.hx">
		<extends path="flixel.system.scaleModes.BaseScaleMode"/>
		<updateGameSize set="method" line="11" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateGameSize>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A scale mode which scales up the game to the highest integer factor it can,
 * maintains the aspect ratio, and windowboxes the game if necessary.</haxe_doc>
	</class>
	<class path="flixel.system.scaleModes.RelativeScaleMode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/scaleModes/RelativeScaleMode.hx">
		<extends path="flixel.system.scaleModes.BaseScaleMode"/>
		<_widthScale><x path="Float"/></_widthScale>
		<_heightScale><x path="Float"/></_heightScale>
		<initScale get="inline" set="null" line="16"><f a="WidthScale:HeightScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initScale>
		<setScale public="1" set="method" line="22"><f a="WidthScale:HeightScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setScale>
		<updateGameSize set="method" line="28" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateGameSize>
		<new public="1" set="method" line="10"><f a="WidthScale:HeightScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.scaleModes.StageSizeScaleMode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/scaleModes/StageSizeScaleMode.hx">
		<extends path="flixel.system.scaleModes.BaseScaleMode"/>
		<onMeasure public="1" set="method" line="7" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMeasure>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.ui.FlxFocusLostScreen" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/ui/FlxFocusLostScreen.hx">
		<extends path="flash.display.Sprite"/>
		<draw public="1" set="method" line="30">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Redraws the big arrow on the focus lost screen.</haxe_doc>
		</draw>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.ui.FlxSoundTray" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/ui/FlxSoundTray.hx">
		<extends path="flash.display.Sprite"/>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc>* Because reading any data from DisplayObject is insanely expensive in hxcpp, keep track of whether we need to update it or not.</haxe_doc>
		</active>
		<_timer>
			<x path="Float"/>
			<haxe_doc>* Helps us auto-hide the sound tray after a volume change.</haxe_doc>
		</_timer>
		<_bars>
			<c path="Array"><c path="flash.display.Bitmap"/></c>
			<haxe_doc>* Helps display the volume bars on the sound tray.</haxe_doc>
		</_bars>
		<_width>
			<x path="Int"/>
			<haxe_doc>* How wide the sound tray background is.</haxe_doc>
		</_width>
		<_defaultScale><x path="Float"/></_defaultScale>
		<update public="1" set="method" line="101">
			<f a="MS">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function just updates the soundtray object.</haxe_doc>
		</update>
		<show public="1" set="method" line="130">
			<f a="?Silent" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Makes the little volume tray slide out.
	 * 
	 * @param	Silent	Whether or not it should beep.</haxe_doc>
		</show>
		<screenCenter public="1" set="method" line="161"><f a=""><x path="Void"/></f></screenCenter>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets up the "sound tray", the little volume meter that pops down sometimes.</haxe_doc>
		</new>
		<haxe_doc>* The flixel sound tray, the little volume meter that pops down sometimes.</haxe_doc>
	</class>
	<class path="flixel.system.ui.FlxSystemButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/system/ui/FlxSystemButton.hx">
		<extends path="flash.display.Sprite"/>
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<upHandler public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The function to be called when the button is pressed.</haxe_doc>
		</upHandler>
		<enabled public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the downHandler function will be called when 
	 * the button is clicked.</haxe_doc>
		</enabled>
		<toggleMode public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether this is a toggle button or not. If so, a Boolean representing the current
	 * state will be passed to the callback function, and the alpha value will be lowered when toggled.</haxe_doc>
		</toggleMode>
		<toggled public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the button has been toggled in toggleMode.</haxe_doc>
		</toggled>
		<_icon>
			<c path="flash.display.Bitmap"/>
			<haxe_doc>* The icon this button uses.</haxe_doc>
		</_icon>
		<_mouseDown>
			<x path="Bool"/>
			<haxe_doc>* Whether the mouse has been pressed while over this button.</haxe_doc>
		</_mouseDown>
		<changeIcon public="1" set="method" line="79">
			<f a="Icon">
				<c path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the Icon of the button
	 * 
	 * @param	Icon	The new icon to use for the button.</haxe_doc>
		</changeIcon>
		<destroy public="1" set="method" line="90"><f a=""><x path="Void"/></f></destroy>
		<onMouseUp set="method" line="100"><f a="?E" v="null">
	<c path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></onMouseUp>
		<onMouseDown set="method" line="114"><f a="?E" v="null">
	<c path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></onMouseDown>
		<onMouseOver get="inline" set="null" line="119"><f a="?E" v="null">
	<c path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></onMouseOver>
		<onMouseOut get="inline" set="null" line="124"><f a="?E" v="null">
	<c path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></onMouseOut>
		<set_toggled set="method" line="129"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_toggled>
		<new public="1" set="method" line="51">
			<f a="Icon:?UpHandler:?ToggleMode" v=":null:false">
				<c path="flash.display.BitmapData"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new FlxSystemButton
	 * 
	 * @param	Icon		The icon to use for the button.
	 * @param	UpHandler	The function to be called when the button is pressed.
	 * @param	ToggleMode	Whether this is a toggle button or not.</haxe_doc>
		</new>
		<haxe_doc>* A basic button for the debugger, extends flash.display.Sprite.
* Cannot be used in a FlxState.</haxe_doc>
	</class>
	<class path="flixel.text.FlxBitmapTextField" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/text/FlxBitmapTextField.hx">
		<extends path="flixel.FlxSprite"/>
		<_font><c path="flixel.text.pxText.PxBitmapFont"/></_font>
		<_text><c path="String"/></_text>
		<_textColor><x path="Int"/></_textColor>
		<_useTextColor><x path="Bool"/></_useTextColor>
		<_outline><x path="Bool"/></_outline>
		<_outlineColor><x path="Int"/></_outlineColor>
		<_shadow><x path="Bool"/></_shadow>
		<_shadowColor><x path="Int"/></_shadowColor>
		<_background><x path="Bool"/></_background>
		<_backgroundColor><x path="Int"/></_backgroundColor>
		<_alignment><x path="Int"/></_alignment>
		<_padding><x path="Int"/></_padding>
		<_lineSpacing><x path="Int"/></_lineSpacing>
		<_letterSpacing><x path="Int"/></_letterSpacing>
		<_fontScale><x path="Float"/></_fontScale>
		<_autoUpperCase><x path="Bool"/></_autoUpperCase>
		<_wordWrap><x path="Bool"/></_wordWrap>
		<_fixedWidth><x path="Bool"/></_fixedWidth>
		<_numSpacesInTab><x path="Int"/></_numSpacesInTab>
		<_tabSpaces><c path="String"/></_tabSpaces>
		<_pendingTextChange><x path="Bool"/></_pendingTextChange>
		<_multiLine><x path="Bool"/></_multiLine>
		<_drawData><c path="Array"><x path="Float"/></c></_drawData>
		<_bgDrawData><c path="Array"><x path="Float"/></c></_bgDrawData>
		<destroy public="1" set="method" line="99" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears all resources used.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="115" override="1"><f a=""><x path="Void"/></f></update>
		<numSpacesInTab public="1" get="accessor" set="accessor"><x path="Int"/></numSpacesInTab>
		<get_numSpacesInTab set="method" line="127"><f a=""><x path="Int"/></f></get_numSpacesInTab>
		<set_numSpacesInTab set="method" line="132"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_numSpacesInTab>
		<draw public="1" set="method" line="161" override="1"><f a=""><x path="Void"/></f></draw>
		<set_color set="method" line="301" override="1"><f a="Color">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<textColor public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Sets the color of the text.</haxe_doc>
		</textColor>
		<get_textColor set="method" line="315"><f a=""><x path="Int"/></f></get_textColor>
		<set_textColor set="method" line="320"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_textColor>
		<useTextColor public="1" get="accessor" set="accessor"><x path="Bool"/></useTextColor>
		<get_useTextColor set="method" line="334"><f a=""><x path="Bool"/></f></get_useTextColor>
		<set_useTextColor set="method" line="339"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useTextColor>
		<set_alpha set="method" line="351" override="1"><f a="PxAlpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<text public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Text to display.</haxe_doc>
		</text>
		<get_text set="method" line="370"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="375"><f a="PxText">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<updateBitmapData set="method" line="389">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal method for updating the view of the text component</haxe_doc>
		</updateBitmapData>
		<background public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Specifies whether the text field should have a filled background.</haxe_doc>
		</background>
		<get_background set="method" line="734"><f a=""><x path="Bool"/></f></get_background>
		<set_background set="method" line="739"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_background>
		<backgroundColor public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Specifies the color of the text field background.</haxe_doc>
		</backgroundColor>
		<get_backgroundColor set="method" line="755"><f a=""><x path="Int"/></f></get_backgroundColor>
		<set_backgroundColor set="method" line="760"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_backgroundColor>
		<shadow public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Specifies whether the text should have a shadow.</haxe_doc>
		</shadow>
		<get_shadow set="method" line="779"><f a=""><x path="Bool"/></f></get_shadow>
		<set_shadow set="method" line="784"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_shadow>
		<shadowColor public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Specifies the color of the text field shadow.</haxe_doc>
		</shadowColor>
		<get_shadowColor set="method" line="802"><f a=""><x path="Int"/></f></get_shadowColor>
		<set_shadowColor set="method" line="807"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_shadowColor>
		<padding public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Sets the padding of the text field. This is the distance between the text and the border of the background (if any).</haxe_doc>
		</padding>
		<get_padding set="method" line="824"><f a=""><x path="Int"/></f></get_padding>
		<set_padding set="method" line="829"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_padding>
		<set_width set="method" line="843" override="1">
			<f a="PxWidth">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Sets the width of the text field. If the text does not fit, it will spread on multiple lines.</haxe_doc>
		</set_width>
		<alignment public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Specifies how the text field should align text.
	 * LEFT, RIGHT, CENTER.</haxe_doc>
		</alignment>
		<get_alignment set="method" line="865"><f a=""><x path="Int"/></f></get_alignment>
		<set_alignment set="method" line="870"><f a="PxAlignment">
	<x path="Int"/>
	<x path="Int"/>
</f></set_alignment>
		<multiLine public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Specifies whether the text field will break into multiple lines or not on overflow.</haxe_doc>
		</multiLine>
		<get_multiLine set="method" line="886"><f a=""><x path="Bool"/></f></get_multiLine>
		<set_multiLine set="method" line="891"><f a="PxMultiLine">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_multiLine>
		<outline public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Specifies whether the text should have an outline.</haxe_doc>
		</outline>
		<get_outline set="method" line="907"><f a=""><x path="Bool"/></f></get_outline>
		<set_outline set="method" line="912"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_outline>
		<outlineColor public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Specifies whether color of the text outline.</haxe_doc>
		</outlineColor>
		<get_outlineColor set="method" line="930"><f a=""><x path="Int"/></f></get_outlineColor>
		<set_outlineColor set="method" line="935"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_outlineColor>
		<font public="1" get="accessor" set="accessor">
			<c path="flixel.text.pxText.PxBitmapFont"/>
			<haxe_doc>* Sets which font to use for rendering.</haxe_doc>
		</font>
		<get_font set="method" line="952"><f a=""><c path="flixel.text.pxText.PxBitmapFont"/></f></get_font>
		<set_font set="method" line="957"><f a="PxFont">
	<c path="flixel.text.pxText.PxBitmapFont"/>
	<c path="flixel.text.pxText.PxBitmapFont"/>
</f></set_font>
		<lineSpacing public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Sets the distance between lines</haxe_doc>
		</lineSpacing>
		<get_lineSpacing set="method" line="978"><f a=""><x path="Int"/></f></get_lineSpacing>
		<set_lineSpacing set="method" line="983"><f a="PxSpacing">
	<x path="Int"/>
	<x path="Int"/>
</f></set_lineSpacing>
		<fontScale public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Sets the "font size" of the text</haxe_doc>
		</fontScale>
		<get_fontScale set="method" line="999"><f a=""><x path="Float"/></f></get_fontScale>
		<set_fontScale set="method" line="1004"><f a="PxScale">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fontScale>
		<letterSpacing public="1" get="accessor" set="accessor"><x path="Int"/></letterSpacing>
		<get_letterSpacing set="method" line="1020"><f a=""><x path="Int"/></f></get_letterSpacing>
		<set_letterSpacing set="method" line="1025"><f a="PxSpacing">
	<x path="Int"/>
	<x path="Int"/>
</f></set_letterSpacing>
		<autoUpperCase public="1" get="accessor" set="accessor"><x path="Bool"/></autoUpperCase>
		<get_autoUpperCase set="method" line="1040"><f a=""><x path="Bool"/></f></get_autoUpperCase>
		<set_autoUpperCase set="method" line="1045"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoUpperCase>
		<wordWrap public="1" get="accessor" set="accessor"><x path="Bool"/></wordWrap>
		<get_wordWrap set="method" line="1058"><f a=""><x path="Bool"/></f></get_wordWrap>
		<set_wordWrap set="method" line="1063"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wordWrap>
		<fixedWidth public="1" get="accessor" set="accessor"><x path="Bool"/></fixedWidth>
		<get_fixedWidth set="method" line="1076"><f a=""><x path="Bool"/></f></get_fixedWidth>
		<set_fixedWidth set="method" line="1081"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fixedWidth>
		<updateGlyphs set="method" line="1092"><f a="?TextGlyphs:?ShadowGlyphs:?OutlineGlyphs" v="false:false:false">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></updateGlyphs>
		<new public="1" set="method" line="63">
			<f a="?PxFont" v="null">
				<c path="flixel.text.pxText.PxBitmapFont"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructs a new text field component.
	 * @param 	PxFont	Optional parameter for component's font prop</haxe_doc>
		</new>
		<haxe_doc>* Extends FlxSprite to support rendering text.
 * Can tint, fade, rotate and scale just like a sprite.
 * Doesn't really animate though, as far as I know.
 * Also does nice pixel-perfect centering on pixel fonts
 * as long as they are only one liners.</haxe_doc>
	</class>
	<class path="flixel.text.FlxTextFormat" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/text/FlxText.hx" module="flixel.text.FlxText">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<borderColor public="1">
			<x path="Int"/>
			<haxe_doc>* The border color if FlxText has a shadow or a border</haxe_doc>
		</borderColor>
		<start public="1">
			<x path="Int"/>
			<haxe_doc>* The start index of the string where the format will be applied</haxe_doc>
		</start>
		<end public="1">
			<x path="Int"/>
			<haxe_doc>* The end index of the string where the format will be applied</haxe_doc>
		</end>
		<format public="1" set="null">
			<c path="flash.text.TextFormat"/>
			<haxe_doc>* Internal TextFormat</haxe_doc>
		</format>
		<destroy public="1" set="method" line="1005"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="981">
			<f a="?FontColor:?Bold:?Italic:?BorderColor:?Start:?End" v="null:null:null:null:-1:-1">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	FontColor	(Optional) Set the font  color. By default, inherits from the default format.
	 * @param	Bold		(Optional) Set the font to bold. The font must support bold. By default, false. 
	 * @param	Italic		(Optional) Set the font to italics. The font must support italics. Only works in Flash. By default, false.  
	 * @param	BorderColor	(Optional) Set the border color. By default, no border (The color is TRANSPARENT)
	 * @param	Start		(Default=-1) The start index of the string where the format will be applied. If not set, the format won't be applied.
	 * @param	End			(Default=-1) The end index of the string where the format will be applied.</haxe_doc>
		</new>
	</class>
	<class path="flixel.text.FlxTextField" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/text/FlxTextField.hx">
		<extends path="flixel.text.FlxText"/>
		<_camera><c path="flixel.FlxCamera"/></_camera>
		<_addedToDisplay><x path="Bool"/></_addedToDisplay>
		<destroy public="1" set="method" line="57" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<stamp public="1" set="method" line="68" override="1"><f a="Brush:?X:?Y" v=":0:0">
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stamp>
		<pixelsOverlapPoint public="1" set="method" line="73" override="1"><f a="point:?Mask:?Camera" v=":255:null">
	<c path="flixel.util.FlxPoint"/>
	<x path="Int"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></pixelsOverlapPoint>
		<isSimpleRender public="1" set="method" line="79" override="1"><f a=""><x path="Bool"/></f></isSimpleRender>
		<get_pixels set="method" line="89" override="1">
			<f a=""><c path="flash.display.BitmapData"/></f>
			<haxe_doc>* Set pixels to any BitmapData object.
	 * Automatically adjust graphic size and render helpers.</haxe_doc>
		</get_pixels>
		<set_pixels set="method" line="95" override="1"><f a="Pixels">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
</f></set_pixels>
		<set_alpha set="method" line="101" override="1"><f a="Alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_height set="method" line="118" override="1"><f a="Height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<set_visible set="method" line="125" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<kill public="1" set="method" line="131" override="1"><f a=""><x path="Void"/></f></kill>
		<revive public="1" set="method" line="137" override="1"><f a=""><x path="Void"/></f></revive>
		<draw public="1" set="method" line="146" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by game loop, updates then blits or renders current frame of animation to the screen</haxe_doc>
		</draw>
		<regenGraphics set="method" line="190" override="1"><f a=""><x path="Void"/></f></regenGraphics>
		<get_camera set="method" line="217" override="1"><f a=""><c path="flixel.FlxCamera"/></f></get_camera>
		<set_camera set="method" line="222" override="1"><f a="Value">
	<c path="flixel.FlxCamera"/>
	<c path="flixel.FlxCamera"/>
</f></set_camera>
		<new public="1" set="method" line="36">
			<f a="X:Y:Width:?Text:?Size:?EmbeddedFont:?Camera" v=":::null:8:true:null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxText object at the specified position.
	 * @param	X				The X position of the text.
	 * @param	Y				The Y position of the text.
	 * @param	Width			The width of the text object (height is determined automatically).
	 * @param	Text			The actual text you would like to display initially.
	 * @param	EmbeddedFont	Whether this text field uses embedded fonts or not
	 * @param	Camera			Camera to display. FlxG.camera is used by default (if you pass null)</haxe_doc>
		</new>
		<haxe_doc>* Extends FlxText for better support rendering text on cpp target.
 * Doesn't have multicamera support.
 * Displays over all other objects.</haxe_doc>
	</class>
	<class path="flixel.text.pxText.PxBitmapFont" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/text/pxText/PxBitmapFont.hx">
		<_storedFonts line="21" static="1"><x path="Map">
	<c path="String"/>
	<c path="flixel.text.pxText.PxBitmapFont"/>
</x></_storedFonts>
		<ZERO_POINT line="23" static="1"><c path="flash.geom.Point"/></ZERO_POINT>
		<store public="1" set="method" line="697" static="1">
			<f a="PxHandle:PxFont">
				<c path="String"/>
				<c path="flixel.text.pxText.PxBitmapFont"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stores a font for global use using an identifier.
	 * 
	 * @param	PxHandle	String identifer for the font.
	 * @param	PxFont		Font to store.</haxe_doc>
		</store>
		<fetch public="1" set="method" line="708" static="1">
			<f a="PxHandle">
				<c path="String"/>
				<c path="flixel.text.pxText.PxBitmapFont"/>
			</f>
			<haxe_doc>* Retrieves a font previously stored.
	 * 
	 * @param	PxHandle	Identifier of font to fetch.
	 * @return	Stored font, or null if no font was found.</haxe_doc>
		</fetch>
		<clearStorage public="1" set="method" line="715" static="1"><f a=""><x path="Void"/></f></clearStorage>
		<_glyphs><x path="Map">
	<x path="Int"/>
	<c path="flixel.text.pxText.PxFontSymbol"/>
</x></_glyphs>
		<_num_letters><x path="Int"/></_num_letters>
		<_bgTileID><x path="Int"/></_bgTileID>
		<_glyphString><c path="String"/></_glyphString>
		<_maxHeight><x path="Int"/></_maxHeight>
		<_point><c path="flash.geom.Point"/></_point>
		<_tileRects><c path="Array"><c path="flash.geom.Rectangle"/></c></_tileRects>
		<_symbols><c path="Array"><c path="flixel.text.pxText._PxBitmapFont.HelperSymbol"/></c></_symbols>
		<_region><c path="flixel.system.layer.Region"/></_region>
		<cachedGraphics><c path="flixel.util.loaders.CachedGraphics"/></cachedGraphics>
		<loadPixelizer public="1" set="method" line="74">
			<f a="PxBitmapData:PxLetters">
				<c path="flash.display.BitmapData"/>
				<c path="String"/>
				<c path="flixel.text.pxText.PxBitmapFont"/>
			</f>
			<haxe_doc>* Loads font data in Pixelizer's format
	 * 
	 * @param	PxBitmapData	Font source image
	 * @param	PxLetters		All letters contained in this font
	 * @return	This PxBitmapFont</haxe_doc>
		</loadPixelizer>
		<loadAngelCode public="1" set="method" line="116">
			<f a="pBitmapData:pXMLData">
				<c path="flash.display.BitmapData"/>
				<c path="Xml"/>
				<c path="flixel.text.pxText.PxBitmapFont"/>
			</f>
			<haxe_doc>* Loads font data in AngelCode's format
	 * 
	 * @param	PxBitmapData	Font image source
	 * @param	PxXMLData		Font data in XML format
	 * @return	This PxBitmapFont</haxe_doc>
		</loadAngelCode>
		<updateGlyphData public="1" set="method" line="140">
			<f a="?Tiles" v="null">
				<c path="flixel.system.layer.TileSheetData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates and caches tile data for passed node object</haxe_doc>
		</updateGlyphData>
		<reset set="method" line="231">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function. Resets current font.</haxe_doc>
		</reset>
		<preparePixelizerBitmapData public="1" set="method" line="248"><f a="PxBitmapData:PxRects">
	<c path="flash.display.BitmapData"/>
	<c path="Array"><c path="flash.geom.Rectangle"/></c>
	<c path="flash.display.BitmapData"/>
</f></preparePixelizerBitmapData>
		<prepareAngelCodeBitmapData public="1" set="method" line="310"><f a="PxBitmapData:PxXMLData:PxSymbols">
	<c path="flash.display.BitmapData"/>
	<c path="Xml"/>
	<c path="Array"><c path="flixel.text.pxText._PxBitmapFont.HelperSymbol"/></c>
	<c path="flash.display.BitmapData"/>
</f></prepareAngelCodeBitmapData>
		<dispose public="1" set="method" line="420">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears all resources used by the font.</haxe_doc>
		</dispose>
		<setGlyph set="method" line="489"><f a="Tiles:PxCharID:PxRect:?PxOffsetX:?PxOffsetY:?PxAdvanceX" v=":::0:0:0">
	<c path="flixel.system.layer.TileSheetData"/>
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setGlyph>
		<render public="1" set="method" line="520">
			<f a="DrawData:PxText:PxColor:PxSecondColor:PxAlpha:PxOffsetX:PxOffsetY:PxLetterSpacing:PxScale:?PxUseColor" v=":::::::::true">
				<c path="Array"><x path="Float"/></c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Renders a string of text onto bitmap data using the font.
	 * 
	 * @param	PxBitmapData	Where to render the text.
	 * @param	PxText			Test to render.
	 * @param	PxColor			Color of text to render.
	 * @param	PxOffsetX		X position of thext output.
	 * @param	PxOffsetY		Y position of thext output.</haxe_doc>
		</render>
		<getTextWidth public="1" set="method" line="594">
			<f a="PxText:?PxLetterSpacing:?PxFontScale" v=":0:1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the width of a certain test string.
	 * 
	 * @param	PxText	String to measure.
	 * @param	PxLetterSpacing	distance between letters
	 * @param	PxFontScale	"size" of the font
	 * @return	Width in pixels.</haxe_doc>
		</getTextWidth>
		<getFontHeight public="1" set="method" line="636">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns height of font in pixels.
	 * 
	 * @return Height of font in pixels.</haxe_doc>
		</getFontHeight>
		<numLetters public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Returns number of letters available in this font.
	 * 
	 * @return Number of letters available in this font.</haxe_doc>
		</numLetters>
		<pixels public="1" get="accessor" set="null"><c path="flash.display.BitmapData"/></pixels>
		<get_pixels set="method" line="651"><f a=""><c path="flash.display.BitmapData"/></f></get_pixels>
		<bgTileID public="1" get="accessor" set="null"><x path="Int"/></bgTileID>
		<get_bgTileID set="method" line="662"><f a=""><x path="Int"/></f></get_bgTileID>
		<get_numLetters set="method" line="668"><f a=""><x path="Int"/></f></get_numLetters>
		<setCachedGraphics set="method" line="677"><f a="value">
	<c path="flixel.util.loaders.CachedGraphics"/>
	<x path="Void"/>
</f></setCachedGraphics>
		<new public="1" set="method" line="54">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a new bitmap font using specified bitmap data and letter input.</haxe_doc>
		</new>
		<haxe_doc>* Holds information and bitmap glpyhs for a bitmap font.
 * @author Johan Peitz
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.text.pxText._PxBitmapFont.HelperSymbol" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/text/pxText/PxBitmapFont.hx" private="1" module="flixel.text.pxText.PxBitmapFont">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<xoffset public="1"><x path="Int"/></xoffset>
		<yoffset public="1"><x path="Int"/></yoffset>
		<xadvance public="1"><x path="Int"/></xadvance>
		<charCode public="1"><x path="Int"/></charCode>
		<new public="1" set="method" line="737"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.text.pxText.PxDefaultFontGenerator" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/text/pxText/PxDefaultFontGenerator.hx">
		<fontData line="12" static="1"><c path="String"/></fontData>
		<generateAndStoreDefaultFont public="1" set="method" line="17" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates and stores the default font for later use.</haxe_doc>
		</generateAndStoreDefaultFont>
		<haxe_doc>* Creates a default font. This is done automatically when intializing Pixelizer.
 * @author Johan Peitz</haxe_doc>
	</class>
	<class path="flixel.text.pxText.PxFontSymbol" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/text/pxText/PxFontSymbol.hx">
		<xoffset public="1">
			<x path="Int"/>
			<haxe_doc>* X offset to draw symbol with</haxe_doc>
		</xoffset>
		<yoffset public="1">
			<x path="Int"/>
			<haxe_doc>* Y offset to draw symbol with</haxe_doc>
		</yoffset>
		<xadvance public="1">
			<x path="Int"/>
			<haxe_doc>* Real width of symbol</haxe_doc>
		</xadvance>
		<tileID public="1">
			<x path="Int"/>
			<haxe_doc>* Tile id in tileSheet</haxe_doc>
		</tileID>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.text.pxText.PxTextAlign" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/text/pxText/PxTextAlign.hx">
		<LEFT public="1" get="inline" set="null" line="8" static="1"><x path="Int"/></LEFT>
		<RIGHT public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></RIGHT>
		<CENTER public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></CENTER>
		<haxe_doc>* Omnipotent class that can be used to take various short cuts. Also holds various useful things.</haxe_doc>
	</class>
	<class path="flixel.tile.FlxTile" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tile/FlxTile.hx">
		<extends path="flixel.FlxObject"/>
		<callbackFunction public="1">
			<f a=":">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function is called whenever an object hits a tile of this type.
	 * This function should take the form myFunction(Tile:FlxTile,Object:FlxObject):void.
	 * Defaults to null, set through FlxTilemap.setTileProperties().</haxe_doc>
		</callbackFunction>
		<filter public="1">
			<x path="Class"><d/></x>
			<haxe_doc>* Each tile can store its own filter class for their callback functions.
	 * That is, the callback will only be triggered if an object with a class
	 * type matching the filter touched it.
	 * Defaults to null, set through FlxTilemap.setTileProperties().</haxe_doc>
		</filter>
		<tilemap public="1">
			<c path="flixel.tile.FlxTilemap"/>
			<haxe_doc>* A reference to the tilemap this tile object belongs to.</haxe_doc>
		</tilemap>
		<index public="1">
			<x path="Int"/>
			<haxe_doc>* The index of this tile type in the core map data.
	 * For example, if your map only has 16 kinds of tiles in it,
	 * this number is usually between 0 and 15.</haxe_doc>
		</index>
		<mapIndex public="1">
			<x path="Int"/>
			<haxe_doc>* The current map index of this tile object at this moment.
	 * You can think of tile objects as moving around the tilemap helping with collisions.
	 * This value is only reliable and useful if used from the callback function.</haxe_doc>
		</mapIndex>
		<destroy public="1" set="method" line="69" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<new public="1" set="method" line="52">
			<f a="Tilemap:Index:Width:Height:Visible:AllowCollisions">
				<c path="flixel.tile.FlxTilemap"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate this new tile object.  This is usually called from FlxTilemap.loadMap().
	 * 
	 * @param 	Tilemap			A reference to the tilemap object creating the tile.
	 * @param 	Index			The actual core map data index for this tile type.
	 * @param 	Width			The width of the tile.
	 * @param 	Height			The height of the tile.
	 * @param 	Visible			Whether the tile is visible or not.
	 * @param 	AllowCollisions	The collision flags for the object.  By default this value is ANY or NONE depending on the parameters sent to loadMap().</haxe_doc>
		</new>
		<haxe_doc>* A simple helper object for FlxTilemap that helps expand collision opportunities and control.
 * You can use FlxTilemap.setTileProperties() to alter the collision properties and
 * callback functions and filters for this object to do things like one-way tiles or whatever.</haxe_doc>
	</class>
	<class path="flixel.tile.FlxTileblock" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tile/FlxTileblock.hx">
		<extends path="flixel.FlxSprite"/>
		<loadTiles public="1" set="method" line="42">
			<f a="TileGraphic:?TileWidth:?TileHeight:?Empties" v=":0:0:0">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.tile.FlxTileblock"/>
			</f>
			<haxe_doc>* Fills the block with a randomly arranged selection of graphics from the image provided.
	 * 
	 * @param	TileGraphic 	The graphic class that contains the tiles that should fill this block.
	 * @param	TileWidth		The width of a single tile in the graphic.
	 * @param	TileHeight		The height of a single tile in the graphic.
	 * @param	Empties			The number of "empty" tiles to add to the auto-fill algorithm (e.g. 8 tiles + 4 empties = 1/3 of block will be open holes).</haxe_doc>
		</loadTiles>
		<new public="1" set="method" line="25">
			<f a="X:Y:Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxBlock object with the specified position and size.
	 * 
	 * @param	X			The X position of the block.
	 * @param	Y			The Y position of the block.
	 * @param	Width		The width of the block.
	 * @param	Height		The height of the block.</haxe_doc>
		</new>
		<haxe_doc>* This is a basic "environment object" class, used to create simple walls and floors.
 * It can be filled with a random selection of tiles to quickly add detail.</haxe_doc>
	</class>
	<class path="flixel.tile.GraphicAuto" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tile/FlxTilemap.hx" module="flixel.tile.FlxTilemap">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/tile/autotiles.png"</e></m>
		</meta>
	</class>
	<class path="flixel.tile.GraphicAutoAlt" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tile/FlxTilemap.hx" module="flixel.tile.FlxTilemap">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/tile/autotiles_alt.png"</e></m>
		</meta>
	</class>
	<class path="flixel.tweens.FlxEase" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/FlxEase.hx">
		<PI2 line="11" static="1">
			<x path="Float"/>
			<haxe_doc>* Easing constants.</haxe_doc>
		</PI2>
		<EL line="12" static="1"><x path="Float"/></EL>
		<B1 line="13" static="1"><x path="Float"/></B1>
		<B2 line="14" static="1"><x path="Float"/></B2>
		<B3 line="15" static="1"><x path="Float"/></B3>
		<B4 line="16" static="1"><x path="Float"/></B4>
		<B5 line="17" static="1"><x path="Float"/></B5>
		<B6 line="18" static="1"><x path="Float"/></B6>
		<ELASTIC_AMPLITUDE line="19" static="1"><x path="Float"/></ELASTIC_AMPLITUDE>
		<ELASTIC_PERIOD line="20" static="1"><x path="Float"/></ELASTIC_PERIOD>
		<quadIn public="1" get="inline" set="null" line="33" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Operation of in/out easers:
	 * 
	 * in(t)
	 *		return t;
	 * out(t)
	 * 		return 1 - in(1 - t);
	 * inOut(t)
	 * 		return (t <= .5) ? in(t * 2) / 2 : out(t * 2 - 1) / 2 + .5;]]></haxe_doc>
		</quadIn>
		<quadOut public="1" get="inline" set="null" line="38" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quadOut>
		<quadInOut public="1" get="inline" set="null" line="43" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quadInOut>
		<cubeIn public="1" get="inline" set="null" line="48" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></cubeIn>
		<cubeOut public="1" get="inline" set="null" line="53" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></cubeOut>
		<cubeInOut public="1" get="inline" set="null" line="58" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></cubeInOut>
		<quartIn public="1" get="inline" set="null" line="63" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quartIn>
		<quartOut public="1" get="inline" set="null" line="68" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quartOut>
		<quartInOut public="1" get="inline" set="null" line="73" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quartInOut>
		<quintIn public="1" get="inline" set="null" line="78" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quintIn>
		<quintOut public="1" get="inline" set="null" line="83" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quintOut>
		<quintInOut public="1" get="inline" set="null" line="88" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quintInOut>
		<sineIn public="1" get="inline" set="null" line="93" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></sineIn>
		<sineOut public="1" get="inline" set="null" line="98" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></sineOut>
		<sineInOut public="1" get="inline" set="null" line="103" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></sineInOut>
		<bounceIn public="1" set="method" line="108" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></bounceIn>
		<bounceOut public="1" set="method" line="117" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></bounceOut>
		<bounceInOut public="1" set="method" line="125" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></bounceInOut>
		<circIn public="1" get="inline" set="null" line="142" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></circIn>
		<circOut public="1" get="inline" set="null" line="147" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></circOut>
		<circInOut public="1" set="method" line="152" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></circInOut>
		<expoIn public="1" get="inline" set="null" line="157" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></expoIn>
		<expoOut public="1" get="inline" set="null" line="162" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></expoOut>
		<expoInOut public="1" set="method" line="167" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></expoInOut>
		<backIn public="1" get="inline" set="null" line="172" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></backIn>
		<backOut public="1" get="inline" set="null" line="177" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></backOut>
		<backInOut public="1" set="method" line="182" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></backInOut>
		<elasticIn public="1" get="inline" set="null" line="190" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></elasticIn>
		<elasticOut public="1" get="inline" set="null" line="195" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></elasticOut>
		<elasticInOut public="1" set="method" line="200" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></elasticInOut>
		<haxe_doc>* Static class with useful easer functions that can be used by Tweens.</haxe_doc>
	</class>
	<typedef path="flixel.tweens.EaseFunction" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/FlxEase.hx" module="flixel.tweens.FlxEase"><f a="">
	<x path="Float"/>
	<x path="Float"/>
</f></typedef>
	<typedef path="flixel.tweens.CompleteCallback" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/FlxTween.hx" module="flixel.tweens.FlxTween"><f a="">
	<c path="flixel.tweens.FlxTween"/>
	<x path="Void"/>
</f></typedef>
	<typedef path="flixel.tweens.TweenOptions" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/FlxTween.hx" module="flixel.tweens.FlxTween"><a>
	<type>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<startDelay>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</startDelay>
	<loopDelay>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</loopDelay>
	<ease>
		<t path="Null"><t path="flixel.tweens.EaseFunction"/></t>
		<meta><m n=":optional"/></meta>
	</ease>
	<complete>
		<t path="Null"><t path="flixel.tweens.CompleteCallback"/></t>
		<meta><m n=":optional"/></meta>
	</complete>
</a></typedef>
	<class path="flixel.tweens.misc.AngleTween" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/misc/AngleTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<angle public="1" set="null"><x path="Float"/></angle>
		<sprite public="1" set="null">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Optional sprite object whose angle to tween</haxe_doc>
		</sprite>
		<_start><x path="Float"/></_start>
		<_range><x path="Float"/></_range>
		<destroy public="1" set="method" line="25" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up references</haxe_doc>
		</destroy>
		<tween public="1" set="method" line="38">
			<f a="FromAngle:ToAngle:Duration:?Sprite" v=":::null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.tweens.misc.AngleTween"/>
			</f>
			<haxe_doc>* Tweens the value from one angle to another.
	 * 
	 * @param	FromAngle		Start angle.
	 * @param	ToAngle			End angle.
	 * @param	Duration		Duration of the tween.</haxe_doc>
		</tween>
		<update set="method" line="61" override="1"><f a=""><x path="Void"/></f></update>
		<new set="method" line="10"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Tweens from one angle to another.</haxe_doc>
	</class>
	<class path="flixel.tweens.misc.ColorTween" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/misc/ColorTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<color public="1" set="null"><x path="Int"/></color>
		<alpha public="1" set="null"><x path="Float"/></alpha>
		<sprite public="1" set="null">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Optional sprite object whose color to tween</haxe_doc>
		</sprite>
		<red public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Red value of the current color, from 0 to 255.</haxe_doc>
		</red>
		<green public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Green value of the current color, from 0 to 255.</haxe_doc>
		</green>
		<blue public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Blue value of the current color, from 0 to 255.</haxe_doc>
		</blue>
		<_startA><x path="Float"/></_startA>
		<_startR><x path="Float"/></_startR>
		<_startG><x path="Float"/></_startG>
		<_startB><x path="Float"/></_startB>
		<_rangeA><x path="Float"/></_rangeA>
		<_rangeR><x path="Float"/></_rangeR>
		<_rangeG><x path="Float"/></_rangeG>
		<_rangeB><x path="Float"/></_rangeB>
		<destroy public="1" set="method" line="46" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up references</haxe_doc>
		</destroy>
		<tween public="1" set="method" line="63">
			<f a="Duration:FromColor:ToColor:?FromAlpha:?ToAlpha:?Sprite" v=":::1:1:null">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.tweens.misc.ColorTween"/>
			</f>
			<haxe_doc>* Tweens the color to a new color and an alpha to a new alpha.
	 * 
	 * @param	Duration		Duration of the tween.
	 * @param	FromColor		Start color.
	 * @param	ToColor			End color.
	 * @param	FromAlpha		Start alpha
	 * @param	ToAlpha			End alpha.
	 * @param	Sprite			Optional sprite object whose color to tween.
	 * @return	The ColorTween.</haxe_doc>
		</tween>
		<update set="method" line="85" override="1"><f a=""><x path="Void"/></f></update>
		<new set="method" line="10"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Tweens a color's red, green, and blue properties
 * independently. Can also tween an alpha value.</haxe_doc>
	</class>
	<class path="flixel.tweens.misc.NumTween" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/misc/NumTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<value public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The current value.</haxe_doc>
		</value>
		<_tweenFunction><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></_tweenFunction>
		<_start><x path="Float"/></_start>
		<_range><x path="Float"/></_range>
		<destroy public="1" set="method" line="23" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up references</haxe_doc>
		</destroy>
		<tween public="1" set="method" line="37">
			<f a="fromValue:toValue:duration:?tweenFunction" v=":::null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<c path="flixel.tweens.misc.NumTween"/>
			</f>
			<haxe_doc>* Tweens the value from one value to another.
	 * 
	 * @param	fromValue		Start value.
	 * @param	toValue			End value.
	 * @param	duration		Duration of the tween.
	 * @param	tweenFunction	Optional tween function. See FlxTween.num()</haxe_doc>
		</tween>
		<update set="method" line="47" override="1"><f a=""><x path="Void"/></f></update>
		<new set="method" line="8"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Tweens a numeric value. See FlxTween.num()</haxe_doc>
	</class>
	<class path="flixel.tweens.misc.VarTween" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/misc/VarTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<_object><d/></_object>
		<_properties><d/></_properties>
		<_vars><c path="Array"><c path="String"/></c></_vars>
		<_startValues><c path="Array"><x path="Float"/></c></_startValues>
		<_range><c path="Array"><x path="Float"/></c></_range>
		<destroy public="1" set="method" line="20" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up references</haxe_doc>
		</destroy>
		<tween public="1" set="method" line="43">
			<f a="object:properties:duration">
				<d/>
				<d/>
				<x path="Float"/>
				<c path="flixel.tweens.misc.VarTween"/>
			</f>
			<haxe_doc>* Tweens multiple numeric public properties.
	 * 
	 * @param	object		The object containing the properties.
	 * @param	properties	An object containing key/value pairs of properties and target values.
	 * @param	duration	Duration of the tween.</haxe_doc>
		</tween>
		<update set="method" line="63" override="1"><f a=""><x path="Void"/></f></update>
		<initializeVars set="method" line="80"><f a=""><x path="Void"/></f></initializeVars>
		<new set="method" line="27"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Tweens multiple numeric public properties of an Object simultaneously.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.Motion" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/motion/Motion.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* Current x position of the Tween.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* Current y position of the Tween.</haxe_doc>
		</y>
		<_object><c path="flixel.FlxObject"/></_object>
		<destroy public="1" set="method" line="23" override="1"><f a=""><x path="Void"/></f></destroy>
		<setObject public="1" set="method" line="29"><f a="object">
	<c path="flixel.FlxObject"/>
	<c path="flixel.tweens.motion.Motion"/>
</f></setObject>
		<update set="method" line="36" override="1"><f a=""><x path="Void"/></f></update>
		<postUpdate set="method" line="42"><f a=""><x path="Void"/></f></postUpdate>
		<new set="method" line="10"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Base class for motion Tweens.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.CircularMotion" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/motion/CircularMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<angle public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The current position on the circle.</haxe_doc>
		</angle>
		<circumference public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The circumference of the current circle motion.</haxe_doc>
		</circumference>
		<_centerX><x path="Float"/></_centerX>
		<_centerY><x path="Float"/></_centerY>
		<_radius><x path="Float"/></_radius>
		<_angleStart><x path="Float"/></_angleStart>
		<_angleFinish><x path="Float"/></_angleFinish>
		<setMotion public="1" set="method" line="38">
			<f a="CenterX:CenterY:Radius:Angle:Clockwise:DurationOrSpeed:?UseDuration" v="::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.CircularMotion"/>
			</f>
			<haxe_doc>* Starts moving along a circle.
	 * 
	 * @param	CenterX			X position of the circle's center.
	 * @param	CenterY			Y position of the circle's center.
	 * @param	Radius			Radius of the circle.
	 * @param	Angle			Starting position on the circle.
	 * @param	Clockwise		If the motion is clockwise.
	 * @param	DurationOrSpeed	Duration of the movement.
	 * @param	UseDuration		Duration of the movement.</haxe_doc>
		</setMotion>
		<update set="method" line="59" override="1"><f a=""><x path="Void"/></f></update>
		<get_circumference set="method" line="71"><f a=""><x path="Float"/></f></get_circumference>
		<new set="method" line="8"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Determines a circular motion.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.CubicMotion" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/motion/CubicMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<_fromX><x path="Float"/></_fromX>
		<_fromY><x path="Float"/></_fromY>
		<_toX><x path="Float"/></_toX>
		<_toY><x path="Float"/></_toY>
		<_aX><x path="Float"/></_aX>
		<_aY><x path="Float"/></_aY>
		<_bX><x path="Float"/></_bX>
		<_bY><x path="Float"/></_bY>
		<_ttt><x path="Float"/></_ttt>
		<_tt><x path="Float"/></_tt>
		<setMotion public="1" set="method" line="36">
			<f a="fromX:fromY:aX:aY:bX:bY:toX:toY:duration">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.tweens.motion.CubicMotion"/>
			</f>
			<haxe_doc>* Starts moving along the curve.
	 * 
	 * @param	fromX		X start.
	 * @param	fromY		Y start.
	 * @param	aX			First control x.
	 * @param	aY			First control y.
	 * @param	bX			Second control x.
	 * @param	bY			Second control y.
	 * @param	toX			X finish.
	 * @param	toY			Y finish.
	 * @param	duration	Duration of the movement.</haxe_doc>
		</setMotion>
		<update set="method" line="51" override="1"><f a=""><x path="Void"/></f></update>
		<new set="method" line="9"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Determines motion along a cubic curve.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.LinearMotion" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/motion/LinearMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<distance public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Length of the current line of movement.</haxe_doc>
		</distance>
		<_fromX><x path="Float"/></_fromX>
		<_fromY><x path="Float"/></_fromY>
		<_moveX><x path="Float"/></_moveX>
		<_moveY><x path="Float"/></_moveY>
		<_distance><x path="Float"/></_distance>
		<setMotion public="1" set="method" line="33">
			<f a="FromX:FromY:ToX:ToY:DurationOrSpeed:?UseDuration" v=":::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.LinearMotion"/>
			</f>
			<haxe_doc>* Starts moving along a line.
	 * 
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.</haxe_doc>
		</setMotion>
		<update set="method" line="55" override="1"><f a=""><x path="Void"/></f></update>
		<get_distance set="method" line="72"><f a=""><x path="Float"/></f></get_distance>
		<new set="method" line="9"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Determines motion along a line, from one point to another.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.LinearPath" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/motion/LinearPath.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<distance public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The full length of the path.</haxe_doc>
		</distance>
		<points public="1"><c path="Array"><c path="flixel.util.FlxPoint"/></c></points>
		<_pointD><c path="Array"><x path="Float"/></c></_pointD>
		<_pointT><c path="Array"><x path="Float"/></c></_pointT>
		<_speed><x path="Float"/></_speed>
		<_index><x path="Int"/></_index>
		<_last><c path="flixel.util.FlxPoint"/></_last>
		<_prevPoint><c path="flixel.util.FlxPoint"/></_prevPoint>
		<_nextPoint><c path="flixel.util.FlxPoint"/></_nextPoint>
		<destroy public="1" set="method" line="40" override="1"><f a=""><x path="Void"/></f></destroy>
		<setMotion public="1" set="method" line="59">
			<f a="DurationOrSpeed:?UseDuration" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.LinearPath"/>
			</f>
			<haxe_doc>* Starts moving along the path.
	 * 
	 * @param	DurationOrSpeed		Duration or speed of the movement.
	 * @param	UseDuration			Whether to use the previous param as duration or speed.</haxe_doc>
		</setMotion>
		<addPoint public="1" set="method" line="78"><f a="?x:?y" v="0:0">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.tweens.motion.LinearPath"/>
</f></addPoint>
		<getPoint public="1" set="method" line="89"><f a="?index" v="0">
	<x path="Int"/>
	<c path="flixel.util.FlxPoint"/>
</f></getPoint>
		<start set="method" line="98" override="1"><f a=""><c path="flixel.tweens.motion.LinearPath"/></f></start>
		<update set="method" line="105" override="1"><f a=""><x path="Void"/></f></update>
		<updatePath set="method" line="167">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the path, preparing it for motion.</haxe_doc>
		</updatePath>
		<new set="method" line="31"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Determines linear motion along a set of points.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.QuadMotion" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/motion/QuadMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<distance public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The distance of the entire curve.</haxe_doc>
		</distance>
		<_distance><x path="Float"/></_distance>
		<_fromX><x path="Float"/></_fromX>
		<_fromY><x path="Float"/></_fromY>
		<_toX><x path="Float"/></_toX>
		<_toY><x path="Float"/></_toY>
		<_controlX><x path="Float"/></_controlX>
		<_controlY><x path="Float"/></_controlY>
		<setMotion public="1" set="method" line="37">
			<f a="FromX:FromY:ControlX:ControlY:ToX:ToY:DurationOrSpeed:?UseDuration" v=":::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.QuadMotion"/>
			</f>
			<haxe_doc>* Starts moving along the curve.
	 * 
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ControlX		X control, used to determine the curve.
	 * @param	ControlY		Y control, used to determine the curve.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration or speed of the movement.
	 * @param	UseDuration		Duration of the movement.</haxe_doc>
		</setMotion>
		<update set="method" line="61" override="1"><f a=""><x path="Void"/></f></update>
		<get_distance set="method" line="72"><f a=""><x path="Float"/></f></get_distance>
		<new set="method" line="9"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Determines motion along a quadratic curve.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.QuadPath" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/tweens/motion/QuadPath.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<_points><c path="Array"><c path="flixel.util.FlxPoint"/></c></_points>
		<_distance><x path="Float"/></_distance>
		<_speed><x path="Float"/></_speed>
		<_index><x path="Int"/></_index>
		<_numSegs><x path="Int"/></_numSegs>
		<_updateCurve><x path="Bool"/></_updateCurve>
		<_curveT><c path="Array"><x path="Float"/></c></_curveT>
		<_curveD><c path="Array"><x path="Float"/></c></_curveD>
		<_a><c path="flixel.util.FlxPoint"/></_a>
		<_b><c path="flixel.util.FlxPoint"/></_b>
		<_c><c path="flixel.util.FlxPoint"/></_c>
		<destroy public="1" set="method" line="40" override="1"><f a=""><x path="Void"/></f></destroy>
		<setMotion public="1" set="method" line="59">
			<f a="DurationOrSpeed:?UseDuration" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<haxe_doc>* Starts moving along the path.
	 * 
	 * @param	DurationOrSpeed		Duration or speed of the movement.
	 * @param	UseDuration			Whether to use the previous param as duration or speed.</haxe_doc>
		</setMotion>
		<addPoint public="1" set="method" line="81">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<haxe_doc>* Adds the point to the path.</haxe_doc>
		</addPoint>
		<getPoint public="1" set="method" line="91">
			<f a="?index" v="0">
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Gets the point on the path.</haxe_doc>
		</getPoint>
		<start set="method" line="100" override="1"><f a=""><c path="flixel.tweens.motion.QuadPath"/></f></start>
		<update set="method" line="107" override="1"><f a=""><x path="Void"/></f></update>
		<updatePath set="method" line="164"><f a=""><x path="Void"/></f></updatePath>
		<getCurveLength set="method" line="200"><f a="start:control:finish">
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
	<c path="flixel.util.FlxPoint"/>
	<x path="Float"/>
</f></getCurveLength>
		<new set="method" line="31"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A series of points which will determine a path from the
 * beginning point to the end poing using quadratic curves.</haxe_doc>
	</class>
	<class path="flixel.ui._FlxAnalog.GraphicBase" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxAnalog.hx" private="1" module="flixel.ui.FlxAnalog">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/analog/base.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui._FlxAnalog.GraphicThumb" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxAnalog.hx" private="1" module="flixel.ui.FlxAnalog">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/analog/thumb.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui.FlxAnalog" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxAnalog.hx">
		<extends path="flixel.group.FlxSpriteGroup"/>
		<NORMAL get="inline" set="null" line="56" static="1">
			<x path="Int"/>
			<haxe_doc>* Used with public variable status, means not highlighted or pressed.</haxe_doc>
		</NORMAL>
		<HIGHLIGHT get="inline" set="null" line="60" static="1">
			<x path="Int"/>
			<haxe_doc>* Used with public variable status, means highlighted (usually from mouse over).</haxe_doc>
		</HIGHLIGHT>
		<PRESSED get="inline" set="null" line="64" static="1">
			<x path="Int"/>
			<haxe_doc>* Used with public variable status, means pressed (usually from mouse click).</haxe_doc>
		</PRESSED>
		<_analogs static="1">
			<c path="Array"><c path="flixel.ui.FlxAnalog"/></c>
			<haxe_doc>* A list of analogs that are currently active.</haxe_doc>
		</_analogs>
		<status public="1">
			<x path="Int"/>
			<haxe_doc>* Shows the current state of the button.</haxe_doc>
		</status>
		<thumb public="1"><c path="flixel.FlxSprite"/></thumb>
		<base public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* The background of the joystick, also known as the base.</haxe_doc>
		</base>
		<onUp public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called when the button is released.</haxe_doc>
		</onUp>
		<onDown public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called when the button is pressed down.</haxe_doc>
		</onDown>
		<onOver public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called when the mouse goes over the button.</haxe_doc>
		</onOver>
		<onPressed public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called when the button is hold down.</haxe_doc>
		</onPressed>
		<_currentTouch>
			<c path="flixel.input.touch.FlxTouch"/>
			<haxe_doc>* The current pointer that's active on the analog.</haxe_doc>
		</_currentTouch>
		<_tempTouches>
			<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
			<haxe_doc>* Helper array for checking touches</haxe_doc>
		</_tempTouches>
		<_zone>
			<c path="flixel.util.FlxRect"/>
			<haxe_doc>* The area which the joystick will react.</haxe_doc>
		</_zone>
		<_radius>
			<x path="Float"/>
			<haxe_doc>* The radius in which the stick can move.</haxe_doc>
		</_radius>
		<_direction><x path="Float"/></_direction>
		<_amount><x path="Float"/></_amount>
		<_ease>
			<x path="Float"/>
			<haxe_doc>* The speed of easing when the thumb is released.</haxe_doc>
		</_ease>
		<createBase set="method" line="138">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates the background of the analog stick.
	 * Override this to customize the background.</haxe_doc>
		</createBase>
		<createThumb set="method" line="158">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates the thumb of the analog stick.
	 * Override this to customize the thumb.</haxe_doc>
		</createThumb>
		<createZone set="method" line="177">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates the touch zone. It's based on the size of the background. 
	 * The thumb will react when the mouse is in the zone.
	 * Override this to customize the zone.</haxe_doc>
		</createZone>
		<destroy public="1" set="method" line="190" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="213" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the behavior.</haxe_doc>
		</update>
		<updateAnalog set="method" line="291"><f a="TouchPoint:Pressed:JustPressed:JustReleased:?Touch" v="::::null">
	<c path="flixel.util.FlxPoint"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="flixel.input.touch.FlxTouch"/>
	<x path="Bool"/>
</f></updateAnalog>
		<getAngle public="1" set="method" line="386">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the angle in degrees.
	 * 
	 * @return	The angle.</haxe_doc>
		</getAngle>
		<pressed public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the thumb is pressed or not.</haxe_doc>
		</pressed>
		<get_pressed get="inline" set="null" line="396"><f a=""><x path="Bool"/></f></get_pressed>
		<justPressed public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the thumb is just pressed or not.</haxe_doc>
		</justPressed>
		<get_justPressed set="method" line="406"><f a=""><x path="Bool"/></f></get_justPressed>
		<justReleased public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the thumb is just released or not.</haxe_doc>
		</justReleased>
		<get_justReleased set="method" line="427"><f a=""><x path="Bool"/></f></get_justReleased>
		<set_x set="method" line="443" override="1"><f a="X">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="451" override="1"><f a="Y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<new public="1" set="method" line="106">
			<f a="X:Y:?Radius:?Ease" v="::0:0.25f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a virtual thumbstick - useful for input on mobile devices.
	 *  
	 * @param	X		The X-coordinate of the point in space.
 	 * @param	Y		The Y-coordinate of the point in space.
 	 * @param	radius	The radius where the thumb can move. If 0, the background will be use as radius.
 	 * @param	ease	The duration of the easing. The value must be between 0 and 1.</haxe_doc>
		</new>
		<haxe_doc>* A virtual thumbstick - useful for input on mobile devices.
 * 
 * @author Ka Wing Chin</haxe_doc>
	</class>
	<class path="flixel.ui.FlxBar" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxBar.hx">
		<extends path="flixel.FlxSprite"/>
		<FILL_LEFT_TO_RIGHT public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></FILL_LEFT_TO_RIGHT>
		<FILL_RIGHT_TO_LEFT public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></FILL_RIGHT_TO_LEFT>
		<FILL_TOP_TO_BOTTOM public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></FILL_TOP_TO_BOTTOM>
		<FILL_BOTTOM_TO_TOP public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></FILL_BOTTOM_TO_TOP>
		<FILL_HORIZONTAL_INSIDE_OUT public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></FILL_HORIZONTAL_INSIDE_OUT>
		<FILL_HORIZONTAL_OUTSIDE_IN public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></FILL_HORIZONTAL_OUTSIDE_IN>
		<FILL_VERTICAL_INSIDE_OUT public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></FILL_VERTICAL_INSIDE_OUT>
		<FILL_VERTICAL_OUTSIDE_IN public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></FILL_VERTICAL_OUTSIDE_IN>
		<FRAMES_POSITION_HORIZONTAL public="1" get="inline" set="null" line="40" static="1"><c path="String"/></FRAMES_POSITION_HORIZONTAL>
		<FRAMES_POSITION_VERTICAL public="1" get="inline" set="null" line="41" static="1"><c path="String"/></FRAMES_POSITION_VERTICAL>
		<BAR_FILLED get="inline" set="null" line="43" static="1"><x path="Int"/></BAR_FILLED>
		<BAR_GRADIENT get="inline" set="null" line="44" static="1"><x path="Int"/></BAR_GRADIENT>
		<BAR_IMAGE get="inline" set="null" line="45" static="1"><x path="Int"/></BAR_IMAGE>
		<barType><x path="Int"/></barType>
		<barWidth><x path="Int"/></barWidth>
		<barHeight><x path="Int"/></barHeight>
		<parent><d/></parent>
		<parentVariable><c path="String"/></parentVariable>
		<fixedPosition public="1">
			<x path="Bool"/>
			<haxe_doc>* fixedPosition controls if the FlxBar sprite is at a fixed location on screen, or tracking its parent</haxe_doc>
		</fixedPosition>
		<positionOffset public="1" set="null">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* The positionOffset controls how far offset the FlxBar is from the parent sprite (if at all)</haxe_doc>
		</positionOffset>
		<min>
			<x path="Float"/>
			<haxe_doc><![CDATA[* The minimum value the bar can be (can never be >= max)]]></haxe_doc>
		</min>
		<max>
			<x path="Float"/>
			<haxe_doc><![CDATA[* The maximum value the bar can be (can never be <= min)]]></haxe_doc>
		</max>
		<range>
			<x path="Float"/>
			<haxe_doc>* How wide is the range of this bar? (max - min)</haxe_doc>
		</range>
		<pct>
			<x path="Float"/>
			<haxe_doc>* What 1% of the bar is equal to in terms of value (range / 100)</haxe_doc>
		</pct>
		<value>
			<x path="Float"/>
			<haxe_doc>* The current value - must always be between min and max</haxe_doc>
		</value>
		<pxPerPercent public="1">
			<x path="Float"/>
			<haxe_doc>* How many pixels = 1% of the bar (barWidth (or height) / 100)</haxe_doc>
		</pxPerPercent>
		<emptyCallback><f a=""><x path="Void"/></f></emptyCallback>
		<emptyBar><c path="flash.display.BitmapData"/></emptyBar>
		<emptyBarRect><c path="flash.geom.Rectangle"/></emptyBarRect>
		<emptyBarPoint><c path="flash.geom.Point"/></emptyBarPoint>
		<emptyKill><x path="Bool"/></emptyKill>
		<zeroOffset><c path="flash.geom.Point"/></zeroOffset>
		<filledCallback><f a=""><x path="Void"/></f></filledCallback>
		<filledBar><c path="flash.display.BitmapData"/></filledBar>
		<filledBarRect><c path="flash.geom.Rectangle"/></filledBarRect>
		<filledBarPoint><c path="flash.geom.Point"/></filledBarPoint>
		<fillDirection><x path="Int"/></fillDirection>
		<fillHorizontal><x path="Bool"/></fillHorizontal>
		<_emptyBarFrameID><x path="Int"/></_emptyBarFrameID>
		<_filledBarFrames><c path="Array"><x path="Float"/></c></_filledBarFrames>
		<_framesPosition><c path="String"/></_framesPosition>
		<_cachedFrontGraphics><c path="flixel.util.loaders.CachedGraphics"/></_cachedFrontGraphics>
		<_frontRegion><c path="flixel.system.layer.Region"/></_frontRegion>
		<destroy public="1" set="method" line="185" override="1"><f a=""><x path="Void"/></f></destroy>
		<trackParent public="1" set="method" line="221">
			<f a="offsetX:offsetY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Track the parent FlxSprites x/y coordinates. For example if you wanted your sprite to have a floating health-bar above their head.<br />
	 * If your health bar is 10px tall and you wanted it to appear above your sprite, then set offsetY to be -10<br />
	 * If you wanted it to appear below your sprite, and your sprite was 32px tall, then set offsetY to be 32. Same applies to offsetX.
	 * 
	 * @param	offsetX		The offset on X in relation to the origin x/y of the parent
	 * @param	offsetY		The offset on Y in relation to the origin x/y of the parent
	 * @see		stopTrackingParent]]></haxe_doc>
		</trackParent>
		<setParent public="1" set="method" line="243">
			<f a="parentRef:variable:?track:?offsetX:?offsetY" v="::false:0:0">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets a parent for this FlxBar. Instantly replaces any previously set parent and refreshes the bar.
	 * 
	 * @param	parentRef	A reference to an object in your game that you wish the bar to track
	 * @param	variable	The variable of the object that is used to determine the bar position. For example if the parent was an FlxSprite this could be "health" to track the health value
	 * @param	track		If you wish the FlxBar to track the x/y coordinates of parent set to true (default false)
	 * @param	offsetX		The offset on X in relation to the origin x/y of the parent
	 * @param	offsetY		The offset on Y in relation to the origin x/y of the parent</haxe_doc>
		</setParent>
		<stopTrackingParent public="1" set="method" line="263">
			<f a="posX:posY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Tells the health bar to stop following the parent sprite. The given posX and posY values are where it will remain on-screen.
	 * 
	 * @param	posX	X coordinate of the health bar now it's no longer tracking the parent sprite
	 * @param	posY	Y coordinate of the health bar now it's no longer tracking the parent sprite</haxe_doc>
		</stopTrackingParent>
		<setCallbacks public="1" set="method" line="280">
			<f a="onEmpty:onFilled:?killOnEmpty" v="::false">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets callbacks which will be triggered when the value of this FlxBar reaches min or max.
	 * Functions will only be called once and not again until the value changes.
	 * Optionally the FlxBar can be killed if it reaches min, but if will fire the empty callback first (if set)
	 * 
	 * @param	onEmpty			The function that is called if the value of this FlxBar reaches min
	 * @param	onFilled		The function that is called if the value of this FlxBar reaches max
	 * @param	killOnEmpty		If set it will call FlxBar.kill() if the value reaches min</haxe_doc>
		</setCallbacks>
		<killOnEmpty public="1" get="accessor" set="accessor"><x path="Bool"/></killOnEmpty>
		<set_killOnEmpty set="method" line="303">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* If this FlxBar should be killed when its value reaches empty, set to true</haxe_doc>
		</set_killOnEmpty>
		<get_killOnEmpty set="method" line="309"><f a=""><x path="Bool"/></f></get_killOnEmpty>
		<setRange public="1" set="method" line="320">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the minimum and maximum allowed values for the FlxBar
	 * 
	 * @param	min			The minimum value. I.e. for a progress bar this would be zero (nothing loaded yet)
	 * @param	max			The maximum value the bar can reach. I.e. for a progress bar this would typically be 100.</haxe_doc>
		</setRange>
		<stats public="1" get="accessor" set="null"><x path="Map">
	<c path="String"/>
	<d/>
</x></stats>
		<get_stats set="method" line="368"><f a=""><x path="Map">
	<c path="String"/>
	<d/>
</x></f></get_stats>
		<createFilledBar public="1" set="method" line="390">
			<f a="empty:fill:?showBorder:?border" v="::false:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a solid-colour filled health bar in the given colours, with optional 1px thick border.<br />
	 * All colour values are in 0xAARRGGBB format, so if you want a slightly transparent health bar give it lower AA values.
	 * 
	 * @param	empty		The color of the bar when empty in 0xAARRGGBB format (the background colour)
	 * @param	fill		The color of the bar when full in 0xAARRGGBB format (the foreground colour)
	 * @param	showBorder	Should the bar be outlined with a 1px solid border?
	 * @param	border		The border colour in 0xAARRGGBB format]]></haxe_doc>
		</createFilledBar>
		<createGradientBar public="1" set="method" line="494">
			<f a="empty:fill:?chunkSize:?rotation:?showBorder:?border" v="::1:180:false:-1">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a gradient filled health bar using the given colour ranges, with optional 1px thick border.<br />
	 * All colour values are in 0xAARRGGBB format, so if you want a slightly transparent health bar give it lower AA values.
	 * 
	 * @param	empty		Array of colour values used to create the gradient of the health bar when empty, each colour must be in 0xAARRGGBB format (the background colour)
	 * @param	fill		Array of colour values used to create the gradient of the health bar when full, each colour must be in 0xAARRGGBB format (the foreground colour)
	 * @param	chunkSize	If you want a more old-skool looking chunky gradient, increase this value!
	 * @param	rotation	Angle of the gradient in degrees. 90 = top to bottom, 180 = left to right. Any angle is valid
	 * @param	showBorder	Should the bar be outlined with a 1px solid border?
	 * @param	border		The border colour in 0xAARRGGBB format]]></haxe_doc>
		</createGradientBar>
		<createImageBar public="1" set="method" line="612">
			<f a="?empty:?fill:?emptyBackground:?fillBackground" v="null:null:-16777216:-16711936">
				<d/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a health bar filled using the given bitmap images.<br />
	 * You can provide "empty" (background) and "fill" (foreground) images. either one or both images (empty / fill), and use the optional empty/fill colour values 
	 * All colour values are in 0xAARRGGBB format, so if you want a slightly transparent health bar give it lower AA values.
	 * 
	 * @param	empty				Bitmap image used as the background (empty part) of the health bar, if null the emptyBackground colour is used
	 * @param	fill				Bitmap image used as the foreground (filled part) of the health bar, if null the fillBackground colour is used
	 * @param	emptyBackground		If no background (empty) image is given, use this colour value instead. 0xAARRGGBB format
	 * @param	fillBackground		If no foreground (fill) image is given, use this colour value instead. 0xAARRGGBB format]]></haxe_doc>
		</createImageBar>
		<setFillDirection public="1" set="method" line="805">
			<f a="direction">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the direction from which the health bar will fill-up. Default is from left to right. Change takes effect immediately.
	 * 
	 * @param	direction 			One of the FlxBar.FILL_ constants (such as FILL_LEFT_TO_RIGHT, FILL_TOP_TO_BOTTOM etc)</haxe_doc>
		</setFillDirection>
		<updateValueFromParent set="method" line="823"><f a=""><x path="Void"/></f></updateValueFromParent>
		<updateValue set="method" line="828"><f a="newValue">
	<x path="Float"/>
	<x path="Void"/>
</f></updateValue>
		<updateBar set="method" line="862">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal
	 * Called when the health bar detects a change in the health of the parent.</haxe_doc>
		</updateBar>
		<update public="1" set="method" line="920" override="1"><f a=""><x path="Void"/></f></update>
		<percent public="1" get="accessor" set="accessor"><x path="Float"/></percent>
		<get_percent set="method" line="945">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The percentage of how full the bar is (a value between 0 and 100)</haxe_doc>
		</get_percent>
		<set_percent set="method" line="965">
			<f a="newPct">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Sets the percentage of how full the bar is (a value between 0 and 100). This changes FlxBar.currentValue</haxe_doc>
		</set_percent>
		<currentValue public="1" get="accessor" set="accessor"><x path="Float"/></currentValue>
		<set_currentValue set="method" line="980">
			<f a="newValue">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Set the current value of the bar (must be between min and max range)</haxe_doc>
		</set_currentValue>
		<get_currentValue set="method" line="990">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The current actual value of the bar</haxe_doc>
		</get_currentValue>
		<draw public="1" set="method" line="996" override="1"><f a=""><x path="Void"/></f></draw>
		<set_pixels set="method" line="1124" override="1"><f a="Pixels">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
</f></set_pixels>
		<isSimpleRender public="1" set="method" line="1129" override="1"><f a=""><x path="Bool"/></f></isSimpleRender>
		<updateFrameData public="1" set="method" line="1135" override="1"><f a=""><x path="Void"/></f></updateFrameData>
		<setCachedGraphics get="inline" set="null" line="1229"><f a="value">
	<c path="flixel.util.loaders.CachedGraphics"/>
	<x path="Void"/>
</f></setCachedGraphics>
		<setCachedFrontGraphics set="method" line="1233"><f a="value">
	<c path="flixel.util.loaders.CachedGraphics"/>
	<x path="Void"/>
</f></setCachedFrontGraphics>
		<toString public="1" set="method" line="1248" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="137">
			<f a="?x:?y:?direction:?width:?height:?parentRef:?variable:?min:?max:?border" v="0:0:1:100:10:null:'':0:100:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new FlxBar Object
	 * 
	 * @param	x			The x coordinate location of the resulting bar (in world pixels)
	 * @param	y			The y coordinate location of the resulting bar (in world pixels)
	 * @param	direction 	One of the FlxBar.FILL_ constants (such as FILL_LEFT_TO_RIGHT, FILL_TOP_TO_BOTTOM etc)
	 * @param	width		The width of the bar in pixels
	 * @param	height		The height of the bar in pixels
	 * @param	parentRef	A reference to an object in your game that you wish the bar to track
	 * @param	variable	The variable of the object that is used to determine the bar position. For example if the parent was an FlxSprite this could be "health" to track the health value
	 * @param	min			The minimum value. I.e. for a progress bar this would be zero (nothing loaded yet)
	 * @param	max			The maximum value the bar can reach. I.e. for a progress bar this would typically be 100.
	 * @param	border		Include a 1px border around the bar? (if true it adds +2 to width and height to accommodate it)</haxe_doc>
		</new>
		<haxe_doc>* FlxBar is a quick and easy way to create a graphical bar which can
 * be used as part of your UI/HUD, or positioned next to a sprite. It could represent
 * a loader, progress or health bar.
 * 
 * @version 1.6 - October 10th 2011
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
	</class>
	<class path="flixel.ui.FlxButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxButton.hx">
		<extends path="flixel.ui.FlxTypedButton"><c path="flixel.text.FlxText"/></extends>
		<NORMAL public="1" get="inline" set="null" line="14" static="1">
			<x path="Int"/>
			<haxe_doc>* Used with public variable status, means not highlighted or pressed.</haxe_doc>
		</NORMAL>
		<HIGHLIGHT public="1" get="inline" set="null" line="18" static="1">
			<x path="Int"/>
			<haxe_doc>* Used with public variable status, means highlighted (usually from mouse over).</haxe_doc>
		</HIGHLIGHT>
		<PRESSED public="1" get="inline" set="null" line="22" static="1">
			<x path="Int"/>
			<haxe_doc>* Used with public variable status, means pressed (usually from mouse click).</haxe_doc>
		</PRESSED>
		<text public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Shortcut to setting label.text</haxe_doc>
		</text>
		<resetHelpers set="method" line="53" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the size of the text field to match the button.</haxe_doc>
		</resetHelpers>
		<initLabel get="inline" set="null" line="64"><f a="Text">
	<c path="String"/>
	<x path="Void"/>
</f></initLabel>
		<get_text get="inline" set="null" line="71"><f a=""><c path="String"/></f></get_text>
		<set_text get="inline" set="null" line="76"><f a="Text">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<new public="1" set="method" line="38">
			<f a="?X:?Y:?Text:?OnClick" v="0:0:null:null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxButton object with a gray background
	 * and a callback function on the UI thread.
	 * 
	 * @param	X				The X position of the button.
	 * @param	Y				The Y position of the button.
	 * @param	Text			The text that you want to appear on the button.
	 * @param	OnClick			The function to call whenever the button is clicked.</haxe_doc>
		</new>
		<haxe_doc>* A simple button class that calls a function when clicked by the mouse.</haxe_doc>
	</class>
	<class path="flixel.ui._FlxTypedButton.GraphicButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxTypedButton.hx" private="1" module="flixel.ui.FlxTypedButton">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/button.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui._FlxTypedButton.FlxButtonEvent" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxTypedButton.hx" private="1" module="flixel.ui.FlxTypedButton">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<callback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The callback function to call when this even fires.</haxe_doc>
		</callback>
		<sound public="1">
			<c path="flixel.system.FlxSound"/>
			<haxe_doc>* The sound to play when this event fires.</haxe_doc>
		</sound>
		<destroy public="1" get="inline" set="null" line="413">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cleans up memory.</haxe_doc>
		</destroy>
		<fire public="1" get="inline" set="null" line="425">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fires this event (calls the callback and plays the sound)</haxe_doc>
		</fire>
		<new public="1" set="method" line="401">
			<f a="?Callback:?sound" v="null:null">
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	Callback		The callback function to call when this even fires.
	 * @param	sound			The sound to play when this event fires.</haxe_doc>
		</new>
		<haxe_doc>* Helper function for FlxButton which handles its events.</haxe_doc>
	</class>
	<class path="flixel.ui._FlxVirtualPad.GraphicA" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" private="1" module="flixel.ui.FlxVirtualPad">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/virtualpad/a.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui._FlxVirtualPad.GraphicB" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" private="1" module="flixel.ui.FlxVirtualPad">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/virtualpad/b.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui._FlxVirtualPad.GraphicC" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" private="1" module="flixel.ui.FlxVirtualPad">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/virtualpad/c.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui._FlxVirtualPad.GraphicDown" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" private="1" module="flixel.ui.FlxVirtualPad">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/virtualpad/down.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui._FlxVirtualPad.GraphicLeft" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" private="1" module="flixel.ui.FlxVirtualPad">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/virtualpad/left.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui._FlxVirtualPad.GraphicRight" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" private="1" module="flixel.ui.FlxVirtualPad">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/virtualpad/right.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui._FlxVirtualPad.GraphicUp" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" private="1" module="flixel.ui.FlxVirtualPad">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/virtualpad/up.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui._FlxVirtualPad.GraphicX" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" private="1" module="flixel.ui.FlxVirtualPad">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/virtualpad/x.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui._FlxVirtualPad.GraphicY" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" private="1" module="flixel.ui.FlxVirtualPad">
		<extends path="flash.display.BitmapData"/>
		<resourceName line="14" static="1"><c path="String"/></resourceName>
		<new public="1" set="method" line="14"><f a="width:height:?transparent:?fillRGBA" v="::true:-1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":bitmap"><e>"assets/images/ui/virtualpad/y.png"</e></m>
		</meta>
	</class>
	<class path="flixel.ui.FlxVirtualPad" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx">
		<extends path="flixel.group.FlxSpriteGroup"/>
		<buttonA public="1"><c path="flixel.ui.FlxButton"/></buttonA>
		<buttonB public="1"><c path="flixel.ui.FlxButton"/></buttonB>
		<buttonC public="1"><c path="flixel.ui.FlxButton"/></buttonC>
		<buttonY public="1"><c path="flixel.ui.FlxButton"/></buttonY>
		<buttonX public="1"><c path="flixel.ui.FlxButton"/></buttonX>
		<buttonLeft public="1"><c path="flixel.ui.FlxButton"/></buttonLeft>
		<buttonUp public="1"><c path="flixel.ui.FlxButton"/></buttonUp>
		<buttonRight public="1"><c path="flixel.ui.FlxButton"/></buttonRight>
		<buttonDown public="1"><c path="flixel.ui.FlxButton"/></buttonDown>
		<dPad public="1">
			<c path="flixel.group.FlxSpriteGroup"/>
			<haxe_doc>* Group of directions buttons.</haxe_doc>
		</dPad>
		<actions public="1">
			<c path="flixel.group.FlxSpriteGroup"/>
			<haxe_doc>* Group of action buttons.</haxe_doc>
		</actions>
		<destroy public="1" set="method" line="126" override="1"><f a=""><x path="Void"/></f></destroy>
		<createButton public="1" set="method" line="155">
			<f a="X:Y:Width:Height:Image:?OnClick" v=":::::null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.ui.FlxButton"/>
			</f>
			<haxe_doc>* @param 	X			The x-position of the button.
	 * @param 	Y			The y-position of the button.
	 * @param 	Width		The width of the button.
	 * @param 	Height		The height of the button.
	 * @param 	Image		The image of the button. It must contains 3 frames (NORMAL, HIGHLIGHT, PRESSED).
	 * @param 	Callback	The callback for the button.
	 * @return	The button</haxe_doc>
		</createButton>
		<new public="1" set="method" line="68">
			<f a="?DPad:?Action" v="null:null">
				<e path="flixel.ui.DPadMode"/>
				<e path="flixel.ui.ActionMode"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a gamepad which contains 4 directional buttons and 4 action buttons.
	 * 
	 * @param 	DPadMode	The D-Pad mode. FULL for example.
	 * @param 	ActionMode	The action buttons mode. A_B_C for example.</haxe_doc>
		</new>
		<haxe_doc>* A gamepad which contains 4 directional buttons and 4 action buttons.
 * It's easy to set the callbacks and to customize the layout.
 * 
 * @author Ka Wing Chin</haxe_doc>
	</class>
	<enum path="flixel.ui.DPadMode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" module="flixel.ui.FlxVirtualPad">
		<NONE/>
		<UP_DOWN/>
		<LEFT_RIGHT/>
		<UP_LEFT_RIGHT/>
		<FULL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flixel.ui.ActionMode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/FlxVirtualPad.hx" module="flixel.ui.FlxVirtualPad">
		<NONE/>
		<A/>
		<A_B/>
		<A_B_C/>
		<A_B_X_Y/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flixel.ui.PxButton" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/ui/PxButton.hx">
		<extends path="flixel.ui.FlxTypedButton"><c path="flixel.text.FlxBitmapTextField"/></extends>
		<resetHelpers set="method" line="48" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the size of the text field to match the button.</haxe_doc>
		</resetHelpers>
		<update public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></update>
		<new public="1" set="method" line="15"><f a="?X:?Y:?Label:?OnClick" v="0:0:null:null">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A button with a bitmap text field for the label</haxe_doc>
	</class>
	<class path="flixel.util.FlxAngle" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxAngle.hx">
		<cosTable public="1" line="18" static="1">
			<c path="Array"><x path="Float"/></c>
			<haxe_doc>* Use this to access the cos-table generated via sinCosGenerator().</haxe_doc>
		</cosTable>
		<sinTable public="1" line="22" static="1">
			<c path="Array"><x path="Float"/></c>
			<haxe_doc>* Use this to access the sin-table generated via sinCosGenerator().</haxe_doc>
		</sinTable>
		<TO_DEG public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Convert radians to degrees by multiplying it with this value.</haxe_doc>
		</TO_DEG>
		<TO_RAD public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Convert degrees to radians by multiplying it with this value.</haxe_doc>
		</TO_RAD>
		<rotatePoint public="1" get="inline" set="null" line="42" static="1">
			<f a="X:Y:PivotX:PivotY:Angle:?point" v=":::::null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Rotates a point in 2D space around another point by the given angle.
	 * @param	X		The X coordinate of the point you want to rotate.
	 * @param	Y		The Y coordinate of the point you want to rotate.
	 * @param	PivotX	The X coordinate of the point you want to rotate around.
	 * @param	PivotY	The Y coordinate of the point you want to rotate around.
	 * @param	Angle	Rotate the point by this many degrees.
	 * @param	Point	Optional FlxPoint to store the results in.
	 * @return	A FlxPoint containing the coordinates of the rotated point.</haxe_doc>
		</rotatePoint>
		<getAngle public="1" get="inline" set="null" line="131" static="1">
			<f a="Point1:Point2">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculates the angle between two points.  0 degrees points straight up.
	 * 
	 * @param	Point1		The X coordinate of the point.
	 * @param	Point2		The Y coordinate of the point.
	 * @return	The angle in degrees, between -180 and 180.</haxe_doc>
		</getAngle>
		<sinCosGenerator public="1" set="method" line="183" static="1">
			<f a="length:?sinAmplitude:?cosAmplitude:?frequency" v=":1.0f:1.0f:1.0f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Generate a sine and cosine table simultaneously and extremely quickly. Based on research by Franky of scene.at
	 * 
	 * The parameters allow you to specify the length, amplitude and frequency of the wave. Once you have called this function
	 * you should get the results via sinTable and cosTable. This generator is fast enough to be used in real-time.
	 * 
	 * @param length 		The length of the wave
	 * @param sinAmplitude 	The amplitude to apply to the sine table (default 1.0) if you need values between say -+ 125 then give 125 as the value
	 * @param cosAmplitude 	The amplitude to apply to the cosine table (default 1.0) if you need values between say -+ 125 then give 125 as the value
	 * @param frequency 	The frequency of the sine and cosine table data
	 * @return	Returns the sine table
	 * @see getSinTable
	 * @see getCosTable</haxe_doc>
		</sinCosGenerator>
		<wrapAngle public="1" set="method" line="210" static="1">
			<f a="angle">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Keeps an angle value between -180 and +180
	 * Should be called whenever the angle is updated on a FlxSprite to stop it from going insane.
	 * 
	 * @param	angle	The angle value to check
	 * 
	 * @return	The new angle value, returns the same as the input angle if it was within bounds</haxe_doc>
		</wrapAngle>
		<angleLimit public="1" set="method" line="235" static="1">
			<f a="angle:min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Keeps an angle value between the given min and max values
	 * 
	 * @param	angle	The angle value to check. Must be between -180 and +180
	 * @param	min		The minimum angle that is allowed (must be -180 or greater)
	 * @param	max		The maximum angle that is allowed (must be 180 or less)
	 * 
	 * @return	The new angle value, returns the same as the input angle if it was within bounds</haxe_doc>
		</angleLimit>
		<asDegrees public="1" get="inline" set="null" line="258" static="1">
			<f a="radians">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Converts a Radian value into a Degree
	 * Converts the radians value into degrees and returns
	 * 
	 * @param 	radians 	The value in radians
	 * @return	Degrees</haxe_doc>
		</asDegrees>
		<asRadians public="1" get="inline" set="null" line="270" static="1">
			<f a="degrees">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Converts a Degrees value into a Radian
	 * Converts the degrees value into radians and returns
	 * 
	 * @param 	degrees The value in degrees
	 * @return	Radians</haxe_doc>
		</asRadians>
		<angleBetween public="1" get="inline" set="null" line="284" static="1">
			<f a="SpriteA:SpriteB:?AsDegrees" v="::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the angle (in radians) between the two FlxSprite, taking their x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	SpriteA		The FlxSprite to test from
	 * @param	SpriteB		The FlxSprite to test to
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless asDegrees is true)</haxe_doc>
		</angleBetween>
		<angleBetweenPoint public="1" set="method" line="304" static="1">
			<f a="Sprite:Target:?AsDegrees" v="::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the angle (in radians) between an FlxSprite and an FlxPoint. The source sprite takes its x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	Sprite		The FlxSprite to test from
	 * @param	Target		The FlxPoint to angle the FlxSprite towards
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless AsDegrees is true)</haxe_doc>
		</angleBetweenPoint>
		<angleBetweenMouse public="1" set="method" line="324" static="1">
			<f a="Object:?AsDegrees" v=":false">
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the angle (in radians) between an FlxSprite and the mouse, taking their x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	Object		The FlxObject to test from
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless AsDegrees is true)</haxe_doc>
		</angleBetweenMouse>
		<angleBetweenTouch public="1" get="inline" set="null" line="352" static="1">
			<f a="Object:Touch:?AsDegrees" v="::false">
				<c path="flixel.FlxObject"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the angle (in radians) between an FlxSprite and a FlxTouch, taking their x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	Object		The FlxObject to test from
	 * @param	Touch		The FlxTouch to test to
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless AsDegrees is true)</haxe_doc>
		</angleBetweenTouch>
		<getCartesianCoords public="1" set="method" line="375" static="1">
			<f a="Radius:Angle:?point" v="::null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Convert polar coordinates (radius + angle) to cartesian coordinates (x + y)
	 * 
	 * @param	Radius	The radius
	 * @param	Angle	The angle, in degrees
	 * @param	point	Optional FlxPoint if you don't want a new one created
	 * @return	The point in cartesian coords</haxe_doc>
		</getCartesianCoords>
		<getPolarCoords public="1" set="method" line="396" static="1">
			<f a="X:Y:?point" v="::null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Convert cartesian coordinates (x + y) to polar coordinates (radius + angle) 
	 * 
	 * @param	X		x position
	 * @param	Y		y position
	 * @param	point	Optional FlxPoint if you don't want a new one created
	 * @return	The point in polar coords (x = Radius (degrees), y = Angle)</haxe_doc>
		</getPolarCoords>
		<get_TO_DEG get="inline" set="null" line="409" static="1"><f a=""><x path="Float"/></f></get_TO_DEG>
		<get_TO_RAD get="inline" set="null" line="414" static="1"><f a=""><x path="Float"/></f></get_TO_RAD>
		<haxe_doc>* A set of functions related to angle calculations.</haxe_doc>
	</class>
	<class path="flixel.util.FlxArrayUtil" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxArrayUtil.hx">
		<fastSplice_flixel_text_FlxTextFormat public="1" get="inline" set="null" line="102" static="1">
			<f a="array:element">
				<c path="Array"><c path="flixel.text.FlxTextFormat"/></c>
				<c path="flixel.text.FlxTextFormat"/>
				<c path="Array"><c path="flixel.text.FlxTextFormat"/></c>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</fastSplice_flixel_text_FlxTextFormat>
		<clearArray_flixel_group_FlxTypedGroup_T public="1" set="method" line="146" static="1">
			<f a="array:?recursive" v=":false">
				<c path="Array"><c path="flixel.group.FlxTypedGroup.T"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</clearArray_flixel_group_FlxTypedGroup_T>
		<getRandom_flixel_group_FlxTypedGroup_T public="1" get="inline" set="null" line="87" static="1">
			<f a="Objects:?StartIndex:?EndIndex" v=":0:0">
				<c path="Array"><c path="flixel.group.FlxTypedGroup.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</getRandom_flixel_group_FlxTypedGroup_T>
		<indexOf_flixel_system_layer_frames_FlxFrame public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="flixel.system.layer.frames.FlxFrame"/></c>
				<c path="flixel.system.layer.frames.FlxFrame"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_flixel_system_layer_frames_FlxFrame>
		<clearArray_flixel_input_FlxSwipe public="1" set="method" line="146" static="1">
			<f a="array:?recursive" v=":false">
				<c path="Array"><c path="flixel.input.FlxSwipe"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</clearArray_flixel_input_FlxSwipe>
		<setLength_flixel_input_keyboard_FlxKey public="1" set="method" line="44" static="1">
			<f a="array:newLength">
				<c path="Array"><c path="flixel.input.keyboard.FlxKey"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</setLength_flixel_input_keyboard_FlxKey>
		<setLength_flixel_system_replay_FrameRecord public="1" set="method" line="44" static="1">
			<f a="array:newLength">
				<c path="Array"><c path="flixel.system.replay.FrameRecord"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</setLength_flixel_system_replay_FrameRecord>
		<clearArray_flixel_util_FlxPath public="1" set="method" line="146" static="1">
			<f a="array:?recursive" v=":false">
				<c path="Array"><c path="flixel.util.FlxPath"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</clearArray_flixel_util_FlxPath>
		<indexOf_flixel_util_FlxPoint public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_flixel_util_FlxPoint>
		<fastSplice_flixel_util_FlxPath public="1" get="inline" set="null" line="102" static="1">
			<f a="array:element">
				<c path="Array"><c path="flixel.util.FlxPath"/></c>
				<c path="flixel.util.FlxPath"/>
				<c path="Array"><c path="flixel.util.FlxPath"/></c>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</fastSplice_flixel_util_FlxPath>
		<indexOf_flixel_util_FlxPath public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="flixel.util.FlxPath"/></c>
				<c path="flixel.util.FlxPath"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_flixel_util_FlxPath>
		<clearArray_flixel_util_FlxTimer public="1" set="method" line="146" static="1">
			<f a="array:?recursive" v=":false">
				<c path="Array"><c path="flixel.util.FlxTimer"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</clearArray_flixel_util_FlxTimer>
		<fastSplice_flixel_tweens_FlxTween public="1" get="inline" set="null" line="102" static="1">
			<f a="array:element">
				<c path="Array"><c path="flixel.tweens.FlxTween"/></c>
				<c path="flixel.tweens.FlxTween"/>
				<c path="Array"><c path="flixel.tweens.FlxTween"/></c>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</fastSplice_flixel_tweens_FlxTween>
		<clearArray_clearArray_T public="1" set="method" static="1">
			<f a="array:?recursive">
				<c path="Array"><c path="clearArray.T"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</clearArray_clearArray_T>
		<fastSplice_flixel_util_FlxTimer public="1" get="inline" set="null" line="102" static="1">
			<f a="array:element">
				<c path="Array"><c path="flixel.util.FlxTimer"/></c>
				<c path="flixel.util.FlxTimer"/>
				<c path="Array"><c path="flixel.util.FlxTimer"/></c>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</fastSplice_flixel_util_FlxTimer>
		<indexOf_flixel_addons_display_FlxNestedSprite public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="flixel.addons.display.FlxNestedSprite"/></c>
				<c path="flixel.addons.display.FlxNestedSprite"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_flixel_addons_display_FlxNestedSprite>
		<indexOf_flixel_system_ui_FlxSystemButton public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="flixel.system.ui.FlxSystemButton"/></c>
				<c path="flixel.system.ui.FlxSystemButton"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_flixel_system_ui_FlxSystemButton>
		<setLength_Int public="1" set="method" line="44" static="1">
			<f a="array:newLength">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</setLength_Int>
		<indexOf_Int public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_Int>
		<setLength_flixel_group_FlxTypedGroup_T public="1" set="method" line="44" static="1">
			<f a="array:newLength">
				<c path="Array"><c path="flixel.group.FlxTypedGroup.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</setLength_flixel_group_FlxTypedGroup_T>
		<indexOf_Float public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_Float>
		<fastSplice_flixel_system_debug_Window public="1" get="inline" set="null" line="102" static="1">
			<f a="array:element">
				<c path="Array"><c path="flixel.system.debug.Window"/></c>
				<c path="flixel.system.debug.Window"/>
				<c path="Array"><c path="flixel.system.debug.Window"/></c>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</fastSplice_flixel_system_debug_Window>
		<indexOf_flixel_system_debug_WatchEntry public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="flixel.system.debug.WatchEntry"/></c>
				<c path="flixel.system.debug.WatchEntry"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_flixel_system_debug_WatchEntry>
		<fastSplice_flixel_system_debug_WatchEntry public="1" get="inline" set="null" line="102" static="1">
			<f a="array:element">
				<c path="Array"><c path="flixel.system.debug.WatchEntry"/></c>
				<c path="flixel.system.debug.WatchEntry"/>
				<c path="Array"><c path="flixel.system.debug.WatchEntry"/></c>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</fastSplice_flixel_system_debug_WatchEntry>
		<swapAndPop_fastSplice_T public="1" get="inline" set="null" line="130" static="1">
			<f a="array:index">
				<c path="Array"><c path="fastSplice.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="fastSplice.T"/></c>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</swapAndPop_fastSplice_T>
		<indexOf_fastSplice_T public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="fastSplice.T"/></c>
				<c path="fastSplice.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_fastSplice_T>
		<indexOf_String public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_String>
		<indexOf_flixel_group_FlxTypedGroup_T public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="flixel.group.FlxTypedGroup.T"/></c>
				<c path="flixel.group.FlxTypedGroup.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_flixel_group_FlxTypedGroup_T>
		<indexOf_flixel_util_FlxPool_T public="1" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="flixel.util.FlxPool.T"/></c>
				<c path="flixel.util.FlxPool.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</indexOf_flixel_util_FlxPool_T>
		<indexOf public="1" params="T" set="method" line="18" static="1">
			<f a="array:whatToFind:?fromIndex" v="::0">
				<c path="Array"><c path="indexOf.T"/></c>
				<c path="indexOf.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Function to search for a specified element in an array. This is faster than Lambda.indexOf()
	 * on the flash target because it uses the the native array indexOf() method.
	 * 
	 * @param	array		The array.
	 * @param	whatToFind	The element you're looking for.
	 * @param 	fromIndex	The index to start the search from (optional, for optimization).
	 * @return	The index of the element within the array. -1 if it wasn't found.</haxe_doc>
		</indexOf>
		<setLength public="1" params="T" set="method" line="44" static="1">
			<f a="array:newLength">
				<c path="Array"><c path="setLength.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Sets the length of an array.
	 * 
	 * @param	array		The array.
	 * @param	newLength	The length you want the array to have.</haxe_doc>
		</setLength>
		<shuffle public="1" params="T" get="inline" set="null" line="72" static="1">
			<f a="Objects:HowManyTimes">
				<c path="Array"><c path="shuffle.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="shuffle.T"/></c>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Deprecated; please use FlxRandom.shuffleArray() instead.
	 * Shuffles the entries in an array into a new random order.
	 * 
	 * @param	Objects			An array to shuffle.
	 * @param	HowManyTimes	How many swaps to perform during the shuffle operation.  A good rule of thumb is 2-4 times the number of objects in the list.
	 * @return	The newly shuffled array.</haxe_doc>
		</shuffle>
		<getRandom public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="Objects:?StartIndex:?EndIndex" v=":0:0">
				<c path="Array"><c path="getRandom.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="getRandom.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Deprecated; please use FlxRandom.getObject() instead.
	 * Fetch a random entry from the given array from StartIndex to EndIndex.
	 * 
	 * @param	Objects			An array from which to select a random entry.
	 * @param	StartIndex		Optional index from which to restrict selection. Default value is 0, or the beginning of the array.
	 * @param	EndIndex		Optional index at which to restrict selection. Ignored if 0, which is the default value.
	 * @return	The random object that was selected.</haxe_doc>
		</getRandom>
		<fastSplice public="1" params="T" get="inline" set="null" line="102" static="1">
			<f a="array:element">
				<c path="Array"><c path="fastSplice.T"/></c>
				<c path="fastSplice.T"/>
				<c path="Array"><c path="fastSplice.T"/></c>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Safely removes an element from an array by swapping it with the last element and calling pop()
	 * (won't do anything if the element is not in the array). This is a lot faster than regular splice(), 
	 * but it can only be used on arrays where order doesn't matter.
	 * 
	 * @param	array	The array to remove the element from
	 * @param 	element	The element to remove from the array
	 * @return	The array</haxe_doc>
		</fastSplice>
		<swapAndPop public="1" params="T" get="inline" set="null" line="130" static="1">
			<f a="array:index">
				<c path="Array"><c path="swapAndPop.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="swapAndPop.T"/></c>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc><![CDATA[* Removes an element from an array by swapping it with the last element and calling pop().
	 * This is a lot faster than regular splice(), but it can only be used on arrays where order doesn't matter.
	 * 
	 * IMPORTANT: always count down from length to zero if removing elements from whithin a loop
	 * 
	 * var i = array.length;
	 * while (i-- > 0)
	 * {
	 *      if (array[i].shouldRemove)
	 *      {
	 *           FlxArrayUtil.swapAndPop(array, i);
	 *      }
	 * }
	 * 
	 * @param	array	The array to remove the element from
	 * @param 	index	The index of the element to be removed from the array
	 * @return	The array]]></haxe_doc>
		</swapAndPop>
		<clearArray public="1" params="T" set="method" line="146" static="1">
			<f a="array:?recursive" v=":false">
				<c path="Array"><c path="clearArray.T"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Clears an array structure, but leaves the object data untouched
	 * Useful for cleaning up temporary references to data you want to preserve
	 * WARNING: Can lead to memory leaks. Use destroyArray() instead for data you truly want GONE.
	 *
	 * @param	array		The array to clear out
	 * @param	Recursive	Whether to search for arrays inside of arr and clear them out, too (false by default)</haxe_doc>
		</clearArray>
		<haxe_doc>* A set of functions for array manipulation.</haxe_doc>
	</class>
	<class path="flixel.util.FlxBitmapDataPool" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxBitmapDataPool.hx">
		<maxLength public="1" set="accessor" line="21" static="1">
			<x path="Int"/>
			<haxe_doc>* Maximum number of BitmapData to hold in the pool.</haxe_doc>
		</maxLength>
		<length public="1" set="null" line="26" static="1">
			<x path="Int"/>
			<haxe_doc>* Current number of BitmapData present in the pool.</haxe_doc>
		</length>
		<_head line="28" static="1"><c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/></_head>
		<_tail line="29" static="1"><c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/></_tail>
		<_rect line="31" static="1"><c path="flash.geom.Rectangle"/></_rect>
		<get public="1" set="method" line="40" static="1">
			<f a="w:h:?transparent:?fillColor:?exactSize" v="::true:null:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc><![CDATA[* Returns a BitmapData with the specified parameters. 
	 * If a suitable BitmapData cannot be found in the pool a new one will be created.
	 * If fillColor is specified the returned BitmapData will also be cleared with it.
	 * 
	 * @param ?exactSize	If false a BitmapData with size >= [w, h] may be returned.]]></haxe_doc>
		</get>
		<put public="1" set="method" line="88" static="1">
			<f a="bmd">
				<c path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds bmd to the pool for future use.</haxe_doc>
		</put>
		<clear public="1" set="method" line="120" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Disposes of all the BitmapData in the pool.</haxe_doc>
		</clear>
		<set_maxLength set="method" line="134" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxLength>
		<haxe_doc>* BitmapData pool class.
 * 
 * Notes on implementation:
 *     get() starts searching for a suitable BitmapData from the start of the pool list
 *     put() adds the BitmapData to the start of the pool list (removing the last one if the pool exceeds maxLength)
 * 
 * @author azrafe7</haxe_doc>
		<meta><m n=":access"><e>FlxBitmapDataPoolNode</e></m></meta>
	</class>
	<class path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxBitmapDataPool.hx" private="1" module="flixel.util.FlxBitmapDataPool">
		<bmd public="1"><c path="flash.display.BitmapData"/></bmd>
		<prev public="1"><c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/></prev>
		<next public="1"><c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/></next>
		<new public="1" set="method" line="158"><f a="?bmd:?prev:?next" v="null:null:null">
	<c path="flash.display.BitmapData"/>
	<c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/>
	<c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.util.FlxBitmapUtil" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxBitmapUtil.hx">
		<merge public="1" set="method" line="9" static="1"><f a="sourceBitmapData:sourceRect:destBitmapData:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></merge>
		<mergeColorComponent get="inline" set="null" line="146" static="1"><f a="source:dest:multiplier">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></mergeColorComponent>
		<compare public="1" set="method" line="151" static="1"><f a="Bitmap1:Bitmap2">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
	</class>
	<class path="flixel.util.FlxCollision" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxCollision.hx">
		<CAMERA_WALL_OUTSIDE public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></CAMERA_WALL_OUTSIDE>
		<CAMERA_WALL_INSIDE public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></CAMERA_WALL_INSIDE>
		<pointA line="25" static="1"><c path="flash.geom.Point"/></pointA>
		<pointB line="26" static="1"><c path="flash.geom.Point"/></pointB>
		<centerA line="27" static="1"><c path="flash.geom.Point"/></centerA>
		<centerB line="28" static="1"><c path="flash.geom.Point"/></centerB>
		<matrixA line="29" static="1"><c path="flash.geom.Matrix"/></matrixA>
		<matrixB line="30" static="1"><c path="flash.geom.Matrix"/></matrixB>
		<testMatrix line="31" static="1"><c path="flash.geom.Matrix"/></testMatrix>
		<boundsA line="32" static="1"><c path="flash.geom.Rectangle"/></boundsA>
		<boundsB line="33" static="1"><c path="flash.geom.Rectangle"/></boundsB>
		<pixelPerfectCheck public="1" set="method" line="45" static="1">
			<f a="Contact:Target:?AlphaTolerance:?Camera" v="::1:null">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* A Pixel Perfect Collision check between two FlxSprites. It will do a bounds check first, and if that passes it will run a 
	 * pixel perfect match on the intersecting area. Works with rotated and animated sprites. May be slow, so use it sparingly.
	 * 
	 * @param	Contact			The first FlxSprite to test against
	 * @param	Target			The second FlxSprite to test again, sprite order is irrelevant
	 * @param	AlphaTolerance	The tolerance value above which alpha pixels are included. Default to 1 (anything that is not fully invisible).
	 * @param	Camera			If the collision is taking place in a camera other than FlxG.camera (the default/current) then pass it here
	 * @return	Whether the sprites collide</haxe_doc>
		</pixelPerfectCheck>
		<pixelPerfectPointCheck public="1" set="method" line="216" static="1">
			<f a="PointX:PointY:Target:?AlphaTolerance" v=":::1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* A Pixel Perfect Collision check between a given x/y coordinate and an FlxSprite
	 * 
	 * @param	PointX			The x coordinate of the point given in local space (relative to the FlxSprite, not game world coordinates)
	 * @param	PointY			The y coordinate of the point given in local space (relative to the FlxSprite, not game world coordinates)
	 * @param	Target			The FlxSprite to check the point against
	 * @param	AlphaTolerance	The alpha tolerance level above which pixels are counted as colliding. Default to 1 (anything that is not fully invisible).
	 * @return	Boolean True if the x/y point collides with the FlxSprite, false if not</haxe_doc>
		</pixelPerfectPointCheck>
		<createCameraWall public="1" set="method" line="258" static="1">
			<f a="Camera:Placement:Thickness:?AdjustWorldBounds" v=":::false">
				<c path="flixel.FlxCamera"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.group.FlxGroup"/>
			</f>
			<haxe_doc>* Creates a "wall" around the given camera which can be used for FlxSprite collision
	 * 
	 * @param	Camera				The FlxCamera to use for the wall bounds (can be FlxG.camera for the current one)
	 * @param	Placement			CAMERA_WALL_OUTSIDE or CAMERA_WALL_INSIDE
	 * @param	Thickness			The thickness of the wall in pixels
	 * @param	AdjustWorldBounds	Adjust the FlxG.worldBounds based on the wall (true) or leave alone (false)
	 * @return	FlxGroup The 4 FlxTileblocks that are created are placed into this FlxGroup which should be added to your State</haxe_doc>
		</createCameraWall>
		<haxe_doc>* FlxCollision
 *
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
	</class>
	<class path="flixel.util.FlxColor" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxColor.hx">
		<RED public="1" get="inline" set="null" line="11" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xffff0012</haxe_doc>
		</RED>
		<YELLOW public="1" get="inline" set="null" line="16" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xffffff00</haxe_doc>
		</YELLOW>
		<GREEN public="1" get="inline" set="null" line="21" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff00f225</haxe_doc>
		</GREEN>
		<BLUE public="1" get="inline" set="null" line="26" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff0090e9</haxe_doc>
		</BLUE>
		<PINK public="1" get="inline" set="null" line="31" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xfff01eff</haxe_doc>
		</PINK>
		<PURPLE public="1" get="inline" set="null" line="36" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff800080</haxe_doc>
		</PURPLE>
		<WHITE public="1" get="inline" set="null" line="41" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xffffffff</haxe_doc>
		</WHITE>
		<BLACK public="1" get="inline" set="null" line="46" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff000000</haxe_doc>
		</BLACK>
		<GRAY public="1" get="inline" set="null" line="51" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff808080</haxe_doc>
		</GRAY>
		<BROWN public="1" get="inline" set="null" line="56" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff964B00</haxe_doc>
		</BROWN>
		<TRANSPARENT public="1" get="inline" set="null" line="61" static="1">
			<x path="Int"/>
			<haxe_doc>* 0x00000000</haxe_doc>
		</TRANSPARENT>
		<IVORY public="1" get="inline" set="null" line="66" static="1">
			<x path="Int"/>
			<haxe_doc>* Ivory is an off-white color that resembles ivory. 0xfffffff0</haxe_doc>
		</IVORY>
		<BEIGE public="1" get="inline" set="null" line="71" static="1">
			<x path="Int"/>
			<haxe_doc>* Beige is a very pale brown. 0xfff5f5dc</haxe_doc>
		</BEIGE>
		<WHEAT public="1" get="inline" set="null" line="76" static="1">
			<x path="Int"/>
			<haxe_doc>* Wheat is a color that resembles wheat. 0xfff5deb3</haxe_doc>
		</WHEAT>
		<TAN public="1" get="inline" set="null" line="81" static="1">
			<x path="Int"/>
			<haxe_doc>* Tan is a pale tone of brown. 0xffd2b48c</haxe_doc>
		</TAN>
		<KHAKI public="1" get="inline" set="null" line="86" static="1">
			<x path="Int"/>
			<haxe_doc>* Khaki is a light shade of yellow-brown similar to tan or beige. 0xffc3b091</haxe_doc>
		</KHAKI>
		<SILVER public="1" get="inline" set="null" line="91" static="1">
			<x path="Int"/>
			<haxe_doc>* Silver is a metallic color tone resembling gray that is a representation of the color of polished silver. 0xffc0c0c0</haxe_doc>
		</SILVER>
		<CHARCOAL public="1" get="inline" set="null" line="96" static="1">
			<x path="Int"/>
			<haxe_doc>* Charcoal is a representation of the dark gray color of burned wood. 0xff464646</haxe_doc>
		</CHARCOAL>
		<NAVY_BLUE public="1" get="inline" set="null" line="101" static="1">
			<x path="Int"/>
			<haxe_doc>* Navy blue is a dark shade of the color blue. 0xff000080</haxe_doc>
		</NAVY_BLUE>
		<ROYAL_BLUE public="1" get="inline" set="null" line="106" static="1">
			<x path="Int"/>
			<haxe_doc>* Royal blue is a dark shade of the color blue. 0xff084c9e</haxe_doc>
		</ROYAL_BLUE>
		<MEDIUM_BLUE public="1" get="inline" set="null" line="111" static="1">
			<x path="Int"/>
			<haxe_doc>* A medium blue tone. 0xff0000cd</haxe_doc>
		</MEDIUM_BLUE>
		<AZURE public="1" get="inline" set="null" line="116" static="1">
			<x path="Int"/>
			<haxe_doc>* Azure is a color that is commonly compared to the color of the sky on a clear summer's day. 0xff007fff</haxe_doc>
		</AZURE>
		<CYAN public="1" get="inline" set="null" line="121" static="1">
			<x path="Int"/>
			<haxe_doc>* Cyan is a color between blue and green. 0xff00ffff</haxe_doc>
		</CYAN>
		<MAGENTA public="1" get="inline" set="null" line="126" static="1">
			<x path="Int"/>
			<haxe_doc>* Magenta is a color between blue and red. 0xffff00ff</haxe_doc>
		</MAGENTA>
		<AQUAMARINE public="1" get="inline" set="null" line="131" static="1">
			<x path="Int"/>
			<haxe_doc>* Aquamarine is a color that is a bluish tint of cerulean toned toward cyan. 0xff7fffd4</haxe_doc>
		</AQUAMARINE>
		<TEAL public="1" get="inline" set="null" line="136" static="1">
			<x path="Int"/>
			<haxe_doc>* Teal is a low-saturated color, a bluish-green to dark medium. 0xff008080</haxe_doc>
		</TEAL>
		<FOREST_GREEN public="1" get="inline" set="null" line="141" static="1">
			<x path="Int"/>
			<haxe_doc>* Forest green is a green color resembling trees and other plants in a forest. 0xff228b22</haxe_doc>
		</FOREST_GREEN>
		<OLIVE public="1" get="inline" set="null" line="146" static="1">
			<x path="Int"/>
			<haxe_doc>* Olive is a dark yellowish green or greyish-green color like that of unripe or green olives. 0xff808000</haxe_doc>
		</OLIVE>
		<CHARTREUSE public="1" get="inline" set="null" line="151" static="1">
			<x path="Int"/>
			<haxe_doc>* Chartreuse is a color halfway between yellow and green. 0xff7fff00</haxe_doc>
		</CHARTREUSE>
		<LIME public="1" get="inline" set="null" line="156" static="1">
			<x path="Int"/>
			<haxe_doc>* Lime is a color three-quarters of the way between yellow and green. 0xffbfff00</haxe_doc>
		</LIME>
		<GOLDEN public="1" get="inline" set="null" line="161" static="1">
			<x path="Int"/>
			<haxe_doc>* Golden is one of a variety of yellow-brown color blends used to give the impression of the color of the element gold. 0xffffd700</haxe_doc>
		</GOLDEN>
		<GOLDENROD public="1" get="inline" set="null" line="166" static="1">
			<x path="Int"/>
			<haxe_doc>* Goldenrod is a color that resembles the goldenrod plant. 0xffdaa520</haxe_doc>
		</GOLDENROD>
		<CORAL public="1" get="inline" set="null" line="171" static="1">
			<x path="Int"/>
			<haxe_doc>* Coral is a pinkish-orange color. 0xffff7f50</haxe_doc>
		</CORAL>
		<SALMON public="1" get="inline" set="null" line="176" static="1">
			<x path="Int"/>
			<haxe_doc>* Salmon is a pale pinkish-orange to light pink color, named after the color of salmon flesh. 0xfffa8072</haxe_doc>
		</SALMON>
		<HOT_PINK public="1" get="inline" set="null" line="181" static="1">
			<x path="Int"/>
			<haxe_doc>* Hot Pink is a more saturated version of the color pink. 0xfffc0fc0</haxe_doc>
		</HOT_PINK>
		<FUCHSIA public="1" get="inline" set="null" line="186" static="1">
			<x path="Int"/>
			<haxe_doc>* Fuchsia is a vivid reddish or pink color named after the flower of the fuchsia plant. 0xffff77ff</haxe_doc>
		</FUCHSIA>
		<PUCE public="1" get="inline" set="null" line="191" static="1">
			<x path="Int"/>
			<haxe_doc>* Puce is a brownish-purple color. 0xffcc8899</haxe_doc>
		</PUCE>
		<MAUVE public="1" get="inline" set="null" line="196" static="1">
			<x path="Int"/>
			<haxe_doc>* Mauve is a pale lavender-lilac color. 0xffe0b0ff</haxe_doc>
		</MAUVE>
		<LAVENDER public="1" get="inline" set="null" line="201" static="1">
			<x path="Int"/>
			<haxe_doc>* Lavender is a pale tint of violet. 0xffb57edc</haxe_doc>
		</LAVENDER>
		<PLUM public="1" get="inline" set="null" line="206" static="1">
			<x path="Int"/>
			<haxe_doc>* Plum is a deep purple color. 0xff843179</haxe_doc>
		</PLUM>
		<INDIGO public="1" get="inline" set="null" line="211" static="1">
			<x path="Int"/>
			<haxe_doc>* Indigo is a deep and bright shade of blue. 0xff4b0082</haxe_doc>
		</INDIGO>
		<MAROON public="1" get="inline" set="null" line="216" static="1">
			<x path="Int"/>
			<haxe_doc>* Maroon is a dark brownish-red color. 0xff800000</haxe_doc>
		</MAROON>
		<CRIMSON public="1" get="inline" set="null" line="221" static="1">
			<x path="Int"/>
			<haxe_doc>* Crimson is a strong, bright, deep red color. 0xffdc143c</haxe_doc>
		</CRIMSON>
		<haxe_doc>* Class containing a set of useful color constants.</haxe_doc>
	</class>
	<class path="flixel.util.FlxColorUtil" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxColorUtil.hx">
		<makeFromARGB public="1" get="inline" set="null" line="19" static="1">
			<f a="?Alpha:Red:Green:Blue" v="1.0f:::">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Generate a color from ARGB components.
	 * 
	 * @param	Alpha	How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @param	Red		The red component, between 0 and 255.
	 * @param	Green	The green component, between 0 and 255.
	 * @param	Blue	The blue component, between 0 and 255.
	 * @return	The color as an integer</haxe_doc>
		</makeFromARGB>
		<makeFromHSBA public="1" get="inline" set="null" line="33" static="1">
			<f a="Hue:Saturation:Brightness:?Alpha" v=":::1.0f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Generate a color from HSBA components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as an integer</haxe_doc>
		</makeFromHSBA>
		<getARGB public="1" get="inline" set="null" line="102" static="1">
			<f a="Color:?Results" v=":null">
				<x path="Int"/>
				<t path="flixel.util.ARGB"/>
				<t path="flixel.util.ARGB"/>
			</f>
			<haxe_doc>* Loads an array with the ARGB values of a color.
	 * RGB values are stored 0-255.  Alpha is stored as a floating point number between 0 and 1 rounded to 4 decimals.
	 * 
	 * @param	Color	The color you want to break into components.
	 * @param	Results	An optional parameter, allows you to use an ARGB that already exists in memory to store the result.
	 * @return	An ARGB object containing the Red, Green, Blue and Alpha values of the given color.</haxe_doc>
		</getARGB>
		<getHSBA public="1" set="method" line="125" static="1">
			<f a="Color:?Results" v=":null">
				<x path="Int"/>
				<t path="flixel.util.HSBA"/>
				<t path="flixel.util.HSBA"/>
			</f>
			<haxe_doc>* Loads an array with the HSB values of a integer color.
	 * Hue is a value between 0 and 360. Saturation, Brightness and Alpha
	 * are as floating point numbers between 0 and 1 rounded to 4 decimals.
	 * 
	 * @param	Color	The color you want to break into components.
	 * @param	Results	An optional parameter, allows you to use an array that already exists in memory to store the result.
	 * @return	An HSBA object containing the Red, Green, Blue and Alpha values of the given color.</haxe_doc>
		</getHSBA>
		<getAlpha public="1" get="inline" set="null" line="185" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component, as a value between 0 and 255
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @return	The Alpha component of the color, will be between 0 and 255 (0 being no Alpha, 255 full Alpha)</haxe_doc>
		</getAlpha>
		<getAlphaFloat public="1" get="inline" set="null" line="196" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component as a value between 0 and 1
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @return	The Alpha component of the color, will be between 0 and 1 (0 being no Alpha (opaque), 1 full Alpha (transparent))</haxe_doc>
		</getAlphaFloat>
		<getRed public="1" get="inline" set="null" line="208" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given a native color value (in the format 0xAARRGGBB) this will return the Red component, as a value between 0 and 255
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @return	The Red component of the color, will be between 0 and 255 (0 being no color, 255 full Red)</haxe_doc>
		</getRed>
		<getGreen public="1" get="inline" set="null" line="219" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given a native color value (in the format 0xAARRGGBB) this will return the Green component, as a value between 0 and 255
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @return	The Green component of the color, will be between 0 and 255 (0 being no color, 255 full Green)</haxe_doc>
		</getGreen>
		<getBlue public="1" get="inline" set="null" line="230" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given a native color value (in the format 0xAARRGGBB) this will return the Blue component, as a value between 0 and 255
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @return	The Blue component of the color, will be between 0 and 255 (0 being no color, 255 full Blue)</haxe_doc>
		</getBlue>
		<getRandomColor public="1" get="inline" set="null" line="244" static="1">
			<f a="?Min:?Max:?Alpha" v="0:255:255">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Deprecated; please use FlxRandom.color() instead.
	 * Returns a random color value between black and white
	 * 
	 * @param	Min		The lowest value to use for each channel.
	 * @param	Max 	The highest value to use for each channel.
	 * @param	Alpha	The alpha value of the returning color (default 255 = fully opaque).
	 * @return 	A color value in hex ARGB format.</haxe_doc>
		</getRandomColor>
		<getColor32 public="1" get="inline" set="null" line="258" static="1">
			<f a="Alpha:Red:Green:Blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given an alpha and 3 color values this will return an integer representation of it (ARGB format)
	 * 
	 * @param	Alpha	The Alpha value (between 0 and 255)
	 * @param	Red		The Red channel value (between 0 and 255)
	 * @param	Green	The Green channel value (between 0 and 255)
	 * @param	Blue	The Blue channel value (between 0 and 255)
	 * @return	A native color value integer (format: 0xAARRGGBB)</haxe_doc>
		</getColor32>
		<getColor24 public="1" get="inline" set="null" line="271" static="1">
			<f a="Red:Green:Blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given 3 color values this will return an integer representation of it
	 * 
	 * @param	Red		The Red channel value (between 0 and 255)
	 * @param	Green	The Green channel value (between 0 and 255)
	 * @param	Blue	The Blue channel value (between 0 and 255)
	 * @return	A native color value integer (format: 0xRRGGBB)</haxe_doc>
		</getColor24>
		<getHSVColorWheel public="1" set="method" line="282" static="1">
			<f a="?Alpha" v="255">
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Get HSV color wheel values in an array which will be 360 elements in size
	 * 
	 * @param	Alpha	Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque)
	 * @return	HSV color wheel as Array of Ints</haxe_doc>
		</getHSVColorWheel>
		<getComplementHarmony public="1" get="inline" set="null" line="302" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns a Complementary Color Harmony for the given color.
	 * A complementary hue is one directly opposite the color given on the color wheel
	 * Value returned in 0xAARRGGBB format with Alpha set to 255.
	 * 
	 * @param	Color	The color to base the harmony on
	 * @return	0xAARRGGBB format color value</haxe_doc>
		</getComplementHarmony>
		<getAnalogousHarmony public="1" set="method" line="319" static="1">
			<f a="Color:?Threshold" v=":30">
				<x path="Int"/>
				<x path="Int"/>
				<t path="flixel.util.Harmony"/>
			</f>
			<haxe_doc>* Returns an Analogous Color Harmony for the given color.
	 * An Analogous harmony are hues adjacent to each other on the color wheel
	 * Values returned in 0xAARRGGBB format with Alpha set to 255.
	 * 
	 * @param	color The color to base the harmony on
	 * @param	threshold Control how adjacent the colors will be (default +- 30 degrees)
	 * @return 	Object containing 3 properties: color1 (the original color), color2 (the warmer analogous color) and color3 (the colder analogous color)</haxe_doc>
		</getAnalogousHarmony>
		<getSplitComplementHarmony public="1" set="method" line="343" static="1">
			<f a="Color:?Threshold" v=":30">
				<x path="Int"/>
				<x path="Int"/>
				<t path="flixel.util.Harmony"/>
			</f>
			<haxe_doc>* Returns an Split Complement Color Harmony for the given color.
	 * A Split Complement harmony are the two hues on either side of the color's Complement
	 * Values returned in 0xAARRGGBB format with Alpha set to 255.
	 * 
	 * @param	Color 		The color to base the harmony on
	 * @param	Threshold 	Control how adjacent the colors will be to the Complement (default +- 30 degrees)
	 * @return 	Object containing 3 properties: color1 (the original color), color2 (the warmer analogous color) and color3 (the colder analogous color)</haxe_doc>
		</getSplitComplementHarmony>
		<getTriadicHarmony public="1" get="inline" set="null" line="369" static="1">
			<f a="Color">
				<x path="Int"/>
				<t path="flixel.util.TriadicHarmony"/>
			</f>
			<haxe_doc>* Returns a Triadic Color Harmony for the given color. A Triadic harmony are 3 hues equidistant 
	 * from each other on the color wheel. Values returned in 0xAARRGGBB format with Alpha set to 255.
	 * 
	 * @param	Color 	The color to base the harmony on
	 * @return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
		</getTriadicHarmony>
		<getColorInfo public="1" get="inline" set="null" line="386" static="1">
			<f a="Color">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns a String containing handy information about the given color including String hex value,
	 * RGB format information and HSL information. Each section starts on a newline, 3 lines in total.
	 * 
	 * @param	Color 	A color value in the format 0xAARRGGBB
	 * @return	String containing the 3 lines of information</haxe_doc>
		</getColorInfo>
		<ARGBtoHexString public="1" get="inline" set="null" line="409" static="1">
			<f a="Color">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String representation of the color in the format 0xAARRGGBB
	 * 
	 * @param	Color 	The color to get the String representation for
	 * @return	A string of length 10 characters in the format 0xAARRGGBB</haxe_doc>
		</ARGBtoHexString>
		<ARGBtoWebString public="1" get="inline" set="null" line="421" static="1">
			<f a="Color">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
	 * 
	 * @param	Color 	The color to get the String representation for
	 * @return	A string of length 10 characters in the format 0xAARRGGBB</haxe_doc>
		</ARGBtoWebString>
		<colorToHexString public="1" get="inline" set="null" line="433" static="1">
			<f a="Color">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String containing a hex representation of the given color
	 * 
	 * @param	Color	The color channel to get the hex value for, must be a value between 0 and 255)
	 * @return	A string of length 2 characters, i.e. 255 = FF, 0 = 00</haxe_doc>
		</colorToHexString>
		<HSVtoARGB public="1" set="method" line="452" static="1">
			<f a="H:S:V:?Alpha" v=":::255">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Convert a HSV (hue, saturation, lightness) color space value to an ARGB color
	 * 
	 * @param	H 		Hue degree, between 0 and 359
	 * @param	S 		Saturation, between 0.0 (grey) and 1.0
	 * @param	V 		Value, between 0.0 (black) and 1.0
	 * @param	Alpha	Alpha value to set per color (between 0 and 255)
	 * @return	32-bit ARGB color value (0xAARRGGBB)</haxe_doc>
		</HSVtoARGB>
		<RGBtoHSV public="1" set="method" line="496" static="1">
			<f a="Color">
				<x path="Int"/>
				<t path="flixel.util.HSV"/>
			</f>
			<haxe_doc>* Convert an RGB color value to an object containing the HSV color space values: Hue, Saturation and Lightness
	 * 
	 * @param	Color 	The color in format 0xRRGGBB
	 * @return 	Object with the properties hue (from 0 to 360), saturation (from 0 to 1.0) and lightness (from 0 to 1.0, also available under .value)</haxe_doc>
		</RGBtoHSV>
		<ARGBtoRGB public="1" get="inline" set="null" line="570" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Turn a color with alpha and rgb values into a color without the alpha comoponent.
	 * Example: 0x55ff0000 becomes 0xff0000
	 * 
	 * @param	Color	The Color to convert
	 * @return	The color without its alpha component</haxe_doc>
		</ARGBtoRGB>
		<interpolateColor public="1" get="inline" set="null" line="585" static="1">
			<f a="Color1:Color2:Steps:CurrentStep:?Alpha" v="::::255">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get an interpolated color based on two different colors.
	 * 
	 * @param 	Color1			The first color
	 * @param 	Color2			The second color
	 * @param 	Steps			The amount of total steps
	 * @param 	CurrentStep		The step the interpolated color should be on
	 * @param	Alpha			The alpha value you want the interpolated color to have
	 * @return	The interpolated color</haxe_doc>
		</interpolateColor>
		<interpolateColorWithRGB public="1" get="inline" set="null" line="609" static="1">
			<f a="Color:R2:G2:B2:Steps:CurrentStep">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get an interpolated color based on a color and the RGB value of a second color.
	 * 
	 * @param 	Color			The first color
	 * @param 	R2				The red value of the second color
	 * @param 	G2				The green value of the second color
	 * @param 	B2				The blue value of the second color
	 * @param 	Steps			The amount of total steps
	 * @param 	CurrentStep		The step the interpolated color should be on
	 * @param	Alpha			The alpha value you want the interpolated color to have
	 * @return	The interpolated color</haxe_doc>
		</interpolateColorWithRGB>
		<interpolateRGB public="1" get="inline" set="null" line="634" static="1">
			<f a="R1:G1:B1:R2:G2:B2:Steps:CurrentStep">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get an interpolated color based on the RGB values of two different colors.
	 * 
	 * @param 	R1				The red value of the first color
	 * @param 	G1				The green value of the first color
	 * @param 	B1				The blue value of the first color
	 * @param 	R2				The red value of the second color
	 * @param 	G2				The green value of the second color
	 * @param 	B2				The blue value of the second color
	 * @param 	Steps			The amount of total steps
	 * @param 	CurrentStep		The step the interpolated color should be on
	 * @param	Alpha			The alpha value you want the interpolated color to have
	 * @return	The interpolated color</haxe_doc>
		</interpolateRGB>
		<darken public="1" get="inline" set="null" line="650" static="1">
			<f a="Color:?Factor" v=":0.2f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Darken an ARGB color.
	 * 
	 * @param	Color	Color in the format 0xAARRGGBB
	 * @param	Factor	The higher, the darker! Number from 0 to 1.0.
	 * @return 	The darkened color</haxe_doc>
		</darken>
		<brighten public="1" get="inline" set="null" line="675" static="1">
			<f a="Color:?Factor" v=":0.2f">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Lighten an ARGB color.
	 * 
	 * @param	Color	Color in the format 0xAARRGGBB
	 * @param	Factor	The higher, the lighter! Number from 0.0 to 1.0.
	 * @return 	The lightened color</haxe_doc>
		</brighten>
		<haxe_doc>* Class containing a set of functions for color manipulation and color harmony.</haxe_doc>
	</class>
	<typedef path="flixel.util.ARGB" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxColorUtil.hx" module="flixel.util.FlxColorUtil"><a>
	<red><x path="Int"/></red>
	<green><x path="Int"/></green>
	<blue><x path="Int"/></blue>
	<alpha><x path="Float"/></alpha>
</a></typedef>
	<typedef path="flixel.util.HSBA" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxColorUtil.hx" module="flixel.util.FlxColorUtil"><a>
	<saturation><x path="Float"/></saturation>
	<hue><x path="Int"/></hue>
	<brightness><x path="Float"/></brightness>
	<alpha><x path="Float"/></alpha>
</a></typedef>
	<typedef path="flixel.util.HSV" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxColorUtil.hx" module="flixel.util.FlxColorUtil"><a>
	<value><x path="Float"/></value>
	<saturation><x path="Float"/></saturation>
	<lightness><x path="Float"/></lightness>
	<hue><x path="Float"/></hue>
</a></typedef>
	<typedef path="flixel.util.Harmony" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxColorUtil.hx" module="flixel.util.FlxColorUtil"><a>
	<hue3><x path="Int"/></hue3>
	<hue2><x path="Int"/></hue2>
	<hue1><x path="Int"/></hue1>
	<color3><x path="Int"/></color3>
	<color2><x path="Int"/></color2>
	<color1><x path="Int"/></color1>
</a></typedef>
	<typedef path="flixel.util.TriadicHarmony" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxColorUtil.hx" module="flixel.util.FlxColorUtil"><a>
	<color3><x path="Int"/></color3>
	<color2><x path="Int"/></color2>
	<color1><x path="Int"/></color1>
</a></typedef>
	<class path="flixel.util.FlxDestroyUtil" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxDestroyUtil.hx">
		<destroy public="1" params="T" set="method" line="15" static="1">
			<f a="object">
				<t path="Null"><c path="flixel.interfaces.IFlxDestroyable"/></t>
				<c path="destroy.T"/>
			</f>
			<haxe_doc>* Checks if an object is not null before calling destroy(), always returns null.
	 * 
	 * @param	object	An IFlxDestroyable object that will be destroyed if it's not null.
	 * @return	null</haxe_doc>
		</destroy>
		<destroyArray public="1" params="T" set="method" line="30" static="1">
			<f a="array">
				<c path="Array"><c path="destroyArray.T"/></c>
				<c path="Array"><c path="destroyArray.T"/></c>
			</f>
			<haxe_doc>* Completely destroys an Array of destroyable objects:
	 * 1) Clears the array structure
	 * 2) Calls FlxDestroyUtil.destroy() on every element
	 *
	 * @param	array	An Array of IFlxDestroyable objects
	 * @return	null</haxe_doc>
		</destroyArray>
		<put public="1" params="T" set="method" line="48" static="1">
			<f a="object">
				<c path="flixel.interfaces.IFlxPooled"/>
				<c path="put.T"/>
			</f>
			<haxe_doc>* Checks if an object is not null before putting it back into the pool, always returns null.
	 * 
	 * @param	object	An IFlxPooled object that will be put back into the pool if it's not null
	 * @return	null</haxe_doc>
		</put>
		<putArray public="1" params="T" set="method" line="62" static="1">
			<f a="array">
				<c path="Array"><c path="putArray.T"/></c>
				<c path="Array"><c path="putArray.T"/></c>
			</f>
			<haxe_doc>* Puts all objects in an Array of IFlxPooled objects back into 
	 * the pool by calling FlxDestroyUtil.put() on them
	 *
	 * @param	array	An Array of IFlxPooled objects
	 * @return	null</haxe_doc>
		</putArray>
		<dispose public="1" set="method" line="80" static="1">
			<f a="Bitmap">
				<c path="flash.display.BitmapData"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Checks if a BitmapData object is not null before calling dispose() on it, always returns null.
	 * 
	 * @param	Bitmap	A BitampData to be disposed if not null
	 * @return 	null</haxe_doc>
		</dispose>
	</class>
	<class path="flixel.util.FlxGradient" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxGradient.hx">
		<createGradientMatrix public="1" set="method" line="23" static="1"><f a="width:height:colors:?chunkSize:?rotation" v=":::1:90">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<t path="flixel.util.GradientMatrix"/>
</f></createGradientMatrix>
		<createGradientArray public="1" set="method" line="78" static="1"><f a="width:height:colors:?chunkSize:?rotation:?interpolate" v=":::1:90:true">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="Array"><x path="Int"/></c>
</f></createGradientArray>
		<createGradientFlxSprite public="1" set="method" line="103" static="1">
			<f a="width:height:colors:?chunkSize:?rotation:?interpolate" v=":::1:90:true">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Creates an FlxSprite of the given width/height with a colour gradient flowing through it.
	 * 
	 * @param	width		The width of the FlxSprite (and therefore gradient)
	 * @param	height		The height of the FlxSprite (and therefore gradient)
	 * @param	colors		An array of colour values for the gradient to cycle through
	 * @param	chunkSize	If you want a more old-skool looking chunky gradient, increase this value!
	 * @param	rotation	Angle of the gradient in degrees. 90 = top to bottom, 180 = left to right. Any angle is valid
	 * @param	interpolate	Interpolate the colours? True uses RGB interpolation, false uses linear RGB
	 * 
	 * @return	An FlxSprite containing your gradient (if valid parameters given!)</haxe_doc>
		</createGradientFlxSprite>
		<createGradientBitmapData public="1" set="method" line="111" static="1"><f a="width:height:colors:?chunkSize:?rotation:?interpolate" v=":::1:90:true">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="flash.display.BitmapData"/>
</f></createGradientBitmapData>
		<overlayGradientOnFlxSprite public="1" set="method" line="209" static="1">
			<f a="dest:width:height:colors:?destX:?destY:?chunkSize:?rotation:?interpolate" v="::::0:0:1:90:true">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Creates a new gradient and overlays that on-top of the given FlxSprite at the destX/destY coordinates (default 0,0)
	 * Use low alpha values in the colours to have the gradient overlay and not destroy the image below
	 * 
	 * @param	dest		The FlxSprite to overlay the gradient onto
	 * @param	width		The width of the FlxSprite (and therefore gradient)
	 * @param	height		The height of the FlxSprite (and therefore gradient)
	 * @param	colors		An array of colour values for the gradient to cycle through
	 * @param	destX		The X offset the gradient is drawn at (default 0)
	 * @param	destY		The Y offset the gradient is drawn at (default 0)
	 * @param	chunkSize	If you want a more old-skool looking chunky gradient, increase this value!
	 * @param	rotation	Angle of the gradient in degrees. 90 = top to bottom, 180 = left to right. Any angle is valid
	 * @param	interpolate	Interpolate the colours? True uses RGB interpolation, false uses linear RGB
	 * @return	The composited FlxSprite (for chaining, if you need)</haxe_doc>
		</overlayGradientOnFlxSprite>
		<overlayGradientOnBitmapData public="1" set="method" line="242" static="1">
			<f a="dest:width:height:colors:?destX:?destY:?chunkSize:?rotation:?interpolate" v="::::0:0:1:90:true">
				<c path="flash.display.BitmapData"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Creates a new gradient and overlays that on-top of the given BitmapData at the destX/destY coordinates (default 0,0)
	 * Use low alpha values in the colours to have the gradient overlay and not destroy the image below
	 * 
	 * @param	dest		The BitmapData to overlay the gradient onto
	 * @param	width		The width of the FlxSprite (and therefore gradient)
	 * @param	height		The height of the FlxSprite (and therefore gradient)
	 * @param	colors		An array of colour values for the gradient to cycle through
	 * @param	destX		The X offset the gradient is drawn at (default 0)
	 * @param	destY		The Y offset the gradient is drawn at (default 0)
	 * @param	chunkSize	If you want a more old-skool looking chunky gradient, increase this value!
	 * @param	rotation	Angle of the gradient in degrees. 90 = top to bottom, 180 = left to right. Any angle is valid
	 * @param	interpolate	Interpolate the colours? True uses RGB interpolation, false uses linear RGB
	 * @return	The composited BitmapData</haxe_doc>
		</overlayGradientOnBitmapData>
		<haxe_doc>* Adds a set of color gradient creation / rendering functions
 * 
 * @version 1.6 - May 9th 2011
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm
 * @see Requires FlxMath</haxe_doc>
	</class>
	<typedef path="flixel.util.GradientMatrix" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxGradient.hx" module="flixel.util.FlxGradient"><a>
	<ratio><c path="Array"><x path="Int"/></c></ratio>
	<matrix><c path="flash.geom.Matrix"/></matrix>
	<alpha><c path="Array"><x path="Float"/></c></alpha>
</a></typedef>
	<class path="flixel.util.FlxMath" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxMath.hx">
		<MIN_VALUE public="1" get="inline" set="null" line="24" static="1">
			<x path="Float"/>
			<haxe_doc>* Minimum value of a floating point number.</haxe_doc>
		</MIN_VALUE>
		<MAX_VALUE public="1" get="inline" set="null" line="29" static="1">
			<x path="Float"/>
			<haxe_doc>* Maximum value of a floating point number.</haxe_doc>
		</MAX_VALUE>
		<SQUARE_ROOT_OF_TWO public="1" get="inline" set="null" line="33" static="1">
			<x path="Float"/>
			<haxe_doc>* Approximation of Math.sqrt(2).</haxe_doc>
		</SQUARE_ROOT_OF_TWO>
		<roundDecimal public="1" set="method" line="43" static="1">
			<f a="Value:Precision">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Round a decimal number to have reduced precision (less decimal numbers).
	 * Ex: roundDecimal(1.2485, 2) -> 1.25
	 * 
	 * @param	Value		Any number.
	 * @param	Precision	Number of decimal points to leave in float. Should be a positive number
	 * @return	The rounded value of that number.]]></haxe_doc>
		</roundDecimal>
		<bound public="1" get="inline" set="null" line="61" static="1">
			<f a="Value:Min:Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Bound a number by a minimum and maximum. Ensures that this number is 
	 * no smaller than the minimum, and no larger than the maximum.
	 * @param	Value	Any number.
	 * @param	Min		Any number.
	 * @param	Max		Any number.
	 * @return	The bounded value of the number.</haxe_doc>
		</bound>
		<lerp public="1" get="inline" set="null" line="75" static="1">
			<f a="Min:Max:Ratio">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns linear interpolated value between Max and Min numbers
	 *
	 * @param Min 		Lower bound.
	 * @param Max	 	Higher bound.
	 * @param Ratio 	Defines which number is closer to desired value.
	 * @return 			Interpolated number.</haxe_doc>
		</lerp>
		<inBounds public="1" get="inline" set="null" line="88" static="1">
			<f a="Value:Min:Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if number is in defined range.
	 *
	 * @param Value		Number to check.
	 * @param Min		Lower bound of range.
	 * @param Max 		Higher bound of range.
	 * @return Returns true if Value is in range.</haxe_doc>
		</inBounds>
		<isOdd public="1" set="method" line="99" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the number given is odd.
	 * 
	 * @param	n	The number to check 
	 * @return	True if the given number is odd. False if the given number is even.</haxe_doc>
		</isOdd>
		<isEven public="1" set="method" line="117" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the number given is even.
	 * 
	 * @param	n	The number to check
	 * @return	True if the given number is even. False if the given number is odd.</haxe_doc>
		</isEven>
		<numericComparison public="1" set="method" line="136" static="1">
			<f a="num1:num2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Compare two numbers.
	 * 
	 * @param	num1	The first number
	 * @param	num2	The second number
	 * @return	-1 if num1 is smaller, 1 if num2 is bigger, 0 if they are equal</haxe_doc>
		</numericComparison>
		<pointInCoordinates public="1" set="method" line="161" static="1">
			<f a="pointX:pointY:rectX:rectY:rectWidth:rectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the given rectangular block
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rectX		The X value of the region to test within
	 * @param	rectY		The Y value of the region to test within
	 * @param	rectWidth	The width of the region to test within
	 * @param	rectHeight	The height of the region to test within
	 * 
	 * @return	true if pointX/pointY is within the region, otherwise false</haxe_doc>
		</pointInCoordinates>
		<pointInFlxRect public="1" set="method" line="181" static="1">
			<f a="pointX:pointY:rect">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the given rectangular block
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rect		The FlxRect to test within
	 * @return	true if pointX/pointY is within the FlxRect, otherwise false</haxe_doc>
		</pointInFlxRect>
		<mouseInFlxRect public="1" set="method" line="199" static="1">
			<f a="useWorldCoords:rect">
				<x path="Bool"/>
				<c path="flixel.util.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the mouse world x/y coordinate are within the given rectangular block
	 * 
	 * @param	useWorldCoords	If true the world x/y coordinates of the mouse will be used, otherwise screen x/y
	 * @param	rect			The FlxRect to test within. If this is null for any reason this function always returns true.
	 * 
	 * @return	true if mouse is within the FlxRect, otherwise false</haxe_doc>
		</mouseInFlxRect>
		<pointInRectangle public="1" set="method" line="225" static="1">
			<f a="pointX:pointY:rect">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the Rectangle
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rect		The Rectangle to test within
	 * @return	true if pointX/pointY is within the Rectangle, otherwise false</haxe_doc>
		</pointInRectangle>
		<maxAdd public="1" set="method" line="244" static="1">
			<f a="value:amount:max:?min" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Adds the given amount to the value, but never lets the value
	 * go over the specified maximum or under the specified minimum.
	 * 
	 * @param 	value 	The value to add the amount to
	 * @param 	amount 	The amount to add to the value
	 * @param 	max 	The maximum the value is allowed to be
	 * @param 	min 	The minimum the value is allowed to be
	 * @return The new value</haxe_doc>
		</maxAdd>
		<wrapValue public="1" set="method" line="269" static="1">
			<f a="value:amount:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Adds value to amount and ensures that the result always stays between 0 and max, by wrapping the value around.
	 * Values must be positive integers, and are passed through Math.abs
	 * 
	 * @param 	value 	The value to add the amount to
	 * @param 	amount 	The amount to add to the value
	 * @param 	max 	The maximum the value is allowed to be
	 * @return The wrapped value</haxe_doc>
		</wrapValue>
		<dotProduct public="1" get="inline" set="null" line="292" static="1">
			<f a="ax:ay:bx:by">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Finds the dot product value of two vectors
	 * 
	 * @param	ax		Vector X
	 * @param	ay		Vector Y
	 * @param	bx		Vector X
	 * @param	by		Vector Y
	 * 
	 * @return	Result of the dot product</haxe_doc>
		</dotProduct>
		<vectorLength public="1" get="inline" set="null" line="305" static="1">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Finds the length of the given vector
	 * 
	 * @param	dx
	 * @param	dy
	 * 
	 * @return The length</haxe_doc>
		</vectorLength>
		<getDistance public="1" get="inline" set="null" line="317" static="1">
			<f a="Point1:Point2">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate the distance between two points.
	 * 
	 * @param 	Point1		A FlxPoint object referring to the first location.
	 * @param 	Point2		A FlxPoint object referring to the second location.
	 * @return	The distance between the two points as a floating point Number object.</haxe_doc>
		</getDistance>
		<distanceBetween public="1" get="inline" set="null" line="333" static="1">
			<f a="SpriteA:SpriteB">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) between two FlxSprites, taking their origin into account
	 * 
	 * @param	SpriteA		The first FlxSprite
	 * @param	SpriteB		The second FlxSprite
	 * @return	Distance between the sprites in pixels</haxe_doc>
		</distanceBetween>
		<isDistanceWithin public="1" get="inline" set="null" line="350" static="1">
			<f a="SpriteA:SpriteB:Distance:?IncludeEqual" v=":::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the distance between two FlxSprites is within a specified number. 
	 * A faster algoritm than distanceBetween because the Math.sqrt() is avoided.
	 *
	 * @param	SpriteA		The first FlxSprite
	 * @param	SpriteB		The second FlxSprite
	 * @param	Distance	The distance to check
	 * @param	IncludeEqual	If set to true, the function will return true if the calcualted distance is equal to the given Distance
	 * @return	True if the distance between the sprites is less than the given Distance</haxe_doc>
		</isDistanceWithin>
		<distanceToPoint public="1" get="inline" set="null" line="369" static="1">
			<f a="Sprite:Target">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) from an FlxSprite
	 * to the given FlxPoint, taking the source origin into account.
	 * 
	 * @param	Sprite	The FlxSprite
	 * @param	Target	The FlxPoint
	 * @return	Distance in pixels</haxe_doc>
		</distanceToPoint>
		<isDistanceToPointWithin public="1" get="inline" set="null" line="388" static="1">
			<f a="Sprite:Target:Distance:?IncludeEqual" v=":::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the distance from an FlxSprite to the given
	 * FlxPoint is within a specified number. 
	 * A faster algoritm than distanceToPoint because the Math.sqrt() is avoided.
	 * 
	 * @param	Sprite	The FlxSprite
	 * @param	Target	The FlxPoint
	 * @param	Distance	The distance to check
	 * @param	IncludeEqual	If set to true, the function will return true if the calcualted distance is equal to the given Distance
	 * @return	True if the distance between the sprites is less than the given Distance</haxe_doc>
		</isDistanceToPointWithin>
		<distanceToMouse public="1" get="inline" set="null" line="408" static="1">
			<f a="Sprite">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) from the object x/y and the mouse x/y
	 * 
	 * @param	Sprite	The FlxSprite to test against
	 * @return	The distance between the given sprite and the mouse coordinates</haxe_doc>
		</distanceToMouse>
		<isDistanceToMouseWithin public="1" get="inline" set="null" line="424" static="1">
			<f a="Sprite:Distance:?IncludeEqual" v="::false">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the distance from the object x/y and the mouse x/y is within a specified number. 
	 * A faster algoritm than distanceToMouse because the Math.sqrt() is avoided.
	 *
	 * @param	Sprite		The FlxSprite to test against
	 * @param	Distance	The distance to check
	 * @param	IncludeEqual	If set to true, the function will return true if the calcualted distance is equal to the given Distance
	 * @return	True if the distance between the sprites is less than the given Distance</haxe_doc>
		</isDistanceToMouseWithin>
		<distanceToTouch public="1" get="inline" set="null" line="444" static="1">
			<f a="Sprite:Touch">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) from the object x/y and the FlxPoint screen x/y
	 * 
	 * @param	Sprite	The FlxSprite to test against
	 * @param	Touch	The FlxTouch to test against
	 * @return	The distance between the given sprite and the mouse coordinates</haxe_doc>
		</distanceToTouch>
		<isDistanceToTouchWithin public="1" get="inline" set="null" line="460" static="1">
			<f a="Sprite:Touch:Distance:?IncludeEqual" v=":::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if the distance from the object x/y and the FlxPoint screen x/y is within a specified number. 
	 * A faster algoritm than distanceToTouch because the Math.sqrt() is avoided.
	 *
	 * @param	Sprite	The FlxSprite to test against
	 * @param	Distance	The distance to check
	 * @param	IncludeEqual	If set to true, the function will return true if the calcualted distance is equal to the given Distance
	 * @return	True if the distance between the sprites is less than the given Distance</haxe_doc>
		</isDistanceToTouchWithin>
		<getDecimals public="1" set="method" line="478" static="1">
			<f a="Number">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the amount of decimals a Float has
	 * 
	 * @param	Number	The floating point number
	 * @return	Amount of decimals</haxe_doc>
		</getDecimals>
		<equal public="1" get="inline" set="null" line="491" static="1"><f a="aValueA:aValueB:?aDiff" v="::0.00001f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></equal>
		<signOf public="1" get="inline" set="null" line="499" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns -1 if the number is smaller than 0 and 1 otherwise</haxe_doc>
		</signOf>
		<sameSign public="1" get="inline" set="null" line="507" static="1">
			<f a="f1:f2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if two numbers have the same sign (using signOf()).</haxe_doc>
		</sameSign>
		<haxe_doc>* A class containing a set of math-related functions.</haxe_doc>
	</class>
	<class path="flixel.util.FlxCallbackPoint" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxPoint.hx" module="flixel.util.FlxPoint">
		<extends path="flixel.util.FlxPoint"/>
		<_setXCallback><f a="">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></_setXCallback>
		<_setYCallback><f a="">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></_setYCallback>
		<_setXYCallback><f a="">
	<c path="flixel.util.FlxPoint"/>
	<x path="Void"/>
</f></_setXYCallback>
		<set public="1" get="inline" set="null" line="327" override="1"><f a="?X:?Y" v="0:0">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.util.FlxCallbackPoint"/>
</f></set>
		<set_x get="inline" set="null" line="335" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="343" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<destroy public="1" set="method" line="351" override="1"><f a=""><x path="Void"/></f></destroy>
		<put public="1" set="method" line="359" override="1"><f a=""><x path="Void"/></f></put>
		<new public="1" set="method" line="310">
			<f a="setXCallback:?setYCallback:?setXYCallback" v=":null:null">
				<f a="">
					<c path="flixel.util.FlxPoint"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="flixel.util.FlxPoint"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="flixel.util.FlxPoint"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you only specifiy one callback function, then the remaining two will use the same.
	 * 
	 * @param	setXCallback	Callback for set_x()
	 * @param	setYCallback	Callback for set_y()
	 * @param	setXYCallback	Callback for set()</haxe_doc>
		</new>
		<haxe_doc>* A FlxPoint that calls a function when set_x(), set_y() or set() is called. Used in FlxSpriteGroup.
 * IMPORTANT: Calling set(x, y); is MUCH FASTER than setting x and y separately. Needs to be destroyed unlike simple FlxPoints!</haxe_doc>
	</class>
	<class path="flixel.util.FlxPool" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxPool.hx">
		<_pool><c path="Array"><c path="flixel.util.FlxPool.T"/></c></_pool>
		<_class><x path="Class"><c path="flixel.util.FlxPool.T"/></x></_class>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<get public="1" set="method" line="23"><f a=""><c path="flixel.util.FlxPool.T"/></f></get>
		<put public="1" set="method" line="33"><f a="obj">
	<c path="flixel.util.FlxPool.T"/>
	<x path="Void"/>
</f></put>
		<putUnsafe public="1" set="method" line="43"><f a="obj">
	<c path="flixel.util.FlxPool.T"/>
	<x path="Void"/>
</f></putUnsafe>
		<preAllocate public="1" set="method" line="52"><f a="numObjects">
	<x path="Int"/>
	<x path="Void"/>
</f></preAllocate>
		<clear public="1" set="method" line="60"><f a=""><c path="Array"><c path="flixel.util.FlxPool.T"/></c></f></clear>
		<get_length get="inline" set="null" line="67"><f a=""><x path="Int"/></f></get_length>
		<new public="1" set="method" line="17"><f a="classObj">
	<x path="Class"><c path="flixel.util.FlxPool.T"/></x>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A generic container that facilitates pooling and recycling of objects.
 * WARNING: Pooled objects must have parameterless constructors: function new()</haxe_doc>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="flixel.util.FlxPool_flixel_util_FlxVector" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxPool.hx">
		<_pool><c path="Array"><c path="flixel.util.FlxVector"/></c></_pool>
		<_class><x path="Class"><c path="flixel.util.FlxVector"/></x></_class>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<get public="1" set="method" line="23"><f a=""><c path="flixel.util.FlxVector"/></f></get>
		<put public="1" set="method" line="33"><f a="obj">
	<c path="flixel.util.FlxVector"/>
	<x path="Void"/>
</f></put>
		<putUnsafe public="1" set="method" line="43"><f a="obj">
	<c path="flixel.util.FlxVector"/>
	<x path="Void"/>
</f></putUnsafe>
		<preAllocate public="1" set="method" line="52"><f a="numObjects">
	<x path="Int"/>
	<x path="Void"/>
</f></preAllocate>
		<clear public="1" set="method" line="60"><f a=""><c path="Array"><c path="flixel.util.FlxVector"/></c></f></clear>
		<get_length get="inline" set="null" line="67"><f a=""><x path="Int"/></f></get_length>
		<new public="1" set="method" line="17"><f a="classObj">
	<x path="Class"><c path="flixel.util.FlxVector"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.util.FlxPool_flixel_util_LabelValuePair" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxPool.hx">
		<_pool><c path="Array"><c path="flixel.util.LabelValuePair"/></c></_pool>
		<_class><x path="Class"><c path="flixel.util.LabelValuePair"/></x></_class>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<get public="1" set="method" line="23"><f a=""><c path="flixel.util.LabelValuePair"/></f></get>
		<put public="1" set="method" line="33"><f a="obj">
	<c path="flixel.util.LabelValuePair"/>
	<x path="Void"/>
</f></put>
		<putUnsafe public="1" set="method" line="43"><f a="obj">
	<c path="flixel.util.LabelValuePair"/>
	<x path="Void"/>
</f></putUnsafe>
		<preAllocate public="1" set="method" line="52"><f a="numObjects">
	<x path="Int"/>
	<x path="Void"/>
</f></preAllocate>
		<clear public="1" set="method" line="60"><f a=""><c path="Array"><c path="flixel.util.LabelValuePair"/></c></f></clear>
		<get_length get="inline" set="null" line="67"><f a=""><x path="Int"/></f></get_length>
		<new public="1" set="method" line="17"><f a="classObj">
	<x path="Class"><c path="flixel.util.LabelValuePair"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.util.FlxRandom" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxRandom.hx">
		<getObject_getRandom_T public="1" set="method" line="288" static="1">
			<f a="Objects:?StartIndex:?EndIndex" v=":0:0">
				<c path="Array"><c path="getRandom.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="getRandom.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</getObject_getRandom_T>
		<shuffleArray_shuffle_T public="1" set="method" line="327" static="1">
			<f a="Objects:HowManyTimes">
				<c path="Array"><c path="shuffle.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="shuffle.T"/></c>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noUsing"/>
			</meta>
		</shuffleArray_shuffle_T>
		<globalSeed public="1" set="accessor" line="16" static="1">
			<x path="Int"/>
			<haxe_doc>* The global random number generator seed (for deterministic behavior in recordings and saves).
	 * If you want, you can set the seed with an integer between 1 and 2,147,483,647 inclusive. However, FlxG automatically sets this with a new random seed when starting your game. Altering this yourself may break recording functionality!</haxe_doc>
		</globalSeed>
		<set_globalSeed set="method" line="21" static="1">
			<f a="NewSeed">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Internal function to update the internal seed whenever the global seed is reset, and keep the global seed's value in range.</haxe_doc>
		</set_globalSeed>
		<_internalSeed line="42" static="1">
			<x path="Int"/>
			<haxe_doc>* Internal seed used to generate new random numbers.</haxe_doc>
		</_internalSeed>
		<MULTIPLIER get="inline" set="null" line="51" static="1">
			<x path="Int"/>
			<haxe_doc>* Constants used in the pseudorandom number generation equation.
	 * These are the constants suggested by the revised MINSTD pseudorandom number generator, and they use the full range of possible integer values.
	 * 
	 * @see 	http://en.wikipedia.org/wiki/Linear_congruential_generator
	 * @see 	Stephen K. Park and Keith W. Miller and Paul K. Stockmeyer (1988). "Technical Correspondence". Communications of the ACM 36 (7): 105–110.</haxe_doc>
		</MULTIPLIER>
		<MODULUS get="inline" set="null" line="52" static="1"><x path="Int"/></MODULUS>
		<_intHelper line="57" static="1">
			<x path="Int"/>
			<haxe_doc>* Internal helper variables.</haxe_doc>
		</_intHelper>
		<_intHelper2 line="58" static="1"><x path="Int"/></_intHelper2>
		<_intHelper3 line="59" static="1"><x path="Int"/></_intHelper3>
		<_floatHelper line="60" static="1"><x path="Float"/></_floatHelper>
		<_arrayFloatHelper line="61" static="1"><c path="Array"><x path="Float"/></c></_arrayFloatHelper>
		<_red line="62" static="1"><x path="Int"/></_red>
		<_green line="63" static="1"><x path="Int"/></_green>
		<_blue line="64" static="1"><x path="Int"/></_blue>
		<_alpha line="65" static="1"><x path="Int"/></_alpha>
		<resetGlobalSeed public="1" get="inline" set="null" line="118" static="1">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Function to easily set the global seed to a new random number. Used primarily by FlxG whenever the game is reset.
	 * Please note that this function is not deterministic! If you call it in your game, recording may not work.
	 * 
	 * @return	The new global seed.</haxe_doc>
		</resetGlobalSeed>
		<int public="1" get="inline" set="null" line="126" static="1">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns a pseudorandom number between 0 and 2,147,483,647, inclusive.</haxe_doc>
		</int>
		<float public="1" get="inline" set="null" line="134" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns a pseudorandom number between 0 and 1, inclusive.</haxe_doc>
		</float>
		<intRanged public="1" set="method" line="147" static="1">
			<f a="?Min:?Max:?Excludes" v="0:2147483647:null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns a pseudorandom integer between Min and Max, inclusive. Will not return a number in the Excludes array, if provided.
	 * Please note that large Excludes arrays can slow calculations.
	 * 
	 * @param	Min			The minimum value that should be returned. 0 by default.
	 * @param	Max			The maximum value that should be returned. 2,147,483,647 by default.
	 * @param	?Excludes	An optional array of values that should not be returned.</haxe_doc>
		</intRanged>
		<floatRanged public="1" set="method" line="189" static="1">
			<f a="?Min:?Max:?Excludes" v="0:1:null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns a pseudorandom float value between Min and Max, inclusive. Will not return a number in the Excludes array, if provided.
	 * Please note that large Excludes arrays can slow calculations.
	 * 
	 * @param	Min			The minimum value that should be returned. 0 by default.
	 * @param	Max			The maximum value that should be returned. 33,554,429 by default.
	 * @param	?Excludes	An optional array of values that should not be returned.</haxe_doc>
		</floatRanged>
		<chanceRoll public="1" get="inline" set="null" line="230" static="1">
			<f a="?Chance" v="50">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true or false based on the chance value (default 50%). 
	 * For example if you wanted a player to have a 30% chance of getting a bonus, call chanceRoll(30) - true means the chance passed, false means it failed.
	 * 
	 * @param 	Chance 	The chance of receiving the value. Should be given as a number between 0 and 100 (effectively 0% to 100%)
	 * @return 	Whether the roll passed or not.</haxe_doc>
		</chanceRoll>
		<sign public="1" get="inline" set="null" line="241" static="1">
			<f a="?Chance" v="50">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns either a 1 or -1. 
	 * 
	 * @param	Chance	The chance of receiving a positive value. Should be given as a number between 0 and 100 (effectively 0% to 100%)
	 * @return	1 or -1</haxe_doc>
		</sign>
		<weightedPick public="1" set="method" line="253" static="1">
			<f a="WeightsArray">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>* Pseudorandomly select from an array of weighted options. For example, if you passed in an array of [ 50, 30, 20 ] there would be a 50% chance of returning a 0, a 30% chance of returning a 1, and a 20% chance of returning a 2.
	 * Note that the values in the array do not have to add to 100 or any other number. The percent chance will be equal to a given value in the array divided by the total of all values in the array.
	 * 
	 * @param	WeightsArray		An array of weights.
	 * @return	A value between 0 and (SelectionArray.length - 1), with a probability equivalent to the values in SelectionArray.</haxe_doc>
		</weightedPick>
		<getObject public="1" params="T" set="method" line="288" static="1">
			<f a="Objects:?StartIndex:?EndIndex" v=":0:0">
				<c path="Array"><c path="getObject.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="getObject.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Fetch a random entry from the given array from StartIndex to EndIndex.
	 * Will return null if random selection is missing, or array has no entries.
	 * 
	 * @param	Objects			An array from which to select a random entry.
	 * @param	StartIndex		Optional index from which to restrict selection. Default value is 0, or the beginning of the array.
	 * @param	EndIndex		Optional index at which to restrict selection. Ignored if 0, which is the default value.
	 * @return	The random object that was selected.</haxe_doc>
		</getObject>
		<shuffleArray public="1" params="T" set="method" line="327" static="1">
			<f a="Objects:HowManyTimes">
				<c path="Array"><c path="shuffleArray.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="shuffleArray.T"/></c>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Shuffles the entries in an array into a new pseudorandom order.
	 * 
	 * @param	Objects			An array to shuffle.
	 * @param	HowManyTimes	How many swaps to perform during the shuffle operation.  A good rule of thumb is 2-4 times the number of objects in the list.
	 * @return	The newly shuffled array.</haxe_doc>
		</shuffleArray>
		<weightedGetObject public="1" params="T" set="method" line="356" static="1">
			<f a="Objects:WeightsArray:?StartIndex:?EndIndex" v="::0:0">
				<c path="Array"><c path="weightedGetObject.T"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="weightedGetObject.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Returns a random object from an array between StartIndex and EndIndex with a weighted chance from WeightsArray.
	 * This function is essentially a combination of weightedPick and getObject.
	 * 
	 * @param	Objects			An array from which to return an object.
	 * @param	WeightsArray	An array of weights which will determine the likelihood of returning a given value from Objects. Values in WeightsArray will correspond to objects in Objects exactly.
	 * @param	StartIndex		Optional index from which to restrict selection. Default value is 0, or the beginning of the Objects array.
	 * @param 	EndIndex 		Optional index at which to restrict selection. Ignored if 0, which is the default value.
	 * @return	A pseudorandomly chosen object from Objects.</haxe_doc>
		</weightedGetObject>
		<color public="1" set="method" line="402" static="1">
			<f a="?Min:?Max:?Alpha:?GreyScale" v="0:255:255:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns a random color value in hex ARGB format.
	 * 
	 * @param	Min			The lowest value to use for each channel.
	 * @param	Max 		The highest value to use for each channel.
	 * @param	Alpha		The alpha value of the returning color (default 255 = fully opaque).
	 * @param 	GreyScale	Whether or not to create a color that is strictly a shade of grey. False by default.
	 * @return 	A color value in hex ARGB format.</haxe_doc>
		</color>
		<colorExt public="1" set="method" line="463" static="1">
			<f a="?RedMinimum:?RedMaximum:?GreenMinimum:?GreenMaximum:?BlueMinimum:?BlueMaximum:?AlphaMinimum:?AlphaMaximum" v="0:255:0:255:0:255:-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Much like color(), but with much finer control over the output color.
	 * 
	 * @param	RedMinimum		The minimum amount of red in the output color, from 0 to 255.
	 * @param	RedMaximum		The maximum amount of red in the output color, from 0 to 255.
	 * @param	GreedMinimum	The minimum amount of green in the output color, from 0 to 255.
	 * @param	GreenMaximum	The maximum amount of green in the output color, from 0 to 255.
	 * @param	BlueMinimum		The minimum amount of blue in the output color, from 0 to 255.
	 * @param	BlueMaximum		The maximum amount of blue in the output color, from 0 to 255.
	 * @param	AlphaMinimum	The minimum alpha value for the output color, from 0 (fully transparent) to 255 (fully opaque). Set to -1 or ignore for the output to be always fully opaque.
	 * @param	AlphaMaximum	The maximum alpha value for the output color, from 0 (fully transparent) to 255 (fully opaque). Set to -1 or ignore for the output to be always fully opaque.
	 * @return	A pseudorandomly generated color within the ranges specified.</haxe_doc>
		</colorExt>
		<generate get="inline" set="null" line="498" static="1">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Internal method to quickly generate a pseudorandom number. Used only by other functions of this class.
	 * Also updates the internal seed, which will then be used to generate the next pseudorandom number.
	 * 
	 * @return	A new pseudorandom number.</haxe_doc>
		</generate>
		<haxe_doc>* A class containing a set of functions for random generation.</haxe_doc>
	</class>
	<typedef path="flixel.util.FlxSignal" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx"><x path="flixel.util.FlxTypedSignal"><f a=""><x path="Void"/></f></x></typedef>
	<abstract path="flixel.util.FlxTypedSignal" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx" module="flixel.util.FlxSignal">
		<this><c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c></this>
		<to>
			<icast field="toSignal0"><c path="flixel.util._FlxSignal.FlxSignal0"/></icast>
			<icast field="toSignal1"><c path="flixel.util._FlxSignal.FlxSignal1"><c path="toSignal1.T1"/></c></icast>
			<icast field="toSignal2"><c path="flixel.util._FlxSignal.FlxSignal2">
	<c path="toSignal2.T1"/>
	<c path="toSignal2.T2"/>
</c></icast>
			<icast field="toSignal3"><c path="flixel.util._FlxSignal.FlxSignal3">
	<c path="toSignal3.T1"/>
	<c path="toSignal3.T2"/>
	<c path="toSignal3.T3"/>
</c></icast>
			<icast field="toSignal4"><c path="flixel.util._FlxSignal.FlxSignal4">
	<c path="toSignal4.T1"/>
	<c path="toSignal4.T2"/>
	<c path="toSignal4.T3"/>
	<c path="toSignal4.T4"/>
</c></icast>
		</to>
		<meta><m n=":multiType"/></meta>
		<impl><class path="flixel.util._FlxSignal.FlxTypedSignal_Impl_" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
	<dispatch public="1" get="accessor" set="null" static="1">
		<c path="flixel.util.FlxTypedSignal.T"/>
		<meta><m n=":impl"/></meta>
	</dispatch>
	<_new public="1" set="method" static="1">
		<f a=""><c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c></f>
		<meta><m n=":impl"/></meta>
	</_new>
	<add public="1" get="inline" set="null" line="19" static="1">
		<f a="this:listener">
			<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<c path="flixel.util.FlxTypedSignal.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</add>
	<addOnce public="1" get="inline" set="null" line="24" static="1">
		<f a="this:listener">
			<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<c path="flixel.util.FlxTypedSignal.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</addOnce>
	<remove public="1" get="inline" set="null" line="29" static="1">
		<f a="this:listener">
			<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<c path="flixel.util.FlxTypedSignal.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</remove>
	<has public="1" get="inline" set="null" line="34" static="1">
		<f a="this:listener">
			<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<c path="flixel.util.FlxTypedSignal.T"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</has>
	<removeAll public="1" get="inline" set="null" line="39" static="1">
		<f a="this">
			<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</removeAll>
	<get_dispatch get="inline" set="null" line="44" static="1">
		<f a="this">
			<c path="flixel.interfaces.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<c path="flixel.util.FlxTypedSignal.T"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_dispatch>
	<toSignal0 get="inline" set="null" line="50" static="1">
		<f a="signal">
			<c path="flixel.interfaces.IFlxSignal"><f a=""><x path="Void"/></f></c>
			<c path="flixel.util._FlxSignal.FlxSignal0"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toSignal0>
	<toSignal1 params="T1" get="inline" set="null" line="56" static="1">
		<f a="signal">
			<c path="flixel.interfaces.IFlxSignal"><f a="">
	<c path="toSignal1.T1"/>
	<x path="Void"/>
</f></c>
			<c path="flixel.util._FlxSignal.FlxSignal1"><c path="toSignal1.T1"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toSignal1>
	<toSignal2 params="T1:T2" get="inline" set="null" line="62" static="1">
		<f a="signal">
			<c path="flixel.interfaces.IFlxSignal"><f a=":">
	<c path="toSignal2.T1"/>
	<c path="toSignal2.T2"/>
	<x path="Void"/>
</f></c>
			<c path="flixel.util._FlxSignal.FlxSignal2">
				<c path="toSignal2.T1"/>
				<c path="toSignal2.T2"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toSignal2>
	<toSignal3 params="T1:T2:T3" get="inline" set="null" line="68" static="1">
		<f a="signal">
			<c path="flixel.interfaces.IFlxSignal"><f a="::">
	<c path="toSignal3.T1"/>
	<c path="toSignal3.T2"/>
	<c path="toSignal3.T3"/>
	<x path="Void"/>
</f></c>
			<c path="flixel.util._FlxSignal.FlxSignal3">
				<c path="toSignal3.T1"/>
				<c path="toSignal3.T2"/>
				<c path="toSignal3.T3"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toSignal3>
	<toSignal4 params="T1:T2:T3:T4" get="inline" set="null" line="74" static="1">
		<f a="signal">
			<c path="flixel.interfaces.IFlxSignal"><f a=":::">
	<c path="toSignal4.T1"/>
	<c path="toSignal4.T2"/>
	<c path="toSignal4.T3"/>
	<c path="toSignal4.T4"/>
	<x path="Void"/>
</f></c>
			<c path="flixel.util._FlxSignal.FlxSignal4">
				<c path="toSignal4.T1"/>
				<c path="toSignal4.T2"/>
				<c path="toSignal4.T3"/>
				<c path="toSignal4.T4"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toSignal4>
</class></impl>
	</abstract>
	<class path="flixel.util._FlxSignal.FlxSignalHandler" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<listener public="1"><c path="flixel.util._FlxSignal.FlxSignalHandler.T"/></listener>
		<dispatchOnce public="1" set="null"><x path="Bool"/></dispatchOnce>
		<destroy public="1" set="method" line="91"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="85"><f a="listener:dispatchOnce">
	<c path="flixel.util._FlxSignal.FlxSignalHandler.T"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignalBase" params="T" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<implements path="flixel.interfaces.IFlxSignal"><c path="flixel.util._FlxSignal.FlxSignalBase.T"/></implements>
		<buildDispatch set="method" static="1"><f a="exprs">
	<d/>
	<d/>
</f></buildDispatch>
		<dispatch public="1">
			<c path="flixel.util._FlxSignal.FlxSignalBase.T"/>
			<haxe_doc>* Typed function reference used to dispatch this signal.</haxe_doc>
		</dispatch>
		<_handlers><c path="Array"><c path="flixel.util._FlxSignal.FlxSignalHandler"><c path="flixel.util._FlxSignal.FlxSignalBase.T"/></c></c></_handlers>
		<add public="1" set="method" line="125"><f a="listener">
	<c path="flixel.util._FlxSignal.FlxSignalBase.T"/>
	<x path="Void"/>
</f></add>
		<addOnce public="1" set="method" line="131"><f a="listener">
	<c path="flixel.util._FlxSignal.FlxSignalBase.T"/>
	<x path="Void"/>
</f></addOnce>
		<remove public="1" set="method" line="137"><f a="listener">
	<c path="flixel.util._FlxSignal.FlxSignalBase.T"/>
	<x path="Void"/>
</f></remove>
		<has public="1" set="method" line="151"><f a="listener">
	<c path="flixel.util._FlxSignal.FlxSignalBase.T"/>
	<x path="Bool"/>
</f></has>
		<removeAll public="1" get="inline" set="null" line="158"><f a=""><x path="Void"/></f></removeAll>
		<destroy public="1" set="method" line="168"><f a=""><x path="Void"/></f></destroy>
		<registerListener set="method" line="174"><f a="listener:dispatchOnce">
	<c path="flixel.util._FlxSignal.FlxSignalBase.T"/>
	<x path="Bool"/>
	<c path="flixel.util._FlxSignal.FlxSignalHandler"><c path="flixel.util._FlxSignal.FlxSignalBase.T"/></c>
</f></registerListener>
		<getHandler set="method" line="195"><f a="listener">
	<c path="flixel.util._FlxSignal.FlxSignalBase.T"/>
	<c path="flixel.util._FlxSignal.FlxSignalHandler"><c path="flixel.util._FlxSignal.FlxSignalBase.T"/></c>
</f></getHandler>
		<new public="1" set="method" line="120"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignal0" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<extends path="flixel.util._FlxSignal.FlxSignalBase"><f a=""><x path="Void"/></f></extends>
		<dispatch0 public="1" set="method" line="216"><f a=""><x path="Void"/></f></dispatch0>
		<new public="1" set="method" line="210"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignal1" params="T1" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<extends path="flixel.util._FlxSignal.FlxSignalBase"><f a="">
	<c path="flixel.util._FlxSignal.FlxSignal1.T1"/>
	<x path="Void"/>
</f></extends>
		<dispatch1 public="1" set="method" line="230"><f a="value1">
	<c path="flixel.util._FlxSignal.FlxSignal1.T1"/>
	<x path="Void"/>
</f></dispatch1>
		<new public="1" set="method" line="224"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignal2" params="T1:T2" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<extends path="flixel.util._FlxSignal.FlxSignalBase"><f a=":">
	<c path="flixel.util._FlxSignal.FlxSignal2.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal2.T2"/>
	<x path="Void"/>
</f></extends>
		<dispatch2 public="1" set="method" line="244"><f a="value1:value2">
	<c path="flixel.util._FlxSignal.FlxSignal2.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal2.T2"/>
	<x path="Void"/>
</f></dispatch2>
		<new public="1" set="method" line="238"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignal3" params="T1:T2:T3" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<extends path="flixel.util._FlxSignal.FlxSignalBase"><f a="::">
	<c path="flixel.util._FlxSignal.FlxSignal3.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal3.T2"/>
	<c path="flixel.util._FlxSignal.FlxSignal3.T3"/>
	<x path="Void"/>
</f></extends>
		<dispatch3 public="1" set="method" line="258"><f a="value1:value2:value3">
	<c path="flixel.util._FlxSignal.FlxSignal3.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal3.T2"/>
	<c path="flixel.util._FlxSignal.FlxSignal3.T3"/>
	<x path="Void"/>
</f></dispatch3>
		<new public="1" set="method" line="252"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignal4" params="T1:T2:T3:T4" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<extends path="flixel.util._FlxSignal.FlxSignalBase"><f a=":::">
	<c path="flixel.util._FlxSignal.FlxSignal4.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T2"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T3"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T4"/>
	<x path="Void"/>
</f></extends>
		<dispatch4 public="1" set="method" line="272"><f a="value1:value2:value3:value4">
	<c path="flixel.util._FlxSignal.FlxSignal4.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T2"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T3"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T4"/>
	<x path="Void"/>
</f></dispatch4>
		<new public="1" set="method" line="266"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util.FlxSort" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSort.hx">
		<ASCENDING public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></ASCENDING>
		<DESCENDING public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></DESCENDING>
		<byY public="1" get="inline" set="null" line="16" static="1">
			<f a="Order:Obj1:Obj2">
				<x path="Int"/>
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* You can use this function in FlxTypedGroup.sort() to sort FlxObjects by their y values.</haxe_doc>
		</byY>
		<byValues public="1" get="inline" set="null" line="24" static="1">
			<f a="Order:Value1:Value2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* You can use this function as a backend to write a custom sorting function (see byY() for an example).</haxe_doc>
		</byValues>
		<haxe_doc>* Helper class for sort() in FlxTypedGroup, but could theoretically be used on regular arrays as well.</haxe_doc>
	</class>
	<class path="flixel.util.FlxSpriteUtil" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSpriteUtil.hx">
		<flashGfxSprite public="1" set="null" line="36" static="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* Useful helper objects for doing Flash-specific rendering.
	 * Primarily used for "debug visuals" like drawing bounding boxes directly to the screen buffer.</haxe_doc>
		</flashGfxSprite>
		<flashGfx public="1" set="null" line="37" static="1"><c path="flash.display.Graphics"/></flashGfx>
		<alphaMask public="1" set="method" line="51" static="1">
			<f a="output:source:mask">
				<c path="flixel.FlxSprite"/>
				<d/>
				<d/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Takes two source images (typically from Embedded bitmaps) and puts the resulting image into the output FlxSprite.
	 * Note: It assumes the source and mask are the same size. Different sizes may result in undesired results.
	 * It works by copying the source image (your picture) into the output sprite. Then it removes all areas of it that do not
	 * have an alpha color value in the mask image. So if you draw a big black circle in your mask with a transparent edge, you'll
	 * get a circular image appear. Look at the mask PNG files in the assets/pics folder for examples.
	 * 
	 * @param	output		The FlxSprite you wish the resulting image to be placed in (will adjust width/height of image)
	 * @param	source		The source image. Typically the one with the image / picture / texture in it.
	 * @param	mask		The mask to apply. Remember the non-alpha zero areas are the parts that will display.
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</alphaMask>
		<alphaMaskFlxSprite public="1" set="method" line="105" static="1">
			<f a="sprite:mask:output">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Takes the image data from two FlxSprites and puts the resulting image into the output FlxSprite.
	 * Note: It assumes the source and mask are the same size. Different sizes may result in undesired results.
	 * It works by copying the source image (your picture) into the output sprite. Then it removes all areas of it that do not
	 * have an alpha color value in the mask image. So if you draw a big black circle in your mask with a transparent edge, you'll
	 * get a circular image appear.
	 * 
	 * @param	sprite		The source FlxSprite. Typically the one with the image / picture / texture in it.
	 * @param	mask		The FlxSprite containing the mask to apply. Remember the non-alpha zero areas are the parts that will display.
	 * @param	output		The FlxSprite you wish the resulting image to be placed in (will adjust width/height of image)
	 * @return 	The output FlxSprite for chaining</haxe_doc>
		</alphaMaskFlxSprite>
		<screenWrap public="1" set="method" line="125" static="1">
			<f a="sprite:?Left:?Right:?Top:?Bottom" v=":true:true:true:true">
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Checks the x/y coordinates of the FlxSprite and keeps them within the 
	 * area of 0, 0, FlxG.width, FlxG.height (i.e. wraps it around the screen)
	 * 
	 * @param	sprite		The FlxSprite to keep within the screen
	 * @param	Left		Whether to activate screen wrapping on the left side of the screen
	 * @param	Right		Whether to activate screen wrapping on the right side of the screen
	 * @param	Top			Whether to activate screen wrapping on the top of the screen
	 * @param	Bottom		Whether to activate screen wrapping on the bottom of the screen
	 * @return	The FlxSprite for chaining</haxe_doc>
		</screenWrap>
		<bound public="1" set="method" line="158" static="1">
			<f a="sprite:?MinX:?MaxX:?MinY:?MaxY" v=":0:0:0:0">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Makes sure a FlxSprite doesn't leave the specified area - most common use case is to call this every frame in update().
	 * If you call this without specifying an area, the game area (FlxG.width / height as max) will be used. Takes the graphic size into account.
	 * 
	 * @param	sprite	The FlxSprite to bound to an area
	 * @param	MinX	The minimum x position allowed
	 * @param	MaxX	The maximum x position allowed
	 * @param	MinY	The minimum y position allowed
	 * @param	MaxY	The minimum y position allowed
	 * @return	The FlxSprite for chaining</haxe_doc>
		</bound>
		<space public="1" set="method" line="188" static="1">
			<f a="objects:startX:startY:?horizontalSpacing:?verticalSpacing:?spaceFromBounds" v=":::0:0:false">
				<c path="Array"><c path="flixel.FlxObject"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Aligns a set of FlxObjects so there is equal spacing between them
	 * 
	 * @param	objects				An Array of FlxObjects
	 * @param	startX				The base X coordinate to start the spacing from
	 * @param	startY				The base Y coordinate to start the spacing from
	 * @param	horizontalSpacing	The amount of pixels between each sprite horizontally (default 0)
	 * @param	verticalSpacing		The amount of pixels between each sprite vertically (default 0)
	 * @param	spaceFromBounds		If set to true the h/v spacing values will be added to the width/height of the sprite, if false it will ignore this</haxe_doc>
		</space>
		<screenCenter public="1" set="method" line="218" static="1">
			<f a="object:?xAxis:?yAxis" v=":true:true">
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxObject"/>
			</f>
			<haxe_doc>* Centers the given FlxObject on the screen, either by the x axis, y axis, or both
	 * 
	 * @param	object			The FlxSprite to center
	 * @param	Horizontally	Boolean true if you want it centered horizontally
	 * @param	Vertically		Boolean	true if you want it centered vertically
	 * @return 	The FlxObject for chaining</haxe_doc>
		</screenCenter>
		<drawLine public="1" set="method" line="248" static="1">
			<f a="sprite:StartX:StartY:EndX:EndY:?lineStyle:?drawStyle" v=":::::null:null">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This function draws a line on a FlxSprite from position X1,Y1
	 * to position X2,Y2 with the specified color.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	StartX		X coordinate of the line's start point.
	 * @param	StartY		Y coordinate of the line's start point.
	 * @param	EndX		X coordinate of the line's end point.
	 * @param	EndY		Y coordinate of the line's end point.
	 * @param	Color		The line's color.
	 * @param	Thickness	How thick the line is in pixels (default value is 1).
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	drawStyle	A DrawStyle typdef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawLine>
		<drawRect public="1" set="method" line="271" static="1">
			<f a="sprite:X:Y:Width:Height:Color:?lineStyle:?fillStyle:?drawStyle" v="::::::null:null:null">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This function draws a rectangle on a FlxSprite.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	X			X coordinate of the rectangle's start point.
	 * @param	Y			Y coordinate of the rectangle's start point.
	 * @param	Width		Width of the rectangle
	 * @param	Height		Height of the rectangle
	 * @param	Color		The rectangle's color.
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	fillStyle	A FillStyle typedef containing the params of Graphics.fillStyle()
	 * @param	drawStyle	A DrawStyle typdef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawRect>
		<drawRoundRect public="1" set="method" line="295" static="1">
			<f a="sprite:X:Y:Width:Height:EllipseWidth:EllipseHeight:Color:?lineStyle:?fillStyle:?drawStyle" v="::::::::null:null:null">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This function draws a rounded rectangle on a FlxSprite.
	 * 
	 * @param	sprite			The FlxSprite to manipulate
	 * @param	X				X coordinate of the rectangle's start point.
	 * @param	Y				Y coordinate of the rectangle's start point.
	 * @param	Width			Width of the rectangle
	 * @param	Height			Height of the rectangle
	 * @param	EllipseWidth	The width of the ellipse used to draw the rounded corners
	 * @param	EllipseHeight	The height of the ellipse used to draw the rounded corners
	 * @param	Color			The rectangle's color.
	 * @param	lineStyle		A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	fillStyle		A FillStyle typedef containing the params of Graphics.fillStyle()
	 * @param	drawStyle		A DrawStyle typdef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawRoundRect>
		<drawCircle public="1" set="method" line="345" static="1">
			<f a="sprite:?X:?Y:?Radius:?Color:?lineStyle:?fillStyle:?drawStyle" v=":-1:-1:-1:-1:null:null:null">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc><![CDATA[* This function draws a circle on a FlxSprite at position X,Y with the specified color.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	X 			X coordinate of the circle's center (automatically centered on the sprite if -1)
	 * @param	Y 			Y coordinate of the circle's center (automatically centered on the sprite if -1)
	 * @param	Radius 		Radius of the circle (makes sure the circle fully fits on the sprite's graphic if < 1, assuming and and y are centered)
	 * @param	Color 		Color of the circle
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	fillStyle	A FillStyle typedef containing the params of Graphics.fillStyle()
	 * @param	drawStyle	A DrawStyle typdef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining]]></haxe_doc>
		</drawCircle>
		<drawEllipse public="1" set="method" line="385" static="1">
			<f a="sprite:X:Y:Width:Height:Color:?lineStyle:?fillStyle:?drawStyle" v="::::::null:null:null">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This function draws an ellipse on a FlxSprite.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	X			X coordinate of the ellipse's start point.
	 * @param	Y			Y coordinate of the ellipse's start point.
	 * @param	Width		Width of the ellipse
	 * @param	Height		Height of the ellipse
	 * @param	Color		The ellipse's color.
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	fillStyle	A FillStyle typedef containing the params of Graphics.fillStyle()
	 * @param	drawStyle	A DrawStyle typdef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawEllipse>
		<drawTriangle public="1" set="method" line="406" static="1">
			<f a="sprite:X:Y:Height:Color:?lineStyle:?fillStyle:?drawStyle" v=":::::null:null:null">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This function draws a simple, equilateral triangle on a FlxSprite.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	X			X position of the triangle
	 * @param	Y			Y position of the triangle
	 * @param	Height		Height of the triangle
	 * @param	Color		Color of the triangle
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	fillStyle	A FillStyle typedef containing the params of Graphics.fillStyle()
	 * @param	drawStyle	A DrawStyle typdef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawTriangle>
		<drawPolygon public="1" set="method" line="428" static="1">
			<f a="sprite:Vertices:Color:?lineStyle:?fillStyle:?drawStyle" v=":::null:null:null">
				<c path="flixel.FlxSprite"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Int"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This function draws a polygon on a FlxSprite.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	Vertices	Array of Vertices to use for drawing the polygon
	 * @param	Color		Color of the polygon
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	fillStyle	A FillStyle typedef containing the params of Graphics.fillStyle();
	 * @param	drawStyle	A DrawStyle typdef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawPolygon>
		<beginDraw public="1" get="inline" set="null" line="449" static="1">
			<f a="Color:?lineStyle:?fillStyle" v=":null:null">
				<x path="Int"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.FillStyle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Helper function that the drawing functions use at the start to set the color and lineStyle.
	 * 
	 * @param	Color		The color to use for drawing
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	fillStyle	A FillStyle typedef containing the params of Graphics.fillStyle()</haxe_doc>
		</beginDraw>
		<endDraw public="1" get="inline" set="null" line="473" static="1">
			<f a="sprite:?drawStyle" v=":null">
				<c path="flixel.FlxSprite"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Helper function that the drawing functions use at the end.
	 * 
	 * @param	sprite		The FlxSprite to draw to
	 * @param	drawStyle	A DrawStyle typdef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</endDraw>
		<updateSpriteGraphic public="1" set="method" line="488" static="1">
			<f a="sprite:?drawStyle" v=":null">
				<c path="flixel.FlxSprite"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Just a helper function that is called at the end of the draw functions
	 * to handle a few things related to updating a sprite's graphic.
	 * 
	 * @param	Sprite		The FlxSprite to manipulate
	 * @param	drawStyle	A DrawStyle typdef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</updateSpriteGraphic>
		<setLineStyle public="1" get="inline" set="null" line="513" static="1">
			<f a="lineStyle">
				<t path="flixel.util.LineStyle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Just a helper function that is called in the draw functions
	 * to set the lineStyle via Graphics.lineStyle()
	 * 
	 * @param	lineStyle	The lineStyle typedef</haxe_doc>
		</setLineStyle>
		<fill public="1" set="method" line="552" static="1">
			<f a="sprite:Color">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Fills this sprite's graphic with a specific color.
	 * 
	 * @param	Sprite	The FlxSprite to manipulate
	 * @param	Color	The color with which to fill the graphic, format 0xAARRGGBB.
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</fill>
		<flicker public="1" get="inline" set="null" line="577" static="1">
			<f a="Object:?Duration:?Interval:?EndVisibility:?ForceRestart:?CompletionCallback:?ProgressCallback" v=":1:0.04f:true:true:null:null">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<c path="flixel.FlxObject"/>
			</f>
			<haxe_doc><![CDATA[* A simple flicker effect for sprites achieved by toggling visibility.
	 * 
	 * @param	Object				The sprite.
	 * @param	Duration			How long to flicker for. 0 means "forever".
	 * @param	Interval			In what interval to toggle visibility. Set to FlxG.elapsed if <= 0!
	 * @param	EndVisibility		Force the visible value when the flicker completes, useful with fast repetitive use.
	 * @param	ForceRestart		Force the flicker to restart from beginnig, discarding the flickering effect already in progress if there is one.
	 * @param	CompletionCallback	An optional callback that will be triggered when a flickering has finished.
	 * @param	ProgressCallback	An optional callback that will be triggered when visibility is toggled.
	 * @return	The FlxObject for chaining]]></haxe_doc>
		</flicker>
		<isFlickering public="1" get="inline" set="null" line="588" static="1">
			<f a="Object">
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether an object is flickering or not.
	 * 
	 * @param  Object 	The object to check against.</haxe_doc>
		</isFlickering>
		<stopFlickering public="1" get="inline" set="null" line="599" static="1">
			<f a="Object">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
			</f>
			<haxe_doc>* Stops flickering of the object. Also it will make the object visible.
	 * 
	 * @param  Object 	The object to stop flickering.
	 * @return The FlxObject for chaining</haxe_doc>
		</stopFlickering>
		<fadeIn public="1" get="inline" set="null" line="612" static="1">
			<f a="sprite:?Duration:?ResetAlpha:?OnComplete" v=":1:null:null">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.CompleteCallback"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Fade in a sprite.
	 * 
	 * @param  sprite 	The object to fade.
	 * @param  Duration How long the fade will take (in seconds).
	 * @return The FlxSprite for chaining</haxe_doc>
		</fadeIn>
		<fadeOut public="1" get="inline" set="null" line="629" static="1">
			<f a="sprite:?Duration:?FadeToBlack:?OnComplete" v=":1:null:null">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.CompleteCallback"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Fade out a sprite.
	 * 
	 * @param  sprite 	The object to fade.
	 * @param  Duration How long the fade will take (in seconds).
	 * @return The FlxSprite for chaining</haxe_doc>
		</fadeOut>
		<haxe_doc>* Some handy functions for FlxSprite manipulation, mostly drawing-related.
 * Some of these work with FlxObject too.</haxe_doc>
	</class>
	<typedef path="flixel.util.LineStyle" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSpriteUtil.hx" module="flixel.util.FlxSpriteUtil"><a>
	<thickness>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</thickness>
	<scaleMode>
		<e path="flash.display.LineScaleMode"/>
		<meta><m n=":optional"/></meta>
	</scaleMode>
	<pixelHinting>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</pixelHinting>
	<miterLimit>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</miterLimit>
	<jointStyle>
		<e path="flash.display.JointStyle"/>
		<meta><m n=":optional"/></meta>
	</jointStyle>
	<color>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</color>
	<capsStyle>
		<e path="flash.display.CapsStyle"/>
		<meta><m n=":optional"/></meta>
	</capsStyle>
</a></typedef>
	<typedef path="flixel.util.FillStyle" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSpriteUtil.hx" module="flixel.util.FlxSpriteUtil"><a>
	<hasFill>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</hasFill>
	<color>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</color>
	<alpha>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</alpha>
</a></typedef>
	<typedef path="flixel.util.DrawStyle" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxSpriteUtil.hx" module="flixel.util.FlxSpriteUtil"><a>
	<smoothing>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</smoothing>
	<matrix>
		<c path="flash.geom.Matrix"/>
		<meta><m n=":optional"/></meta>
	</matrix>
	<colorTransform>
		<c path="flash.geom.ColorTransform"/>
		<meta><m n=":optional"/></meta>
	</colorTransform>
	<clipRect>
		<c path="flash.geom.Rectangle"/>
		<meta><m n=":optional"/></meta>
	</clipRect>
	<blendMode>
		<e path="flash.display.BlendMode"/>
		<meta><m n=":optional"/></meta>
	</blendMode>
</a></typedef>
	<class path="flixel.util.FlxStringUtil" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxStringUtil.hx">
		<formatTicks public="1" get="inline" set="null" line="26" static="1">
			<f a="StartTicks:EndTicks">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Takes two "ticks" timestamps and formats them into the number of seconds that passed as a String.
	 * Useful for logging, debugging, the watch window, or whatever else.
	 * 
	 * @param	StartTicks	The first timestamp from the system.
	 * @param	EndTicks	The second timestamp from the system.
	 * @return	A String containing the formatted time elapsed information.</haxe_doc>
		</formatTicks>
		<formatTime public="1" get="inline" set="null" line="38" static="1">
			<f a="Seconds:?ShowMS" v=":false">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Format seconds as minutes with a colon, an optionally with milliseconds too.
	 * 
	 * @param	Seconds		The number of seconds (for example, time remaining, time spent, etc).
	 * @param	ShowMS		Whether to show milliseconds after a "." as well.  Default value is false.
	 * @return	A nicely formatted String, like "1:03".</haxe_doc>
		</formatTime>
		<formatArray public="1" get="inline" set="null" line="68" static="1">
			<f a="AnyArray">
				<c path="Array"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Generate a comma-separated string from an array.
	 * Especially useful for tracing or other debug output.
	 * 
	 * @param	AnyArray	Any Array object.
	 * @return	A comma-separated String containing the .toString() output of each element in the array.</haxe_doc>
		</formatArray>
		<formatStringMap public="1" get="inline" set="null" line="90" static="1">
			<f a="AnyMap">
				<x path="Map">
					<c path="String"/>
					<d/>
				</x>
				<c path="String"/>
			</f>
			<haxe_doc>* Generate a comma-seperated string representation of the keys of a StringMap.
	 * 
	 * @param  AnyMap    A StringMap object.
	 * @return  A String formatted like this: key1, key2, ..., keyX</haxe_doc>
		</formatStringMap>
		<formatMoney public="1" get="inline" set="null" line="112" static="1">
			<f a="Amount:?ShowDecimal:?EnglishStyle" v=":true:true">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Automatically commas and decimals in the right places for displaying money amounts.
	 * Does not include a dollar sign or anything, so doesn't really do much
	 * if you call say var results:String = FlxString.formatMoney(10,false);
	 * However, very handy for displaying large sums or decimal money values.
	 * 
	 * @param	Amount			How much moneys (in dollars, or the equivalent "main" currency - i.e. not cents).
	 * @param	ShowDecimal		Whether to show the decimals/cents component. Default value is true.
	 * @param	EnglishStyle	Major quantities (thousands, millions, etc) separated by commas, and decimal by a period.  Default value is true.
	 * @return	A nicely formatted String.  Does not include a dollar sign or anything!</haxe_doc>
		</formatMoney>
		<filterDigits public="1" set="method" line="166" static="1">
			<f a="Input">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Takes a string and filters out everything but the digits.
	 * 
	 * @param 	Input	The input string
	 * @return 	The output string, digits-only</haxe_doc>
		</filterDigits>
		<htmlFormat public="1" set="method" line="190" static="1">
			<f a="Text:?Size:?Color:?Bold:?Italic:?Underlined" v=":12:'FFFFFF':false:false:false">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Format a text with html tags - useful for TextField.htmlText. 
	 * Used by the log window of the debugger.
	 * 
	 * @param	Text		The text to format
	 * @param	Size		The text size, using the font-size-tag
	 * @param	Color		The text color, using font-color-tag
	 * @param	Bold		Whether the text should be bold (b-tag)
	 * @param	Italic		Whether the text should be italic (i-tag)
	 * @param	Underlined 	Whether the text should be underlined (u-tag)
	 * @return	The html-formatted text.</haxe_doc>
		</htmlFormat>
		<getClassName public="1" get="inline" set="null" line="222" static="1">
			<f a="Obj:?Simple" v=":false">
				<d/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":extern"/></meta>
			<haxe_doc>* Get the String name of any Object.
	 * 
	 * @param	Obj		The object in question.
	 * @param	Simple	Returns only the class name, not the package or packages.
	 * @return	The name of the Class as a String object.</haxe_doc>
		</getClassName>
		<getDomain public="1" set="method" line="249" static="1">
			<f a="url">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns the domain of a URL.</haxe_doc>
		</getDomain>
		<sameClassName public="1" get="inline" set="null" line="269" static="1">
			<f a="Obj1:Obj2:?Simple" v="::true">
				<d/>
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Helper function that uses getClassName to compare two objects' class names.
	 * 
	 * @param	Obj1	The first object
	 * @param	Obj2	The second object
	 * @param	Simple 	Only uses the class name, not the package or packages.
	 * @return	Whether they have the same class name or not</haxe_doc>
		</sameClassName>
		<toIntArray public="1" set="method" line="281" static="1">
			<f a="Data">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Split a comma-separated string into an array of ints
	 * 
	 * @param	Data 	String formatted like this: "1, 2, 5, -10, 120, 27"
	 * @return	An array of ints</haxe_doc>
		</toIntArray>
		<toFloatArray public="1" set="method" line="302" static="1">
			<f a="Data">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Split a comma-separated string into an array of floats
	 * 
	 * @param	Data string formatted like this: "1.0,2.1,5.6,1245587.9, -0.00354"
	 * @return	An array of floats</haxe_doc>
		</toFloatArray>
		<arrayToCSV public="1" set="method" line="325" static="1">
			<f a="Data:Width:?Invert" v="::false">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts a one-dimensional array of tile data to a comma-separated string.
	 * 
	 * @param	Data		An array full of integer tile references.
	 * @param	Width		The number of tiles in each row.
	 * @param	Invert		Recommended only for 1-bit arrays - changes 0s to 1s and vice versa.
	 * @return	A comma-separated string containing the level data in a FlxTilemap-friendly format.</haxe_doc>
		</arrayToCSV>
		<bitmapToCSV public="1" set="method" line="390" static="1">
			<f a="Bitmap:?Invert:?Scale:?ColorMap" v=":false:1:null">
				<c path="flash.display.BitmapData"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts a BitmapData object to a comma-separated string. Black pixels are flagged as 'solid' by default,
	 * non-black pixels are set as non-colliding. Black pixels must be PURE BLACK.
	 * 
	 * @param	Bitmap		A Flash BitmapData object, preferably black and white.
	 * @param	Invert		Load white pixels as solid instead.
	 * @param	Scale		Default is 1.  Scale of 2 means each pixel forms a 2x2 block of tiles, and so on.
	 * @param  	ColorMap  	An array of color values (0xAARRGGBB) in the order they're intended to be assigned as indices
	 * @return	A comma-separated string containing the level data in a FlxTilemap-friendly format.</haxe_doc>
		</bitmapToCSV>
		<imageToCSV public="1" set="method" line="495" static="1">
			<f a="ImageFile:?Invert:?Scale" v=":false:1">
				<d/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts a resource image file to a comma-separated string. Black pixels are flagged as 'solid' by default,
	 * non-black pixels are set as non-colliding. Black pixels must be PURE BLACK.
	 * 
	 * @param	ImageFile	An embedded graphic, preferably black and white.
	 * @param	Invert		Load white pixels as solid instead.
	 * @param	Scale		Default is 1.  Scale of 2 means each pixel forms a 2x2 block of tiles, and so on.
	 * @return	A comma-separated string containing the level data in a FlxTilemap-friendly format.</haxe_doc>
		</imageToCSV>
		<getDebugString public="1" set="method" line="517" static="1">
			<f a="LabelValuePairs">
				<c path="Array"><c path="flixel.util.LabelValuePair"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Helper function to create a string for toString() functions. Automatically rounds values according to FlxG.debugger.precision.
	 * Strings are formatted in the format: (x: 50 | y: 60 | visible: false)
	 * 
	 * @param	LabelValuePairs		Array with the data for the string</haxe_doc>
		</getDebugString>
		<haxe_doc>* A class primarily containing functions related 
 * to formatting different data types to strings.</haxe_doc>
	</class>
	<class path="flixel.util.LabelValuePair" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxStringUtil.hx" module="flixel.util.FlxStringUtil">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<_pool line="539" static="1"><c path="flixel.util.FlxPool_flixel_util_LabelValuePair"/></_pool>
		<weak public="1" get="inline" set="null" line="541" static="1"><f a="label:value">
	<c path="String"/>
	<d/>
	<c path="flixel.util.LabelValuePair"/>
</f></weak>
		<label public="1"><c path="String"/></label>
		<value public="1"><d/></value>
		<create public="1" get="inline" set="null" line="549"><f a="label:value">
	<c path="String"/>
	<d/>
	<c path="flixel.util.LabelValuePair"/>
</f></create>
		<put public="1" get="inline" set="null" line="556"><f a=""><x path="Void"/></f></put>
		<destroy public="1" get="inline" set="null" line="561"><f a=""><x path="Void"/></f></destroy>
		<new set="method" line="567"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util.FlxVector" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxVector.hx">
		<extends path="flixel.util.FlxPoint"/>
		<EPSILON public="1" get="inline" set="null" line="8" static="1"><x path="Float"/></EPSILON>
		<EPSILON_SQUARED public="1" get="inline" set="null" line="9" static="1"><x path="Float"/></EPSILON_SQUARED>
		<_pool line="11" static="1"><c path="flixel.util.FlxPool_flixel_util_FlxVector"/></_pool>
		<_vector1 line="13" static="1"><c path="flixel.util.FlxVector"/></_vector1>
		<_vector2 line="14" static="1"><c path="flixel.util.FlxVector"/></_vector2>
		<_vector3 line="15" static="1"><c path="flixel.util.FlxVector"/></_vector3>
		<get public="1" get="inline" set="null" line="24" static="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Recycle or create new FlxVector.
	 * Be sure to put() them back into the pool after you're done with them!
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.</haxe_doc>
		</get>
		<put public="1" set="method" line="34" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this FlxVector to the recycling pool.</haxe_doc>
		</put>
		<dx public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The horizontal component of the unit vector</haxe_doc>
		</dx>
		<dy public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The vertical component of the unit vector</haxe_doc>
		</dy>
		<length public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Length of the vector</haxe_doc>
		</length>
		<lengthSquared public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* length of the vector squared</haxe_doc>
		</lengthSquared>
		<degrees public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The angle formed by the vector with the horizontal axis (in degrees)</haxe_doc>
		</degrees>
		<radians public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The angle formed by the vector with the horizontal axis (in radians)</haxe_doc>
		</radians>
		<rx public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The horizontal component of the right normal of the vector</haxe_doc>
		</rx>
		<ry public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The vertical component of the right normal of the vector</haxe_doc>
		</ry>
		<lx public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The horizontal component of the left normal of the vector</haxe_doc>
		</lx>
		<ly public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The vertical component of the left normal of the vector</haxe_doc>
		</ly>
		<set public="1" set="method" line="90" override="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Set the coordinates of this point object.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.</haxe_doc>
		</set>
		<scale public="1" get="inline" set="null" line="103">
			<f a="k">
				<x path="Float"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Scale this vector.
	 * 
	 * @param	k - scale coefficient
	 * @return	scaled vector</haxe_doc>
		</scale>
		<scaleNew public="1" get="inline" set="null" line="116">
			<f a="k">
				<x path="Float"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Returns scaled copy of this vector.
	 * 
	 * @param	k - scale coefficient
	 * @return	scaled vector</haxe_doc>
		</scaleNew>
		<addNew public="1" get="inline" set="null" line="127">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Return new vector which equals to sum of this vector and passed v vector.
	 * 
	 * @param	v	vector to add
	 * @return	addition result</haxe_doc>
		</addNew>
		<subtractNew public="1" get="inline" set="null" line="140">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Returns new vector which is result of subtraction of v vector from this vector.
	 * 
	 * @param	v	vector to subtract
	 * @return	subtraction result</haxe_doc>
		</subtractNew>
		<dotProduct public="1" get="inline" set="null" line="153">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Dot product between two vectors.
	 * 
	 * @param	v	vector to multiply
	 * @return	dot product of two vectors</haxe_doc>
		</dotProduct>
		<dotProdWithNormalizing public="1" get="inline" set="null" line="164">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Dot product of vectors with normalization of the second vector.
	 * 
	 * @param	v	vector to multiply
	 * @return	dot product of two vectors</haxe_doc>
		</dotProdWithNormalizing>
		<isPerpendicular public="1" get="inline" set="null" line="176">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check the perpendicularity of two vectors.
	 * 
	 * @param	v	vector to check
	 * @return	true - if they are perpendicular</haxe_doc>
		</isPerpendicular>
		<crossProductLength public="1" get="inline" set="null" line="187">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the length of cross product between two vectors.
	 * 
	 * @param	v	vector to multiply
	 * @return	the length of cross product of two vectors</haxe_doc>
		</crossProductLength>
		<isParallel public="1" get="inline" set="null" line="198">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check for parallelism of two vectors.
	 * 
	 * @param	v	vector to check
	 * @return	true - if they are parallel</haxe_doc>
		</isParallel>
		<isZero public="1" get="inline" set="null" line="208">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if this vector has zero length.
	 * 
	 * @return	true - if the vector is zero</haxe_doc>
		</isZero>
		<zero public="1" get="inline" set="null" line="216">
			<f a=""><c path="flixel.util.FlxVector"/></f>
			<haxe_doc>* Vector reset</haxe_doc>
		</zero>
		<normalize public="1" set="method" line="225">
			<f a=""><c path="flixel.util.FlxVector"/></f>
			<haxe_doc>* Normalization of the vector (reduction to unit length)</haxe_doc>
		</normalize>
		<isNormalized public="1" get="inline" set="null" line="238">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check the vector for unit length</haxe_doc>
		</isNormalized>
		<equals public="1" get="inline" set="null" line="248">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checking for equality of vectors.
	 * 
	 * @return	true - if the vectors are equal</haxe_doc>
		</equals>
		<rotateByRadians public="1" get="inline" set="null" line="259">
			<f a="rads">
				<x path="Float"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Rotate the vector for a given angle.
	 * 
	 * @param	rads	angle to rotate
	 * @return	rotated vector</haxe_doc>
		</rotateByRadians>
		<rotateByDegrees public="1" get="inline" set="null" line="277">
			<f a="degs">
				<x path="Float"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Rotate the vector for a given angle.
	 * 
	 * @param	rads	angle to rotate
	 * @return	rotated vector</haxe_doc>
		</rotateByDegrees>
		<rotateWithTrig public="1" get="inline" set="null" line="289">
			<f a="sin:cos">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Rotate the vector vector with the values of sine and cosine of the angle of rotation.
	 * 
	 * @param	sin	the value of sine of the angle of rotation
	 * @param	cos	the value of cosine of the angle of rotation
	 * @return	rotated vector</haxe_doc>
		</rotateWithTrig>
		<rightNormal public="1" set="method" line="300">
			<f a="?vec" v="null">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Right normal of the vector</haxe_doc>
		</rightNormal>
		<leftNormal public="1" set="method" line="313">
			<f a="?vec" v="null">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Left normal of the vector</haxe_doc>
		</leftNormal>
		<negate public="1" get="inline" set="null" line="326">
			<f a=""><c path="flixel.util.FlxVector"/></f>
			<haxe_doc>* Change direction of the vector to opposite</haxe_doc>
		</negate>
		<negateNew public="1" get="inline" set="null" line="333"><f a=""><c path="flixel.util.FlxVector"/></f></negateNew>
		<projectTo public="1" set="method" line="346">
			<f a="v:?proj" v=":null">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* The projection of this vector to vector that is passed as an argument 
	 * (without modifying the original Vector!).
	 * 
	 * @param	v	vector to project
	 * @param	proj	optional argument - result vector
	 * @return	projection of the vector</haxe_doc>
		</projectTo>
		<projectToNormalized public="1" set="method" line="366">
			<f a="v:?proj" v=":null">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Projecting this vector on the normalized vector v.
	 * 
	 * @param	v	this vector has to be normalized, ie have unit length
	 * @param	proj	optional argument - result vector
	 * @return	projection of the vector</haxe_doc>
		</projectToNormalized>
		<perpProduct public="1" get="inline" set="null" line="381">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Dot product of left the normal vector and vector v</haxe_doc>
		</perpProduct>
		<ratio public="1" set="method" line="394">
			<f a="a:b:v">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the ratio between the perpProducts of this vector and v vector. This helps to find the intersection point.
	 * 
	 * @param	a	start point of the vector
	 * @param	b	start point of the v vector
	 * @param	v	the second vector
	 * @return	the ratio between the perpProducts of this vector and v vector</haxe_doc>
		</ratio>
		<findIntersection public="1" set="method" line="413">
			<f a="a:b:v:?intersection" v=":::null">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Finding the point of intersection of vectors.
	 * 
	 * @param	a	start point of the vector
	 * @param	b	start point of the v vector
	 * @param	v	the second vector
	 * @return the point of intersection of vectors</haxe_doc>
		</findIntersection>
		<findIntersectionInBounds public="1" set="method" line="438">
			<f a="a:b:v:?intersection" v=":::null">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Finding the point of intersection of vectors if it is in the "bounds" of the vectors.
	 * 
	 * @param	a	start point of the vector
	 * @param	b	start point of the v vector
	 * @param	v	the second vector
	 * @return the point of intersection of vectors if it is in the "bounds" of the vectors</haxe_doc>
		</findIntersectionInBounds>
		<truncate public="1" get="inline" set="null" line="460">
			<f a="max">
				<x path="Float"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Limit the length of this vector.
	 * 
	 * @param	max	maximum length of this vector</haxe_doc>
		</truncate>
		<radiansBetween public="1" get="inline" set="null" line="472">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get the angle between vectors (in radians).
	 * 
	 * @param	v	second vector, which we find the angle
	 * @return	the angle in radians</haxe_doc>
		</radiansBetween>
		<degreesBetween public="1" get="inline" set="null" line="494">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* The angle between vectors (in degrees).
	 * 
	 * @param	v	second vector, which we find the angle
	 * @return	the angle in radians</haxe_doc>
		</degreesBetween>
		<sign public="1" set="method" line="505">
			<f a="a:b">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* The sign of half-plane of point with respect to the vector through the a and b points.
	 * 
	 * @param	a	start point of the wall-vector
	 * @param	b	end point of the wall-vector</haxe_doc>
		</sign>
		<dist public="1" get="inline" set="null" line="518">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* The distance between points</haxe_doc>
		</dist>
		<distSquared public="1" get="inline" set="null" line="526">
			<f a="v">
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* The squared distance between points</haxe_doc>
		</distSquared>
		<bounce public="1" get="inline" set="null" line="540">
			<f a="normal:?bounceCoeff" v=":1">
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc><![CDATA[* Reflect the vector with respect to the normal of the "wall".
	 * 
	 * @param normal left normal of the "wall". It must be normalized (no checks)
	 * @param bounceCoeff bounce coefficient (0 <= bounceCoeff <= 1)
	 * @return reflected vector (angle of incidence equals to angle of reflection)]]></haxe_doc>
		</bounce>
		<bounceWithFriction public="1" get="inline" set="null" line="556">
			<f a="normal:?bounceCoeff:?friction" v=":1:0">
				<c path="flixel.util.FlxVector"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc><![CDATA[* Reflect the vector with respect to the normal. This operation takes "friction" into account.
	 * 
	 * @param normal left normal of the "wall". It must be normalized (no checks)
	 * @param bounceCoeff bounce coefficient (0 <= bounceCoeff <= 1)
	 * @param friction friction coefficient
	 * @return reflected vector]]></haxe_doc>
		</bounceWithFriction>
		<isValid public="1" get="inline" set="null" line="574">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Checking if this is a valid vector.
	 * 
	 * @return	true - if the vector is valid</haxe_doc>
		</isValid>
		<clone public="1" set="method" line="585">
			<f a="?vec" v="null">
				<c path="flixel.util.FlxVector"/>
				<c path="flixel.util.FlxVector"/>
			</f>
			<haxe_doc>* Copies this vector.
	 * 
	 * @param	vec		optional vector to copy this vector to
	 * @return	copy	of this vector</haxe_doc>
		</clone>
		<get_dx get="inline" set="null" line="597"><f a=""><x path="Float"/></f></get_dx>
		<get_dy get="inline" set="null" line="604"><f a=""><x path="Float"/></f></get_dy>
		<get_length get="inline" set="null" line="611"><f a=""><x path="Float"/></f></get_length>
		<set_length get="inline" set="null" line="616"><f a="l">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<get_lengthSquared get="inline" set="null" line="624"><f a=""><x path="Float"/></f></get_lengthSquared>
		<get_degrees get="inline" set="null" line="629"><f a=""><x path="Float"/></f></get_degrees>
		<set_degrees get="inline" set="null" line="634"><f a="degs">
	<x path="Float"/>
	<x path="Float"/>
</f></set_degrees>
		<get_radians set="method" line="640"><f a=""><x path="Float"/></f></get_radians>
		<set_radians get="inline" set="null" line="647"><f a="rads">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radians>
		<get_rx get="inline" set="null" line="656"><f a=""><x path="Float"/></f></get_rx>
		<get_ry get="inline" set="null" line="661"><f a=""><x path="Float"/></f></get_ry>
		<get_lx get="inline" set="null" line="666"><f a=""><x path="Float"/></f></get_lx>
		<get_ly get="inline" set="null" line="671"><f a=""><x path="Float"/></f></get_ly>
		<new public="1" set="method" line="6"><f a="?X:?Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* 2-dimensional vector class</haxe_doc>
	</class>
	<class path="flixel.util.FlxVelocity" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/FlxVelocity.hx">
		<moveTowardsObject public="1" set="method" line="24" static="1">
			<f a="Source:Dest:?Speed:?MaxTime" v="::60:0">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the source FlxSprite x/y velocity so it will move directly towards the destination FlxSprite at the speed given (in pixels per second)
	 * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * If you need the object to accelerate, see accelerateTowardsObject() instead
	 * Note: Doesn't take into account acceleration, maxVelocity or drag (if you set drag or acceleration too high this object may not move at all)
	 * 
	 * @param	Source		The FlxSprite on which the velocity will be set
	 * @param	Dest		The FlxSprite where the source object will move to
	 * @param	Speed		The speed it will move, in pixels per second (default is 60 pixels/sec)
	 * @param	MaxTime		Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the source will arrive at destination in the given number of ms</haxe_doc>
		</moveTowardsObject>
		<accelerateTowardsObject public="1" set="method" line="51" static="1">
			<f a="Source:Dest:Speed:MaxXSpeed:MaxYSpeed">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the x/y acceleration on the source FlxSprite so it will move towards the destination FlxSprite at the speed given (in pixels per second)
	 * You must give a maximum speed value, beyond which the FlxSprite won't go any faster.
	 * If you don't need acceleration look at moveTowardsObject() instead.
	 * 
	 * @param	Source			The FlxSprite on which the acceleration will be set
	 * @param	Dest			The FlxSprite where the source object will move towards
	 * @param	Speed			The speed it will accelerate in pixels per second
	 * @param	MaxXSpeed		The maximum speed in pixels per second in which the sprite can move horizontally
	 * @param	MaxYSpeed		The maximum speed in pixels per second in which the sprite can move vertically</haxe_doc>
		</accelerateTowardsObject>
		<moveTowardsMouse public="1" set="method" line="76" static="1">
			<f a="Source:?Speed:?MaxTime" v=":60:0">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the given FlxSprite towards the mouse pointer coordinates at a steady velocity
	 * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * 
	 * @param	Source		The FlxSprite to move
	 * @param	Speed		The speed it will move, in pixels per second (default is 60 pixels/sec)
	 * @param	MaxTime		Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the source will arrive at destination in the given number of ms</haxe_doc>
		</moveTowardsMouse>
		<moveTowardsTouch public="1" set="method" line="104" static="1">
			<f a="Source:Touch:?Speed:?MaxTime" v="::60:0">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the given FlxSprite towards a FlxTouch point at a steady velocity
	 * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * 
	 * @param	source			The FlxSprite to move
	 * @param	speed				The speed it will move, in pixels per second (default is 60 pixels/sec)
	 * @param	maxTime		Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the source will arrive at destination in the given number of ms</haxe_doc>
		</moveTowardsTouch>
		<accelerateTowardsMouse public="1" set="method" line="132" static="1">
			<f a="Source:Speed:MaxXSpeed:MaxYSpeed">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the x/y acceleration on the source FlxSprite so it will move towards the mouse coordinates at the speed given (in pixels per second)
	 * You must give a maximum speed value, beyond which the FlxSprite won't go any faster.
	 * If you don't need acceleration look at moveTowardsMouse() instead.
	 * 
	 * @param	Source			The FlxSprite on which the acceleration will be set
	 * @param	Speed			The speed it will accelerate in pixels per second
	 * @param	MaxXSpeed		The maximum speed in pixels per second in which the sprite can move horizontally
	 * @param	MaxYSpeed		The maximum speed in pixels per second in which the sprite can move vertically</haxe_doc>
		</accelerateTowardsMouse>
		<accelerateTowardsTouch public="1" set="method" line="159" static="1">
			<f a="Source:Touch:Speed:MaxXSpeed:MaxYSpeed">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the x/y acceleration on the source FlxSprite so it will move towards a FlxTouch at the speed given (in pixels per second)
	 * You must give a maximum speed value, beyond which the FlxSprite won't go any faster.
	 * If you don't need acceleration look at moveTowardsMouse() instead.
	 * 
	 * @param	Source			The FlxSprite on which the acceleration will be set
	 * @param	Touch			The FlxTouch on which to accelerate towards
	 * @param	Speed			The speed it will accelerate in pixels per second
	 * @param	MaxXSpeed		The maximum speed in pixels per second in which the sprite can move horizontally
	 * @param	MaxYSpeed		The maximum speed in pixels per second in which the sprite can move vertically</haxe_doc>
		</accelerateTowardsTouch>
		<moveTowardsPoint public="1" set="method" line="185" static="1">
			<f a="Source:Target:?Speed:?MaxTime" v="::60:0">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the x/y velocity on the source FlxSprite so it will move towards the target coordinates at the speed given (in pixels per second)
	 * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * 
	 * @param	Source		The FlxSprite to move
	 * @param	Target		The FlxPoint coordinates to move the source FlxSprite towards
	 * @param	Speed		The speed it will move, in pixels per second (default is 60 pixels/sec)
	 * @param	MaxTime		Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the source will arrive at destination in the given number of ms</haxe_doc>
		</moveTowardsPoint>
		<accelerateTowardsPoint public="1" set="method" line="214" static="1">
			<f a="Source:Target:Speed:MaxXSpeed:MaxYSpeed">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the x/y acceleration on the source FlxSprite so it will move towards the target coordinates at the speed given (in pixels per second)
	 * You must give a maximum speed value, beyond which the FlxSprite won't go any faster.
	 * If you don't need acceleration look at moveTowardsPoint() instead.
	 * 
	 * @param	Source			The FlxSprite on which the acceleration will be set
	 * @param	Target			The FlxPoint coordinates to move the source FlxSprite towards
	 * @param	Speed			The speed it will accelerate in pixels per second
	 * @param	MaxXSpeed		The maximum speed in pixels per second in which the sprite can move horizontally
	 * @param	MaxYSpeed		The maximum speed in pixels per second in which the sprite can move vertically</haxe_doc>
		</accelerateTowardsPoint>
		<velocityFromAngle public="1" get="inline" set="null" line="237" static="1">
			<f a="Angle:Speed">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Given the angle and speed calculate the velocity and return it as an FlxPoint
	 * 
	 * @param	Angle	The angle (in degrees) calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * @param	Speed	The speed it will move, in pixels per second sq
	 * @return	A FlxPoint where FlxPoint.x contains the velocity x value and FlxPoint.y contains the velocity y value</haxe_doc>
		</velocityFromAngle>
		<velocityFromFacing public="1" set="method" line="256" static="1">
			<f a="Parent:Speed">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Given the FlxSprite and speed calculate the velocity and return it as an FlxPoint based on the direction the sprite is facing
	 * 
	 * @param	Parent	The FlxSprite to get the facing value from
	 * @param	Speed	The speed it will move, in pixels per second
	 * @return	An FlxPoint where FlxPoint.x contains the velocity x value and FlxPoint.y contains the velocity y value</haxe_doc>
		</velocityFromFacing>
		<computeVelocity public="1" set="method" line="294" static="1">
			<f a="Velocity:Acceleration:Drag:Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* A tween-like function that takes a starting velocity and some other factors and returns an altered velocity.
	 * 
	 * @param	Velocity		Any component of velocity (e.g. 20).
	 * @param	Acceleration	Rate at which the velocity is changing.
	 * @param	Drag			Really kind of a deceleration, this is how much the velocity changes if Acceleration is not set.
	 * @param	Max				An absolute value cap for the velocity (0 for no cap).
	 * @return	The altered Velocity value.</haxe_doc>
		</computeVelocity>
	</class>
	<class path="flixel.util.loaders.CachedGraphics" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/loaders/CachedGraphics.hx">
		<key public="1">
			<c path="String"/>
			<haxe_doc>* Key in BitmapFrontEnd cache</haxe_doc>
		</key>
		<bitmap public="1">
			<c path="flash.display.BitmapData"/>
			<haxe_doc>* Cached BitmapData object</haxe_doc>
		</bitmap>
		<assetsKey public="1">
			<c path="String"/>
			<haxe_doc>* Asset name from openfl.Assets</haxe_doc>
		</assetsKey>
		<assetsClass public="1">
			<x path="Class"><c path="flash.display.BitmapData"/></x>
			<haxe_doc>* Class name for the BitmapData</haxe_doc>
		</assetsClass>
		<data public="1">
			<c path="flixel.util.loaders.TexturePackerData"/>
			<haxe_doc>* TexturePackerData associated with the BitmapData</haxe_doc>
		</data>
		<persist public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether this cached object should stay in cache after state changes or not.</haxe_doc>
		</persist>
		<destroyOnNoUse public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether we should destroy this CachedGraphics object when useCount become zero.
	 * Default is false.</haxe_doc>
		</destroyOnNoUse>
		<isDumped public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the BitmapData of this cached object has been dumped or not.</haxe_doc>
		</isDumped>
		<canBeDumped public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the BitmapData of this cached object can be dumped for decreased memory usage.</haxe_doc>
		</canBeDumped>
		<tilesheet public="1" get="accessor" set="null"><c path="flixel.system.layer.TileSheetData"/></tilesheet>
		<useCount public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Usage counter for this CachedGraphics object.</haxe_doc>
		</useCount>
		<_tilesheet><c path="flixel.system.layer.TileSheetData"/></_tilesheet>
		<dump public="1" set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dumps bits of bitmapdata = less memory, but you can't read / write pixels on it anymore 
	 * (but you can call onContext() method which will restore it again)</haxe_doc>
		</dump>
		<undump public="1" set="method" line="86">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Undumps bits of bitmapdata - regenerates it and regenerate tilesheet data for this object</haxe_doc>
		</undump>
		<onContext public="1" set="method" line="112">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this method to restore cached bitmapdata (if it's possible).
	 * It's called automatically when the RESIZE event occurs.</haxe_doc>
		</onContext>
		<getRegionForFrame public="1" set="method" line="122"><f a="FrameName">
	<c path="String"/>
	<c path="flixel.util.loaders.TextureRegion"/>
</f></getRegionForFrame>
		<destroy public="1" set="method" line="138"><f a=""><x path="Void"/></f></destroy>
		<get_tilesheet set="method" line="148"><f a=""><c path="flixel.system.layer.TileSheetData"/></f></get_tilesheet>
		<getBitmapFromSystem set="method" line="163"><f a=""><c path="flash.display.BitmapData"/></f></getBitmapFromSystem>
		<get_canBeDumped get="inline" set="null" line="178"><f a=""><x path="Bool"/></f></get_canBeDumped>
		<set_useCount set="method" line="183"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_useCount>
		<set_destroyOnNoUse set="method" line="193"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_destroyOnNoUse>
		<new public="1" set="method" line="61"><f a="Key:Bitmap:?Persist" v="::false">
	<c path="String"/>
	<c path="flash.display.BitmapData"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.util.loaders.TexturePackerData" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/loaders/TexturePackerData.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<frames public="1"><c path="Array"><c path="flixel.util.loaders.TextureAtlasFrame"/></c></frames>
		<assetName public="1"><c path="String"/></assetName>
		<description public="1"><c path="String"/></description>
		<asset public="1"><c path="flash.display.BitmapData"/></asset>
		<parseData public="1" set="method" line="39">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Data parsing method.
	 * Override it in subclasses if you want to implement support for new atlas formats</haxe_doc>
		</parseData>
		<destroy public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Memory cleaning method</haxe_doc>
		</destroy>
		<new public="1" set="method" line="25">
			<f a="Description:AssetName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * 
	 * @param	Description		Name of the data file with atlas description
	 * @param	AssetName		Name of the atlas image file</haxe_doc>
		</new>
	</class>
	<class path="flixel.util.loaders.LibGDXData" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/loaders/LibGDXData.hx">
		<extends path="flixel.util.loaders.TexturePackerData"/>
		<parseData public="1" set="method" line="28" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Data parsing method.
	 * Override it in subclasses if you want to implement support for new atlas formats</haxe_doc>
		</parseData>
		<getDimensions set="method" line="101"><f a="line:size">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></getDimensions>
		<new public="1" set="method" line="19">
			<f a="Description:AssetName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * 
	 * @param	Description		Name of the data file with atlas description
	 * @param	AssetName		Name of the atlas image file</haxe_doc>
		</new>
	</class>
	<class path="flixel.util.loaders.SparrowData" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/loaders/SparrowData.hx">
		<extends path="flixel.util.loaders.TexturePackerData"/>
		<parseData public="1" set="method" line="29" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Data parsing method.
	 * Override it in subclasses if you want to implement support for new atlas formats</haxe_doc>
		</parseData>
		<new public="1" set="method" line="20">
			<f a="Description:AssetName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * 
	 * @param	Description		Name of the data file with atlas description
	 * @param	AssetName		Name of the atlas image file</haxe_doc>
		</new>
	</class>
	<class path="flixel.util.loaders.TextureAtlasFrame" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/loaders/TextureAtlasFrame.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<name public="1"><c path="String"/></name>
		<frame public="1"><c path="flash.geom.Rectangle"/></frame>
		<rotated public="1"><x path="Bool"/></rotated>
		<trimmed public="1"><x path="Bool"/></trimmed>
		<sourceSize public="1"><c path="flixel.util.FlxPoint"/></sourceSize>
		<offset public="1"><c path="flixel.util.FlxPoint"/></offset>
		<additionalAngle public="1"><x path="Int"/></additionalAngle>
		<destroy public="1" set="method" line="21"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util.loaders.TexturePackerXMLData" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/loaders/TexturePackerXMLData.hx">
		<extends path="flixel.util.loaders.TexturePackerData"/>
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<parseData public="1" set="method" line="29" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Data parsing method.
	 * Override it in subclasses if you want to implement support for new atlas formats</haxe_doc>
		</parseData>
		<new public="1" set="method" line="20">
			<f a="Description:AssetName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * 
	 * @param	Description		Name of the data file with atlas description
	 * @param	AssetName		Name of the atlas image file</haxe_doc>
		</new>
	</class>
	<class path="flixel.util.loaders.TextureRegion" params="" file="C:\HaxeToolkit\haxe\lib/flixel/git/flixel/util/loaders/TextureRegion.hx">
		<implements path="flixel.interfaces.IFlxDestroyable"/>
		<data public="1"><c path="flixel.util.loaders.CachedGraphics"/></data>
		<region public="1"><c path="flixel.system.layer.Region"/></region>
		<clone public="1" get="inline" set="null" line="22"><f a=""><c path="flixel.util.loaders.TextureRegion"/></f></clone>
		<destroy public="1" set="method" line="27"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="12"><f a="data:?startX:?startY:?tileWidth:?tileHeight:?spacingX:?spacingY:?width:?height" v=":0:0:0:0:0:0:0:0">
	<c path="flixel.util.loaders.CachedGraphics"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="haxe.StackItem" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<LocalFunction a="v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
	</enum>
	<class path="haxe.CallStack" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx">
		<callStack public="1" set="method" line="43" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="115" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<meta><m n=":noStack"/></meta>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="170" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
		</toString>
		<itemToString set="method" line="179" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
		<makeStack set="method" line="206" static="1">
			<f a="s">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":noStack"/></meta>
		</makeStack>
		<haxe_doc>Get informations about the call stack.</haxe_doc>
	</class>
	<class path="haxe.EnumTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.
		
		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `e` has no package, the enum name is returned.
		
		If `e` is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params" v="::null">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params" v="::null">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.
		
		The result String does not contain any constructor arguments.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.
		
		If `e` has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.
		
		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<class path="haxe.Json" params="" file="C:\HaxeToolkit\haxe\std/haxe/Json.hx">
		<parse public="1" get="inline" set="null" line="39" static="1">
			<f a="text">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `text` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into Array<Dynamic>.

		If given `text` is not valid JSON, an exception will be thrown.]]></haxe_doc>
		</parse>
		<stringify public="1" get="inline" set="null" line="50" static="1">
			<f a="value:?replacer" v=":null">
				<d/>
				<f a=":">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes given `value` and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve
		actual object to be encoded. The `replacer` function two parameters,
		the key and the value being encoded. Initial key value is an empty string.</haxe_doc>
		</stringify>
		<haxe_doc>Crossplatform JSON API : it will automatically use the optimized native API if available.
	Use -D haxeJSON to force usage of the Haxe implementation even if a native API is found : this will provide
	extra encoding features such as enums (replaced by their index) and StringMaps.</haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\HaxeToolkit\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.
	
	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.
	
	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Resource" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/haxe/Resource.hx">
		<listNames public="1" set="method" line="27" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Lists all available resource names. The resource name is the name part
		of the -resource file@name command line parameter.</haxe_doc>
		</listNames>
		<getString public="1" set="method" line="30" static="1">
			<f a="name">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Retrieves the resource identified by `name` as a String.

		If `name` does not match any resource name, null is returned.</haxe_doc>
		</getString>
		<getBytes public="1" set="method" line="33" static="1">
			<f a="name">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Retrieves the resource identified by `name` as an instance of
		haxe.io.Bytes.

		If `name` does not match any resource name, null is returned.</haxe_doc>
		</getBytes>
		<haxe_doc>Resource can be used to access resources that were added through the
	-resource file@name command line parameter.

	Depending on their type they can be obtained as String through
	getString(name), or as binary data through getBytes(name).

	A list of all available resource names can be obtained from listNames().</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.Serializer" params="" file="C:\HaxeToolkit\haxe\std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="55" static="1">
			<x path="Bool"/>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set USE_CACHE to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="67" static="1">
			<x path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="69" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="526" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="115">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		http://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="150"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="169"><f a="v">
	<unknown/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="206"><f a="v">
	<unknown/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="224">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<serializeException public="1" set="method" line="503"><f a="e">
	<d/>
	<x path="Void"/>
</f></serializeException>
		<new public="1" set="method" line="100">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc>The Serializer class can be used to encode values and objects into a String,
	from which the Unserializer class can recreate the original representation.

	This class can be used in two ways:
	
	- create a new Serializer() instance, call its serialize() method with
		any argument and finally retrieve the String representation from
		toString()
	- call Serializer.run() to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	`http://haxe.org/manual/serialization/format`</haxe_doc>
	</class>
	<class path="haxe.Timer" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/haxe/Timer.hx">
		<sRunningTimers line="101" static="1"><c path="Array"><c path="haxe.Timer"/></c></sRunningTimers>
		<delay public="1" set="method" line="118" static="1"><f a="f:time">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<getMS set="method" line="134" static="1"><f a=""><x path="Float"/></f></getMS>
		<measure public="1" params="T" set="method" line="141" static="1"><f a="f:?pos" v=":null">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<stamp public="1" set="method" line="158" static="1"><f a=""><x path="Float"/></f></stamp>
		<__checkTimers public="1" set="method" line="199" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__checkTimers>
		<__nextWake public="1" set="method" line="228" static="1">
			<f a="limit">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__nextWake>
		<lime_time_stamp line="266" static="1"><f a=""><x path="Float"/></f></lime_time_stamp>
		<mTime><x path="Float"/></mTime>
		<mFireAt><x path="Float"/></mFireAt>
		<mRunning><x path="Bool"/></mRunning>
		<run public="1" set="dynamic" line="151"><f a=""><x path="Void"/></f></run>
		<stop public="1" set="method" line="165"><f a=""><x path="Void"/></f></stop>
		<__check set="method" line="187">
			<f a="inTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__check>
		<new public="1" set="method" line="108"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.Unserializer" params="" file="C:\HaxeToolkit\haxe\std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="60" static="1">
			<t path="haxe.TypeResolver"/>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a Class or Enum instance from a given String. By
		default, the haxe Type Api is used.

		A type resolver must provide two methods:
		
		1. resolveClass(name:String):Class<Dynamic> is called to determine a
				Class from a class name
		2. resolveEnum(name:String):Enum<Dynamic> is called to determine an
				Enum from an enum name

		This value is applied when a new Unserializer instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 line="62" static="1"><c path="String"/></BASE64>
		<CODES line="65" static="1"><c path="Array"><x path="Int"/></c></CODES>
		<initCodes set="method" line="67" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="433" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its unserialize() method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="124">
			<f a="r">
				<t path="haxe.TypeResolver"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the type resolver of `this` Unserializer instance to `r`.

		If `r` is null, a special resolver is used which returns null for all
		input values.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</setResolver>
		<getResolver public="1" set="method" line="139">
			<f a=""><t path="haxe.TypeResolver"/></f>
			<haxe_doc>Gets the type resolver of `this` Unserializer instance.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</getResolver>
		<get get="inline" set="null" line="143"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<readDigits set="method" line="147"><f a=""><x path="Int"/></f></readDigits>
		<unserializeObject set="method" line="172"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="187"><f a="edecl:tag">
	<x path="Enum"><unknown/></x>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="219">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from Type.createEmptyInstance, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="99">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc>The Unserializer class is the complement to the Serializer class. It parses
	a serialization String and creates objects from the contained data.

	This class can be used in two ways:
	
	- create a new Unserializer() instance with a given serialization
		String, then call its unserialize() method until all values are
		extracted
	- call Unserializer.run() to unserialize a single value from a given
		String</haxe_doc>
	</class>
	<class path="haxe.Utf8" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/haxe/Utf8.hx">
		<encode public="1" set="method" line="45" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode the input ISO string into the corresponding UTF8 one.</haxe_doc>
		</encode>
		<decode public="1" set="method" line="51" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an UTF8 string back to an ISO string.
		Throw an exception if a given UTF8 character is not supported by the decoder.</haxe_doc>
		</decode>
		<iter public="1" set="method" line="55" static="1">
			<f a="s:chars">
				<c path="String"/>
				<f a="">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Call the `chars` function for each UTF8 char of the string.</haxe_doc>
		</iter>
		<charCodeAt public="1" set="method" line="61" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Similar to `String.charCodeAt` but uses the UTF8 character position.</haxe_doc>
		</charCodeAt>
		<validate public="1" set="method" line="66" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the String is correctly encoded as UTF8.</haxe_doc>
		</validate>
		<length public="1" set="method" line="74" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of UTF8 chars of the String.</haxe_doc>
		</length>
		<compare public="1" set="method" line="79" static="1">
			<f a="a:b">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compare two UTF8 strings, character by character.</haxe_doc>
		</compare>
		<sub public="1" set="method" line="91" static="1">
			<f a="s:pos:len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>This is similar to `String.substr` but the `pos` and `len` parts are considering UTF8 characters.</haxe_doc>
		</sub>
		<__s><c path="Array"><x path="Int"/></c></__s>
		<addChar public="1" set="method" line="35">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add the given UTF8 character code to the buffer.</haxe_doc>
		</addChar>
		<toString public="1" set="method" line="39">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the buffer converted to a String;</haxe_doc>
		</toString>
		<new public="1" set="method" line="29">
			<f a="?size" v="null">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allocate a new Utf8 buffer using an optional bytes size.</haxe_doc>
		</new>
		<haxe_doc>Since all platforms does not guarantee that String always uses UTF-8 encoding, you
	can use this crossplatform API to perform operations on such strings.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.crypto.Md5" params="" file="C:\HaxeToolkit\haxe\std/haxe/crypto/Md5.hx">
		<encode public="1" set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<make public="1" set="method" line="41" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<bytes2blks set="method" line="110" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<str2blks set="method" line="139" static="1"><f a="str">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bitOR set="method" line="76"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitOR>
		<bitXOR set="method" line="82"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitXOR>
		<bitAND set="method" line="88"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitAND>
		<addme set="method" line="94"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></addme>
		<hex set="method" line="100"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<rol set="method" line="168"><f a="num:cnt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rol>
		<cmn set="method" line="172"><f a="q:a:b:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></cmn>
		<ff set="method" line="176"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ff>
		<gg set="method" line="180"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gg>
		<hh set="method" line="184"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hh>
		<ii set="method" line="188"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ii>
		<doEncode set="method" line="192"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<new set="method" line="73"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a MD5 of a String.</haxe_doc>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="C:\HaxeToolkit\haxe\std/haxe/crypto/Sha1.hx">
		<encode public="1" set="method" line="26" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<make public="1" set="method" line="36" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<str2blks set="method" line="104" static="1"><f a="s">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bytes2blks set="method" line="121" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<doEncode set="method" line="58"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<rol get="inline" set="null" line="141">
			<f a="num:cnt">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Bitwise rotate a 32-bit number to the left</haxe_doc>
		</rol>
		<ft set="method" line="148">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<kt set="method" line="158">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<hex set="method" line="168"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<new set="method" line="55"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/BalancedTree.hx">
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.
		
		If `key` is already bound to a value, that binding disappears.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<t path="Null"><c path="haxe.ds.BalancedTree.V"/></t>
			</f>
			<haxe_doc>Returns the value `key` is bound to.
		
		If `key` is not bound to any value, `null` is returned.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<remove public="1" set="method" line="82">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the current binding of `key`.
		
		If `key` has no binding, `this` BalancedTree is unchanged and false is
		returned.
		
		Otherwise the binding of `key` is removed and true is returned.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="99">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `key` is bound to a value.
		
		This method returns true even if `key` is bound to null.
		
		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<iterator public="1" set="method" line="115">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.V"/></t></f>
			<haxe_doc>Iterates over the bound values of `this` BalancedTree.
		
		This operation is performed in-order.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="126">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.K"/></t></f>
			<haxe_doc>Iterates over the keys of `this` BalancedTree.
		
		This operation is performed in-order.</haxe_doc>
		</keys>
		<setLoop set="method" line="132"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<removeLoop set="method" line="145"><f a="k:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeLoop>
		<iteratorLoop set="method" line="153"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.V"/></c>
	<x path="Void"/>
</f></iteratorLoop>
		<keysLoop set="method" line="161"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.K"/></c>
	<x path="Void"/>
</f></keysLoop>
		<merge set="method" line="169"><f a="t1:t2">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></merge>
		<minBinding set="method" line="176"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></minBinding>
		<removeMinBinding set="method" line="182"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeMinBinding>
		<balance set="method" line="187"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="201"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<toString public="1" set="method" line="205"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.
	
	Operations have a logarithmic average and worst-case cost.
	
	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="231">
			<f a=""><x path="Int"/></f>
			<meta><m n=":extern"/></meta>
		</get_height>
		<toString public="1" set="method" line="233"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="220"><f a="l:k:v:r:?h" v="::::-1">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="33" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="42"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="52"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.
	
	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx">
		<this><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap">
	<_new public="1" set="method" line="25" static="1">
		<f a=""><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></f>
		<meta><m n=":impl"/></meta>
	</_new>
	<set public="1" get="inline" set="null" line="28" static="1">
		<f a="this:k:v">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<c path="haxe.ds.HashMap.V"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<get public="1" get="inline" set="null" line="32" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<t path="Null"><c path="haxe.ds.HashMap.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</get>
	<exists public="1" get="inline" set="null" line="35" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</exists>
	<remove public="1" get="inline" set="null" line="38" static="1">
		<f a="this:k">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</remove>
	<keys public="1" get="inline" set="null" line="42" static="1">
		<f a="this">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<t path="Iterator"><c path="haxe.ds.HashMap.K"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</keys>
	<iterator public="1" get="inline" set="null" line="45" static="1">
		<f a="this">
			<a>
				<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
				<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
			</a>
			<t path="Iterator"><c path="haxe.ds.HashMap.V"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
</class></impl>
	</abstract>
	<class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap">
		<_new public="1" set="method" line="25" static="1">
			<f a=""><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></f>
			<meta><m n=":impl"/></meta>
		</_new>
		<set public="1" get="inline" set="null" line="28" static="1">
			<f a="this:k:v">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<get public="1" get="inline" set="null" line="32" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<t path="Null"><c path="haxe.ds.HashMap.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</get>
		<exists public="1" get="inline" set="null" line="35" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</exists>
		<remove public="1" get="inline" set="null" line="38" static="1">
			<f a="this:k">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</remove>
		<keys public="1" get="inline" set="null" line="42" static="1">
			<f a="this">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<t path="Iterator"><c path="haxe.ds.HashMap.K"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</keys>
		<iterator public="1" get="inline" set="null" line="45" static="1">
			<f a="this">
				<a>
					<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
					<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
				</a>
				<t path="Iterator"><c path="haxe.ds.HashMap.V"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="C:\HaxeToolkit\haxe\std/cpp/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<__Internal><d/></__Internal>
		<set public="1" set="method" line="31">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="35">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="39">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="43">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="47">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.</haxe_doc>
		<meta><m n=":arrayAccess"/></meta>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
	<_new public="1" get="inline" set="null" line="53" static="1">
		<f a="length">
			<x path="Int"/>
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a new Vector of length `length`.

		Initially `this` Vector contains `length` neutral elements:
			
		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
	</_new>
	<get public="1" get="inline" set="null" line="78" static="1">
		<f a="this:index">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<x path="Int"/>
			<t path="Null"><c path="haxe.ds.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the value at index `index`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
	</get>
	<set public="1" get="inline" set="null" line="88" static="1">
		<f a="this:index:val">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<x path="Int"/>
			<c path="haxe.ds.Vector.T"/>
			<c path="haxe.ds.Vector.T"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Sets the value at index `index` to `val`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
	</set>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<get_length get="inline" set="null" line="97" static="1">
		<f a="this">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<blit public="1" params="T" set="method" line="116" static="1">
		<f a="src:srcPos:dest:destPos:len">
			<x path="haxe.ds.Vector"><c path="blit.T"/></x>
			<x path="Int"/>
			<x path="haxe.ds.Vector"><c path="blit.T"/></x>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Copies `length` of elements from `src` Vector, beginning at `srcPos` to
		`dest` Vector, beginning at `destPos`

		The results are unspecified if `length` results in out-of-bounds access,
		or if `src` or `dest` are null</haxe_doc>
	</blit>
	<toArray public="1" set="method" line="135" static="1">
		<f a="this">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<c path="Array"><c path="haxe.ds.Vector.T"/></c>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a new Array, copy the content from the Vector to it, and returns it.</haxe_doc>
	</toArray>
	<toData public="1" get="inline" set="null" line="152" static="1">
		<f a="this">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Extracts the data of `this` Vector.

		This returns the internal representation type.</haxe_doc>
	</toData>
	<fromData public="1" params="T" get="inline" set="null" line="162" static="1">
		<f a="data">
			<t path="haxe.ds._Vector.VectorData"><c path="fromData.T"/></t>
			<x path="haxe.ds.Vector"><c path="fromData.T"/></x>
		</f>
		<haxe_doc>Initializes a new Vector from `data`.

		Since `data` is the internal representation of Vector, this is a no-op.

		If `data` is null, the corresponding Vector is also `null`.</haxe_doc>
	</fromData>
	<fromArrayCopy public="1" params="T" get="inline" set="null" line="177" static="1">
		<f a="array">
			<c path="Array"><c path="fromArrayCopy.T"/></c>
			<x path="haxe.ds.Vector"><c path="fromArrayCopy.T"/></x>
		</f>
		<haxe_doc>Creates a new Vector by copying the elements of `array`.

		This always creates a copy, even on platforms where the internal
		representation is Array.

		The elements are not copied and retain their identity, so
		`a[i] == Vector.fromArrayCopy(a).get(i)` is true for any valid i.

		If `array` is null, the result is unspecified.</haxe_doc>
	</fromArrayCopy>
</class></impl>
	</abstract>
	<class path="haxe.ds._Vector.Vector_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
		<_new public="1" get="inline" set="null" line="53" static="1">
			<f a="length">
				<x path="Int"/>
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a new Vector of length `length`.

		Initially `this` Vector contains `length` neutral elements:
			
		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
		</_new>
		<get public="1" get="inline" set="null" line="78" static="1">
			<f a="this:index">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the value at index `index`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="88" static="1">
			<f a="this:index:val">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<x path="Int"/>
				<c path="haxe.ds.Vector.T"/>
				<c path="haxe.ds.Vector.T"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Sets the value at index `index` to `val`.

		If `index` is negative or exceeds `this.length`, the result is
		unspecified.</haxe_doc>
		</set>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="97" static="1">
			<f a="this">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<blit public="1" params="T" set="method" line="116" static="1">
			<f a="src:srcPos:dest:destPos:len">
				<x path="haxe.ds.Vector"><c path="blit.T"/></x>
				<x path="Int"/>
				<x path="haxe.ds.Vector"><c path="blit.T"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies `length` of elements from `src` Vector, beginning at `srcPos` to
		`dest` Vector, beginning at `destPos`

		The results are unspecified if `length` results in out-of-bounds access,
		or if `src` or `dest` are null</haxe_doc>
		</blit>
		<toArray public="1" set="method" line="135" static="1">
			<f a="this">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<c path="Array"><c path="haxe.ds.Vector.T"/></c>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a new Array, copy the content from the Vector to it, and returns it.</haxe_doc>
		</toArray>
		<toData public="1" get="inline" set="null" line="152" static="1">
			<f a="this">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Extracts the data of `this` Vector.

		This returns the internal representation type.</haxe_doc>
		</toData>
		<fromData public="1" params="T" get="inline" set="null" line="162" static="1">
			<f a="data">
				<t path="haxe.ds._Vector.VectorData"><c path="fromData.T"/></t>
				<x path="haxe.ds.Vector"><c path="fromData.T"/></x>
			</f>
			<haxe_doc>Initializes a new Vector from `data`.

		Since `data` is the internal representation of Vector, this is a no-op.

		If `data` is null, the corresponding Vector is also `null`.</haxe_doc>
		</fromData>
		<fromArrayCopy public="1" params="T" get="inline" set="null" line="177" static="1">
			<f a="array">
				<c path="Array"><c path="fromArrayCopy.T"/></c>
				<x path="haxe.ds.Vector"><c path="fromArrayCopy.T"/></x>
			</f>
			<haxe_doc>Creates a new Vector by copying the elements of `array`.

		This always creates a copy, even on platforms where the internal
		representation is Array.

		The elements are not copied and retain their identity, so
		`a[i] == Vector.fromArrayCopy(a).get(i)` is true for any valid i.

		If `array` is null, the result is unspecified.</haxe_doc>
		</fromArrayCopy>
	</class>
	<class path="haxe.ds.WeakMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/WeakMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.WeakMap.K"/>
			<c path="haxe.ds.WeakMap.V"/>
		</implements>
		<set public="1" set="method" line="44">
			<f a="key:value">
				<c path="haxe.ds.WeakMap.K"/>
				<c path="haxe.ds.WeakMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="50">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<t path="Null"><c path="haxe.ds.WeakMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="57">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="64">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="71">
			<f a=""><t path="Iterator"><c path="haxe.ds.WeakMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="78">
			<f a=""><t path="Iterator"><c path="haxe.ds.WeakMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="85">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new WeakMap.</haxe_doc>
		</new>
		<haxe_doc>WeakMap allows mapping of object keys to arbitrary values.
	
	The keys are considered to be weak references on static targets.
	
	See `Map` for documentation details.</haxe_doc>
	</class>
	<class path="haxe.format.JsonParser" params="" file="C:\HaxeToolkit\haxe\std/haxe/format/JsonParser.hx">
		<parse public="1" get="inline" set="null" line="5" static="1"><f a="str">
	<c path="String"/>
	<d/>
</f></parse>
		<str><c path="String"/></str>
		<pos><x path="Int"/></pos>
		<parseRec set="method" line="17"><f a=""><d/></f></parseRec>
		<parseString set="method" line="99"><f a=""><c path="String"/></f></parseString>
		<parseNumber get="inline" set="null" line="160"><f a="c">
	<x path="Int"/>
	<d/>
</f></parseNumber>
		<nextChar get="inline" set="null" line="198"><f a=""><x path="Int"/></f></nextChar>
		<invalidChar set="method" line="202"><f a=""><x path="Void"/></f></invalidChar>
		<invalidNumber set="method" line="207"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<new set="method" line="12"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.format.JsonPrinter" params="" file="C:\HaxeToolkit\haxe\std/haxe/format/JsonPrinter.hx">
		<print public="1" set="method" line="5" static="1"><f a="o:?replacer" v=":null">
	<d/>
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
</f></print>
		<buf><c path="StringBuf"/></buf>
		<replacer><f a=":">
	<d/>
	<d/>
	<d/>
</f></replacer>
		<write set="method" line="26"><f a="k:v">
	<d/>
	<d/>
	<x path="Void"/>
</f></write>
		<addChar get="inline" set="null" line="80">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</addChar>
		<add get="inline" set="null" line="88">
			<f a="v">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</add>
		<objString get="inline" set="null" line="103"><f a="v">
	<d/>
	<x path="Void"/>
</f></objString>
		<fieldsString set="method" line="107"><f a="v:fields">
	<d/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></fieldsString>
		<quote set="method" line="121"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></quote>
		<quoteUtf8 set="method" line="153"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></quoteUtf8>
		<new set="method" line="14"><f a="replacer">
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/BytesBuffer.hx">
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="63"><f a=""><x path="Int"/></f></get_length>
		<addByte public="1" get="inline" set="null" line="75"><f a="byte">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="93"><f a="src">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></add>
		<addBytes public="1" get="inline" set="null" line="112"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="138">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.io.Unsigned_char__" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/BytesData.hx" module="haxe.io.BytesData" extern="1"/>
	<typedef path="haxe.io.BytesData" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/BytesData.hx"><c path="Array"><c path="haxe.io.Unsigned_char__"/></c></typedef>
	<class path="haxe.io.BytesInput" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<get_position get="inline" set="null" line="60"><f a=""><x path="Int"/></f></get_position>
		<get_length get="inline" set="null" line="68"><f a=""><x path="Int"/></f></get_length>
		<set_position set="method" line="76"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></set_position>
		<readByte public="1" set="method" line="87" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="108" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="38"><f a="b:?pos:?len" v=":null:null">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Eof" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<class path="haxe.io.Path" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Path.hx">
		<withoutExtension public="1" set="method" line="117" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the file extension.

		If `path` is null, the result is unspecified.</haxe_doc>
		</withoutExtension>
		<withoutDirectory public="1" set="method" line="128" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the directory.

		If `path` is null, the result is unspecified.</haxe_doc>
		</withoutDirectory>
		<directory public="1" set="method" line="141" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is null, the empty String "" is returned.

		If `path` is null, the result is unspecified.</haxe_doc>
		</directory>
		<extension public="1" set="method" line="155" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the extension of `path`.

		If the extension is null, the empty String "" is returned.

		If `path` is null, the result is unspecified.</haxe_doc>
		</extension>
		<withExtension public="1" set="method" line="169" static="1">
			<f a="path:ext">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String representation of `path` where the extension is `ext`.

		If `path` has no extension, `ext` is added as extension.

		If `path` or `ext` are null, the result is unspecified.</haxe_doc>
		</withExtension>
		<join public="1" set="method" line="183" static="1">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all paths in `paths` together.

		If `paths` is empty, the empty String `""` is returned. Otherwise the
		paths are joined with a slash between them.

		If `paths` is null, the result is unspecified.</haxe_doc>
		</join>
		<normalize public="1" set="method" line="204" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Normalize a given `path` (e.g. make '/usr/local/../lib' to '/usr/lib').

		Also replaces backslashes \ with slashes / and afterwards turns
		multiple slashes into a single one.

		If `path` is null, the result is unspecified.</haxe_doc>
		</normalize>
		<addTrailingSlash public="1" set="method" line="268" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		"".

		If `path` is null, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<removeTrailingSlashes public="1" set="method" line="293" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":require"><e><![CDATA[haxe_ver>=3.1]]></e></m></meta>
			<haxe_doc>Removes trailing slashes from `path`.

		If `path` does not end with a `/` or `\`, `path` is returned unchanged.

		Otherwise the substring of `path` excluding the trailing slashes or
		backslashes is returned.

		If `path` is null, the result is unspecified.</haxe_doc>
		</removeTrailingSlashes>
		<dir public="1">
			<c path="String"/>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is null.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for ".htaccess" or "/dir/", the value
		is the empty String "".</haxe_doc>
		</file>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is null.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>True if the last directory separator is a backslash, false otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="108">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

		If `this.backslash` is true, backslash is used as directory separator,
		otherwise slash is used. This only affects the separator between
		`this.dir` and `this.file`.

		If `this.directory` or `this.extension` is null, their representation
		is the empty String "".</haxe_doc>
		</toString>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Path instance by parsing `path`.

		Path information can be retrieved by accessing the dir, file and ext
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- directory1/directory2/filename.extension
	- directory1\directory2\filename.excention</haxe_doc>
	</class>
	<class path="haxe.io.StringInput" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/StringInput.hx">
		<extends path="haxe.io.BytesInput"/>
		<new public="1" set="method" line="26"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.xml._Fast.NodeAccess" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="32"><f a="name">
	<c path="String"/>
	<c path="haxe.xml.Fast"/>
</f></resolve>
		<new public="1" set="method" line="28"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.xml.Fast"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.AttribAccess" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="51"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></resolve>
		<new public="1" set="method" line="47"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><c path="String"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasAttribAccess" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="70"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></resolve>
		<new public="1" set="method" line="66"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><x path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasNodeAccess" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="86"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></resolve>
		<new public="1" set="method" line="82"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><x path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.NodeListAccess" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="100"><f a="name">
	<c path="String"/>
	<c path="List"><c path="haxe.xml.Fast"/></c>
</f></resolve>
		<new public="1" set="method" line="96"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><c path="List"><c path="haxe.xml.Fast"/></c></haxe_dynamic>
	</class>
	<class path="haxe.xml.Fast" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx">
		<x public="1" set="null"><c path="Xml"/></x>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<innerData public="1" get="accessor" set="null"><c path="String"/></innerData>
		<innerHTML public="1" get="accessor" set="null"><c path="String"/></innerHTML>
		<node public="1" set="null"><c path="haxe.xml._Fast.NodeAccess"/></node>
		<nodes public="1" set="null"><c path="haxe.xml._Fast.NodeListAccess"/></nodes>
		<att public="1" set="null"><c path="haxe.xml._Fast.AttribAccess"/></att>
		<has public="1" set="null"><c path="haxe.xml._Fast.HasAttribAccess"/></has>
		<hasNode public="1" set="null"><c path="haxe.xml._Fast.HasNodeAccess"/></hasNode>
		<elements public="1" get="accessor" set="null"><t path="Iterator"><c path="haxe.xml.Fast"/></t></elements>
		<get_name set="method" line="133"><f a=""><c path="String"/></f></get_name>
		<get_innerData set="method" line="137"><f a=""><c path="String"/></f></get_innerData>
		<get_innerHTML set="method" line="157"><f a=""><c path="String"/></f></get_innerHTML>
		<get_elements set="method" line="164"><f a=""><a>
	<next><f a=""><c path="haxe.xml.Fast"/></f></next>
	<hasNext><f a=""><x path="Bool"/></f></hasNext>
</a></f></get_elements>
		<new public="1" set="method" line="122"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.xml._Parser.S" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" extern="1">
		<IGNORE_SPACES public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></IGNORE_SPACES>
		<BEGIN public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></BEGIN>
		<BEGIN_NODE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></BEGIN_NODE>
		<TAG_NAME public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></TAG_NAME>
		<BODY public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></BODY>
		<ATTRIB_NAME public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></ATTRIB_NAME>
		<EQUALS public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></EQUALS>
		<ATTVAL_BEGIN public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></ATTVAL_BEGIN>
		<ATTRIB_VAL public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></ATTRIB_VAL>
		<CHILDS public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></CHILDS>
		<CLOSE public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></CLOSE>
		<WAIT_END public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></WAIT_END>
		<WAIT_END_RET public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></WAIT_END_RET>
		<PCDATA public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></PCDATA>
		<HEADER public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></HEADER>
		<COMMENT public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></COMMENT>
		<DOCTYPE public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></DOCTYPE>
		<CDATA public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></CDATA>
		<ESCAPE public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></ESCAPE>
	</class>
	<class path="haxe.xml.Parser" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx">
		<escapes line="51" static="1"><c path="haxe.ds.StringMap"><c path="String"/></c></escapes>
		<parse public="1" set="method" line="62" static="1"><f a="str">
	<c path="String"/>
	<c path="Xml"/>
</f></parse>
		<doParse set="method" line="69" static="1"><f a="str:?p:?parent" v=":0:null">
	<c path="String"/>
	<x path="Int"/>
	<c path="Xml"/>
	<x path="Int"/>
</f></doParse>
		<isValidChar get="inline" set="null" line="343" static="1"><f a="c">
	<x path="Int"/>
	<x path="Bool"/>
</f></isValidChar>
	</class>
	<class path="haxe.xml.Printer" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Printer.hx">
		<print public="1" set="method" line="33" static="1"><f a="xml">
	<c path="Xml"/>
	<c path="String"/>
</f></print>
		<output><c path="StringBuf"/></output>
		<writeNode set="method" line="45"><f a="value:tabs">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeNode>
		<write get="inline" set="null" line="93"><f a="input">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<newline get="inline" set="null" line="97"><f a=""><x path="Void"/></f></newline>
		<hasChildren set="method" line="101"><f a="value">
	<c path="Xml"/>
	<x path="Bool"/>
</f></hasChildren>
		<new set="method" line="41"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.zip.Compress" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/haxe/zip/Compress.hx">
		<run public="1" set="method" line="45" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_deflate_init line="56" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></_deflate_init>
		<_deflate_bound line="57" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></_deflate_bound>
		<_deflate_buffer line="58" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></_deflate_buffer>
		<_deflate_end line="59" static="1"><f a="">
	<d/>
	<unknown/>
</f></_deflate_end>
		<_set_flush_mode line="60" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="33"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="37"><f a="f">
	<e path="haxe.zip.FlushMode"/>
	<x path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="41"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="29"><f a="level">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":coreApi"/></meta>
	</class>
	<enum path="haxe.zip.FlushMode" params="" file="C:\HaxeToolkit\haxe\std/haxe/zip/FlushMode.hx">
		<NO/>
		<SYNC/>
		<FULL/>
		<FINISH/>
		<BLOCK/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="haxe.zip.Uncompress" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/haxe/zip/Uncompress.hx">
		<run public="1" set="method" line="44" static="1"><f a="src:?bufsize" v=":null">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_inflate_init line="62" static="1"><f a="">
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></_inflate_init>
		<_inflate_buffer line="63" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></_inflate_buffer>
		<_inflate_end line="64" static="1"><f a="">
	<d/>
	<unknown/>
</f></_inflate_end>
		<_set_flush_mode line="65" static="1"><f a=":">
	<d/>
	<unknown/>
	<unknown/>
</f></_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="32"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="36"><f a="f">
	<e path="haxe.zip.FlushMode"/>
	<x path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="40"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="28"><f a="?windowBits" v="null">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="nape.Config" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/Config.hx">
		<epsilon public="1" line="15" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Generic epsilon value for float comparisons
     * <br/><br/>
     * @default 1e-8]]></haxe_doc>
		</epsilon>
		<fluidAngularDragFriction public="1" line="27" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing shape fluid angular drag coeffecient.
     * <br/><br/>
     * Defines the contribution to the drag coeffecient due to Material dynamicFriction
     * <br/><br/>
     * This global value must be set as the very first thing to ensure all Shapes
     * use your intended value.
     * <br/><br/>
     * This parameter has units kg/px
     * @default 2.5 kg/px]]></haxe_doc>
		</fluidAngularDragFriction>
		<fluidAngularDrag public="1" line="40" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing shape fluid angular drag coeffecient.
     * <br/><br/>
     * Defines the contribution to the drag coeffecient due to shape's surface
     * area rotating into a fluid.
     * <br/><br/>
     * This global value must be set as the very first thing to ensure all Shapes
     * use your intended value.
     * <br/><br/>
     * This parameter has units kg/px
     * @default 100kg/px]]></haxe_doc>
		</fluidAngularDrag>
		<fluidVacuumDrag public="1" line="53" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing fluid drags.
     * <br/><br/>
     * Defines an added weight for scaling the contribution of forward drag due
     * to leaving a vaccuum behind the shape pulling it back.
     * <br/><br/>
     * This global value must be set as the very first thing to ensure all Shapes
     * use your intended value.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.5]]></haxe_doc>
		</fluidVacuumDrag>
		<fluidLinearDrag public="1" line="62" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing shapes linear drag in fluid.
     * <br/><br/>
     * Used in determining the amount of linear drag for the shape based on forward profile.
     * <br/><br/>
     * This parameter has units kg/px
     * @default 0.5kg/px]]></haxe_doc>
		</fluidLinearDrag>
		<collisionSlop public="1" line="69" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of overlap permitted between Shapes for collisions.
     * <br/><br/>
     * This parameter has units of pixels.
     * @default 0.2px]]></haxe_doc>
		</collisionSlop>
		<collisionSlopCCD public="1" line="77" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of overlap permitted between Shapes before CCD kicks in.
     * <br/><br/>
     * This parameter has units of pixels, and should always be larger
     * than collisionSlop parameter.
     * @default 0.5px]]></haxe_doc>
		</collisionSlopCCD>
		<distanceThresholdCCD public="1" line="88" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Biased distance treshold for CCD collisions.
     * <br/><br/>
     * In CCD collision routines, two Shapes will be considered intersecting
     * when the distance between them + collisionSlopCCD falls below this
     * value.
     * <br/><br/>
     * This parameter has units of pixels, and should always be > 0
     * @default 0.05px]]></haxe_doc>
		</distanceThresholdCCD>
		<staticCCDLinearThreshold public="1" line="104" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear sweep threshold-ratio for static CCD collisions
     * <br/><br/>
     * In deciding what non-bullet objects should be collided continuously against
     * static/kinematic objects, the linear speed of the body is considered.
     * <code>
     * ccdCollide if: bodyLinearSpeed * deltaTime > threshold * bodyRadius
     * </code>
     * Intuitively, a value of 0.5 would mean that a body, in the worst case scenario
     * will be permitted to move half of its width in a single time step, before CCD
     * is enabled for this reason.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.05]]></haxe_doc>
		</staticCCDLinearThreshold>
		<staticCCDAngularThreshold public="1" line="121" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular sweep threshold for static CCD collisions
     * <br><br/>
     * In deciding what non-bullet objects should be collided continuously against
     * static/kinematic objects, the angular speed of the body is considered.
     * <code>
     * ccdCollide if: bodyAngularSpeed * deltaTime > threshold
     * </code>
     * Intuitively, a value of 0.5 would mean that a body would have to rotate more than
     * 0.5 radians in a single time step, before CCD is enabled for this reason. Noting that
     * at 60fps physics, the body would need an angularVel greater than 30rad/s for this
     * limit of 0.5 to be reached; the default is far smaller.
     * <br/><br/>
     * This parameter has units of rad.
     * @default 0.005rad]]></haxe_doc>
		</staticCCDAngularThreshold>
		<bulletCCDLinearThreshold public="1" line="136" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear sweep threshold-ratio for bullet CCD collisions
     * <br/><br/>
     * A dynamic body marked as a bullet, will not necessarigly always be collided
     * with continuously.
     * <br/><br/>
     * Should a body be moving, or rotating fast enough to pass the tests determined
     * by staticCCD#Threshold parameters, and is marked as a bullet, it must then
     * have its velocities checked against the equivalent bullet thresholds to actually
     * be collided continuously against other dynamic bodies too.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.125]]></haxe_doc>
		</bulletCCDLinearThreshold>
		<bulletCCDAngularThreshold public="1" line="145" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular sweep threshold for bullet CCD collisions.
     * <br/><br/>
     * See description of bulletCCDLinearThreshold.
     * <br/><br/>
     * This parameter has units of rad.
     * @default 0.0125rad]]></haxe_doc>
		</bulletCCDAngularThreshold>
		<dynamicSweepLinearThreshold public="1" line="157" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Relative linear threshold for dynamic-dynamic sweeps.
     * <br/><br/>
     * When performing dynamic-dynamic sweep of Body shapes during CCD collision phase,
     * should the relative velocity of the bodies fall beneath this magnitude, they
     * may be considered (based on angular velocities also) to be moving together, and
     * this specific CCD test will be skipped.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 17px/s]]></haxe_doc>
		</dynamicSweepLinearThreshold>
		<dynamicSweepAngularThreshold public="1" line="174" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Relative angular bias threshold for dynamic-dynamic sweeps.
     * <br/><br/>
     * When performing dynamic-dynamic sweep of Body shapes during CCD collision phase,
     * should the relative angular velocity (weighted by the shape bias values) fall
     * beneath this magnitude, they may be considered (based on linear velocities also) to
     * be moving together, and this specific CCD test will be skipped.
     * <br/><br/>
     * The shape bias, is an internal value which indicates the 'amount of radius' of
     * a shape about the centre of rotation that can be considered to change under rotations.
     * eg: A circle at origin has a bias of 0 (Its rotation has no effect on sweeps)
     * whilst A circle far from the origin may have a large bias.
     * <br/><br/>
     * This parameter has units of px.rad/s
     * @default 0.6px.rad/s]]></haxe_doc>
		</dynamicSweepAngularThreshold>
		<angularCCDSlipScale public="1" line="188" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular velocity scaling during CCD slips.
     * <br/><br/>
     * In rare cases, a Body can be moving in such a way that we fail to compute a perfect
     * time of impact; generally when a thin box-like object is rotating very quickly. The
     * time of impact solver in Nape attempts to avoid impacts which are seperating; so that
     * we can catch true impact times; but in a 'slip' case we are unable to achieve this and
     * to avoid a possible tunneling from the other side during later operations we will in
     * these rare cases scale down the angular velocity of a Body by this parameter.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.75]]></haxe_doc>
		</angularCCDSlipScale>
		<arbiterExpirationDelay public="1" line="200" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Expiration delay length for collision arbiter destruction.
     * <br/><br/>
     * In unstable physics conditions, two colliding shapes may jitter such as to constantly
     * seperate, and then come back together again. This parameter controls the number of time
     * steps during which we will delay this destruction so that cached impulse values may
     * persist and improve stability of strenuous simulations.
     * <br/><br/>
     * This parameter has units of 'steps' I suppose.
     * @default 6steps]]></haxe_doc>
		</arbiterExpirationDelay>
		<staticFrictionThreshold public="1" line="210" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Contact velocity threshold for static-dynamic friction
     * <br/><br/>
     * This is the threshold on projected contact velocities at which Nape will use
     * dynamic friction Mateiral values, in place of static friction Material values.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 2px/s]]></haxe_doc>
		</staticFrictionThreshold>
		<elasticThreshold public="1" line="222" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Contact velocity threshold for elastic collisions
     * <br/><br/>
     * This is the threshold on weighted projected normal-contact velocities at which Nape will
     * decide to stop using elastic collisions. Nape will take the normal velocities at contact
     * and scale by the combined elasticity coeffecient for the Arbiter, if this value falls
     * below the threshold, then elasticity is ignored for stability in stacking.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 20px/s]]></haxe_doc>
		</elasticThreshold>
		<sleepDelay public="1" line="234" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Sleep delay for stationary bodies.
     * <br/><br/>
     * By default, Nape considers a body to be stationary even if it has a very small linear
     * or angular velocity. This parameter controls how many steps such a Body will continue
     * to be simulated for, before being put to sleep (Assuming everything else in the island
     * is also stationary for a sufficiently long time).
     * <br/><br/>
     * This parameter has units of 'steps' I suppose.
     * @default 60steps]]></haxe_doc>
		</sleepDelay>
		<linearSleepThreshold public="1" line="244" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear speed threshold for sleeping of Bodies.
     * <br/><br/>
     * A body in Nape will be considered stationary only if its linear velocity has magnitude
     * under this threshold.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 0.2px/s]]></haxe_doc>
		</linearSleepThreshold>
		<angularSleepThreshold public="1" line="258" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular speed threshold for sleeping of Bodies.
     * <br/><br/>
     * A body in Nape will be considered stationary only if its angular velocity, multiplied
     * by the body radius (never under-estimated) about the origin, falls below this threshold.
     * <br/><br/>
     * The body radius scaling, ensures that a very large body needs to be rotating more slowly
     * to be considered stationary than a very small body. Intuitively we're designating this
     * a threshold on the maximum tangentenial velocity of the body due to rotation.
     * <br/><br/>
     * This parameter has units of px.rad/s
     * @default 0.4px.rad/s]]></haxe_doc>
		</angularSleepThreshold>
		<contactBiasCoef public="1" line="269" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for dynamic-dynamic discrete collisions.
     * <br/><br/>
     * This value determines, in the case of two non-continuously colliding dynamic objects
     * the fraction of the contact overlap that will attempt to be resolved during positional
     * iterations.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.3/step]]></haxe_doc>
		</contactBiasCoef>
		<contactStaticBiasCoef public="1" line="279" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for static/kinematic discrete collisions.
     * <br/><br/>
     * See description of contactBiasCoef; this is the coeffecient for non-continuous collisions
     * between a dynamic, and a static or kinematic object.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.6/step]]></haxe_doc>
		</contactStaticBiasCoef>
		<contactContinuousBiasCoef public="1" line="289" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for dynamic-dynamic continuous collisions.
     * <br/><br/>
     * See description of contactBiasCoef; this is the coeffecient for continuous collisions
     * between two dynamic bodies.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.4/step]]></haxe_doc>
		</contactContinuousBiasCoef>
		<contactContinuousStaticBiasCoef public="1" line="299" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for static/kinematic continuous collisions.
     * <br/><br/>
     * See description of contactBiasCoef; this is the coeffecient for continuous collisions
     * between a dynamic, and a static or kinematic object.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.5/step]]></haxe_doc>
		</contactContinuousStaticBiasCoef>
		<constraintLinearSlop public="1" line="309" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of linear slop permitted in constraints.
     * <br/><br/>
     * A constraint will be considered to be 'relaxed' during positional iterations
     * only if the linear error falls below this threshold.
     * <br/><br/>
     * Assuming a 'sensible' constraint, this has units of px
     * @default 0.1px]]></haxe_doc>
		</constraintLinearSlop>
		<constraintAngularSlop public="1" line="319" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of angular slop permitted in constraints.
     * <br/><br/>
     * A constraint will be considered to be 'relaxed' during positional iterations
     * only if the angular error falls below this threshold.
     * <br/><br/>
     * Assuming a 'sensible' constraint, this has units of rad
     * @default 1e-3rad]]></haxe_doc>
		</constraintAngularSlop>
		<illConditionedThreshold public="1" line="332" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Ill-conditioned threshold for 2-contact collision constraints.
     * <br/><br/>
     * This is a threshold on the measure of ill-conditioning of the effective-mass-matrix
     * in a 2-contact collision at which the contact manifold will be forced into a 1-contact
     * constraint. This can occur quite readily when two contact points are almost exactly equal
     * or in certain other conditions where the mathematics quite simply breaks down when using
     * a block solver.
     * <br/><br/>
     * This parameter has no units.
     * @default 2e+8]]></haxe_doc>
		</illConditionedThreshold>
		<new set="method" line="9">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Configuration parameters for Nape</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<typedef path="nape.TArray" params="T" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/TArray.hx">
		<c path="Array"><c path="nape.TArray.T"/></c>
		<haxe_doc><![CDATA[* Platform specific Array type.
 * <br/><br/>
 * For flash10+ This is <code>flash.Vector&lt;T&gt;</code>, and otherwise
 * <code>Array&lt;T&gt;</code>.
 * <pre>
 * #if flash10
 *     typedef TArray&lt;T&gt; = flash.Vector&lt;T&gt;;
 * #else
 *     typedef TArray&lt;T&gt; = Array&lt;T&gt;;
 * #end
 * </pre>]]></haxe_doc>
	</typedef>
	<class path="nape.callbacks.Callback" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/Callback.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_Callback"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<event public="1" get="accessor" set="null">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* CbEvent type this callback was generated for.</haxe_doc>
		</event>
		<get_event get="inline" set="null" line="190"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_event>
		<listener public="1" get="accessor" set="null">
			<c path="nape.callbacks.Listener"/>
			<haxe_doc>* The Listener which was responsive for this callback being generated.</haxe_doc>
		</listener>
		<get_listener get="inline" set="null" line="198"><f a=""><c path="nape.callbacks.Listener"/></f></get_listener>
		<toString public="1" set="method" line="214">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="204">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Base type for Callback event objects.
 * <br/><br/>
 * Callback objects are automatically reused and you should not keep references
 * to them.]]></haxe_doc>
	</class>
	<class path="nape.callbacks.BodyCallback" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/BodyCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<body public="1" get="accessor" set="null">
			<c path="nape.phys.Body"/>
			<haxe_doc>* Body involved in callback event.</haxe_doc>
		</body>
		<get_body get="inline" set="null" line="192"><f a=""><c path="nape.phys.Body"/></f></get_body>
		<toString public="1" set="method" line="198" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Body type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.Listener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/Listener.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_Listener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<type public="1" get="accessor" set="null">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* The sub-type of this listener.</haxe_doc>
		</type>
		<get_type get="inline" set="null" line="187"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_type>
		<event public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* The CbEvent this listener responds to.</haxe_doc>
		</event>
		<get_event get="inline" set="null" line="195"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_event>
		<set_event get="inline" set="null" line="198"><f a="event">
	<c path="nape.callbacks.CbEvent"/>
	<c path="nape.callbacks.CbEvent"/>
</f></set_event>
		<precedence public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The precedence of this listener.
     * <br/><br/>
     * In any case that there is more than one suitable listener for a situation,
     * the listeners will be ordered by their precedence.
     *
     * @default 0]]></haxe_doc>
		</precedence>
		<get_precedence get="inline" set="null" line="222"><f a=""><x path="Int"/></f></get_precedence>
		<set_precedence get="inline" set="null" line="225"><f a="precedence">
	<x path="Int"/>
	<x path="Int"/>
</f></set_precedence>
		<space public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.space.Space"/></t>
			<haxe_doc><![CDATA[* The Space this listener is assigned to.
     * <br/><br/>
     * This value can be set, with setting to null being equivalent to removing
     * the listener from whichever Space it is presently assigned to.
     *
     * @default null]]></haxe_doc>
		</space>
		<get_space get="inline" set="null" line="254"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<set_space get="inline" set="null" line="257"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<toString public="1" set="method" line="276">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="237">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Base type for all Nape callback listeners.</haxe_doc>
	</class>
	<class path="nape.callbacks.BodyListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/BodyListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<options public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc><![CDATA[* The OptionType used to match against Bodies.
     * <br/><br/>
     * When added to the same Space, any Body who's CbType list matches
     * against this OptionType will be issued a callback when the relevant
     * event occurs.]]></haxe_doc>
		</options>
		<get_options get="inline" set="null" line="194"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options>
		<set_options get="inline" set="null" line="197"><f a="options">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options>
		<handler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="nape.callbacks.BodyCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The callback handler for this listener.</haxe_doc>
		</handler>
		<get_handler get="inline" set="null" line="208"><f a=""><f a="">
	<c path="nape.callbacks.BodyCallback"/>
	<x path="Void"/>
</f></f></get_handler>
		<set_handler get="inline" set="null" line="211"><f a="handler">
	<f a="">
		<c path="nape.callbacks.BodyCallback"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="nape.callbacks.BodyCallback"/>
		<x path="Void"/>
	</f>
</f></set_handler>
		<new public="1" set="method" line="248">
			<f a="event:options:handler:?precedence" v=":::0">
				<c path="nape.callbacks.CbEvent"/>
				<t path="Null"><d/></t>
				<f a="">
					<c path="nape.callbacks.BodyCallback"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new BodyListener.
     * <br/><br/>
     * The possible event types are WAKE and SLEEP.
     * <br/><br/>
     * The options argument is typed Dynamic, and is permitted to be either an
     * <code>OptionType</code> or one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     * In which case the input CbType's will be used to construct an OptionType
     * whose included types will be the set of CbTypes supplied.
     *
     * @param event The event type to listen for.
     * @param options The OptionType to match Bodys against, passing null
     *                will equate to an empty OptionType.
     * @param handler The callback handler for this listener.
     * @param precedence The precedence of this listener used to sort
     *                   the order of callbacks in the case of more than
     *                   one suitable BodyListener existing for the same
     *                   event on the same Body. (default 0)
     * @return The newly constructed BodyListener
     * @throws # If handler is null.
     * @throws # If the event type is not permitted for this listener.
     * @throws # If options is not of the expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Event listener for Body type events.
 * <br/><br/>
 * The events that can be caught are WAKE and SLEEP type events.
 * Theses listeners will only operate on Bodys, not Interactors in general.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbEvent" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/CbEvent.hx">
		<BEGIN public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* BEGIN event corresponds to the start of an interaction</haxe_doc>
		</BEGIN>
		<get_BEGIN get="inline" set="null" line="206" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_BEGIN>
		<ONGOING public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* ONGOING event corresponds to any step in which an interaction is occuring
     * overlapping with the BEGIN event.</haxe_doc>
		</ONGOING>
		<get_ONGOING get="inline" set="null" line="220" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_ONGOING>
		<END public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* END event corresponds to the end of an interaction.</haxe_doc>
		</END>
		<get_END get="inline" set="null" line="233" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_END>
		<WAKE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* WAKE event corresponds to the waking of a Body or Constraint in the space.</haxe_doc>
		</WAKE>
		<get_WAKE get="inline" set="null" line="246" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_WAKE>
		<SLEEP public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* SLEEP event corresponds to the sleeping of a Body or Constraint in the space.</haxe_doc>
		</SLEEP>
		<get_SLEEP get="inline" set="null" line="259" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_SLEEP>
		<BREAK public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* BREAK event corresponds to the breaking of a defined limit on a Constraint.</haxe_doc>
		</BREAK>
		<get_BREAK get="inline" set="null" line="272" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_BREAK>
		<PRE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* PRE event corresponds to a special mid-step event that occurs after it is determined
     * that two objects 'will' begin to interact, but before any interaction commences.</haxe_doc>
		</PRE>
		<get_PRE get="inline" set="null" line="286" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_PRE>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of possible callback event types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/CbType.hx">
		<ANY_BODY public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbType"/>
			<haxe_doc>* Default CbType given to all Bodys
     *
     * Due to the way the Callback system in Nape works, you can use this
     * CbType to match against 'all'
     * Bodys
     * In a Listener (Assuming you do not 'remove' this type from the object)</haxe_doc>
		</ANY_BODY>
		<get_ANY_BODY get="inline" set="null" line="212" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_BODY>
		<ANY_CONSTRAINT public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbType"/>
			<haxe_doc>* Default CbType given to all Constraints
     *
     * Due to the way the Callback system in Nape works, you can use this
     * CbType to match against 'all'
     * Constraints
     * In a Listener (Assuming you do not 'remove' this type from the object)</haxe_doc>
		</ANY_CONSTRAINT>
		<get_ANY_CONSTRAINT get="inline" set="null" line="225" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_CONSTRAINT>
		<ANY_SHAPE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbType"/>
			<haxe_doc>* Default CbType given to all Shapes
     *
     * Due to the way the Callback system in Nape works, you can use this
     * CbType to match against 'all'
     * Shapes
     * In a Listener (Assuming you do not 'remove' this type from the object)</haxe_doc>
		</ANY_SHAPE>
		<get_ANY_SHAPE get="inline" set="null" line="238" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_SHAPE>
		<ANY_COMPOUND public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbType"/>
			<haxe_doc>* Default CbType given to all Compounds
     *
     * Due to the way the Callback system in Nape works, you can use this
     * CbType to match against 'all'
     * Compounds
     * In a Listener (Assuming you do not 'remove' this type from the object)</haxe_doc>
		</ANY_COMPOUND>
		<get_ANY_COMPOUND get="inline" set="null" line="251" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_COMPOUND>
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_CbType"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<id public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Unique identifier for this CbType.</haxe_doc>
		</id>
		<get_id get="inline" set="null" line="189"><f a=""><x path="Int"/></f></get_id>
		<including public="1" set="method" line="267">
			<f a="includes">
				<d/>
				<c path="nape.callbacks.OptionType"/>
			</f>
			<haxe_doc><![CDATA[* Construct OptionType with given extra includes.
     * <br/><br/>
     * Equivalent to <code>new OptionType(this).including(includes)</code>
     * <br/><br/>
     * The includes argument is typed Dynamic, and is permitted to be one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     *
     * @param includes The CbTypes to include.
     * @return A new OptionType whose includes are equal to this CbType
     *         and all the CbTypes given as argument.
     * @throws # If includes is null.]]></haxe_doc>
		</including>
		<excluding public="1" set="method" line="283">
			<f a="excludes">
				<d/>
				<c path="nape.callbacks.OptionType"/>
			</f>
			<haxe_doc><![CDATA[* Construct OptionType with given excludes.
     * <br/><br/>
     * Equivalent to <code>new OptionType(this).excluding(excludes)</code>
     * <br/><br/>
     * The excludes argument is typed Dynamic, and is permitted to be one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     *
     * @param excludes The CbTypes to exclude.
     * @return A new OptionType whose included types are just 'this' and whose
     *         excluded types are those given as argument.
     * @throws # If excludes is null.]]></haxe_doc>
		</excluding>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<get_userData get="inline" set="null" line="299"><f a=""><d><d/></d></f></get_userData>
		<interactors public="1" get="accessor" set="null">
			<c path="nape.phys.InteractorList"/>
			<haxe_doc><![CDATA[* List of all Interactors using this CbType.
     * <br/><br/>
     * This list contains only those Interactors that are inside of a Space
     * <br/><br/>
     * This list is not only readonly, but also immutable.]]></haxe_doc>
		</interactors>
		<get_interactors get="inline" set="null" line="314"><f a=""><c path="nape.phys.InteractorList"/></f></get_interactors>
		<constraints public="1" get="accessor" set="null">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc><![CDATA[* List of all Constraints using this CbType.
     * <br/><br/>
     * This list contains only those Constraints that are inside of a Space
     * <br/><br/>
     * This list is not only readonly, but also immutable.]]></haxe_doc>
		</constraints>
		<get_constraints get="inline" set="null" line="329"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<toString public="1" set="method" line="338">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="197">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new CbType object.
     *
     * @return A new CbType.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback Type applied to Interactors and Constraints.
 * <br/><br/>
 * Callback types are ranged over by listeners.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbTypeIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/CbTypeIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.callbacks.CbTypeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.callbacks.CbTypeList"/>
				<c path="nape.callbacks.CbTypeIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.callbacks.CbTypeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.callbacks.CbType"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbTypeList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/CbTypeList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.callbacks.CbType"/></c>
				<c path="nape.callbacks.CbTypeList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than CbType</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_CbTypeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.callbacks.CbType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.callbacks.CbType"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.callbacks.CbType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.callbacks.CbType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.callbacks.CbType"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.callbacks.CbType"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.callbacks.CbType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.callbacks.CbType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.callbacks.CbTypeIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.callbacks.CbTypeList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.callbacks.CbTypeList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.callbacks.CbType"/>
					<x path="Void"/>
				</f>
				<c path="nape.callbacks.CbTypeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.callbacks.CbType"/>
					<x path="Bool"/>
				</f>
				<c path="nape.callbacks.CbTypeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of CbType type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:CbType = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:CbType = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:CbType = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ConstraintCallback" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/ConstraintCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<constraint public="1" get="accessor" set="null">
			<c path="nape.constraint.Constraint"/>
			<haxe_doc>* Constraint involved in callback event.</haxe_doc>
		</constraint>
		<get_constraint get="inline" set="null" line="192"><f a=""><c path="nape.constraint.Constraint"/></f></get_constraint>
		<toString public="1" set="method" line="198" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Constraint type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ConstraintListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/ConstraintListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<options public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc><![CDATA[* The OptionType used to match against Constraints.
     * <br/><br/>
     * When added to the same Space, any Constraint who's CbType list matches
     * against this OptionType will be issued a callback when the relevant
     * event occurs.]]></haxe_doc>
		</options>
		<get_options get="inline" set="null" line="194"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options>
		<set_options get="inline" set="null" line="197"><f a="options">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options>
		<handler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="nape.callbacks.ConstraintCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The callback handler for this event.</haxe_doc>
		</handler>
		<get_handler get="inline" set="null" line="208"><f a=""><f a="">
	<c path="nape.callbacks.ConstraintCallback"/>
	<x path="Void"/>
</f></f></get_handler>
		<set_handler get="inline" set="null" line="211"><f a="handler">
	<f a="">
		<c path="nape.callbacks.ConstraintCallback"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="nape.callbacks.ConstraintCallback"/>
		<x path="Void"/>
	</f>
</f></set_handler>
		<new public="1" set="method" line="248">
			<f a="event:options:handler:?precedence" v=":::0">
				<c path="nape.callbacks.CbEvent"/>
				<t path="Null"><d/></t>
				<f a="">
					<c path="nape.callbacks.ConstraintCallback"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new ConstraintListener.
     * <br/><br/>
     * The possible event types are WAKE, SLEEP and BREAK.
     * <br/><br/>
     * The options argument is typed Dynamic, and is permitted to be either an
     * <code>OptionType</code> or one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     * In which case the input CbType's will be used to construct an OptionType
     * whose included types will be the set of CbTypes supplied.
     *
     * @param event The event type to listen for.
     * @param options The OptionType to match Constraints against, passing null
     *                will equate to an empty OptionType.
     * @param handler The callback handler for this listener.
     * @param precedence The precedence of this listener used to sort
     *                   the order of callbacks in the case of more than
     *                   one suitable ConstraintListener existing for the same
     *                   event on the same Constraint. (default 0)
     * @return The newly constructed ConstraintListener
     * @throws # If handler is null.
     * @throws # If the event type is not permitted for this listener.
     * @throws # If options is not of the expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Event listener for Constraint type events.
 * <br/><br/>
 * The events that can be caught are WAKE, SLEEP and BREAK type events.
 * Theses listeners will only operate on Constraints.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.InteractionCallback" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/InteractionCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<int1 public="1" get="accessor" set="null">
			<c path="nape.phys.Interactor"/>
			<haxe_doc><![CDATA[* First Interactor involved in callback event.
     * <br/><br/>
     * This interactor will have CbType set matched by the first
     * OptionType in InteractionListener]]></haxe_doc>
		</int1>
		<get_int1 get="inline" set="null" line="195"><f a=""><c path="nape.phys.Interactor"/></f></get_int1>
		<int2 public="1" get="accessor" set="null">
			<c path="nape.phys.Interactor"/>
			<haxe_doc><![CDATA[* Second Interactor involved in callback event.
     * <br/><br/>
     * This interactor will have CbType set matched by the second
     * OptionType in InteractionListener]]></haxe_doc>
		</int2>
		<get_int2 get="inline" set="null" line="206"><f a=""><c path="nape.phys.Interactor"/></f></get_int2>
		<arbiters public="1" get="accessor" set="null">
			<c path="nape.dynamics.ArbiterList"/>
			<haxe_doc><![CDATA[* Existing arbiters between interactors.
     * <br/><br/>
     * This list will at present contain 'all' arbiters, not just those matching the
     * interactionType in the InteractionListener. (This may be subject to change).]]></haxe_doc>
		</arbiters>
		<get_arbiters get="inline" set="null" line="217"><f a=""><c path="nape.dynamics.ArbiterList"/></f></get_arbiters>
		<toString public="1" set="method" line="223" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Interaction type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.InteractionListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/InteractionListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<options1 public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc>* The OptionType used to match against Interactors for the first object.</haxe_doc>
		</options1>
		<get_options1 get="inline" set="null" line="217"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options1>
		<set_options1 get="inline" set="null" line="220"><f a="options1">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options1>
		<options2 public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc>* The OptionType used to match against Interactors for the second object.</haxe_doc>
		</options2>
		<get_options2 get="inline" set="null" line="231"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options2>
		<set_options2 get="inline" set="null" line="234"><f a="options2">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options2>
		<interactionType public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc><![CDATA[* The specific type of interaction that is to be listened for.
     * <br/><br/>
     * If we specify that we only want to listen for a fluid type interaction, then
     * this listener will operate so that any other interactions for the same pair
     * of objects is ignored.]]></haxe_doc>
		</interactionType>
		<get_interactionType get="inline" set="null" line="249"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_interactionType>
		<set_interactionType get="inline" set="null" line="257"><f a="interactionType">
	<c path="nape.callbacks.InteractionType"/>
	<c path="nape.callbacks.InteractionType"/>
</f></set_interactionType>
		<handler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="nape.callbacks.InteractionCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The callback handler for this listener.</haxe_doc>
		</handler>
		<get_handler get="inline" set="null" line="276"><f a=""><f a="">
	<c path="nape.callbacks.InteractionCallback"/>
	<x path="Void"/>
</f></f></get_handler>
		<set_handler get="inline" set="null" line="279"><f a="handler">
	<f a="">
		<c path="nape.callbacks.InteractionCallback"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="nape.callbacks.InteractionCallback"/>
		<x path="Void"/>
	</f>
</f></set_handler>
		<allowSleepingCallbacks public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* For ONGOING listeners only, permit ONGOING callbacks whilst sleeping.
     * <br/><br/>
     * This property determines whether we will still receive
     * ONGOING callbacks between two sleeping Interactors. The default action is to
     * inhibit callbacks between sleeping objects for performance. Setting this field to true
     * will permit Nape to always generate callbacks.]]></haxe_doc>
		</allowSleepingCallbacks>
		<get_allowSleepingCallbacks get="inline" set="null" line="300"><f a=""><x path="Bool"/></f></get_allowSleepingCallbacks>
		<set_allowSleepingCallbacks get="inline" set="null" line="303"><f a="allowSleepingCallbacks">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowSleepingCallbacks>
		<new public="1" set="method" line="338">
			<f a="event:interactionType:options1:options2:handler:?precedence" v=":::::0">
				<c path="nape.callbacks.CbEvent"/>
				<c path="nape.callbacks.InteractionType"/>
				<t path="Null"><d/></t>
				<t path="Null"><d/></t>
				<f a="">
					<c path="nape.callbacks.InteractionCallback"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new InteractionListener.
     * <br/><br/>
     * The possible event types are BEGIN, ONGOING and END.
     * <br/><br/>
     * The options arguments are typed Dynamic, and are permitted to be either an
     * <code>OptionType</code> or one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     * In which case the input CbType's will be used to construct an OptionType
     * whose included types will be the set of CbTypes supplied.
     *
     * @param event The event type to listen for.
     * @param interactionType The interaction type to listen for.
     * @param options1 The OptionType to match first Interactor against, passing null
     *                will equate to an empty OptionType.
     * @param options2 The OptionType to match second Interactor against, passing null
     *                will equate to an empty OptionType.
     * @param handler The callback handler for this listener.
     * @param precedence The precedence of this listener used to sort
     *                   the order of callbacks in the case of more than
     *                   one suitable BodyListener existing for the same
     *                   event on the same Body. (default 0)
     * @return The newly constructed InteractionListener
     * @throws # If handler is null.
     * @throws # If the event type is not permitted for this listener.
     * @throws # If either option is not of the expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Event listener for Interaction type events.
 * <br/><br/>
 * Interaction type events can occur between any two Interactors (whether they
 * be Shapes, Bodys, Compounds or a mix thereof).
 * <br/><br/>
 * The events that can be caught are BEGIN, ONGOING, and END type events.
 * Theses listeners will operate between pairs of Interactors.
 * <pre>
 *          _Space
 *         /      \
 *     Cmp1        Cmp3
 *    /    \         |
 * Body1  Cmp2     Body3
 *   |      |        |
 * Shp1   Body2    Shp3
 *          |
 *        Shp2
 * </pre>
 * The possible interactor pairs for callbacks are formed by finding the most
 * recent common ancestor in the world for the given pair of shapes and taking all
 * possible pairings. In the above situation we have:
 * <pre>
 * MRCA(Shp1, Shp2) = Cmp1  --> Possible pairings = [Shp1, Body1] x [Shp2, Body2, Cmp2]
 * MRCA(Shp1, Shp3) = Space --> Possible pairings = [Shp1, Body1, Cmp1] x [Shp3, Body3, Cmp3]
 * MRCA(Shp2, Shp3) = Space --> Possible pairings = [Shp2, Body2, Cmp2, Cmp1] x [Shp3, Body3, Cmp3]
 * </pre>
 * Of course, not all of these pairings will generate callbacks, only those for which
 * a valid listener exists for the event type, and for the cbtypes of each interactor.
 * <br/><br/>
 * Furthermore, the listener specifies an interaction type which works even in mixed
 * cases where many types of interaction between two objects is happening at once.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.InteractionType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/InteractionType.hx">
		<COLLISION public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc>* Collision interaction type.</haxe_doc>
		</COLLISION>
		<get_COLLISION get="inline" set="null" line="203" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_COLLISION>
		<SENSOR public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc>* Sensor interaction type.
    ""</haxe_doc>
		</SENSOR>
		<get_SENSOR get="inline" set="null" line="215" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_SENSOR>
		<FLUID public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc>* Fluid interaction type.</haxe_doc>
		</FLUID>
		<get_FLUID get="inline" set="null" line="228" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_FLUID>
		<ANY public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc>* Special enum corresponding to 'all' interaction types.</haxe_doc>
		</ANY>
		<get_ANY get="inline" set="null" line="241" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_ANY>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Interaction types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ListenerIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/ListenerIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.callbacks.ListenerIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.callbacks.ListenerList"/>
				<c path="nape.callbacks.ListenerIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.callbacks.ListenerList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.callbacks.ListenerIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.callbacks.Listener"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ListenerList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/ListenerList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.callbacks.Listener"/></c>
				<c path="nape.callbacks.ListenerList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Listener</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ListenerList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.callbacks.Listener"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.callbacks.Listener"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.callbacks.Listener"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.callbacks.Listener"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.callbacks.Listener"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.callbacks.Listener"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.callbacks.Listener"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.callbacks.Listener"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.callbacks.ListenerIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.callbacks.ListenerList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.callbacks.ListenerList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.callbacks.Listener"/>
					<x path="Void"/>
				</f>
				<c path="nape.callbacks.ListenerList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.callbacks.Listener"/>
					<x path="Bool"/>
				</f>
				<c path="nape.callbacks.ListenerList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Listener type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Listener = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Listener = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Listener = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ListenerType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/ListenerType.hx">
		<BODY public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* Type for BodyListeners</haxe_doc>
		</BODY>
		<get_BODY get="inline" set="null" line="203" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_BODY>
		<CONSTRAINT public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* Type for ConstraintListeners</haxe_doc>
		</CONSTRAINT>
		<get_CONSTRAINT get="inline" set="null" line="216" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_CONSTRAINT>
		<INTERACTION public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* Type for InteractionListeners</haxe_doc>
		</INTERACTION>
		<get_INTERACTION get="inline" set="null" line="229" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_INTERACTION>
		<PRE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* Type for PreListeners</haxe_doc>
		</PRE>
		<get_PRE get="inline" set="null" line="242" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_PRE>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Listener types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.OptionType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/OptionType.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_OptionType"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<includes public="1" get="accessor" set="null">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc><![CDATA[* List of included CbTypes.
     * <br/><br/>
     * This list is both readonly, and immutable. To remove an element
     * from this list you can use: <code>option.excluding(cbType)</code>
     *
     * @default []]]></haxe_doc>
		</includes>
		<get_includes get="inline" set="null" line="214"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_includes>
		<excludes public="1" get="accessor" set="null">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc><![CDATA[* List of excluded CbTypes.
     * <br/><br/>
     * This list is both readonly, and immutable. To remove an element
     * from this list you can use: <code>option.including(cbType)</code>
     *
     * @default []]]></haxe_doc>
		</excludes>
		<get_excludes get="inline" set="null" line="228"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_excludes>
		<including public="1" set="method" line="267">
			<f a="?includes" v="null">
				<d/>
				<c path="nape.callbacks.OptionType"/>
			</f>
			<haxe_doc><![CDATA[* Append set of types to includes list.
     * <br/><br/>
     * This method was originally named the more appropriate 'include'
     * but this conflicted with the AS3 keyword include and had to be
     * change.
     * <br/><br/>
     * The argument is typed Dynamic, and is permitted to be one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt; flash.Vector&lt;CbType&gt;</code>
     *
     * @param includes The set of CbTypes to be included. (default null)
     * @return A reference to this OptionType.
     * @throws # If argument is not of the expected Type.]]></haxe_doc>
		</including>
		<excluding public="1" set="method" line="285">
			<f a="?excludes" v="null">
				<d/>
				<c path="nape.callbacks.OptionType"/>
			</f>
			<haxe_doc><![CDATA[* Append set of types to excludes list.
     * <br/><br/>
     * This method was originally named the more appropriate 'exclude'
     * but to match the necessary change for the include function, this was
     * renamed as excluding.
     * <br/><br/>
     * The argument is typed Dynamic, and is permitted to be one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt; flash.Vector&lt;CbType&gt;</code>
     *
     * @param excludes The set of CbTypes to be excluded. (default null)
     * @return A reference to this OptionType.
     * @throws # If argument is not of the expected Type.]]></haxe_doc>
		</excluding>
		<toString public="1" set="method" line="292">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="247">
			<f a="?includes:?excludes" v="null:null">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new OptionType.
     * <br/><br/>
     * The type of the arguments is Dynamic, and is permitted to be one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt; flash.Vector&lt;CbType&gt;</code>
     *
     * @param includes The set of CbTypes to be included in the matching process.
     *                 (default null)
     * @param excludes The set of CbTypes to be excluded in the matching process.
     *                 (default null)
     * @return Return new OptionType with give sets of CbTypes.
     * @throws # If either argument is not of the expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* OptionType representing matching behaviour for Listeners.
 * <br/><br/>
 * An object's set of CbType's 'matches' against an OptionType iff.
 * the OptionType's includes list intersects the object's set of CbTypes
 * and the OptionType's excludes list 'does not' intersect the object's set
 * of CbTypes.
 * <pre>
 * option = new OptionType([A, B], [C, D]);
 * obj.cbTypes = [] // => does not match option.
 * obj.cbTypes = [A] // => matches the option
 * obj.cbTypes = [A, C] // => does not match option.
 * </pre>
 * The optionType's includes and excludes list are managed to be always
 * disjoint: The action of including an already excluded type serves to
 * remove it from the excludes list, equalliy excluding an already included
 * type serves to remove it from the includes list.
 * <pre>
 * var option = new OptionType();
 * option.including(A); // option = {[A]:[]}
 * option.excluding(A); // option = {[]:[]}
 * option.excluding(A); // option = {[]:[A]}
 * option.including(A); // option = {[A]:[]}
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.PreCallback" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/PreCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<arbiter public="1" get="accessor" set="null">
			<c path="nape.dynamics.Arbiter"/>
			<haxe_doc><![CDATA[* Arbiter related to callback event.
     * <br/><br/>
     * In the case that this pre-event occurs between two non-Shape's
     * then this is the first arbiter to be created for the related
     * interactionType]]></haxe_doc>
		</arbiter>
		<get_arbiter get="inline" set="null" line="196"><f a=""><c path="nape.dynamics.Arbiter"/></f></get_arbiter>
		<int1 public="1" get="accessor" set="null">
			<c path="nape.phys.Interactor"/>
			<haxe_doc><![CDATA[* First Interactor involved in callback event.
     * <br/><br/>
     * This interactor will have CbType set matched by the first
     * OptionType in InteractionListener]]></haxe_doc>
		</int1>
		<get_int1 get="inline" set="null" line="207"><f a=""><c path="nape.phys.Interactor"/></f></get_int1>
		<int2 public="1" get="accessor" set="null">
			<c path="nape.phys.Interactor"/>
			<haxe_doc><![CDATA[* Second Interactor involved in callback event.
     * <br/><br/>
     * This interactor will have CbType set matched by the second
     * OptionType in InteractionListener]]></haxe_doc>
		</int2>
		<get_int2 get="inline" set="null" line="218"><f a=""><c path="nape.phys.Interactor"/></f></get_int2>
		<swapped public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Describes how Arbiter's objects are related to int1/int2 properties
     * <br/><br/>
     * If true, then arbiter.shape1 will belong to callback.int2, and
     * arbiter.shape2 will belong to callback.int1.
     * <br/><br/>
     * If you take the arbiter's normal, then if swapped is true, the normal
     * will point from int2 towards int1 instead of from int1 towards int2.]]></haxe_doc>
		</swapped>
		<get_swapped get="inline" set="null" line="232"><f a=""><x path="Bool"/></f></get_swapped>
		<toString public="1" set="method" line="238" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Pre-Interaction type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.PreFlag" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/PreFlag.hx">
		<ACCEPT public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.PreFlag"/>
			<haxe_doc>* Value denotes interaction will occur, and Nape will not ask again.</haxe_doc>
		</ACCEPT>
		<get_ACCEPT get="inline" set="null" line="204" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_ACCEPT>
		<IGNORE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.PreFlag"/>
			<haxe_doc>* Value denotes interaction will be ignored, and Nape will not ask again.</haxe_doc>
		</IGNORE>
		<get_IGNORE get="inline" set="null" line="217" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_IGNORE>
		<ACCEPT_ONCE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.PreFlag"/>
			<haxe_doc>* Value denotes interaction will occur 'this' step, and Nape will ask what
     * to do again in the following step if interaction is still possible.</haxe_doc>
		</ACCEPT_ONCE>
		<get_ACCEPT_ONCE get="inline" set="null" line="231" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_ACCEPT_ONCE>
		<IGNORE_ONCE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.PreFlag"/>
			<haxe_doc>* Value denotes interaction will be ignored 'this' step, and Nape will ask what
     * to do again in the following step if interaction is still possible.</haxe_doc>
		</IGNORE_ONCE>
		<get_IGNORE_ONCE get="inline" set="null" line="245" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_IGNORE_ONCE>
		<toString public="1" set="method" line="190">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="182">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of interaction states for arbiters. These values are returned
 * by PreListener callback handlers.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.PreListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/callbacks/PreListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<options1 public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc>* The OptionType used to match against Interactors for the first object.</haxe_doc>
		</options1>
		<get_options1 get="inline" set="null" line="190"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options1>
		<set_options1 get="inline" set="null" line="193"><f a="options1">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options1>
		<options2 public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc>* The OptionType used to match against Interactors for the second object.</haxe_doc>
		</options2>
		<get_options2 get="inline" set="null" line="204"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options2>
		<set_options2 get="inline" set="null" line="207"><f a="options2">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options2>
		<handler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="nape.callbacks.PreCallback"/>
				<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
			</f>
			<haxe_doc><![CDATA[* Callback handler for this listener.
     * <br/><br/>
     * This callback handler returns a possibly null PreFlag object.
     * <br/>
     * Passing null is equivalent to telling nape 'ignore me' so that whatever existing
     * decision has been made regarding the interaction is not modified.
     * Otherwise returning a non-null PreFlag will change the current decision about what
     * to do with the interaction.
     * <br/><br/>
     * Returning ACCEPT/IGNORE inform nape to take control over all subsequent interaction
     * between the two objects until they seperate. Returning these will mean that the pre
     * listener will not be invoked again until the objects seperate, and then begin to interact
     * afresh.
     * <br/><br/>
     * Returning #_ONCE, the objects will only be effected for a single step, and the following
     * step should they still be candidates for interaction, this handler will be invoked again.
     * <br/>
     * In the case of a #_ONCE, PreFlag; Nape will 'not' permit the two objects to go to sleep
     * as Nape cannot know if this callback handler will suddenly changes its mind.
     * <br/>
     * If this handler is a 'pure' function, then you may mark it as such and Nape will keep you
     * to your word and permit the objects to sleep.]]></haxe_doc>
		</handler>
		<get_handler get="inline" set="null" line="239"><f a=""><f a="">
	<c path="nape.callbacks.PreCallback"/>
	<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
</f></f></get_handler>
		<set_handler get="inline" set="null" line="242"><f a="handler">
	<f a="">
		<c path="nape.callbacks.PreCallback"/>
		<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
	</f>
	<f a="">
		<c path="nape.callbacks.PreCallback"/>
		<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
	</f>
</f></set_handler>
		<pure public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Mark this listener as having a pure callback handler.
     * <br/><br/>
     * A pure callback handler is one which under no circumstances will change its behaviour.
     * In such a (favourable) instance, marking the callback as pure will allow Nape to permit
     * objects in interaction to go to sleep even if the handler returns an IGNORE_ONCE/ACCEPT_ONCE
     * PreFlag.
     *
     * @default false]]></haxe_doc>
		</pure>
		<get_pure get="inline" set="null" line="266"><f a=""><x path="Bool"/></f></get_pure>
		<set_pure get="inline" set="null" line="269"><f a="pure">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pure>
		<interactionType public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc><![CDATA[* The specific type of interaction that is to be listened for.
     * <br/><br/>
     * If we specify that we only want to listen for a fluid type interaction, then
     * this listener will operate so that any other interactions for the same pair
     * of objects is ignored.]]></haxe_doc>
		</interactionType>
		<get_interactionType get="inline" set="null" line="287"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_interactionType>
		<set_interactionType get="inline" set="null" line="295"><f a="interactionType">
	<c path="nape.callbacks.InteractionType"/>
	<c path="nape.callbacks.InteractionType"/>
</f></set_interactionType>
		<new public="1" set="method" line="336">
			<f a="interactionType:options1:options2:handler:?precedence:?pure" v="::::0:false">
				<c path="nape.callbacks.InteractionType"/>
				<t path="Null"><d/></t>
				<t path="Null"><d/></t>
				<f a="">
					<c path="nape.callbacks.PreCallback"/>
					<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
				</f>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new PreListener.
     * <br/><br/>
     * The options arguments are typed Dynamic, and are permitted to be either an
     * <code>OptionType</code> or one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     * In which case the input CbType's will be used to construct an OptionType
     * whose included types will be the set of CbTypes supplied.
     *
     * @param interactionType The interaction type to listen for.
     * @param options1 The OptionType to match first Interactor against, passing null
     *                will equate to an empty OptionType.
     * @param options2 The OptionType to match second Interactor against, passing null
     *                will equate to an empty OptionType.
     * @param handler The callback handler for this listener.
     * @param precedence The precedence of this listener used to sort
     *                   the order of callbacks in the case of more than
     *                   one suitable BodyListener existing for the same
     *                   event on the same Body. (default 0)
     * @param pure If true, then the listener will be marked as having a pure handler.
     *             (default false)
     * @return The newly constructed InteractionListener
     * @throws # If handler is null.
     * @throws # If either option is not of the expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Event listener for Pre-Interaction type events.
 * <br/><br/>
 * Pre-Interaction type events can occur between any two Interactors (whether they
 * be Shapes, Bodys, Compounds or a mix thereof).]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.Constraint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/Constraint.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.constraint.ZPP_Constraint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<debugDraw public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Set to disable debug drawing/
     * <br/><br/>
     * When true, this Constraint will not be drawn during debug draw operations
     * unless specifically given as argument to Debug draw() method.
     * @default true]]></haxe_doc>
		</debugDraw>
		<compound public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Compound"/></t>
			<haxe_doc><![CDATA[* Compound this Constraints belong to.
     * <br/><br/>
     * If this constraint is in a Space or another Compound and you change
     * its compound, then it will be removed from that Space or Compound.
     *
     * @default null]]></haxe_doc>
		</compound>
		<get_compound get="inline" set="null" line="219"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_compound>
		<set_compound get="inline" set="null" line="222"><f a="compound">
	<t path="Null"><c path="nape.phys.Compound"/></t>
	<t path="Null"><c path="nape.phys.Compound"/></t>
</f></set_compound>
		<space public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.space.Space"/></t>
			<haxe_doc><![CDATA[* Space this constraint is inside of.
     * <br/><br/>
     * Whether this constraint is directly in a Space, or part of a Compound
     * which is inside of a space, this value will be equal to that Space.
     * <br/><br/>
     * If this constraint is inside of a Compound, then you cannot modify its
     * Space as the constraint belongs to that Compound.
     *
     * @default null]]></haxe_doc>
		</space>
		<get_space get="inline" set="null" line="248"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<set_space get="inline" set="null" line="251"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<isSleeping public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether this constraint is sleeping or not.
     * <br/><br/>
     * This property is only defined if the constraint is inside of a Space
     * and is active, otherwise an error will be thrown should you access this
     * property.
     * <br/><br/>
     * This value is immutable, In Nape you do not ever need to manually
     * wake up a Constraint. It will always be done automatically without error.
     * <br/><br/>
     * To manually put a Constraint to sleep is against the very nature of Nape
     * API and so is excluded from the core of Nape. If you really want to do this
     * you should make use of the nape-hacks module.]]></haxe_doc>
		</isSleeping>
		<get_isSleeping get="inline" set="null" line="290"><f a=""><x path="Bool"/></f></get_isSleeping>
		<active public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether this constraint is active or not.
     * <br/><br/>
     * Setting a constraint to be no longer active is a useful way of
     * temporarigly disabling a constraint without having to remove it
     * from a Space.
     *
     * @default true]]></haxe_doc>
		</active>
		<get_active get="inline" set="null" line="309"><f a=""><x path="Bool"/></f></get_active>
		<set_active get="inline" set="null" line="312"><f a="active">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_active>
		<ignore public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether interactions between related Bodys will be ignored.
     * <br/><br/>
     * If true, then the Bodys related to this constraint will not
     * be permitted to interact in anyway, including callbacks.
     *
     * @default false]]></haxe_doc>
		</ignore>
		<get_ignore get="inline" set="null" line="347"><f a=""><x path="Bool"/></f></get_ignore>
		<set_ignore get="inline" set="null" line="350"><f a="ignore">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignore>
		<stiff public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether constraint is stiff, or elastic.
     * <br/><br/>
     * A stiff constraint has its positional error resolved directly
     * as with contact penetrations. This is generally a more stable
     * way of solving positional errors but has a side-effect that for example
     * changing the pivot point on a constraint used for mouse control will not
     * cause the objects to swing as the positional error is solved without
     * effecting the velocity of the object which may not be wanted.
     * <br/><br/>
     * If false, then the positional error of the constraint will be
     * resolved in an elastic way using changes in velocity.
     *
     * @default true]]></haxe_doc>
		</stiff>
		<get_stiff get="inline" set="null" line="376"><f a=""><x path="Bool"/></f></get_stiff>
		<set_stiff get="inline" set="null" line="379"><f a="stiff">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_stiff>
		<frequency public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Frequency of elastic properties of constraint.
     * <br/><br/>
     * This property only has an effect when constraint is not stiff.
     * <br/><br/>
     * This value corresponds to in an ideal situation, the number of
     * spring like oscillations the constraint will make per second.
     * <br/><br/>
     * This value must be strictly positive (0 not allowed).
     *
     * @default 10]]></haxe_doc>
		</frequency>
		<get_frequency get="inline" set="null" line="402"><f a=""><x path="Float"/></f></get_frequency>
		<set_frequency get="inline" set="null" line="405"><f a="frequency">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frequency>
		<damping public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Damping ratio of elastic properties of constraint.
     * <br/><br/>
     * This property only has an effect when constraint is not stiff.
     * <br/><br/>
     * This value corresponds to in the ideal situation, the damping
     * ratio of the constraints oscillations with 1 corresponding to
     * a total dampening, and values greater than one being over-dampening.
     * <br/><br/>
     * This value must be zero or positive.
     *
     * @default 1]]></haxe_doc>
		</damping>
		<get_damping get="inline" set="null" line="439"><f a=""><x path="Float"/></f></get_damping>
		<set_damping get="inline" set="null" line="442"><f a="damping">
	<x path="Float"/>
	<x path="Float"/>
</f></set_damping>
		<maxForce public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The maximum amount of force this constraint is allowed to use.
     * <br/><br/>
     * This value, whilst still used in a stiff constraint will not work
     * as you might hope for; since a stiff constraint resolves positional
     * error without using impulses, the maxForce will not have any effect
     * on how positional errors are resolved.
     * <br/><br/>
     * This value must be zero or positive.
     *
     * @default infinity]]></haxe_doc>
		</maxForce>
		<get_maxForce get="inline" set="null" line="475"><f a=""><x path="Float"/></f></get_maxForce>
		<set_maxForce get="inline" set="null" line="478"><f a="maxForce">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxForce>
		<maxError public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The maximum amount of error this constraint is allowed to use.
     * <br/><br/>
     * For stiff constraints, this value only serves to work in conjunction
     * with breakUnderError to permit breaking of the constraint.
     * <br/><br/>
     * For non-stiff constraints, this value will also effect how the constraint
     * behaves when breakUnderError is false by restricting the amount of error
     * that will be resolved; this will not work for stiff constraints.
     *
     * @default infinity]]></haxe_doc>
		</maxError>
		<get_maxError get="inline" set="null" line="509"><f a=""><x path="Float"/></f></get_maxError>
		<set_maxError get="inline" set="null" line="512"><f a="maxError">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxError>
		<breakUnderForce public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether constraint will break once maxForce is reached.
     * <br/><br/>
     * This property effects both stiff and non-stiff constraints, though
     * for the same reasons as those of maxForce, does not make much sense
     * to be used in stiff constraints.
     *
     * @default false]]></haxe_doc>
		</breakUnderForce>
		<get_breakUnderForce get="inline" set="null" line="540"><f a=""><x path="Bool"/></f></get_breakUnderForce>
		<set_breakUnderForce get="inline" set="null" line="543"><f a="breakUnderForce">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_breakUnderForce>
		<breakUnderError public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether constraint will break once maxError is reached.
     * <br/><br/>
     * This property effects both stiff and non-stiff constraints.
     *
     * @default false]]></haxe_doc>
		</breakUnderError>
		<get_breakUnderError get="inline" set="null" line="561"><f a=""><x path="Bool"/></f></get_breakUnderError>
		<set_breakUnderError get="inline" set="null" line="564"><f a="breakUnderError">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_breakUnderError>
		<removeOnBreak public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether constraint will be removed when it breaks.
     * <br/><br/>
     * If true, then when constraint is broken it will be removed from
     * the Space. Otherwise it will simple be made inactive.
     *
     * @default true]]></haxe_doc>
		</removeOnBreak>
		<get_removeOnBreak get="inline" set="null" line="583"><f a=""><x path="Bool"/></f></get_removeOnBreak>
		<set_removeOnBreak get="inline" set="null" line="586"><f a="removeOnBreak">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_removeOnBreak>
		<impulse public="1" set="method" line="597">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc>* Return the constraint-space impulse applied in previous step.
     *
     * @return A new MatMN representing the constraint space impulse.</haxe_doc>
		</impulse>
		<bodyImpulse public="1" set="method" line="610">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Compute impulse that was applied to the given Body.
     * <br/><br/>
     * This impulse is the actual (mass weighted) change in velocity
     * that occured due to this constraint.
     *
     * @param body The Body to compute impulse for.
     * @return The impulse that was applied to the body in the previous step.
     * @throws # If Body is not related to the Constraint.]]></haxe_doc>
		</bodyImpulse>
		<visitBodies public="1" set="method" line="622">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Apply given function to all Bodys linked to the constraint.
     * <br/><br/>
     * If a body is duplicated in a constraint then it will only
     * be visited once.
     *
     * @param lambda The function to apply to each Body.
     * @throws # If lambda is null.]]></haxe_doc>
		</visitBodies>
		<cbTypes public="1" get="accessor" set="null">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc><![CDATA[* Set of CbTypes for this constraints for callbacks.
     * <br/><br/>
     * This value cannot at present be set, but can be modified.
     *
     * @default [CbType.ANY_CONSTRAINT]]]></haxe_doc>
		</cbTypes>
		<get_cbTypes get="inline" set="null" line="632"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_cbTypes>
		<toString public="1" set="method" line="650">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<copy public="1" set="method" line="661">
			<f a=""><c path="nape.constraint.Constraint"/></f>
			<haxe_doc><![CDATA[* Produce copy of constraint.
     * <br/><br/>
     * All constraint properties except for internal impulse cache
     * and userData field will be copied.
     *
     * @return The copied Constraint.]]></haxe_doc>
		</copy>
		<new public="1" set="method" line="641">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Base type for all Nape joints and constraints</haxe_doc>
	</class>
	<class path="nape.constraint.AngleJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/AngleJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_AngleJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<get_body1 get="inline" set="null" line="195"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<set_body1 get="inline" set="null" line="198"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<get_body2 get="inline" set="null" line="233"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<set_body2 get="inline" set="null" line="236"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<jointMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Lower bound for constraint.
     * <br/><br/>
     * This value must be less than or equal to jointMax.
     *
     * @default -infinity]]></haxe_doc>
		</jointMin>
		<get_jointMin get="inline" set="null" line="272"><f a=""><x path="Float"/></f></get_jointMin>
		<set_jointMin get="inline" set="null" line="275"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<jointMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Upper bound for constraint.
     * <br/><br/>
     * This value must be greater than or equal to jointMin.
     *
     * @default infinity]]></haxe_doc>
		</jointMax>
		<get_jointMax get="inline" set="null" line="299"><f a=""><x path="Float"/></f></get_jointMax>
		<set_jointMax get="inline" set="null" line="302"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<ratio public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Ratio property of constraint.
     *
     * @default 1</haxe_doc>
		</ratio>
		<get_ratio get="inline" set="null" line="324"><f a=""><x path="Float"/></f></get_ratio>
		<set_ratio get="inline" set="null" line="327"><f a="ratio">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ratio>
		<isSlack public="1" get="inline" set="null" line="353">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if constraint is slack.
     * <br/><br/>
     * This constraint is slack if the positional error is within
     * the bounds of (jointMin, jointMax).
     *
     * @return True if positional error of constraint is between the limits
     *              indicating that the constraint is not doing any work.
     * @throws # If either of the bodies is null.]]></haxe_doc>
		</isSlack>
		<impulse public="1" set="method" line="398" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 1x1.]]></haxe_doc>
		</impulse>
		<bodyImpulse public="1" set="method" line="408" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, only the z coordinate will be non-zero.]]></haxe_doc>
		</bodyImpulse>
		<visitBodies public="1" set="method" line="427" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<new public="1" set="method" line="373">
			<f a="body1:body2:jointMin:jointMax:?ratio" v="::::1.0f">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new AngleJoint.
     *
     * @param body1 The first body in AngleJoint.
     * @param body2 The second body in AngleJoint.
     * @param jointMin The lower bound for constraint.
     * @param jointMax The upper bound for constraint.
     * @param ratio The ratio of joint (default 1)
     * @return The constructed AngleJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* AngleJoint constraining the relative angles of two Bodies.
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * jointMin <= ratio * body2.rotation - body1.rotation <= jointMax
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.ConstraintIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/ConstraintIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.constraint.ConstraintIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.constraint.ConstraintList"/>
				<c path="nape.constraint.ConstraintIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.constraint.ConstraintIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.constraint.Constraint"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.ConstraintList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/ConstraintList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.constraint.Constraint"/></c>
				<c path="nape.constraint.ConstraintList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Constraint</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ConstraintList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.constraint.Constraint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.constraint.Constraint"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.constraint.Constraint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.constraint.Constraint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.constraint.Constraint"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.constraint.Constraint"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.constraint.Constraint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.constraint.Constraint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.constraint.ConstraintIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.constraint.ConstraintList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.constraint.ConstraintList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.constraint.Constraint"/>
					<x path="Void"/>
				</f>
				<c path="nape.constraint.ConstraintList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.constraint.Constraint"/>
					<x path="Bool"/>
				</f>
				<c path="nape.constraint.ConstraintList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Constraint type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Constraint = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Constraint = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Constraint = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.DistanceJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/DistanceJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_DistanceJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<get_body1 get="inline" set="null" line="197"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<set_body1 get="inline" set="null" line="200"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<get_body2 get="inline" set="null" line="235"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<set_body2 get="inline" set="null" line="238"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<anchor1 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on first Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body1.]]></haxe_doc>
		</anchor1>
		<get_anchor1 get="inline" set="null" line="272"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<set_anchor1 get="inline" set="null" line="276"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<anchor2 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on second Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body2.]]></haxe_doc>
		</anchor2>
		<get_anchor2 get="inline" set="null" line="297"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<set_anchor2 get="inline" set="null" line="301"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<jointMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Lower bound for constraint.
     * <br/><br/>
     * This value must be less than or equal to jointMax, and greater equal to 0.]]></haxe_doc>
		</jointMin>
		<get_jointMin get="inline" set="null" line="322"><f a=""><x path="Float"/></f></get_jointMin>
		<set_jointMin get="inline" set="null" line="325"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<jointMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Upper bound for constraint.
     * <br/><br/>
     * This value must be greater than or equal to jointMin.]]></haxe_doc>
		</jointMax>
		<get_jointMax get="inline" set="null" line="350"><f a=""><x path="Float"/></f></get_jointMax>
		<set_jointMax get="inline" set="null" line="353"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<isSlack public="1" get="inline" set="null" line="382">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if constraint is slack.
     * <br/><br/>
     * This constraint is slack if the positional error is within
     * the bounds of (jointMin, jointMax).
     *
     * @return True if positional error of constraint is between the limits
     *              indicating that the constraint is not doing any work.
     * @throws # If either of the bodies is null.]]></haxe_doc>
		</isSlack>
		<impulse public="1" set="method" line="429" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 1x1.]]></haxe_doc>
		</impulse>
		<bodyImpulse public="1" set="method" line="437" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</bodyImpulse>
		<visitBodies public="1" set="method" line="456" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<new public="1" set="method" line="403">
			<f a="body1:body2:anchor1:anchor2:jointMin:jointMax">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new DistanceJoint.
     *
     * @param body1 The first body in DistanceJoint.
     * @param body2 The second body in DistanceJoint.
     * @param anchor1 The first local anchor for joint.
     * @param anchor2 The second local anchor for joint.
     * @param jointMin The lower bound for constraint.
     * @param jointMax The upper bound for constraint.
     * @return The constructed DistanceJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* DistanceJoint limiting the distance between two local anchor points of Bodies.
 * <br/><br/>
 * The equation for this constraint could be written like:
 * <pre>
 * jointMin <= distance(body2.localPointToWorld(anchor2), body1.localPointToWorld(anchor1)) <= jointMax
 * </pre>
 * This joint is not designed to work when <code> jointMin = jointMax = 0 </code> and constraint is
 * stiff. In this instance you should use a PivotJoint instead.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.LineJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/LineJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_LineJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint, defining the line segment.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<get_body1 get="inline" set="null" line="221"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<set_body1 get="inline" set="null" line="224"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<get_body2 get="inline" set="null" line="259"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<set_body2 get="inline" set="null" line="262"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<anchor1 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on first Body, defining position on line.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body1.]]></haxe_doc>
		</anchor1>
		<get_anchor1 get="inline" set="null" line="296"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<set_anchor1 get="inline" set="null" line="300"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<anchor2 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on second Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body2.]]></haxe_doc>
		</anchor2>
		<get_anchor2 get="inline" set="null" line="321"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<set_anchor2 get="inline" set="null" line="325"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<direction public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Direction of line on first Body.
     * <br/><br/>
     * This direction is defined in the local coordinate system of body1 and
     * need not be normalised.]]></haxe_doc>
		</direction>
		<get_direction get="inline" set="null" line="347"><f a=""><c path="nape.geom.Vec2"/></f></get_direction>
		<set_direction get="inline" set="null" line="351"><f a="direction">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_direction>
		<jointMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Lower bound for constraint.
     * <br/><br/>
     * This value must be less than or equal to jointMax.]]></haxe_doc>
		</jointMin>
		<get_jointMin get="inline" set="null" line="372"><f a=""><x path="Float"/></f></get_jointMin>
		<set_jointMin get="inline" set="null" line="375"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<jointMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Upper bound for constraint.
     * <br/><br/>
     * This value must be greater than or equal to jointMin.]]></haxe_doc>
		</jointMax>
		<get_jointMax get="inline" set="null" line="397"><f a=""><x path="Float"/></f></get_jointMax>
		<set_jointMax get="inline" set="null" line="400"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<impulse public="1" set="method" line="456" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 2x1.]]></haxe_doc>
		</impulse>
		<bodyImpulse public="1" set="method" line="465" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</bodyImpulse>
		<visitBodies public="1" set="method" line="484" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<new public="1" set="method" line="429">
			<f a="body1:body2:anchor1:anchor2:direction:jointMin:jointMax">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new LineJoint.
     *
     * @param body1 The first body in LineJoint.
     * @param body2 The second body in LineJoint.
     * @param anchor1 The first local anchor for joint.
     * @param anchor2 The second local anchor for joint.
     * @param direction The direction of local line for joint.
     * @param jointMin The lower bound for constraint.
     * @param jointMax The upper bound for constraint.
     * @return The constructed LineJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* LineJoint constraining anchor of one body, to a line segment of the other.
 * <br/><br/>
 * The equation for this constraint could be written like:
 * <pre>
 *        0  = [dir.cross(delta)]  = 0
 * jointMin <= [dor.dot  (delta)] <= jointMax
 * </pre>
 * where:
 * <pre>
 * dir   = body1.localVectorToWorld(direction).unit();
 * delta = body2.localPointToWorld(anchor2).sub(body1.localPointToWorld(anchor1));
 * </pre>
 * This is a 2 dimensional constraint, and is (when at the limits) solved as a
 * block constraint for better stability. This is however not the most stable
 * of joint when chained and put under stress and is a rather rare case where
 * using a non-stiff joint can actually be more stable than
 * using a stiff one.
 * <br/><br/>
 * When <code> jointMin = jointMax </code>, it would be better to use a PivotJoint
 *instead with suitable
 * placed anchors.
 * <br/><br/>
 * The line segment is defined implicitly via the
 * <code>anchor1, direction, jointMin and jointMax</code> properties with end
 * points defined in local coordinate system of body1 like:
 * <pre>
 * start = anchor1.add(direction.unit().mul(jointMin))
 * end   = anchor1.add(direction.unit().mul(jointMax))
 * </pre>
 * The reason for this more general description of a line segment is that one or
 * both of jointMin, jointMax are permitted to be infinite and a line segment
 * defined with a start and end point is not sufficient to describe such lines.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.MotorJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/MotorJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_MotorJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<get_body1 get="inline" set="null" line="196"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<set_body1 get="inline" set="null" line="199"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<get_body2 get="inline" set="null" line="234"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<set_body2 get="inline" set="null" line="237"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<ratio public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* MotorJoint ratio.
     *
     * @default 1</haxe_doc>
		</ratio>
		<get_ratio get="inline" set="null" line="271"><f a=""><x path="Float"/></f></get_ratio>
		<set_ratio get="inline" set="null" line="274"><f a="ratio">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ratio>
		<rate public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* MotorJoint rate
     *
     * @default 0</haxe_doc>
		</rate>
		<get_rate get="inline" set="null" line="296"><f a=""><x path="Float"/></f></get_rate>
		<set_rate get="inline" set="null" line="299"><f a="rate">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rate>
		<impulse public="1" set="method" line="349" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 1x1.]]></haxe_doc>
		</impulse>
		<bodyImpulse public="1" set="method" line="359" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, only the z coordinate will be non-zero.]]></haxe_doc>
		</bodyImpulse>
		<visitBodies public="1" set="method" line="378" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<new public="1" set="method" line="325">
			<f a="body1:body2:?rate:?ratio" v="::0.0f:1.0f">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new MotorJoint
     *
     * @param body1 The first body in MotorJoint
     * @param body2 The second body in MotorJoint
     * @param rate The rate of motor. (default 0)
     * @param ratio The ratio of the motor. (default 1)
     * @return The constructed MotorJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* MotorJoint constraining the angular velocities of two bodies
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * (ratio * body2.angularVel) - body1.angularVel = rate
 * </pre>
 * This constraint operates only on the velocities of objects.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.PivotJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/PivotJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_PivotJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<get_body1 get="inline" set="null" line="199"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<set_body1 get="inline" set="null" line="202"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<get_body2 get="inline" set="null" line="237"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<set_body2 get="inline" set="null" line="240"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<anchor1 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on first Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body1.]]></haxe_doc>
		</anchor1>
		<get_anchor1 get="inline" set="null" line="274"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<set_anchor1 get="inline" set="null" line="278"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<anchor2 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on second Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body2.]]></haxe_doc>
		</anchor2>
		<get_anchor2 get="inline" set="null" line="299"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<set_anchor2 get="inline" set="null" line="303"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<impulse public="1" set="method" line="352" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 2x1.]]></haxe_doc>
		</impulse>
		<bodyImpulse public="1" set="method" line="361" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</bodyImpulse>
		<visitBodies public="1" set="method" line="380" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<new public="1" set="method" line="328">
			<f a="body1:body2:anchor1:anchor2">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new PivotJoint.
     *
     * @param body1 The first body in PivotJoint.
     * @param body2 The second body in PivotJoint.
     * @param anchor1 The first local anchor for joint.
     * @param anchor2 The second local anchor for joint.
     * @return The constructed PivotJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* PivotJoint constraining two anchors points of bodies to be equal.
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * body2.localPointToWorld(anchor2) = body1.localPointToWorld(anchor1)
 * </pre>
 * You may view this constraint as being equal to the DistanceJoint constraint
 * when both its jointMin and jointMax are exactly 0 (In such a case a
 * DistanceJoint becomes degenerate). Compared to the DistanceJoint this is
 * a 2 dimensional constraint.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.PulleyJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/PulleyJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_PulleyJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<get_body1 get="inline" set="null" line="200"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<set_body1 get="inline" set="null" line="203"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<get_body2 get="inline" set="null" line="238"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<set_body2 get="inline" set="null" line="241"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<body3 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Third Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body3>
		<get_body3 get="inline" set="null" line="276"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body3>
		<set_body3 get="inline" set="null" line="279"><f a="body3">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body3>
		<body4 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Fourth Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body4>
		<get_body4 get="inline" set="null" line="314"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body4>
		<set_body4 get="inline" set="null" line="317"><f a="body4">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body4>
		<anchor1 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on first Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body1.]]></haxe_doc>
		</anchor1>
		<get_anchor1 get="inline" set="null" line="351"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<set_anchor1 get="inline" set="null" line="355"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<anchor2 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on second Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body2.]]></haxe_doc>
		</anchor2>
		<get_anchor2 get="inline" set="null" line="376"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<set_anchor2 get="inline" set="null" line="380"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<anchor3 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on third Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body3.]]></haxe_doc>
		</anchor3>
		<get_anchor3 get="inline" set="null" line="401"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor3>
		<set_anchor3 get="inline" set="null" line="405"><f a="anchor3">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor3>
		<anchor4 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on fourth Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body4.]]></haxe_doc>
		</anchor4>
		<get_anchor4 get="inline" set="null" line="426"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor4>
		<set_anchor4 get="inline" set="null" line="430"><f a="anchor4">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor4>
		<jointMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Lower bound for constraint.
     * <br/><br/>
     * This value must be less than or equal to jointMax, and greater equal to 0.]]></haxe_doc>
		</jointMin>
		<get_jointMin get="inline" set="null" line="451"><f a=""><x path="Float"/></f></get_jointMin>
		<set_jointMin get="inline" set="null" line="454"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<jointMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Upper bound for constraint.
     * <br/><br/>
     * This value must be greater than or equal to jointMin.]]></haxe_doc>
		</jointMax>
		<get_jointMax get="inline" set="null" line="479"><f a=""><x path="Float"/></f></get_jointMax>
		<set_jointMax get="inline" set="null" line="482"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<ratio public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Ratio property of constraint.
     *
     * @default 1</haxe_doc>
		</ratio>
		<get_ratio get="inline" set="null" line="507"><f a=""><x path="Float"/></f></get_ratio>
		<set_ratio get="inline" set="null" line="510"><f a="ratio">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ratio>
		<isSlack public="1" get="inline" set="null" line="536">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if constraint is slack.
     * <br/><br/>
     * This constraint is slack if the positional error is within
     * the bounds of (jointMin, jointMax).
     *
     * @return True if positional error of constraint is between the limits
     *              indicating that the constraint is not doing any work.
     * @throws # If any of the bodies is null.]]></haxe_doc>
		</isSlack>
		<impulse public="1" set="method" line="593" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 1x1.]]></haxe_doc>
		</impulse>
		<bodyImpulse public="1" set="method" line="601" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</bodyImpulse>
		<visitBodies public="1" set="method" line="620" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<new public="1" set="method" line="562">
			<f a="body1:body2:body3:body4:anchor1:anchor2:anchor3:anchor4:jointMin:jointMax:?ratio" v="::::::::::1.0f">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new PulleyJoint.
     *
     * @param body1 The first body in PulleyJoint.
     * @param body2 The second body in PulleyJoint.
     * @param body3 The third body in PulleyJoint.
     * @param body4 The fourth body in PulleyJoint.
     * @param anchor1 The first local anchor for joint.
     * @param anchor2 The second local anchor for joint.
     * @param anchor3 The third local anchor for joint.
     * @param anchor4 The fourth local anchor for joint.
     * @param jointMin The lower bound for constraint.
     * @param jointMax The upper bound for constraint.
     * @param ratio The ratio for constraint.
     * @return The constructed PulleyJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* PulleyJoint limiting the weighted sum of distances between 2 pairs of 4 local anchor points of Bodies.
 * <br/><br/>
 * The equation for this constraint could be written like:
 * <pre>
 * jointMin <= distance(body2.localPointToWorld(anchor2), body1.localPointToWorld(anchor1))
 *   + ratio * distance(body4.localPointToWorld(anchor4), body3.localPointToWorld(anchor3)) <= jointMax
 * </pre>
 * This joint is not designed to work when either of these pairs achieves a distance of 0, it will still work
 * but may not be entirely ideal.
!1*<br/><br/> * This constraint can be used in a full 4-body set up, or a 3-body set up or a 2-body set up permitting
 * any arrangement as long as body1 != body2 and body3 != body4]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.UserConstraint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/UserConstraint.hx">
		<extends path="nape.constraint.Constraint"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_UserConstraint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<__bindVec2 public="1" set="method" line="223">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Create a Vec2 property for user-constraint.
     * <br/><br/>
     * This method is used in creating a custom constraint, to create a
     * Vec2 property which will be tied to this constraint so that modifications
     * to the Vec2 will have the appropriate side effects on constraint.
     * <pre>
     * //Haxe (Cleanest way without using macros, clearly you must ensure this
     * //      is set at least once, likely in constructor)
     * public var property(default, set_property):Vec2;
     * inline function set_property(property:Vec2) {
     *     if (this.property == null) this.property = __bindVec2();
     *     return this.property.set(property);
     * }
     *
     * //AS3
     * private var _property:Vec2 = __bindVec2();
     * public function get property():Vec2 { return _property; }
     * public function set property(property:Vec2):void {
     *     _property.set(property);
     * }
     * </pre>
     * This bound Vec2 will behave like standard Nape anchor/direction Vec2's.
     * <br/><br/>
     * You should hide this method in your sub-type.]]></haxe_doc>
		</__bindVec2>
		<__copy public="1" set="method" line="241">
			<f a=""><c path="nape.constraint.UserConstraint"/></f>
			<haxe_doc><![CDATA[* Internal copying of user defined constraint.
     * <br/><br/>
     * This method must be overriden, and defines how your customised constraint
     * is to be copied. Likely by simply calling your constructor with constraint
     * properties as argument.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @return A copy of your constraint.
     * @throws # If not overriden by sub-type.]]></haxe_doc>
		</__copy>
		<__broken public="1" set="method" line="256">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Internal extra steps in breaking constraint
     * <br/><br/>
     * This method may be optionally overriden, and defines extra steps to
     * be taken when your constraint is broken. This will be called before
     * the constraint is removed or made inactive.
     * <br/><br/>
     * You should hide this method in your sub-type.]]></haxe_doc>
		</__broken>
		<__validate public="1" set="method" line="271">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Internal validation of constraint.
     * <br/><br/>
     * This method may be optionally overriden, and defines extra validation
     * steps to be made in validating your constraint integrity in terms of
     * property values. (Think things like standard nape errors if a body
     * is not in the same space as constraint).
     * <br/><br/>
     * This method will be called in all build types, not just debug and can also
     * be used to pre-compute values that will remain constant over an entire
     * time step and do not depend on the state of the Body's.
     * <br/><br/>
     * You should hide this method in your sub-type.]]></haxe_doc>
		</__validate>
		<__draw public="1" set="method" line="282">
			<f a="debug">
				<c path="nape.util.Debug"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal debug drawing of constraint.
     * <br/><br/>
     * This method will be called by Nape debug draws when enabled to
     * draw your constraint. You do not need to override this method.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param debug Nape Debug draw to draw constraint to.]]></haxe_doc>
		</__draw>
		<__prepare public="1" set="method" line="291">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Internal position dependant calculations for constraint.
     * <br/><br/>
     * This method may be overriden to define extra computations that will
     * remain constant as long as a Body's position/rotation is not changed.
     * <br/><br/>
     * You should hide this method in your sub-type.]]></haxe_doc>
		</__prepare>
		<__position public="1" set="method" line="300">
			<f a="err">
				<t path="nape.TArray"><x path="Float"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal positional error function for constraint.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param err The output array to store constraint space positional error.
     * @throws # If this is not a velocity-only constraint, and is not overriden.]]></haxe_doc>
		</__position>
		<__velocity public="1" set="method" line="313">
			<f a="err">
				<t path="nape.TArray"><x path="Float"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal velocity error function for constraint.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param err The output array to store constraint space velocity error.
     * @throws # If not overriden by sub-type.]]></haxe_doc>
		</__velocity>
		<__eff_mass public="1" set="method" line="335">
			<f a="eff">
				<t path="nape.TArray"><x path="Float"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal effective mass matrix function for constraint.
     * <br/><br/>
     * This array will be of size <code>dimension * (dimension - 1)</code> as a
     * compressed, symmetric matrix:
     * <pre>
     * // Assuming dimension of 3 for constraint:
     * [ eff[0] eff[1] eff[2] ]
     * [ eff[1] eff[3] eff[4] ]
     * [ eff[2] eff[4] eff[5] ]
     * </pre>
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param eff The output array to store constraint space effective mass matrix.
     * @throws # If this method is not overriden.]]></haxe_doc>
		</__eff_mass>
		<__clamp public="1" set="method" line="347">
			<f a="jAcc">
				<t path="nape.TArray"><x path="Float"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal, optional clamping of impulse for constraint.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param jAcc The constraint space impulse to be clamped.]]></haxe_doc>
		</__clamp>
		<__impulse public="1" set="method" line="358">
			<f a="imp:body:out">
				<t path="nape.TArray"><x path="Float"/></t>
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal application of impulse to body.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param imp The constraint space impulse to be applied to bodies.
     * @param body The body to apply impulse to.
     * @param out The Vec3 to store impulse on body to be applied. This
     *            should be in world space.]]></haxe_doc>
		</__impulse>
		<impulse public="1" set="method" line="401" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[@inheritDoc
     * <br/><br/>
     * For user-defined constraints, this will be a dimensions * 1 MatMN.]]></haxe_doc>
		</impulse>
		<bodyImpulse public="1" set="method" line="411" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</bodyImpulse>
		<visitBodies public="1" set="method" line="437" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</visitBodies>
		<__invalidate public="1" set="method" line="469">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Internal method to invalidate constraint on property changes
     * <br/><br/>
     * This method should be hidden in your sub-type, and called by your
     * constraint's API when a property of the constraint has been changed.
     * <br/>
     * This does not need to be called for Vec2 properties created via
     * the bindVec2 method.
     *
     * @throws # If you call this method in the middle of a space step.]]></haxe_doc>
		</__invalidate>
		<__registerBody public="1" set="method" line="504">
			<f a="oldBody:newBody">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
			</f>
			<haxe_doc><![CDATA[* Internal method to register Body's with constraint.
     * <br/><br/>
     * This method should be hidden in your sub-type, and used to deal with
     * adding/removing objects from the constraint so that a functionally equivalent
     * constraint can be created (Dealing with all necessary side-effects etc).
     * <pre>
     * //Haxe
     * public var body1(default, set_body1):Null&lt;Body&gt;;
     * inline function set_body1(body1:Null&lt;Body&gt;) {
     *     return this.body1 = __registerBody(this.body1, body1);
     * }
     *
     * //AS3
     * private var _body1:Body;
     * public function get body1():Body {
     *     return _body1;
     * }
     * public function set body1(body1:Body):void {
     *     _body1 = __registerBody(_body1, body1);
     * }
     * </pre>
     *
     * @param oldBody The present value of body parameter.
     * @param newBody The new value for body parameter.
     * @return Returns newBody parameter.
     * @throws # If oldBody is not registered with constraint.
     * @throws # If you call this method in the middle of a space step.]]></haxe_doc>
		</__registerBody>
		<new public="1" set="method" line="376">
			<f a="dimensions:?velocityOnly" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Base constructor for user constraints.
     * <br/><br/>
     * You should never call this function directly, only though use of
     * super(..) in sub-typed UserConstraint.
     *
     * @param dimensions The number of constraint space dimensions.
     * @param velocityOnly If true, then this constraint will be implemented
     *                     as a velocity-only constraint like the MotorJoint.
     * @throws # If dimensions < 1]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* UserConstraint providing a low-level API for user-defined Constraints.
 * <br/><br/>
 * This API is intended to be powerful enough to model any constraint that
 * Nape can handle, but not so low level as to be completely prohibitive.
 * <br/>
 * For instance, things like soft-constraints are automatically provided
 * by this API.
 * <br/><br/>
 * Working with this API will require mathematical skills. A full manual
 * for this API is provided at: http://napephys.com/help/Constraints.pdf
 * <br/><br/>
 * You may also be interested in the nape-symbolic module that is available
 * on github/haxelib/nape downloads. Which provides a run-time compiled DSL
 * using this API to make prototyping (or creating non-performance critical)
 * user-defined constraints simple without the need for great mathematical
 * skills as well as being much quicker to work with.]]></haxe_doc>
	</class>
	<class path="nape.constraint.WeldJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/constraint/WeldJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_WeldJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<get_body1 get="inline" set="null" line="205"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<set_body1 get="inline" set="null" line="208"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<get_body2 get="inline" set="null" line="243"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<set_body2 get="inline" set="null" line="246"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<anchor1 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on first Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body1.]]></haxe_doc>
		</anchor1>
		<get_anchor1 get="inline" set="null" line="280"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<set_anchor1 get="inline" set="null" line="284"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<anchor2 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on second Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body2.]]></haxe_doc>
		</anchor2>
		<get_anchor2 get="inline" set="null" line="305"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<set_anchor2 get="inline" set="null" line="309"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<phase public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Angular phase of bodies in WeldJoint.
     *
     * @default 0</haxe_doc>
		</phase>
		<get_phase get="inline" set="null" line="330"><f a=""><x path="Float"/></f></get_phase>
		<set_phase get="inline" set="null" line="333"><f a="phase">
	<x path="Float"/>
	<x path="Float"/>
</f></set_phase>
		<impulse public="1" set="method" line="385" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 3x1.]]></haxe_doc>
		</impulse>
		<bodyImpulse public="1" set="method" line="395" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</bodyImpulse>
		<visitBodies public="1" set="method" line="414" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<new public="1" set="method" line="360">
			<f a="body1:body2:anchor1:anchor2:?phase" v="::::0.0f">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new WeldJoint.
     *
     * @param body1 The first body in WeldJoint.
     * @param body2 The second body in WeldJoint.
     * @param anchor1 The first local anchor for joint.
     * @param anchor2 The second local anchor for joint.
     * @param phase The angular phase of joint. (default 0)
     * @return The constructed WeldJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* WeldJoint constraining two bodies to be exactly locked together.
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * [ body2.localPointToWorld(anchor2) ] = [ body1.localPointToWorld(anchor1) ]
 * [          body2.rotation          ]   [      body1.rotation + phase      ]
 * </pre>
 * This constraint is equivalent to using a PivotJoint and AngleJoint
 * together except that it is solved as a single constraint and thus
 * will be more stable.
 * <br/><br/>
 * This constraint is 3 dimensional.
 * <br/><br/>
 * Although this constraint is very stable, if you chain bodies together
 * using this constraint, you should except to see a small amount of rotation
 * about the anchor points so you should chose them accordingly.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.Arbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/Arbiter.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<isSleeping public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Flag representing arbiter sleep state.
     * <br/><br/>
     * When true, this arbiter is sleeping.]]></haxe_doc>
		</isSleeping>
		<get_isSleeping get="inline" set="null" line="192"><f a=""><x path="Bool"/></f></get_isSleeping>
		<type public="1" get="accessor" set="null">
			<c path="nape.dynamics.ArbiterType"/>
			<haxe_doc>* The type of this Arbiter.</haxe_doc>
		</type>
		<get_type get="inline" set="null" line="203"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_type>
		<isCollisionArbiter public="1" get="inline" set="null" line="214">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Equivalent to: <code>arb.type == ArbiterType.COLLISION</code>
     * </br><br/>
     *
     * @return True if this Arbiter is a Collision type arbiter.]]></haxe_doc>
		</isCollisionArbiter>
		<isFluidArbiter public="1" get="inline" set="null" line="225">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Equivalent to: <code>arb.type == ArbiterType.FLUID</code>
     * </br><br/>
     *
     * @return True if this Arbiter is a Fluid type arbiter.]]></haxe_doc>
		</isFluidArbiter>
		<isSensorArbiter public="1" get="inline" set="null" line="236">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Equivalent to: <code>arb.type == ArbiterType.SENSOR</code>
     * </br><br/>
     *
     * @return True if this Arbiter is a Sensor type arbiter.]]></haxe_doc>
		</isSensorArbiter>
		<collisionArbiter public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.dynamics.CollisionArbiter"/></t>
			<haxe_doc><![CDATA[* Fast equivalent to casting this object to a CollisionArbiter.
     * <br/><br/>
     * This value is null when this arbiter is not a collision type.]]></haxe_doc>
		</collisionArbiter>
		<get_collisionArbiter get="inline" set="null" line="246"><f a=""><t path="Null"><c path="nape.dynamics.CollisionArbiter"/></t></f></get_collisionArbiter>
		<fluidArbiter public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.dynamics.FluidArbiter"/></t>
			<haxe_doc><![CDATA[* Fast equivalent to casting this object to a FluidArbiter.
     * <br/><br/>
     * This value is null when this arbiter is not a fluid type.]]></haxe_doc>
		</fluidArbiter>
		<get_fluidArbiter get="inline" set="null" line="256"><f a=""><t path="Null"><c path="nape.dynamics.FluidArbiter"/></t></f></get_fluidArbiter>
		<shape1 public="1" get="accessor" set="null">
			<c path="nape.shape.Shape"/>
			<haxe_doc><![CDATA[* The first shape in Arbiter interaction.
     * <br/><br/>
     * It will always be the case that <code>arb.shape1.id < arb.shape2.id</code>]]></haxe_doc>
		</shape1>
		<get_shape1 get="inline" set="null" line="266"><f a=""><c path="nape.shape.Shape"/></f></get_shape1>
		<shape2 public="1" get="accessor" set="null">
			<c path="nape.shape.Shape"/>
			<haxe_doc><![CDATA[* The second shape in Arbiter interaction.
     * <br/><br/>
     * It will always be the case that <code>arb.shape1.id < arb.shape2.id</code>]]></haxe_doc>
		</shape2>
		<get_shape2 get="inline" set="null" line="279"><f a=""><c path="nape.shape.Shape"/></f></get_shape2>
		<body1 public="1" get="accessor" set="null">
			<c path="nape.phys.Body"/>
			<haxe_doc><![CDATA[* The first body in Arbiter interaction.
     * <br/><br/>
     * It will always be the case that <code>arb.shape1.body == arb.body1</code>]]></haxe_doc>
		</body1>
		<get_body1 get="inline" set="null" line="292"><f a=""><c path="nape.phys.Body"/></f></get_body1>
		<body2 public="1" get="accessor" set="null">
			<c path="nape.phys.Body"/>
			<haxe_doc><![CDATA[* The second body in Arbiter interaction.
     * <br/><br/>
     * It will always be the case that <code>arb.shape2.body == arb.body2</code>]]></haxe_doc>
		</body2>
		<get_body2 get="inline" set="null" line="305"><f a=""><c path="nape.phys.Body"/></f></get_body2>
		<state public="1" get="accessor" set="null">
			<c path="nape.callbacks.PreFlag"/>
			<haxe_doc><![CDATA[* The interaction state of this Arbiter.
     * <br/><br/>
     * This flag will, except for in a PreListener handler, always be either
     * <code>ImmState.ACCEPT</code> or <code>ImmState.IGNORE</code>
     * <br/>
     * During a PreListener handler, you can query this property to see what
     * the current state of the arbiter has been set to, and returning null from
     * the handler will keep the state unchanged.]]></haxe_doc>
		</state>
		<get_state get="inline" set="null" line="323"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_state>
		<totalImpulse public="1" set="method" line="350">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate the total impulse this arbiter applied to the given body for
     * the previous space step including angular impulse based on things like
     * contact position, or centre of buoyancy etc.
     * <br/><br/>
     * If body is null, then the constraint space impulse will be returned instead
     *
     * @param body The body to query impulse for. (default null)
     * @param freshOnly If true, then only 'new' contact points will be queried for
     *                  collision type arbiters. This field has no use on fluid type
     *                  arbiters. (default false)
     * @return The total impulse applied to the given body, or the constraint
     *         space impule if the body is null.
     * @throws # If body is non-null, but not related to this Arbiter.]]></haxe_doc>
		</totalImpulse>
		<toString public="1" set="method" line="372">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="362">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Arbiter representing the state of an interaction between two Bodys.
 * <br/><br/>
 * These objects are automatically reused, and you should not keep your own
 * references to them.]]></haxe_doc>
	</class>
	<class path="nape.dynamics.ArbiterIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/ArbiterIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.dynamics.ArbiterIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.dynamics.ArbiterList"/>
				<c path="nape.dynamics.ArbiterIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.dynamics.ArbiterList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.dynamics.ArbiterIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.dynamics.Arbiter"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.ArbiterList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/ArbiterList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.dynamics.Arbiter"/></c>
				<c path="nape.dynamics.ArbiterList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Arbiter</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ArbiterList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="263"><f a=""><x path="Int"/></f></get_length>
		<zpp_gl public="1" set="method" line="269">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* @private</haxe_doc>
		</zpp_gl>
		<zpp_vm public="1" set="method" line="291">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</zpp_vm>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.dynamics.Arbiter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.dynamics.Arbiter"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.dynamics.Arbiter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.dynamics.Arbiter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.dynamics.Arbiter"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.dynamics.Arbiter"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" set="method" line="563">
			<f a="obj">
				<c path="nape.dynamics.Arbiter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.dynamics.Arbiter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" set="method" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" set="method" line="647">
			<f a=""><c path="nape.dynamics.ArbiterIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.dynamics.ArbiterList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.dynamics.ArbiterList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" set="method" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.Arbiter"/>
					<x path="Void"/>
				</f>
				<c path="nape.dynamics.ArbiterList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.Arbiter"/>
					<x path="Bool"/>
				</f>
				<c path="nape.dynamics.ArbiterList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Arbiter type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Arbiter = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Arbiter = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Arbiter = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
	</class>
	<class path="nape.dynamics.ArbiterType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/ArbiterType.hx">
		<COLLISION public="1" get="accessor" set="null" static="1">
			<c path="nape.dynamics.ArbiterType"/>
			<haxe_doc>* Collision type Arbiter.</haxe_doc>
		</COLLISION>
		<get_COLLISION get="inline" set="null" line="202" static="1"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_COLLISION>
		<SENSOR public="1" get="accessor" set="null" static="1">
			<c path="nape.dynamics.ArbiterType"/>
			<haxe_doc>* Sensor type Arbiter.</haxe_doc>
		</SENSOR>
		<get_SENSOR get="inline" set="null" line="215" static="1"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_SENSOR>
		<FLUID public="1" get="accessor" set="null" static="1">
			<c path="nape.dynamics.ArbiterType"/>
			<haxe_doc>* Fluid type Arbiter.</haxe_doc>
		</FLUID>
		<get_FLUID get="inline" set="null" line="228" static="1"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_FLUID>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Arbiter types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.CollisionArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/CollisionArbiter.hx">
		<extends path="nape.dynamics.Arbiter"/>
		<contacts public="1" get="accessor" set="null">
			<c path="nape.dynamics.ContactList"/>
			<haxe_doc>* Set of contact points for the related pairs of shapes.</haxe_doc>
		</contacts>
		<get_contacts get="inline" set="null" line="183"><f a=""><c path="nape.dynamics.ContactList"/></f></get_contacts>
		<normal public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Normal of contact for collision interaction.
     * <br/><br/>
     * This normal will always point from arbiter's shape1, towards shape2 and
     * corresponds to the direction of the normal before positional integration
     * and erorr resolvement took place (Correct at time of pre-listener).]]></haxe_doc>
		</normal>
		<get_normal get="inline" set="null" line="199"><f a=""><c path="nape.geom.Vec2"/></f></get_normal>
		<radius public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* This radius property describes the sum of the circle's radii for the pair of shapes, with
     * a Polygon having 0 radius. This value is used in positional iterations to resolve penetrations
     * between the Shapes.</haxe_doc>
		</radius>
		<get_radius get="inline" set="null" line="213"><f a=""><x path="Float"/></f></get_radius>
		<referenceEdge1 public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.shape.Edge"/></t>
			<haxe_doc>* The reference edge for the collision on the first Polygon
     * If the first shape in Arbiter is a Circle this value is null.</haxe_doc>
		</referenceEdge1>
		<get_referenceEdge1 get="inline" set="null" line="225"><f a=""><t path="Null"><c path="nape.shape.Edge"/></t></f></get_referenceEdge1>
		<referenceEdge2 public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.shape.Edge"/></t>
			<haxe_doc>* The reference edge for the collision on the second Polygon
     * If the second shape in Arbiter is a Circle this value is null.</haxe_doc>
		</referenceEdge2>
		<get_referenceEdge2 get="inline" set="null" line="239"><f a=""><t path="Null"><c path="nape.shape.Edge"/></t></f></get_referenceEdge2>
		<firstVertex public="1" set="method" line="257">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* In the case that we have a Circle-Polygon collision, then this
     * function will return true, if the circle collided with the first
     * vertex of edge.
     * <br/><br/>
     * If both firstVertex() and secondVertex() are false, it indicates
     * the Circle collided with the edge.
     *
     * @returns True if Circle collided with first reference vertex.]]></haxe_doc>
		</firstVertex>
		<secondVertex public="1" set="method" line="276">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Check if colliding Circle hit second vertex of reference edge.
     * <br/><br/>
     * In the case that we have a Circle-Polygon collision, then this
     * function will return true, if the circle collided with the second
     * vertex of edge.
     * <br/><br/>
     * If both firstVertex() and secondVertex() are false, it indicates
     * the Circle collided with the edge.
     *
     * @returns True if Circle collided with second reference vertex.]]></haxe_doc>
		</secondVertex>
		<normalImpulse public="1" set="method" line="300">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate normal reactive impulses for collision interaction for a given body.
     * <br/><br/>
     * If body argument is null, then the sum of the contact normal impulses will be returned instead
     * with no angular impulse derivable, the direction of this impulse will be the direction of the normal.
     * <br/>
     * If body argument is not null, then this will return the actual impulse applied to that specific body
     * rather than simply the sum of contact normal impulses, this will include angular impulses due to
     * positions of contact points and normal.
     *
     * @param body The Body to query normal impulse for. (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered in computation.
     *                  (default false)
     * @return The impulse applied to the given body, considering normal reactive forces.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</normalImpulse>
		<tangentImpulse public="1" set="method" line="394">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate tangent impulses for collision interaction.
     * <br/><br/>
     * If body argument is null, then the sum of the contact friction impulses is returned with
     * no angular impulse derivable, the direction of this impulse will be against the relative
     * velocity of the first body against the second.
     * <br/>
     * If the body argument is non-null, then the actual impulse applied to that body due to tangent
     * frictino impulses will be returned, including angular effects due to contact positions and normal.
     * <br/><br/>
     * These tangent impulses correspond to the forces of static and dynamic friction.
     *
     * @param body The Body to query tangent impulse for. (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered in computation.
     *                  (default false)
     * @return The impulse applied to the given body, considering standard frictional forces.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</tangentImpulse>
		<totalImpulse public="1" set="method" line="485" override="1">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate total contact impulses for collision interaction.
     * <br/><br/>
     * If body argument is null, then this will return the sum of linear contact impulses, and the sum
     * of contact rolling impulses.
     * <br/>
     * When body argument is non-null, this impulse will be the actual change in (mass weighted)
     * velocity that this collision caused to the Body in the previous time step.
     *
     * @param body The Body to query total impulse for. (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered in computation.
     *                  (default false)
     * @return The impulse applied to the given body
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</totalImpulse>
		<rollingImpulse public="1" set="method" line="573">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate rolling friction impulses for collision interaction.
     * <br/><br/>
     * If body argument is null, then the sum of the rolling impulses of each contact will be returned
     * instead of the angular impulse applied to the specific body as a result of the rolling impulses.
     *
     * @param body The Body to query rolling impulse for. (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered in computation.
     *                  (default false)
     * @return The angular impulse applied to the given body.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</rollingImpulse>
		<elasticity public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of combined elasticity for collision interaction.
     * <br/><br/>
     * The value is computed as the average of the Shape Material's elasticities
     * clamped to be in the range [0,1]
     * <br/><br/>
     * This value may be modified only during a PreListener, and once modified
     * will no longer be under Nape's control. Values must be in the range 0
     * to 1.]]></haxe_doc>
		</elasticity>
		<get_elasticity get="inline" set="null" line="596"><f a=""><x path="Float"/></f></get_elasticity>
		<set_elasticity get="inline" set="null" line="604"><f a="elasticity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_elasticity>
		<dynamicFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of combined dynamic friction for collision interaction.
     * <br/><br/>
     * The value is computed as the square root of the product of the Shape
     * Material's dynamicFriction coeffecients.
     * <br/><br/>
     * This value may be modified only during a PreListener, and once modified
     * will no longer be under Nape's control. Values must not be negative.]]></haxe_doc>
		</dynamicFriction>
		<get_dynamicFriction get="inline" set="null" line="631"><f a=""><x path="Float"/></f></get_dynamicFriction>
		<set_dynamicFriction get="inline" set="null" line="639"><f a="dynamicFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_dynamicFriction>
		<staticFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of combined static friction for collision interaction.
     * <br/><br/>
     * The value is computed as the square root of the product of the Shape
     * Material's staticFriction coeffecients.
     * <br/><br/>
     * This value may be modified only during a PreListener, and once modified
     * will no longer be under Nape's control. Values must not be negative.]]></haxe_doc>
		</staticFriction>
		<get_staticFriction get="inline" set="null" line="666"><f a=""><x path="Float"/></f></get_staticFriction>
		<set_staticFriction get="inline" set="null" line="674"><f a="staticFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_staticFriction>
		<rollingFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of combined rolling friction for collision interaction.
     * <br/><br/>
     * The value is computed as the square root of the product of the Shape
     * Material's rollingFriction coeffecients.
     * <br/><br/>
     * This value may be modified only during a PreListener, and once modified
     * will no longer be under Nape's control. Values must not be negative.]]></haxe_doc>
		</rollingFriction>
		<get_rollingFriction get="inline" set="null" line="701"><f a=""><x path="Float"/></f></get_rollingFriction>
		<set_rollingFriction get="inline" set="null" line="709"><f a="rollingFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rollingFriction>
		<new public="1" set="method" line="728">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Arbiter sub type for collision interactions.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.Contact" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/Contact.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_Contact"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<arbiter public="1" get="accessor" set="null">
			<c path="nape.dynamics.CollisionArbiter"/>
			<haxe_doc>* Reference to the CollisionArbiter this contact belongs to</haxe_doc>
		</arbiter>
		<get_arbiter get="inline" set="null" line="189"><f a=""><c path="nape.dynamics.CollisionArbiter"/></f></get_arbiter>
		<penetration public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Penetration of bodies along normal for this contact.
     * <br/><br/>
     * This value may be negative and corresponds to the penetration (if at all)
     * of the contact point before positional integration and error resolvement
     * took place (correct at time of pre-listeners).]]></haxe_doc>
		</penetration>
		<get_penetration get="inline" set="null" line="201"><f a=""><x path="Float"/></f></get_penetration>
		<position public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* The world-space position of contact.
     * <br/><br/>
     * This value corresponds to the position
     * of the contact point before positional integration and error resolvement
     * took place (correct at time of pre-listeners).]]></haxe_doc>
		</position>
		<get_position get="inline" set="null" line="216"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<fresh public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether this contact is newly generated, or persistant from previous step.</haxe_doc>
		</fresh>
		<get_fresh get="inline" set="null" line="228"><f a=""><x path="Bool"/></f></get_fresh>
		<normalImpulse public="1" set="method" line="248">
			<f a="?body" v="null">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate normal reactive impulses for this contact for a given body.
     * <br/><br/>
     * If body argument is null, then the contact normal impulses will be returned instead
     * with no angular impulse derivable, the direction of this impulse will be the direction of the normal.
     * <br/>
     * If body argument is not null, then this will return the actual impulse applied to that specific body
     * for this contact this will include angular impulses due to position of contact point and normal.
     *
     * @param body The Body to query normal impulse for. (default null)
     * @return The impulse applied to the given body, considering normal reactive forces.
     * @throws # If body is non-null, and unrelated to this Contact.]]></haxe_doc>
		</normalImpulse>
		<tangentImpulse public="1" set="method" line="281">
			<f a="?body" v="null">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate tangent impulses for this contact for a given body.
     * <br/><br/>
     * If body argument is null, then the contact friction impulses is returned with
     * no angular impulse derivable, the direction of this impulse will be against the relative
     * velocity of the first body against the second.
     * <br/>
     * If the body argument is non-null, then the actual impulse applied to that body due to tangent
     * frictino impulses will be returned, including angular effects due to contact position and normal.
     * <br/><br/>
     * These tangent impulses correspond to the forces of static and dynamic friction for this contact.
     *
     * @param body The Body to query tangent impulse for. (default null)
     * @return The impulse applied to the given body, considering standard frictional forces.
     * @throws # If body is non-null, and unrelated to this Contact.]]></haxe_doc>
		</tangentImpulse>
		<rollingImpulse public="1" set="method" line="308">
			<f a="?body" v="null">
				<c path="nape.phys.Body"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate rolling friction impulses for this contact for a given body.
     * <br/><br/>
     * If body argument is null, then the rolling impulse of this contact will be returned
     * instead of the angular impulse applied to the specific body as a result of the rolling impulse.
     *
     * @param body The Body to query rolling impulse for. (default null)
     * @return The angular impulse applied to the given body.
     * @throws # If body is non-null, and unrelated to this Contact.]]></haxe_doc>
		</rollingImpulse>
		<totalImpulse public="1" set="method" line="337">
			<f a="?body" v="null">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate total contact impulse for a given body.
     * <br/><br/>
     * If body argument is null, then this will return the sum of normal and tangent contact impulse, and the contact
     * rolling impulse.
     * <br/>
     * When body argument is non-null, this impulse will be the actual change in (mass weighted)
     * velocity that this contact caused to the Body in the previous time step.
     *
     * @param body The Body to query total impulse for. (default null)
     * @return The impulse applied to the given body
     * @throws # If body is non-null, and unrelated to this Contact.]]></haxe_doc>
		</totalImpulse>
		<friction public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The specific coeffecient of friction for this contact.
     * <br/><br/>
     * This value is equal either to the static or dynamic friction coeffecient of the arbiter
     * based on the relative velocity at contact point.
     * <br/><br/>
     * This value cannot be set, though you may implicitly set it exactly by modifying
     * the arbiter to have the same static and dynamic friction in the PreListener.]]></haxe_doc>
		</friction>
		<get_friction get="inline" set="null" line="386"><f a=""><x path="Float"/></f></get_friction>
		<toString public="1" set="method" line="403">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="395">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Contact point for collision interactions
 * <br/><br/>
 * These objects are automatically reused and you should not keep references to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.ContactIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/ContactIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.dynamics.ContactIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.dynamics.ContactList"/>
				<c path="nape.dynamics.ContactIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.dynamics.ContactList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.dynamics.ContactIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.dynamics.Contact"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.ContactList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/ContactList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.dynamics.Contact"/></c>
				<c path="nape.dynamics.ContactList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Contact</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ContactList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.dynamics.Contact"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.dynamics.Contact"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.dynamics.Contact"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.dynamics.Contact"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.dynamics.Contact"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.dynamics.Contact"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.dynamics.Contact"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.dynamics.Contact"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.dynamics.ContactIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.dynamics.ContactList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.dynamics.ContactList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.Contact"/>
					<x path="Void"/>
				</f>
				<c path="nape.dynamics.ContactList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.Contact"/>
					<x path="Bool"/>
				</f>
				<c path="nape.dynamics.ContactList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Contact type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Contact = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Contact = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Contact = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.FluidArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/FluidArbiter.hx">
		<extends path="nape.dynamics.Arbiter"/>
		<position public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Centre of buoyancy for fluid interaction.
     * <br/><br/>
     * This value can be modified during a related PreListener handler.]]></haxe_doc>
		</position>
		<get_position get="inline" set="null" line="185"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<set_position get="inline" set="null" line="192"><f a="position">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_position>
		<overlap public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Overlap area of Shapes in fluid interaction.
     * <br/><br/>
     * This value is strictly positive, and represents the amount of overlap between the Shapes
     * used in buoyancy computations.
     * <br/><br/>
     * This value can be modified during a related PreListener handler.]]></haxe_doc>
		</overlap>
		<get_overlap get="inline" set="null" line="214"><f a=""><x path="Float"/></f></get_overlap>
		<set_overlap get="inline" set="null" line="220"><f a="overlap">
	<x path="Float"/>
	<x path="Float"/>
</f></set_overlap>
		<buoyancyImpulse public="1" set="method" line="246">
			<f a="?body" v="null">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Determine impulse on a given body due to buoyancy.
     * <br/><br/>
     * If the body is null, then the buoyancy impulse will be returned without consideration to any specific
     * body involved, and no angular impulses can be derived.
     *
     * @param body The body to query impulse for. (default null)
     * @return The buoyancy impulse for given body.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</buoyancyImpulse>
		<dragImpulse public="1" set="method" line="275">
			<f a="?body" v="null">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Determine impulse on a given body due to fluid drag.
     * <br/><br/>
     * If the body is null, then the drag impulse will be returned without consideration to any specific
     * body involved.
     *
     * @param body The body to query impulse for. (default null)
     * @return The drag impulse for given body.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</dragImpulse>
		<totalImpulse public="1" set="method" line="298" override="1">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Determine total impulse on a given body due to fluid interaction.
     * <br/><br/>
     * If the body is null, then the total impulse will be computed without consideration to any specific
     * body involved, and no angular impulses can be derived for the linear portion of the impulses.
     *
     * @param body The body to query impulse for. (default null)
     * @param freshOnly This parameter is unused for FluidArbiters. (default false)
     * @return The total impulse for given body.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</totalImpulse>
		<new public="1" set="method" line="316">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Fluid interaction subtype for Arbiter.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionFilter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/InteractionFilter.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<get_userData get="inline" set="null" line="224"><f a=""><d><d/></d></f></get_userData>
		<shapes public="1" get="accessor" set="null">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc><![CDATA[* Set of all active shapes using this object.
     * <br/><br/>
     * Activeness of a shape in the sense that the Shape's Body is inside of a Space.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</shapes>
		<get_shapes get="inline" set="null" line="239"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<collisionGroup public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Group bitfield for Collision type interactions.
     * @default 1</haxe_doc>
		</collisionGroup>
		<get_collisionGroup get="inline" set="null" line="249"><f a=""><x path="Int"/></f></get_collisionGroup>
		<set_collisionGroup get="inline" set="null" line="252"><f a="collisionGroup">
	<x path="Int"/>
	<x path="Int"/>
</f></set_collisionGroup>
		<collisionMask public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Mask bitfield for Collision type interactions.
     * @default -1 (all bits set)</haxe_doc>
		</collisionMask>
		<get_collisionMask get="inline" set="null" line="267"><f a=""><x path="Int"/></f></get_collisionMask>
		<set_collisionMask get="inline" set="null" line="270"><f a="collisionMask">
	<x path="Int"/>
	<x path="Int"/>
</f></set_collisionMask>
		<sensorGroup public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Group bitfield for Sensor type interactions.
     * @default 1</haxe_doc>
		</sensorGroup>
		<get_sensorGroup get="inline" set="null" line="285"><f a=""><x path="Int"/></f></get_sensorGroup>
		<set_sensorGroup get="inline" set="null" line="288"><f a="sensorGroup">
	<x path="Int"/>
	<x path="Int"/>
</f></set_sensorGroup>
		<sensorMask public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Mask bitfield for Sensor type interactions.
     * @default -1 (all bits set)</haxe_doc>
		</sensorMask>
		<get_sensorMask get="inline" set="null" line="303"><f a=""><x path="Int"/></f></get_sensorMask>
		<set_sensorMask get="inline" set="null" line="306"><f a="sensorMask">
	<x path="Int"/>
	<x path="Int"/>
</f></set_sensorMask>
		<fluidGroup public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Group bitfield for Fluid type interactions.
     * @default 1</haxe_doc>
		</fluidGroup>
		<get_fluidGroup get="inline" set="null" line="321"><f a=""><x path="Int"/></f></get_fluidGroup>
		<set_fluidGroup get="inline" set="null" line="324"><f a="fluidGroup">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fluidGroup>
		<fluidMask public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Mask bitfield for Fluid type interactions.
     * @default -1 (all bits set)</haxe_doc>
		</fluidMask>
		<get_fluidMask get="inline" set="null" line="339"><f a=""><x path="Int"/></f></get_fluidMask>
		<set_fluidMask get="inline" set="null" line="342"><f a="fluidMask">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fluidMask>
		<shouldCollide public="1" set="method" line="400">
			<f a="filter">
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if objects are permitted to collide based on InteractionFilters
     * <br/><br/>
     * A collision type interaction can occur only if this returns True.
     *
     * @param filter The filter to evaluate possibility of collision with.
     * @return True, if based on interaction filters only the two objects would be able to collide.
     * @throws # If filter is null.]]></haxe_doc>
		</shouldCollide>
		<shouldSense public="1" set="method" line="416">
			<f a="filter">
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if objects are permitted to sense based on InteractionFilters
     * <br/><br/>
     * A sensor type interaction can occur only if this returns True.
     *
     * @param filter The filter to evaluate possibility of sensor with.
     * @return True, if based on interaction filters only the two objects would be able to sense.
     * @throws # If filter is null.]]></haxe_doc>
		</shouldSense>
		<shouldFlow public="1" set="method" line="432">
			<f a="filter">
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if objects are permitted to interact as fluids based on InteractionFilters
     * <br/><br/>
     * A fluid type interaction can occur only if this returns True.
     *
     * @param filter The filter to evaluate possibility of fluid with.
     * @return True, if based on interaction filters only the two objects would be able to interact as fluids.
     * @throws # If filter is null.]]></haxe_doc>
		</shouldFlow>
		<copy public="1" set="method" line="444">
			<f a=""><c path="nape.dynamics.InteractionFilter"/></f>
			<haxe_doc>* Produce a copy of this InteractionFilter
     *
     * @return The copy of this filter.</haxe_doc>
		</copy>
		<toString public="1" set="method" line="451">
			<f a=""><c path="String"/></f>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="364">
			<f a="?collisionGroup:?collisionMask:?sensorGroup:?sensorMask:?fluidGroup:?fluidMask" v="1:-1:1:-1:1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new InteractionFilter.
     *
     * @param collisionGroup The Group bitfield for Collision interactions. (default 1)
     * @param collisionMask  The Mask bitfield for Collision interactions. (default -1)
     * @param sensorGroup    The Group bitfield for Sensor interactions. (default 1)
     * @param sensorMask     The Mask bitfield for Sensor interactions. (default -1)
     * @param fluidGroup     The Group bitfield for Fluid interactions. (default 1)
     * @param fluidMask      The Mask bitfield for Fluid interactions. (default -1)
     * @return The newly constructed InteractionFilter.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* InteractionFilter provides bit flags for low-level filtering of interactions.
 * <br/><br/>
 * For a given interaction type, two Shapes will be permitted to interact only if
 * <code>(shape1.group & shape2.mask) != 0 && (shape2.group & shape1.mask) != 0</code>
 * <br/><br/>
 * There are 32 real groups corresponding to a set bit in the group/mask fields. For instance
 * a group value of 0x120 corresponds to the 'real' groups 5 and 8 as <code>0x120 = (1<<5) | (1<<8)</code>
 * <br/><br/>
 * Nape provides group/mask for each interaction type. The actual precedence of interactions
 * is further defined simply as: Sensor > Fluid > Collision.
 * <br/>
 * Two static bodies can never interact, and with the exception of sensor interaction, at least one
 * of the two bodies must be dynamic.
 * <br/>
 * Sensor interactions have the highest precedence, followed by fluid and then collisions.
 * Sensor interaction is permitted only if one of the shapes is sensorEnabled, whilst fluid
 * is permitted only if one of the shapes is fluidEnabled.
 * <pre>
 * if ((shapeA.sensorEnabled || shapeB.sensorEnabled) && shapeA.filter.shouldSense(shapeB.filter)) {
 *     SENSOR INTERACTION!!
 * }
 * else if (bodyA.isDynamic() || bodyB.isDynamic()) {
 *     if ((shapeA.fluidEnabled || shapeB.fluidEnabled) && shapeA.filter.shouldFlow(shapeB.filter)) {
 *         FLUID INTERACTION!!
 *     }
 *     else if (shapeA.filter.shouldCollide(shapeB.filter)) {
 *         COLLISION INTERACTION!!
 *     }
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionGroup" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/InteractionGroup.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<group public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
			<haxe_doc>* Parent group in InteractionGroup tree.
     * @default null</haxe_doc>
		</group>
		<get_group get="inline" set="null" line="229"><f a=""><t path="Null"><c path="nape.dynamics.InteractionGroup"/></t></f></get_group>
		<set_group get="inline" set="null" line="232"><f a="group">
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
</f></set_group>
		<ignore public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Ignore property, set to true so that objects will not interact.
     * @default false</haxe_doc>
		</ignore>
		<get_ignore get="inline" set="null" line="247"><f a=""><x path="Bool"/></f></get_ignore>
		<set_ignore get="inline" set="null" line="250"><f a="ignore">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignore>
		<interactors public="1" get="accessor" set="null">
			<c path="nape.phys.InteractorList"/>
			<haxe_doc><![CDATA[* Set of active interactors using this group.
     * <br/><br/>
     * Active interactors meaning those that are part of a Space.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</interactors>
		<get_interactors get="inline" set="null" line="268"><f a=""><c path="nape.phys.InteractorList"/></f></get_interactors>
		<groups public="1" get="accessor" set="null">
			<c path="nape.dynamics.InteractionGroupList"/>
			<haxe_doc><![CDATA[* Immutable set of children of Interaction groups.
     * <br/><br/>
     * You cannot assign or remove children in this manner, you must do it via setting
     * the childs parent group to this/null.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</groups>
		<get_groups get="inline" set="null" line="282"><f a=""><c path="nape.dynamics.InteractionGroupList"/></f></get_groups>
		<toString public="1" set="method" line="299">
			<f a=""><c path="String"/></f>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="291">
			<f a="?ignore" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new InteractionGroup.
     *
     * @param ignore Whether interactors should be ignored. (default false)</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* InteractionGroups are another way of filtering interactions.
 * <br/><br/>
 * InteractionGroups form tree structures which are checked along side InteractionFilters
 * when deciding if two Shapes should interact.
 * <br/><br/>
 * InteractionGroups are assigned to any Interactor (not just Shapes), and two Shapes will
 * interact only if the most recent common ancestor in the InteractionGroup tree permits it.
 * <br/><br/>
 * For the purposes of the search, if any Interactor has no InteractionGroup assigned, we
 * search up the Compound tree first.
 * <pre>
 *            _Group1
 *           /   |
 *          /  Group2      Group3
 *         /    |    \       |                 Group1
 *     Body1   /      Cmp1   |                 /   \           Group3
 *    /    \  /      /    \  |      ==>    Shp1    Group2        |
 * Shp1   Shp2   Body2     Cmp2                    /    \      Shp4
 *                 |         |                  Shp2    Shp3
 *                Shp3     Body3
 *                           |
 *                         Shp4
 * </pre>
 * If we look at which InteractionGroup is used for which Shape following this rule, then
 * the left graph can be transformed into an InteractionGroup tree on the right and we get
 * that the MRCA (Most recent common ancestors) are such that:
 * <pre>
 * MRCA(Shp1, Shp3) == Group1;
 * MRCA(Shp2, Shp3) == Group2;
 * MRCA(Shp4,   # ) == null;
 * </pre>
 * If we were to set up the groups such that <code>Group1.ignore = false</code> and
 * <code>Group2.ignore = true</code>; then shapes 1 and 3 would not be permitted to
 * interact, whilst shapes 2 and 3 would be permitted.
 * <br/>
 * As the MRCA for shape 4 with any other is null, then the value of Group3's ignore field
 * is irrelevant, but the existance of Group3 is not as it serves to otherwise prevent Shape 4
 * from being permitted to interact with shapes 2 and 3.
 * <br/><br/>
 * InteractionGroup's can be fairly expressive, but they are strictly less powerful than
 * InteractionFilters. InteractionGroup's have their place however as there is no limit
 * to the number of Groups you can use.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionGroupIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/InteractionGroupIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.dynamics.InteractionGroupIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.dynamics.InteractionGroupList"/>
				<c path="nape.dynamics.InteractionGroupIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.dynamics.InteractionGroupList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.dynamics.InteractionGroupIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.dynamics.InteractionGroup"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionGroupList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/dynamics/InteractionGroupList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.dynamics.InteractionGroup"/></c>
				<c path="nape.dynamics.InteractionGroupList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than InteractionGroup</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_InteractionGroupList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.dynamics.InteractionGroup"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.dynamics.InteractionGroup"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.dynamics.InteractionGroup"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.dynamics.InteractionGroup"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.dynamics.InteractionGroup"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.dynamics.InteractionGroup"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.dynamics.InteractionGroup"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.dynamics.InteractionGroup"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.dynamics.InteractionGroupIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionGroupList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.dynamics.InteractionGroupList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.InteractionGroup"/>
					<x path="Void"/>
				</f>
				<c path="nape.dynamics.InteractionGroupList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.InteractionGroup"/>
					<x path="Bool"/>
				</f>
				<c path="nape.dynamics.InteractionGroupList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of InteractionGroup type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:InteractionGroup = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:InteractionGroup = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:InteractionGroup = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.AABB" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/AABB.hx">
		<fromRect public="1" set="method" line="243" static="1">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="nape.geom.AABB"/>
			</f>
			<haxe_doc><![CDATA[* Construct an AABB from an AS3 Rectangle object.
     * <br/><br/>
     * This method is only available on <code>flash</code> and
     * <code>openfl||nme</code> targets.
     *
     * @param rect The AS3 Rectangle to construct AABB from, this value
     *             must not be null.
     * @return The constructed AABB matching the input Rectangle.
     * @throws # If the input rectangle is null.]]></haxe_doc>
		</fromRect>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_AABB"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<copy public="1" set="method" line="226">
			<f a=""><c path="nape.geom.AABB"/></f>
			<haxe_doc><![CDATA[* Produce a copy of this AABB.
     * <br/><br/>
     * As would be expected, if you produce a copy of an 'immutable' AABB then
     * the copy will be 'mutable'.
     *
     * @return The copy of this AABB.]]></haxe_doc>
		</copy>
		<toRect public="1" set="method" line="260">
			<f a=""><c path="flash.geom.Rectangle"/></f>
			<haxe_doc><![CDATA[* Create an AS3 Rectangle object from AABB.
     * <br/><br/>
     * This method is available only on <code>flash</code> and
     * <code>openfl||nme</code> targets.
     *
     * @return The AS3 Rectangle object representing AABB.]]></haxe_doc>
		</toRect>
		<min public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* The minimum bounds for the AABB.
     * <br/><br/>
     * Euivalent to the top-left corner.
     * <br/>
     * This Vec2 is intrinsically linked to the AABB so that modifications
     * to this object are reflected in changes to the AABB and vice-versa.
     * <br/><br/>
     * If the AABB is immutable, then this Vec2 will also be immutable.
     * <br/><br/>
     * This value can be set with the = operator, equivalent to performing
     * <code>aabb.min.set(value)</code>.
     * @default (0, 0)]]></haxe_doc>
		</min>
		<get_min get="inline" set="null" line="280"><f a=""><c path="nape.geom.Vec2"/></f></get_min>
		<set_min get="inline" set="null" line="283"><f a="min">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_min>
		<max public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* The maximum bounds for the AABB.
     * <br/><br/>
     * Euivalent to the bottom-right corner.
     * <br/>
     * This Vec2 is intrinsically linked to the AABB so that modifications
     * to this object are reflected in changes to the AABB and vice-versa.
     * <br/><br/>
     * If the AABB is immutable, then this Vec2 will also be immutable.
     * <br/><br/>
     * This value can be set with the = operator, equivalent to performing
     * <code>aabb.max.set(value)</code>.
     * @default (0, 0)]]></haxe_doc>
		</max>
		<get_max get="inline" set="null" line="329"><f a=""><c path="nape.geom.Vec2"/></f></get_max>
		<set_max get="inline" set="null" line="332"><f a="max">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_max>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The x coordinate of the AABB's top-left corner.
     * <br/><br/>
     * Equivalent to accessing/mutating min.x.
     * @default 0]]></haxe_doc>
		</x>
		<get_x get="inline" set="null" line="370"><f a=""><x path="Float"/></f></get_x>
		<set_x get="inline" set="null" line="374"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The y coordinate of the AABB's top-left corner.
     * <br/><br/>
     * Equivalent to accessing/mutating min.y.
     * @default 0]]></haxe_doc>
		</y>
		<get_y get="inline" set="null" line="400"><f a=""><x path="Float"/></f></get_y>
		<set_y get="inline" set="null" line="404"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* width of AABB.
     * <br/><br/>
     * This value is and must always be positive.
     * @default 0]]></haxe_doc>
		</width>
		<get_width get="inline" set="null" line="430"><f a=""><x path="Float"/></f></get_width>
		<set_width get="inline" set="null" line="434"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* height of AABB.
     * <br/><br/>
     * This value is and must always be positive.
     * @default 0]]></haxe_doc>
		</height>
		<get_height get="inline" set="null" line="464"><f a=""><x path="Float"/></f></get_height>
		<set_height get="inline" set="null" line="468"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<toString public="1" set="method" line="493">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="205">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new AABB.
     * <br/><br/>
     * As input width/height are permitted to be negative it is not guaranteed
     * that the resultant AABB will have the same parameters as those
     * specified as the AABB parameters are guaranteed to always have positive
     * width/height, and for x/y to always be the top-left corner.
     *
     * @param x      The x coordinate of the top-left corner of the AABB.
     *               (default 0)
     * @param y      The y coordinate of the top-left corner of the AABB
     *               (default 0)
     * @param width  The width of the AABB. This value may be negative.
     *               (default 0)
     * @param height The height of the AABB. This value may be negative.
     *               (default 0)
     * @return       The newly constructed AABB object.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Axis Aligned Bounding Box (AABB)
 * <br/><br/>
 * Note that in many cases of an AABB object being returned by a Nape function
 * the AABB object will be marked internally as an 'immutable' AABB. This will
 * always be documented and trying to mutate such an AABB will result in an
 * error being thrown.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.ConvexResult" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/ConvexResult.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_ConvexRayResult"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<normal public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* The normal of the surface at collision.</haxe_doc>
		</normal>
		<get_normal get="inline" set="null" line="190"><f a=""><c path="nape.geom.Vec2"/></f></get_normal>
		<position public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* The position of the collision.</haxe_doc>
		</position>
		<get_position get="inline" set="null" line="201"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<toi public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The time of impact to the collision</haxe_doc>
		</toi>
		<get_toi get="inline" set="null" line="212"><f a=""><x path="Float"/></f></get_toi>
		<shape public="1" get="accessor" set="null">
			<c path="nape.shape.Shape"/>
			<haxe_doc>* The shape which was collided against.</haxe_doc>
		</shape>
		<get_shape get="inline" set="null" line="223"><f a=""><c path="nape.shape.Shape"/></f></get_shape>
		<dispose public="1" get="inline" set="null" line="243">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Release ConvexResult object to pool.</haxe_doc>
		</dispose>
		<toString public="1" set="method" line="252">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="234">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Class representing the results of a convex cast operation.
 * <br/><br/>
 * These objects are allocated from an object pool and can
 * be released back to that pool by calling its dispose method.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.ConvexResultIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/ConvexResultIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.ConvexResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.geom.ConvexResultList"/>
				<c path="nape.geom.ConvexResultIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.geom.ConvexResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.geom.ConvexResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.geom.ConvexResult"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.ConvexResultList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/ConvexResultList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.geom.ConvexResult"/></c>
				<c path="nape.geom.ConvexResultList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than ConvexResult</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ConvexResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.geom.ConvexResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.geom.ConvexResult"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.geom.ConvexResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.geom.ConvexResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.geom.ConvexResult"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.geom.ConvexResult"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.geom.ConvexResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.geom.ConvexResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.geom.ConvexResultIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.geom.ConvexResultList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.geom.ConvexResultList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.ConvexResult"/>
					<x path="Void"/>
				</f>
				<c path="nape.geom.ConvexResultList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.ConvexResult"/>
					<x path="Bool"/>
				</f>
				<c path="nape.geom.ConvexResultList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of ConvexResult type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:ConvexResult = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:ConvexResult = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:ConvexResult = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Geom" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/Geom.hx">
		<distanceBody public="1" set="method" line="223" static="1">
			<f a="body1:body2:out1:out2">
				<c path="nape.phys.Body"/>
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Determine distance and closest points between two Bodies.
     * <br/><br/>
     * If the bodies are intersecting, then a negative value is returned
     * equal to the penetration of the bodies, and the out1/out2 vectors
     * will still be meaningful with their difference being the minimum
     * translational vector to seperate the intersecting shapes of the bodies.
     * (This may not be a global seperation vector as it is considering only
     *  one pair of shapes at a time).
     * <br/><br/>
     * As the out1/out2 vectors are used to return values from the function,
     * this is one of the rare cases where should out1/out2 be weak Vec2's
     * they will 'not' be sent to the global object pool on being passed to
     * this function.
     * <pre>
     * var closest1 = Vec2.get();
     * var closest2 = Vec2.get();
     * var distance = Geom.distanceBody(body1, body2, out1, out2);
     * if (distance < 0) {
     *     trace("Bodies intersect and penetration distance is " +
     *           (-distance) + " with witness points " + closest1.toString() +
     *           " <-> " + closest2.toString());
     * }else {
     *     trace("Bodies do not intersect and distance betweem them is " +
     *           distance + " with closest points " + closest1.toString() +
     *           " <-> " + closest2.toString());
     * }
     * </pre>
     * This algorithm is able to take shortcuts in culling pair tests between Shapes
     * based on the current state of the search, and will be more effecient than
     * a custom implementation that uses Geom.distance(..) method.
     *
     * @param body1 First input Body.
     * @param body2 Second input Body.
     * @param out1 This Vec2 object will be populated with coordinates of
     *             closest point on body1.
     * @param out2 This Vec2 object will be populated with coordinates of
     *             closest point on body2.
     * @return The distance between the two bodies if seperated, or the
     *         penetration distance (negative) if intersecting.
     * @throws # If either body has no shapes.
     * @throws # If out1 or out2 has been disposed.
     * @throws # If out1 or out2 is immutable.]]></haxe_doc>
		</distanceBody>
		<distance public="1" set="method" line="301" static="1">
			<f a="shape1:shape2:out1:out2">
				<c path="nape.shape.Shape"/>
				<c path="nape.shape.Shape"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Determine distance and closest points between two Shapes.
     * <br/><br/>
     * The input Shapes must belong to a Body so that their world positions
     * and orientations are defined; these Bodies need not be different nor
     * part of any Space.
     * <br/><br/>
     * If the shapes are intersecting, then a negative value is returned
     * equal to the penetration of the shapes, and the out1/out2 vectors
     * will still be meaningful with their difference being the minimum
     * translational vector to seperate the Shapes.
     * <br/><br/>
     * As the out1/out2 vectors are used to return values from the function,
     * this is one of the rare cases where should out1/out2 be weak Vec2's
     * they will 'not' be sent to the global object pool on being passed to
     * this function.
     * <pre>
     * var closest1 = Vec2.get();
     * var closest2 = Vec2.get();
     * var distance = Geom.distance(shape1, shape2, out1, out2);
     * if (distance < 0) {
     *     trace("Shapes intersect and penetration distance is " +
     *           (-distance) + " with witness points " + closest1.toString() +
     *           " <-> " + closest2.toString());
     * }else {
     *     trace("Shapes do not intersect and distance betweem them is " +
     *           distance + " with closest points " + closest1.toString() +
     *           " <-> " + closest2.toString());
     * }
     * </pre>
     *
     * @param shape1 this shape must belong to a Body.
     * @param shape2 this shape must belong to a Body.
     * @param out1 This Vec2 object will be populated with coordinates of
     *             closest point on shape1.
     * @param out2 This Vec2 object will be populated with coordinates of
     *             closest point on shape2.
     * @return The distance between the two shapes if seperated, or the
     *         penetration distance (negative) if intersecting.
     * @throws # If shape1.body is null or shape2.body is null.
     * @throws # If out1 or out2 has been disposed.
     * @throws # If out1 or out2 is immutable.]]></haxe_doc>
		</distance>
		<intersectsBody public="1" set="method" line="370" static="1">
			<f a="body1:body2">
				<c path="nape.phys.Body"/>
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if two Bodies intersect.
     * <br/><br/>
     * If you do not need distance/penetration information,
     * then using this method will be more effecient than testing for a negative
     * value using the distance method.
     *
     * @param body1 First input Body .
     * @param body2 Second input Body.
     * @return True if the Bodies are intersecting.
     * @throws # If either body has no shapes.]]></haxe_doc>
		</intersectsBody>
		<intersects public="1" set="method" line="435" static="1">
			<f a="shape1:shape2">
				<c path="nape.shape.Shape"/>
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if two Shapes intersect.
     * <br/><br/>
     * The input Shapes must belong to a Body so that their world positions
     * and orientations are defined; these Bodies need not be different nor
     * part of any Space.
     * <br/><br/>
     * If you do not need distance/penetration information,
     * then using this method will be more effecient than testing for a negative
     * value using the distance method.
     *
     * @param shape1 this shape must belong to a Body.
     * @param shape2 this shape must belong to a Body.
     * @return True if the shapes are intersecting in world space.
     * @throws # If shape1.body or shape2.body is null.]]></haxe_doc>
		</intersects>
		<contains public="1" set="method" line="456" static="1">
			<f a="shape1:shape2">
				<c path="nape.shape.Shape"/>
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if one Shape is entirely contained within another.
     * <br/><br/>
     * The input Shapes must belong to a Body so that their world positions
     * and orientations are defined; these Bodies need not be different nor
     * part of any Space.
     *
     * @param shape1 this shape must belong to a Body.
     * @param shape2 this shape must belong to a Body.
     * @return True if shape2 is completely contained within shape1.
     * @throws # If shape1.body or shape2.body is null.]]></haxe_doc>
		</contains>
		<haxe_doc>* Geom class provides interface to collision detection routines in nape.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomPoly" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/GeomPoly.hx">
		<get public="1" set="method" line="1175" static="1">
			<f a="?vertices" v="null">
				<d/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Allocate GeomPoly from object pool.
     * <br/><br/>
     * The vertices argument is typed Dynamic (* in AS3), and is permitted
     * to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
     * <br/><br/>
     * The input will be used to initialise the vertices of the polygon with
     * the head of the polygon pointing to the first vertex in input with vertices
     * inserted in forward order.
     *
     * @param vertices Vertex data to initialise polygon, or null for empty polygon.
     * @return New GeomPoly representing input vertex data, allocated from object pool.
     * @throws # If input data is not of an expected Type.]]></haxe_doc>
		</get>
		<zpp_pool public="1">
			<c path="nape.geom.GeomPoly"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<zpp_disp public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_disp>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_GeomPoly"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<empty public="1" get="inline" set="null" line="229">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Determine if polygon is empty.
     *
     * @return True if polygon is empty.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</empty>
		<size public="1" set="method" line="243">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Determine number of vertices in polygon
     *
     * @return The number of vertices.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</size>
		<iterator public="1" get="inline" set="null" line="276">
			<f a=""><c path="nape.geom.GeomVertexIterator"/></f>
			<haxe_doc>* Haxe iterator over vertices of polygon.
     *
     * @return A Haxe iterator over the vertices of the polygon.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</iterator>
		<forwardIterator public="1" get="inline" set="null" line="292">
			<f a=""><c path="nape.geom.GeomVertexIterator"/></f>
			<haxe_doc>* Haxe iterator over vertices of polygon.
     *
     * @return A Haxe iterator over the vertices of the polygon.
     *         Iterating in a forward direction.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</forwardIterator>
		<backwardsIterator public="1" get="inline" set="null" line="308">
			<f a=""><c path="nape.geom.GeomVertexIterator"/></f>
			<haxe_doc>* Haxe iterator over vertices of polygon.
     *
     * @return A Haxe iterator over the vertices of the polygon.
     *         Iterating in a backwards direction.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</backwardsIterator>
		<current public="1" get="inline" set="null" line="334">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Current vertex at head of polygon.
     * <br/><br/>
     * The current vertex will not be changed by this access.
     * <br/><br/>
     * This function returns a Vec2 which will be intrinsically tied
     * to the values of the internal vertex so that modifications to
     * this Vec2 will be reflected in the vertex of the polygon.
     * <br/><br/>
     * If invoked again with the head of the polygon pointing to the
     * same vertex, then the same Vec2 will be returned; this Vec2 is
     * not able to be disposed of.
     *
     * @return A Vec2 representing the current vertex of polygon.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</current>
		<push public="1" set="method" line="374">
			<f a="vertex">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Push vertex to polygon.
     * <br/><br/>
     * A vertex will be allocated from a global object pool, and initialised
     * with the values of the given Vec2.
     * <br/><br/>
     * This vertex will be inserted after the current head, and the head
     * advanced to the newly inserted vertex, in this way successive pushes
     * will insert elements in order.
     * <br/><br/>
     * Note that the Vec2 supplied as argument is only used to initialise the
     * inner Vertex.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.push(X);
     *
     * poly := -> A <-> B <-> X <-> C <-> D <-> E <-
     *                      (head)
     * </pre>
     *
     * @param vertex The Vec2 to be used in initialising the inner vertex.
     * @return A reference to this polygon.
     * @throws # If Vec2 is null, or has been disposed.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</push>
		<pop public="1" set="method" line="436">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Pop vertex from polygon.
     * <br/><br/>
     * Pop the current vertex at head of polygon, retreating the 'current'
     * vertex to point to the previous vertex in polygon. This inner vertex
     * will be released to the global object pool.
     * <br/><br/>
     * In this way a pop which follows a push will act to reset the push.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.pop();
     *
     * poly := -> A <-> C <-> D <-> E <-
     *          (head)
     * </pre>
     *
     * @return A reference to this polygon.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="518">
			<f a="vertex">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Unshift vertex to polygon.
     * <br/><br/>
     * A vertex will be allocated from a global object pool, and initialised
     * with the values of the given Vec2.
     * <br/><br/>
     * This vertex will be inserted before the current head, and the head
     * retreated to the newly inserted vertex, in this way successive unshifts
     * will insert elements in the expected reverse order.
     * <br/><br/>
     * Note that the Vec2 supplied as argument is only used to initialise the
     * inner Vertex.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.unshift(X);
     *
     * poly := -> A <-> X <-> B <-> C <-> D <-> E <-
     *                (head)
     * </pre>
     *
     * @param vertex The Vec2 to be used in initialising the inner vertex.
     * @return A reference to this polygon.
     * @throws # If Vec2 is null, or has been disposed.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</unshift>
		<shift public="1" set="method" line="576">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Shift vertex from polygon.
     * <br/><br/>
     * Shift the current vertex at head of polygon, advancing the 'current'
     * vertex to point to the next vertex in polygon. This inner vertex
     * will be released to the global object pool.
     * <br/><br/>
     * In this way a shift which follows an unshift will act to reset the
     * unshift operation.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.shift();
     *
     * poly := -> A <-> C <-> D <-> E <-
     *                (head)
     * </pre>
     *
     * @return A reference to this polygon.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</shift>
		<skipForward public="1" set="method" line="656">
			<f a="times">
				<x path="Int"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Advance head of polygon forward.
     * <br/><br/>
     * The current head of polygon will be moved forwards
     * the given number of times, with a negative value
     * being equivalent to performing a backwards advance.
     * <br/><br/>
     * <code>poly.skip_forwards(times)</code> is equivalent to
     * <code>poly.skip_backwards(-times)</code>
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.skipForwards(2);
     *
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                            (head)
     * </pre>
     *
     * @params times The number of times to advance head forward.
     *               This value can be negative indicating a backwards
     *               advance.
     * @return A reference to this polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</skipForward>
		<skipBackwards public="1" get="inline" set="null" line="698">
			<f a="times">
				<x path="Int"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Advance head of polygon backwards.
     * <br/><br/>
     * The current head of polygon will be moved backwards
     * the given number of times, with a negative value
     * being equivalent to performing a forwards advance.
     * <br/><br/>
     * <code>poly.skip_backwards(times)</code> is equivalent to
     * <code>poly.skip_forwards(-times)</code>
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.skipBackwards(2);
     *
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                                  (head)
     * </pre>
     *
     * @params times The number of times to advance head backwards.
     *               This value can be negative indicating a forwards
     *               advance.
     * @return A reference to this polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</skipBackwards>
		<erase public="1" set="method" line="737">
			<f a="count">
				<x path="Int"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Erase count number of elements
     * <br/><br/>
     * For positive values of count, this is equivalent to successive
     * unshift operations.
     * <br/><br/>
     * For negative values of count, this is equivalent to successive
     * pop operations.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-> F <-> G <-
     *                (head)
     *
     * poly.erase(2);
     *
     * poly := -> A <-> D <-> E <-> F <-> G <-
     *                (head)
     *
     * poly.erase(-3);
     *
     * poly := -> E <-> F <-
     *                (head)
     * </pre>
     * In this case that the specified number of elements to erase is
     * greater than the size of the polygon, the method will simply
     * terminate with the polygon being empty.
     *
     * @param count The number of vertices to erase, with sign indicating
     *              the direction for erasing.
     * @return A reference to this polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</erase>
		<clear public="1" set="method" line="827">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Clear all vertices from polygon.
     * <br/><br/>
     * All of the vertices will be released to the global object pool.
     *
     * @return A reference to this polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</clear>
		<copy public="1" set="method" line="902">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Copy this polygon.
     * <br/><br/>
     * The copy will have its vertices in the same order as 'this' polygon.
     * It will also have its current vertex at head, as the same vertex
     * this polygon has.
     * <br/><br/>
     * This polygon will not be modified in any way.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly2 = poly.copy();
     *
     * poly2 := -> A' <-> B' <-> C' <-> D' <-> E' <-
     *                  (head)
     * </pre>
     *
     * @return The new GeomPoly representing the copy.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</copy>
		<dispose public="1" set="method" line="1416">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Release this GeomPoly to global object pool.
     * <br/><br/>
     * Once disposed this GeomPoly will be accessible to Nape internals for re-allocation
     * and should not be touched (Good practice would be to set any references to this
     * GeomPoly to null to help ensure this).
     * <br/><br/>
     * In debug mode, should you attempt to access this GeomPoly after disposal
     * and the GeomPoly is still in the object pool, you will be given an Error.
     * The object pool operates on a First-In-Last-Out principal in debug mode to help
     * catch these sort of errors.
     * @throws # If this GeomPoly has already been disposed.]]></haxe_doc>
		</dispose>
		<toString public="1" set="method" line="1454">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<area public="1" set="method" line="1487">
			<f a=""><x path="Float"/></f>
			<haxe_doc><![CDATA[* Compute area of weakly-simple polygon.
     * <br/><br/>
     * For complex polygons, this function will return an underestimate
     * to the true area.
     *
     * @return The area of the polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</area>
		<winding public="1" set="method" line="1565">
			<f a=""><c path="nape.geom.Winding"/></f>
			<haxe_doc><![CDATA[* Compute the winding order for this polygon.
     * <br/><br/>
     * The winding order can be conceptualised by thinking of an analog
     * clock face, if your polygon is the numbers on the clock then a
     * clockwise winding would have your polygon's vertices in numerical
     * order.
     * <br/><br/>
     * In the case of a non-simple polygon with self intersections then the
     * winding order is decided by how 'much' of the polygon is locally
     * clockwise wound, and how much is locally anti-clockwise wound.
     * <br/>
     * (Think of a figure 8 style polygon where one loop is larger than the
     * other. This larger loop will dictate the winding of the polygon.)
     * <br/><br/>
     * If no winding can be computed, then <code>Winding.UNDEFINED</code>
     * will be returned.
     *
     * @return The winding of the polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</winding>
		<contains public="1" set="method" line="1641">
			<f a="point">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if point is contained in polygon.
     * <br/><br/>
     * Polygon containment is performed with a ray cast through polygon
     * from the vertex and counting the number of intersections. In this
     * way containment will be defined for self-intersecting polygons based
     * on how such a polygon would be rendered with areas of self-intersection
     * treat as being 'outside' the polygon.
     * <br/><br/>
     * This algorithm operates in O(n) time.
     *
     * @param point The point to test for containment.
     * @return True if point is contained in the polygon.
     * @throws # If point is null or has been disposed.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</contains>
		<isClockwise public="1" get="inline" set="null" line="1707">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if polygon is clockwise wound.
     * <br/><br/>
     * This is equivalent to <code>poly.winding() == Winding.CLOCKWISE</code>.
     *
     * @return True if polygon is clockwise wound.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</isClockwise>
		<isConvex public="1" set="method" line="1735">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if weakly-simple polygon is convex.
     * <br/><br/>
     * This algorithm assumes that the polygon is weakly-simple. Otherwise it may
     * fail (It is very easy to construct a self intersecting polygon which
     * will return True for isConvex()).
     * <br/><br/>
     * You may wish to instead use <code>isSimple() && isConvex()</code> if
     * you cannot be sure of the polygon being simple, noting that this will
     * of course return false in the case of a weakly-simple polygon.
     * <pre>
     *  _____
     * |     |
     * |     |  <-- convex
     * |____/
     *  __
     * |  &#92;___
     * |     /  <-- concave
     * |____/
     * </pre>
     * This algorithm operates in O(n) time.
     *
     * @return True if polygon is found to be convex.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</isConvex>
		<isSimple public="1" get="inline" set="null" line="1844">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if polygon is strictly simple.
     * <br/><br/>
     * By strict simplicity, we refer to not permitting 'glancing'
     * self intersections (where boundary of polygon 'touches' but does not
     * pass through another area of the polygon's boundary). This property
     * is instead referred to as being 'weakly simple' for which there is no
     * easy test!
     * <pre>
     *  _______
     * |   __  |  <-- strictly simple polygon.
     * |   &#92; &#92;_|
     *  &#92;__/
     *  _______
     * |   |   |
     * |  /_&#92;  | <-- weakly simple polygon.
     *  &#92;_____/
     *  ____
     * | __/
     *  X_  __   <-- complex polygon.
     * |  &#92;/  &#92;
     * &#92;__/&#92;__|
     * </pre>
     * This algorithm operates in O(n.log(n)) time.
     *
     * @return True if polygon is strictly simple.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</isSimple>
		<isMonotone public="1" get="inline" set="null" line="1875">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if polygon is y-monotone.
     * <br/><br/>
     * To be classed as y-monotone, the polygon must be such that any horizontal
     * line intersects the polygon in at most 2 intersections.
     * <pre>
     *  ___
     * |   |
     * |   |  <-- y-monotone
     * |___|
     *
     * |&#92;
     * | &#92;/|  <-- not y-monotone, offending vertex at bottom of the V.
     * |___|
     * </pre>
     * This algorithm operates in O(n) time.
     *
     * @return True if polygon is y-monotone.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</isMonotone>
		<isDegenerate public="1" get="inline" set="null" line="1895">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if weakly-simple polygon is degenerate.
     * <br/><br/>
     * Degeneracy is determined by having a zero area, if polygon is complex,
     * then this function may report degeneracy erroneously.
     *
     * @return True if polygon is degenerate.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</isDegenerate>
		<simplify public="1" set="method" line="1931">
			<f a="epsilon">
				<x path="Float"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Simplify polygon.
     * <br/><br/>
     * Simplification is performed with an implementation of the Ramer-Douglas-Peucker
     * algorithm. The output polygon is formed via subset of the vertices in
     * the input polygon such that any discarded vertex is at most 'epsilon' pixels
     * away from the local output polygon.
     * <br/><br/>
     * This algorithm works on both simple and complex polygons, but please note
     * that this algorithm makes no guarantees on a simple polygon remaining simple
     * after simplification. This should not generally be a problem unless the epsilon
     * value is large with respect to the size of the features on the polygon.
     * <br/><br/>
     * Many of the geometric algorithms will mark vertices as important, such that
     * they will be guaranteed to exist after simplification (Such as preventing
     * gaps from opening up in marching squares when simplifying output polygons).
     * <br/><br/>
     * The average runtime of this algorithm is O(n.log(n)). This algorithm is
     * not stable in the sense that adding a new vertex to the polygon may drastically
     * change the result of simplifying the polygon.
     *
     * @param epsilon The distance from polygon at which vertices are ignored.
     * @return A new GeomPoly representing the result of the simplification.
     * @throws # If epsilon is <= 0.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</simplify>
		<simpleDecomposition public="1" set="method" line="1973">
			<f a="?output" v="null">
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Produce a decomposition of complex polygon into simple components.
     * <br/><br/>
     * WARNING: This method is 'not' 100% robust. It may fail!
     * <br/><br/>
     * Produce a decomposition of a self intersecting, complex polygon into
     * a set of weakly-simple components.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time and is based on the
     * Bentley-Ottmann algorithm.
     *
     * @param output If supplied, polygons will be appended to this list via 'add'
     *        instead of a new list being constructed.
     * @return A Nape list of GeomPoly's representing the decomposition.
     * @throws # If polygon is degenerate.
     * @throws # Any other error may be thrown if algorithm has failed, even
     *           in release builds!
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</simpleDecomposition>
		<monotoneDecomposition public="1" set="method" line="2019">
			<f a="?output" v="null">
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Produce a decomposition of weakly-simple polygon into monotone components.
     * <br/><br/>
     * This algorithm 'should' be 100% robust and has been well tested on for
     * example, the output of the Marching Squares utility which produces many
     * degenerate cases of weakly-simple polygons that have not yet broken this
     * algorithm!.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time and may strip vertices from
     * the polygon in degenerate cases where vertex is not needed to define the
     * polygon.
     * <br/><br/>
     * This algorithm is an improved version of the one presented in: Mark de
     * Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf.
     * Computational Geometry: Algorithms and Applications. Springer-Verlag,
     * Berlin, 1997.
    
     * @param output If supplied, polygons will be appended to this list via 'add'
     *        instead of a new list being constructed.
     * @return A Nape list of GeomPoly's defining the decomposition.
     * @throws # If polygon is degenerate.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</monotoneDecomposition>
		<convexDecomposition public="1" set="method" line="2075">
			<f a="?delaunay:?output" v="false:null">
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Produce a decomposition of weakly-simple polygon into convex components.
     * <br/><br/>
     * This algorithm 'should' be 100% robust and has been well test on for
     * example, the output of the Marching Squars utility which produces many
     * degenerate cases of weakly-simple polygons that have not yet broken this
     * algorithm!.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time and will produce no more than
     * 4 times the number of convex poylgons in a minimal decomposition in the
     * worst case scenario.
     * <br/><br/>
     * Vertices may be stripped from the polygon that are found to not be
     * necessary as part of making this algorithm robust.
     *
     * @param delaunay This algorithm first performs a triangulation, if this field
     *                 is true, then this triangulation will be made delaunay and may
     *                 produce better convex polygons resultanly (default false).
     * @param output If supplied, polygons will be appended to this list via 'add'
     *        instead of a new list being constructed.
     * @return A Nape list of GeomPoly's defining the decomposition.
     * @throws # If polygon is degenerate.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</convexDecomposition>
		<triangularDecomposition public="1" set="method" line="2154">
			<f a="?delaunay:?output" v="false:null">
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Produce a decomposition of weakly-simple polygon into triangles.
     * <br/><br/>
     * This algorithm 'should' be 100% robust and has been well test on for
     * example, the output of the Marching Squars utility which produces many
     * degenerate cases of weakly-simple polygons that have not yet broken this
     * algorithm!.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time.
     * <br/><br/>
     * Vertices may be stripped from the polygon that are found to not be
     * necessary as part of making this algorithm robust.
     *
     * @param delaunay If true, then an O(n^2) pass will be made to mutate the original
     *                 triangulation to push it into a delanuay triangulation. (default false)
     * @param output If supplied, polygons will be appended to this list via 'add'
     *        instead of a new list being constructed.
     * @return A Nape list of GeomPoly's defining the decomposition.
     * @throws # If polygon is degenerate.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</triangularDecomposition>
		<inflate public="1" set="method" line="2227">
			<f a="inflation">
				<x path="Float"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Inflate/Deflate polygon.
     * <br/><br/>
     * This algorithm does not attempt to deal with any self-intersections which may
     * result from the process. Gaps are joined with a miter joint.
     * <br/><br/>
     * This algorithm will work for self-intersecting polygons, though the results
     * may not be what you expect; some parts will be inflated, and some deflated
     * depending on the local winding. You should probably avoid using this on
     * self-intersecting polygons.
     *
     * @param inflation The number of pixels to inflate polygon by. To deflate
     *                  use a negative value.
     * @return The inflated polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</inflate>
		<cut public="1" set="method" line="2460">
			<f a="start:end:?boundedStart:?boundedEnd:?output" v="::false:false:null">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Cut simple polygon with line.
     * <br/><br/>
     * The result of this operation will be a list of new GeomPoly representing
     * the connected regions of the polygon after an imaginary cut is made.
     * <pre>
     * (Result of cut assuming
     *  boundedStart = true)       _
     *   /&#92;    _             /&#92;   / &#92;
     *  /  &#92;  / &#92;           /  &#92; '---'
     * / o--&#92;/---&#92;-->  =>  /    &#92;,---,
     * &#92;_________/         &#92;_________/
     * </pre>
     * This algorithm runs in average case O(n.log(n)) time and worst case O(n^2).
     * For convex polygons, this algorithm runs in guaranteed O(n) time.
     *
     * @param start The start point for line segment
     * @param end The end point for line segment.
     * @param boundedStart If true, then the cut will not extend
     *                     beyond the start of the line segment.
     *                     (default false)
     * @param boundedEnd   If true, then the cut will not extend
     *                     beyond the end of the line segment.
     *                     (default false)
     * @param output A GeomPolyList to append results to if supplied,
     *               otherwise a new list is created (default null)
     * @return A list of GeomPoly representing the result of the cut.
     * @throws # If polygon is not simple.
     * @throws # If start or end Vec2 are null or disposed of.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</cut>
		<transform public="1" set="method" line="2521">
			<f a="matrix">
				<c path="nape.geom.Mat23"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Transform polygon by given matrix.
     * <br/><br/>
     * Any transformation (not just equiorthogonal ones) are permitted, though
     * a transformation that causes polygon to be come degenerate is a bit
     * pointless.
     *
     * @param matrix The matrix to transform polygon by.
     * @return A reference to this polygon.
     * @throws # If matrix is null.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</transform>
		<bounds public="1" set="method" line="2562">
			<f a=""><c path="nape.geom.AABB"/></f>
			<haxe_doc>* Determine bounds of polygon.
     *
     * @return A new AABB representing bounds of polygon.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</bounds>
		<top public="1" set="method" line="2644">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Find top most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * @return A Vec2 representing the top most vertex.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</top>
		<bottom public="1" set="method" line="2686">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Find bottom most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * @return A Vec2 representing the bottom most vertex.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</bottom>
		<left public="1" set="method" line="2728">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Find left most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * @return A Vec2 representing the left most vertex.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</left>
		<right public="1" set="method" line="2770">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Find right most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * @return A Vec2 representing the right most vertex.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</right>
		<new public="1" set="method" line="954">
			<f a="?vertices" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Create a new GeomPoly polygon.
     * <br/><br/>
     * The vertices argument is typed Dynamic (* in AS3), and is permitted
     * to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
     * <br/><br/>
     * The input will be used to initialise the vertices of the polygon with
     * the head of the polygon pointing to the first vertex in input with vertices
     * inserted in forward order.
     * <br/><br/>
     * You should use the static 'get' method in preference to make use of object pool.
     *
     * @param vertices Vertex data to initialise polygon, or null for empty polygon.
     * @return New GeomPoly representing input vertex data.
     * @throws # If input data is not of an expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Polygon class with various geometric methods
 * <br/><br/>
 * This class represents a general Polygon, rather than the Polygon class
 * which is physics shape.
 * <br/><br/>
 * Internally this polygon is stored as a circularly linked list of special
 * vertex types that are exposed via a Vec2 that is lazily constructed whenever
 * necessary to the API.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomPolyIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/GeomPolyIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.GeomPolyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.geom.GeomPolyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.geom.GeomPolyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomPolyList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/GeomPolyList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.geom.GeomPoly"/></c>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than GeomPoly</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_GeomPolyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.geom.GeomPoly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.geom.GeomPoly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.geom.GeomPoly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.geom.GeomPoly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.geom.GeomPoly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.geom.GeomPolyIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.geom.GeomPolyList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.GeomPoly"/>
					<x path="Void"/>
				</f>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.GeomPoly"/>
					<x path="Bool"/>
				</f>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of GeomPoly type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:GeomPoly = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:GeomPoly = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:GeomPoly = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomVertexIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/GeomVertexIterator.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_GeomVertexIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<hasNext public="1" set="method" line="200">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any vertices remaining.
     *
     * @return True if there are more vertices to iterate over.</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="237">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Return next vertex in list.
     * <br/><br/>
     * The vertex is represented by an intrinsically linked Vec2
     * unique to that vertex, which cannot be diposed of.
     *
     * @return The next vertex in iteration.]]></haxe_doc>
		</next>
		<new public="1" set="method" line="188">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe compatible iterator over vertices of GeomPoly.
 * <br/><br/>
 * Vec2's intrinsically tied to the vertices are exposed through
 * the iterator which does not modify the state of the polygon.]]></haxe_doc>
	</class>
	<typedef path="nape.geom.IsoFunctionDef" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/IsoFunction.hx" module="nape.geom.IsoFunction">
		<f a=":">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<haxe_doc><![CDATA[* For 'flash' targets only.
 * <br/><br/>
 * Iso-functions for MarchingSquares must be given
 * as an object implementing this IsoFunction interface. This is for
 * reasons of avoiding excessive memory allocations that occur through
 * automatic boxing of arguments/return values when using function values.
 * <br/>
 * Since iso-functions may be called 10,000's of times per-invocation of
 * marching-squares, this can quickly accumulate into a lot of GC activity.]]></haxe_doc>
	</typedef>
	<class path="nape.geom.MarchingSquares" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/MarchingSquares.hx">
		<run public="1" set="method" line="269" static="1">
			<f a="iso:bounds:cellsize:?quality:?subgrid:?combine:?output" v=":::2:null:true:null">
				<t path="nape.geom.IsoFunctionDef"/>
				<c path="nape.geom.AABB"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Execute marching squares algorithm over region of space.
     * <br/><br/>
     * We can, optionally provide a subgrid argument which, when non null
     * will invoke this algorithm seperately on each subgrid cell of the region
     * in space, instead of on the entire region at once. This can be very useful
     * as shown in the DestructibleTerrain demo where regions of a terrain are
     * recomputed with marching squares without needing to regenerate the whole
     * of the terrain.
     *
     * @param iso The iso-function defining the regions where polygons should
     *            be extracted, a negative return indicates a region to be extracted.
     *            This function need not be continuous, but if it is continuous
     *            then more accurate results will be given for the same input
     *            parameters.
     * @param bounds The AABB representing the region of space to be converted.
     *               The arguments to the iso-function will be in the same region.
     * @param cellsize The dimensions of each cell used individual polygon extraction.
     *                 Smaller cells will give more accurate results at a greater
     *                 cost permitting smaller features to be extracted.
     * @param quality This is the number of recursive interpolations which will be
     *                performed along cell edges. If the iso-function is not
     *                continuous, then this value should be increased to get better
     *                accuracy. (default 2)
     * @param subgrid When supplied, the region of space will be first subdivided
     *                into cells with these given dimensions, and each cell treated
     *                as a seperate invocation of this method, this value should
     *                obviously be greater than cellsize or it would be a bit
     *                pointless. (default null)
     * @param combine When True, the polygons generated in each cell of the grid
     *                will be combined into the largest possible weakly-simple
     *                polygons representing the same area. These polygons will
     *                always be suitable for decomposition in Nape. (default true)
     * @param output When supplied, GeomPoly will be inserted into the list (via add)
     *               instead of creating a new GeomPolyList object.
     * @return A list of GeomPoly representing the results of the extraction.
     * @throws # If iso, bounds or cellsize argument is null.
     * @throws # If cellsize is disposed, or its components have 0, or negative values.
     * @throws # If quality is less than 0.
     * @throws # If subgrid is not null, but is disposed or has zero or negative
     *           component values.]]></haxe_doc>
		</run>
		<haxe_doc><![CDATA[* Iso-surface extraction into polygons.
 * <br/><br/>
 * This class, with only one static method provides an interface to
 * an algorithm which will, when given a function mapping each point
 * in a given AABB to a scalar value extract approximated polygons
 * which represent the region of the AABB where the function returns
 * a negative value.
 * <br/><br/>
 * This function could be a mathematical function like the equation of
 * a circle: <code> function (x, y) return (x*x + y*y) - r*r </code>
 * <br/>
 * Or something more practical like the biased alpha value interpolated
 * from a Bitmap:
 * <pre>
 * function (x, y) {
 *    var ix = if (x < 0) 0 else if (x >= bitmap.width - 1) bitmap.width - 2 else Std.int(x);
 *    var iy = if (y < 0) 0 else if (y >= bitmap.height - 1) bitmap.height - 2 else Std.int(y);
 *    var fx = x - ix;
 *    var fy = y - iy;
 *    var gx = 1 - fx;
 *    var gy = 1 - fy;
 *
 *    var a00 = bitmap.getPixel32(ix, iy) >>> 24;
 *    var a01 = bitmap.getPixel32(ix, iy + 1) >>> 24;
 *    var a10 = bitmap.getPixel32(ix + 1, iy) >>> 24;
 *    var a11 = bitmap.getPixel32(ix + 1, iy + 1) >>> 24;
 *
 *    return 0x80 - (gx*gy*a00 + fx*gy*a10 + gx*fy*a01 + fx*fy*a11);
 * }
 * </pre>
 * For 'flash', we must wrap this in an IsoFunction interface to be used
 * by MarchingSquares for performance reasons:
 * <pre>
 * class BitmapIsoFunction implements nape.geom.IsoFunction {
 *     public function iso(x:Float, y:Float):Float {
 *         ...
 *     }
 * }
 * </pre>
 * This function is converted into a set of polygons by sampling along regular
 * grid points, and then recursively interpolating along cell edges based on
 * the function provided to find the point in space along that edge where the
 * function is approximately 0.
 * <br/><br/>
 * From this we generate polygons in each grid cell, which are then by default
 * combined into larger, weakly simply polygons suitable for use in the
 * decomposition routines of GeomPoly like convexDecomposition!
 * <br/><br/>
 * The runtime of the algorithm is O(N+K) for N number of cells and K number
 * of output vertices (A final pass is made to remove unnecessary vertices).]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Mat23" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/Mat23.hx">
		<fromMatrix public="1" set="method" line="451" static="1">
			<f a="matrix">
				<c path="flash.geom.Matrix"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Create a Mat23 matrix from a given AS3 flash.geom.Matrix.
     * <br/><br/>
     * This method should be used in preference to doing so manually
     * as the allocation of matrix entries to name is different and
     * it is easy to make this mistake!
     * <br/><br/>
     * This method is only available on <code>flash</code> and
     * <code>openfl||nme</code> targets.
     *
     * @param matrix The AS3 Matrix to create Mat23 from. This value must
     *               not be null.
     * @return       The constructed Mat23 matching AS3 Matrix.]]></haxe_doc>
		</fromMatrix>
		<rotation public="1" set="method" line="490" static="1">
			<f a="angle">
				<x path="Float"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Construct a Mat23 representing a clockwise rotation.
     *
     * <pre>
     * [ cos angle  -sin angle  0 ]
     * [ sin angle   cos angle  0 ]
     * </pre>
     *
     * @param angle The clockwise rotation in radians
     * @return      The rotation matrix.]]></haxe_doc>
		</rotation>
		<translation public="1" set="method" line="513" static="1">
			<f a="tx:ty">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Construct a Mat23 representing a translation
     *
     * <pre>
     * [ 1  0  tx ]
     * [ 0  1  ty ]
     * </pre>
     *
     * @param tx The x translation.
     * @param ty The y translation.
     * @return   The translation matrix.]]></haxe_doc>
		</translation>
		<scale public="1" set="method" line="529" static="1">
			<f a="sx:sy">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Construct a Mat23 representing a scaling
     *
     * <pre>
     * [ sx  0  0 ]
     * [ 0  sy  0 ]
     * </pre>
     *
     * @param sx The x factor of scaling.
     * @param sy The y factor of scaling.
     * @return   The scaling matrix.]]></haxe_doc>
		</scale>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Mat23"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<a public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (1,1) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ a  .  . ]
     * [ .  .  . ]
     * </pre>
     *
     * @default 1]]></haxe_doc>
		</a>
		<get_a get="inline" set="null" line="204"><f a=""><x path="Float"/></f></get_a>
		<set_a get="inline" set="null" line="207"><f a="a">
	<x path="Float"/>
	<x path="Float"/>
</f></set_a>
		<b public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (1,2) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ .  b  . ]
     * [ .  .  . ]
     * </pre>
     *
     * @default 0]]></haxe_doc>
		</b>
		<get_b get="inline" set="null" line="231"><f a=""><x path="Float"/></f></get_b>
		<set_b get="inline" set="null" line="234"><f a="b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_b>
		<c public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (2,1) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ .  .  . ]
     * [ c  .  . ]
     * </pre>
     *
     * @default 0]]></haxe_doc>
		</c>
		<get_c get="inline" set="null" line="258"><f a=""><x path="Float"/></f></get_c>
		<set_c get="inline" set="null" line="261"><f a="c">
	<x path="Float"/>
	<x path="Float"/>
</f></set_c>
		<d public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (2,2) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ .  .  . ]
     * [ .  d  . ]
     * </pre>
     *
     * @default 1]]></haxe_doc>
		</d>
		<get_d get="inline" set="null" line="285"><f a=""><x path="Float"/></f></get_d>
		<set_d get="inline" set="null" line="288"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></set_d>
		<tx public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (1,3) entry in Mat23 which represents x translation
     * <br/><br/>
     * <pre>
     * [ .  .  tx ]
     * [ .  .  .  ]
     * </pre>
     *
     * @default 0]]></haxe_doc>
		</tx>
		<get_tx get="inline" set="null" line="312"><f a=""><x path="Float"/></f></get_tx>
		<set_tx get="inline" set="null" line="315"><f a="tx">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tx>
		<ty public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (2,3) entry in Mat23 which represents y translation
     * <br/><br/>
     * <pre>
     * [ .  .  .  ]
     * [ .  .  ty ]
     * </pre>
     *
     * @default 0]]></haxe_doc>
		</ty>
		<get_ty get="inline" set="null" line="339"><f a=""><x path="Float"/></f></get_ty>
		<set_ty get="inline" set="null" line="342"><f a="ty">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ty>
		<copy public="1" set="method" line="386">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc>* Produce copy of this Mat23
     *
     * @return The new Mat23 representing copy of this.</haxe_doc>
		</copy>
		<set public="1" set="method" line="396">
			<f a="matrix">
				<c path="nape.geom.Mat23"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc>* Set values of matrix from another.
     *
     * @param matrix The matrix to copy values from.
     * @return       A reference to this Mat23.
     * @throws # if matrix argument is null.</haxe_doc>
		</set>
		<setAs public="1" set="method" line="420">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1.0f:0.0f:0.0f:1.0f:0.0f:0.0f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Set values of matrix from numbers.
     * <br/><br/>
     * So that: <code>mat.setAs(...)</code> is
     * semantically equivalent to: <code>mat.set(new Mat23(...))</code>
     * <br/><br/>
     * @param a  The value to which the (1,1) entry will be set (default 1)
     * @param b  The value to which the (1,2) entry will be set (default 0)
     * @param c  The value to which the (2,1) entry will be set (default 0)
     * @param d  The value to which the (2,2) entry will be set (default 1)
     * @param tx The value to which the (1,3) entry will be set (default 0)
     * @param ty The value to which the (2,3) entry will be set (default 0)
     * @return   A reference to this Mat23.]]></haxe_doc>
		</setAs>
		<reset public="1" get="inline" set="null" line="433">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc><![CDATA[* Reset matrix to identity.
     * <br/><br/>
     * Equivalent to calling setAs with default argument values.
     * <br/><br/>
     * @return A reference to this Mat23.]]></haxe_doc>
		</reset>
		<toMatrix public="1" set="method" line="467">
			<f a="?output" v="null">
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.Matrix"/>
			</f>
			<haxe_doc><![CDATA[* Create an AS3 flash.geom.Matrix from this Mat23.
     * <br/><br/>
     * This method should be used in preference to doing so manually
     * as the allocation of matrix entries to name is different and
     * it is easy to make this mistake!
     *
     * @param output If supplied, this Matrix will have its properties
     *               populated insteaad of creating a new Matrix.
     * @preturn The constructed AS3 Matrix.]]></haxe_doc>
		</toMatrix>
		<determinant public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* (readonly) The determinant of this matrix.
     * <br/><br/>
     * This represents the factor of change in area
     * for a region of the plane after transformation by matrix.
     * <br/><br/>
     * A determinant of 0 signifies that the matrix is not invertible.
     * <br/><br/>
     * A negative determinant signifies that for example, a clockwise wound
     * polygon would be transformed into a counter-clockwise polygon.
     *
     * @default 1]]></haxe_doc>
		</determinant>
		<get_determinant get="inline" set="null" line="547"><f a=""><x path="Float"/></f></get_determinant>
		<singular public="1" set="method" line="560">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if the matrix is singular.
     * This check is based on computing the condition number of the matrix
     * by the Frobenius norm, and comparing against 2 / epsilon.
     * <br/><br/>
     * If matrix is singular, then inversion of the matrix cannot be performed
     *
     * @return True, if matrix is singular.]]></haxe_doc>
		</singular>
		<inverse public="1" set="method" line="577">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc><![CDATA[* Compute the inverse of this matrix, returning the inverse in a new
     * Mat23 object.
     * <br/><br/>
     * The inverse is such that mat.concat(mat.inverse()) is the identity
     * matrix, as well as mat.inverse().concat(mat)
     *
     * @return The inverse matrix.
     * @throws # If matrix is singular.]]></haxe_doc>
		</inverse>
		<transpose public="1" set="method" line="606">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc><![CDATA[* Compute the transpose of this matrix, returning the transpose in a new
     * Mat23 object.
     * <br/><br/>
     * Technically speaking, we cannot transpose a matrix if the tx/ty values
     * are non-zero as the implicit bottom row of matrix must be (0, 0, 1)
     * so the tx/ty values of output matrix are set so that should the main
     * 2x2 block of the matrix be orthogonal (Representing a rotation), then
     * the transpose will be able to act as the matrix inverse.
     * <pre>
     * var mat = Mat23.rotation(..).concat(Mat23.translation(...));
     * trace(mat.concat(mat.transpose())); // Identity matrix
     * trace(mat.concat(mat.inverse())); // Identity matrix
     * </pre>
     * If the main 2x2 block of matrix is 'not' orthogonal, then the transpose
     * will not be equal to the inverse.
     *
     * @return The transposed matrix.]]></haxe_doc>
		</transpose>
		<concat public="1" set="method" line="622">
			<f a="matrix">
				<c path="nape.geom.Mat23"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Concatenate matrices (left-multiplication), returning new Mat23.
     * <br/><br/>
     * <code>mat1.concat(mat2)</code> is the transformation that first
     * performs transformation represented by mat1, followed by transformation
     * represented by mat2.
     * <br/>
     *
     * @param matrix Matrix to concatenate with.
     * @return       The result of the concatenation.
     * @throws # If matrix argument is null.]]></haxe_doc>
		</concat>
		<transform public="1" set="method" line="648">
			<f a="point:?noTranslation:?weak" v=":false:false">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Transform a Vec2 by this matrix in new Vec2.
     * <br/><br/>
     * The Vec2 object will be allocated form the global object pool.
     *
     * @param point         The Vec2 to transform by this matrix.
     * @param noTranslation If true, then the input Vec2 will be treat as a
     *                      vector, rather than a point with the tx/ty values
     *                      treat as 0. (default false)
     * @param weak          If true, then the allocated Vec2 will be
     *                      automatically released to global object pool when
     *                      used as an argument to a Nape function.
     * @return              The result of the transformation as a newly
     *                      allocated (possibly weak) Vec2. (default false)
     * @throws # If point argument is null.]]></haxe_doc>
		</transform>
		<inverseTransform public="1" set="method" line="702">
			<f a="point:?noTranslation:?weak" v=":false:false">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Perform inverse transformation with Vec2, returning new Vec2.
     * <br/><br/>
     * The matrix inverse will be performed implicitly and should this
     * method be called many times for the same Mat23, it would be better
     * to instead compute the matrix inverse only once.
     * <br/><br/>
     * The new Vec2 will be allocated from the global object pool.
     *
     * @param point         The Vec2 to transform.
     * @param noTranslation If true then the input Vec2 will be treat as a
     *                      vector instead of a point, treating the tx/ty
     *                      values of this Mat23 as though they were 0.
     *                      (default false)
     * @param weak          If true, then the allocated Vec2 will be
     *                      automatically released to global object pool when
     *                      used as an argument to a Nape function.
     * @return              The result of the transformation as a newly
     *                      allocated (possibly weak) Vec2. (default false)
     * @throws # If matrix is singular.
     * @throws # If point argument is null.]]></haxe_doc>
		</inverseTransform>
		<toString public="1" set="method" line="742">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<equiorthogonal public="1" set="method" line="766">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if matrix is equiorthogonal
     * <br/><br/>
     * This is a term I invented after
     * failing to find an existing name. It describes that this matrix maps
     * circles into other circles (of not necessarigly the same radius). In
     * otherwords the matrix can be decomposed into a rotation, translation
     * and scaling of equal x/y factors.
     * <br/><br/>
     * This property is required for any Mat23 that is used to transform a
     * Circle, or any Body containing a Circle, or to transform a Debug view.
     * <br/><br/>
     * This is a weaker property than orthogonality which describes a mapping
     * to a circle of equal radius.
     * <br/><br/>
     * Mathematically speaking a matrix is equiorthogonal iff.
     * <code>transpose(M) * M = kI</code> for some non-zero scalar k.
     *
     * @return True if matrix is equiorthogonal.]]></haxe_doc>
		</equiorthogonal>
		<orthogonal public="1" set="method" line="794">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if matrix is orthogonal
     * <br/><br/>
     * This property describes a matrix
     * which maps circles into other circles of equal radius. In otherwords
     * the matrix can be decomposed into a rotation and a translation.
     * <br/><br/>
     * Mathematically speaking a matrix is orthogonal iff.
     * <code>transpose(M) * M = I</code>.
     *
     * @return True if matrix is orthogonal.]]></haxe_doc>
		</orthogonal>
		<equiorthogonalise public="1" set="method" line="817">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc><![CDATA[* Equiorthogonalise matrix.
     * <br/><br/>
     * We do this by finding the 'nearest' orthogonal matrix;
     * scaling the basis vectors of matrix to their mean length
     * and applying an equal and opposite rotation to each basis vector to
     * make them perpendicular.
     *
     * @return A reference to this Mat23.
     * @throws # If matrix is singular.]]></haxe_doc>
		</equiorthogonalise>
		<orthogonalise public="1" set="method" line="862">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc><![CDATA[* Orthogonalise matrix.
     * <br/><br/>
     * We do this by finding the 'nearest' orthogonal matrix;
     * normalising the basis vectors of matrix
     * and applying an equal and opposite rotation to each basis vector to
     * make them perpendicular.
     *
     * @return A reference to this Mat23.
     * @throws # If matrix is singular.]]></haxe_doc>
		</orthogonalise>
		<new public="1" set="method" line="370">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1.0f:0.0f:0.0f:1.0f:0.0f:0.0f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct new Mat23.
     * <br/><br/>
     * <pre>
     * [ a  b  tx ]
     * [ c  d  ty ]
     * </pre>
     *
     * @param a  The (1,1) entry in matrix (default 1)
     * @param b  The (1,2) entry in matrix (default 0)
     * @param c  The (2,1) entry in matrix (default 0)
     * @param d  The (2,2) entry in matrix (default 1)
     * @param tx The (1,3) entry in matrix (default 0)
     * @param ty The (2,3) entry in matrix (default 0)
     * @return   The newly constructed Mat23.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* 2D Matrix class representing affine transformations:
 * <pre>
 * [ a  b  tx ]
 * [ c  d  ty ]
 * [ 0  0  1  ]
 * </pre>
 *
 * Note that in AS3, flash.geom.Matrix has 'b' and 'c' swapped! so if you are
 * converting between flash.geom.Matrix and nape.geom.Mat23 you should use the
 * methods provided to avoid any mistakes with this.
 *]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.MatMN" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/MatMN.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_MatMN"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<rows public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The number of rows in the matrix.</haxe_doc>
		</rows>
		<get_rows get="inline" set="null" line="189"><f a=""><x path="Int"/></f></get_rows>
		<cols public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The number of columns in the matrix.</haxe_doc>
		</cols>
		<get_cols get="inline" set="null" line="197"><f a=""><x path="Int"/></f></get_cols>
		<x public="1" get="inline" set="null" line="209">
			<f a="row:col">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Access element at index.
     *
     * @param row The row of the matrix to access.
     * @param col the column of the matrix to access.
     * @return The element at given (row,col) index.
     * @throws # If access is out of range.</haxe_doc>
		</x>
		<setx public="1" get="inline" set="null" line="228">
			<f a="row:col:x">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Set element at index.
     *
     * @param row The row of the matrix to set.
     * @param col The column of the matrix to set.
     * @param x The value to set at given (row,col) index.
     * @return The value of matrix at given index after set. (Always
     *         equal to the x parameter)
     * @throws # If index is out of range.</haxe_doc>
		</setx>
		<toString public="1" set="method" line="258">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<transpose public="1" set="method" line="274">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc>* Transpose matrix, returning a new Matrix.
     *
     * @return The transposed matrix.</haxe_doc>
		</transpose>
		<mul public="1" set="method" line="294">
			<f a="matrix">
				<c path="nape.geom.MatMN"/>
				<c path="nape.geom.MatMN"/>
			</f>
			<haxe_doc><![CDATA[* Multiple this matrix with another.
     * <br/><br/>
     * This operation is only valid if the number of columns
     * in this matrix, is equal to the number of rows in the input
     * matrix.
     * <br/>
     * The result of the multiplication is returned as a new matrix.
     *
     * @param matrix The matrix to multiple with.
     * @return The result of the multiplication
     * @throws If matrix dimensions are not compatible.]]></haxe_doc>
		</mul>
		<new public="1" set="method" line="246">
			<f a="rows:cols">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new Matrix.
     *
     * @param rows The number of rows in matrix.
     * @param cols The number of columns in matrix.
     * @return The constructed Matrix.
     * @throws # If rows or columns is negative or 0.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A general MxN dimensional matrix.
 * <br/><br/>
 * This object is not often used in Nape :)]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Ray" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/Ray.hx">
		<fromSegment public="1" set="method" line="370" static="1">
			<f a="start:end">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Ray"/>
			</f>
			<haxe_doc><![CDATA[* Create ray representing a line segment.
     * <br/><br/>
     * This function will a ray who's origin is the start point
     * and who's direction is towards the end point with the
     * maxDistance property appropriately set to not extend
     * beyond the end point.
     *
     * @param start Start point of line segment
     * @param end End point of line segment
     * @return A Ray representing this line segment.
     * @throws # If start or end are either null or disposed of.
     * @throws # If start and end point are equal so that the
     *         direction of the ray would be degenerate.]]></haxe_doc>
		</fromSegment>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Ray"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<origin public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Origin of ray.
     * <br/><br/>
     * This property can be set, and is equivalent to performing:
     * <code>ray.origin.set(newOrigin)</code>]]></haxe_doc>
		</origin>
		<get_origin get="inline" set="null" line="209"><f a=""><c path="nape.geom.Vec2"/></f></get_origin>
		<set_origin get="inline" set="null" line="212"><f a="origin">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_origin>
		<direction public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Direction of ray.
     * <br/><br/>
     * This property can be set, and is equivalent to performing:
     * <code>ray.direction.set(newDirection)</code> with the additional
     * constraint that the input direction must not be degenerate.
     * <br/><br/>
     * This direction vector need not be normalised.]]></haxe_doc>
		</direction>
		<get_direction get="inline" set="null" line="239"><f a=""><c path="nape.geom.Vec2"/></f></get_direction>
		<set_direction get="inline" set="null" line="242"><f a="direction">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_direction>
		<maxDistance public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The maximum distance for ray to be queried.
     * <br/><br/>
     * When used in ray test functions, no search will extend beyond this
     * distance.
     * <br/><br/>
     * This value represents a true distance, even if direction vector is
     * not normalised. This value may be equal to infinity.
     *
     * @default infinity]]></haxe_doc>
		</maxDistance>
		<get_maxDistance get="inline" set="null" line="272"><f a=""><x path="Float"/></f></get_maxDistance>
		<set_maxDistance get="inline" set="null" line="275"><f a="maxDistance">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxDistance>
		<aabb public="1" set="method" line="295">
			<f a=""><c path="nape.geom.AABB"/></f>
			<haxe_doc><![CDATA[* Compute bounding box of ray.
     * <br/><br/>
     * This function will take into account the maxDistance property of this ray.
     * <br/>
     * The return AABB may have in the general case infinite values :)
     *
     * @return An AABB representing bounding box of ray.]]></haxe_doc>
		</aabb>
		<at public="1" set="method" line="313">
			<f a="distance:?weak" v=":false">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Compute point along ray at given distance.
     * <br/><br/>
     * Even if ray direction is not normalised, this value still repersents
     * a true distance. The distance may also be negative.
     * <br/><br/>
     * The Vec2 returned will be allocated from the global object pool.
     *
     * @param distance The distance along ray to compute point for.
     * @param weak If true then a weakly allocated Vec2 will be returned
     *             which will be automatically released to global object
     *             pool when used as argument to another Nape function.
     *             (default false)
     * @return Vec2 representing point at given distance along ray.]]></haxe_doc>
		</at>
		<copy public="1" set="method" line="350">
			<f a=""><c path="nape.geom.Ray"/></f>
			<haxe_doc><![CDATA[* Produce a copy of this ray.
     * <br/><br/>
     * All ray properties will be copied including maxDistance.
     *
     * @return The copy of this Ray.]]></haxe_doc>
		</copy>
		<new public="1" set="method" line="327">
			<f a="origin:direction">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct new Ray.
     *
     * @param origin Origin of ray.
     * @param direction Direction of ray.
     * @throws # If origin or direction are null, or disposed of.
     * @throws # If direction is degenerate.</haxe_doc>
		</new>
		<haxe_doc>* Parametrically defined ray used in ray casting functions.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.RayResult" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/RayResult.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_ConvexRayResult"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<normal public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* The normal of the surface at intersection.</haxe_doc>
		</normal>
		<get_normal get="inline" set="null" line="190"><f a=""><c path="nape.geom.Vec2"/></f></get_normal>
		<distance public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The distance to the intersection.</haxe_doc>
		</distance>
		<get_distance get="inline" set="null" line="201"><f a=""><x path="Float"/></f></get_distance>
		<inner public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether this intersection is with the inner surface of an object.</haxe_doc>
		</inner>
		<get_inner get="inline" set="null" line="212"><f a=""><x path="Bool"/></f></get_inner>
		<shape public="1" get="accessor" set="null">
			<c path="nape.shape.Shape"/>
			<haxe_doc>* The shape which was intersected.</haxe_doc>
		</shape>
		<get_shape get="inline" set="null" line="223"><f a=""><c path="nape.shape.Shape"/></f></get_shape>
		<dispose public="1" get="inline" set="null" line="243">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Release RayResult object to pool.</haxe_doc>
		</dispose>
		<toString public="1" set="method" line="252">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="234">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Class representing the results of a ray cast operation.
 * <br/><br/>
 * These objects are allocated from an object pool and can
 * be released back to that pool by calling its dispose method.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.RayResultIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/RayResultIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.RayResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.geom.RayResultList"/>
				<c path="nape.geom.RayResultIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.geom.RayResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.geom.RayResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.geom.RayResult"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.RayResultList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/RayResultList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.geom.RayResult"/></c>
				<c path="nape.geom.RayResultList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than RayResult</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_RayResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.geom.RayResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.geom.RayResult"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.geom.RayResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.geom.RayResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.geom.RayResult"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.geom.RayResult"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.geom.RayResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.geom.RayResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.geom.RayResultIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.geom.RayResultList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.geom.RayResultList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.RayResult"/>
					<x path="Void"/>
				</f>
				<c path="nape.geom.RayResultList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.RayResult"/>
					<x path="Bool"/>
				</f>
				<c path="nape.geom.RayResultList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of RayResult type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:RayResult = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:RayResult = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:RayResult = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Vec2" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/Vec2.hx">
		<weak public="1" get="inline" set="null" line="256" static="1">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Allocate a weak Vec2 from global object pool.
     * <br/><br/>
     * This object which will be automaticaly released back to the object pool
     * when supplied as an argument to a Nape function.
     * <br/><br/>
     * Note that <code>Vec2.weak(x, y)</code> is exactly equivalent to <code>
     * Vec2.get(x, y, true)</code>.
     *
     * @param x The x coordinate for the vector. (default 0)
     * @param y The y coordiante for the vector. (default 0)
     * @return  The allocated weak Vec2 with given x/y values.]]></haxe_doc>
		</weak>
		<get public="1" get="inline" set="null" line="273" static="1">
			<f a="?x:?y:?weak" v="0:0:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Allocates a Vec2 from the global object pool.
     * <br/><br/>
     * Note that <code>Vec2.get(x, y, true)</code> is exactly equivalent to
     * <code>Vec2.weak(x, y)</code> and should be preferred.
     *
     * @param x    The x coordinate for the vector. (default 0)
     * @param y    The y coordinate for the vector. (default 0)
     * @param weak If true, then a weak Vec2 will be allocated which will be
     *             automatically released to object pool when passed as an
     *             argument to a Nape function. (default false)
     * @return     The allocated, possibly weak Vec2 with given x/y values.]]></haxe_doc>
		</get>
		<fromPoint public="1" set="method" line="452" static="1">
			<f a="point:?weak" v=":false">
				<c path="flash.geom.Point"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Allocate a Vec2 from AS3 Point object.
     * <br/><br/>
     * This Vec2 will be allocated from the global object pool.
     * <br/><br/>
     * This method is only available on <code>flash</code> and
     * <code>openfl||nme</code> targets.
     *
     * @param point The AS3 Point to initialise Vec2 with
     * @param weak  If true, then a weak Vec2 will be allocated which will
     *              be automatically released to the object pool when
     *              pass as an argument to any Nape function.
     *              (default false)
     * @return      The possibly weak Vec2 allocated with same values as
     *              input Point object.
     * @throws # If the point argument is null.]]></haxe_doc>
		</fromPoint>
		<fromPolar public="1" set="method" line="505" static="1">
			<f a="length:angle:?weak" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Allocate a Vec2 given polar coordinates.
     * <br/><br/>
     * This Vec2 will be allocated from the global object pool.
     * <br/><br/>
     * This method will assign x/y values equal respectively to:
     * <code>length&#42Math.cos(angle)</code>,
     * <code>length&#42Math.sin(angle)</code>
     *
     * @param length The length of the Vec2. This value may be negative.
     * @param angle  The angle of the Vec2 as measured in radians clockwise
     *               from the positive x axis.
     * @param weak   If true, then a weak Vec2 will be allocated which will be
     *               automatically released to the object pool when passed as
     *               an argument to any Nape function. (default false)
     * @return       The possibly weak Vec2 allocated with given polar values.]]></haxe_doc>
		</fromPolar>
		<dsq public="1" get="inline" set="null" line="711" static="1">
			<f a="a:b">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Compute square distance between two points.
     *
     * @param a The first point Vec2.
     * @param b The second point Vec2.
     * @return Squared distance between points.
     * @throws # If a, b are disposed of or null.</haxe_doc>
		</dsq>
		<distance public="1" get="inline" set="null" line="759" static="1">
			<f a="a:b">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Compute distance between two points.
     *
     * @param a The first point Vec2.
     * @param b The second point Vec2.
     * @return Distance between points.
     * @throws # If a, b are disposed of or null.</haxe_doc>
		</distance>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Vec2"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_pool public="1">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<zpp_disp public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_disp>
		<dispose public="1" get="inline" set="null" line="328">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Release this Vec2 to global object pool.
     * <br/><br/>
     * Once diposed this Vec2
     * will be accessible to Nape internals for re-allocation and should
     * not be touched (Good practice would be to set any references to this
     * Vec2 to null to help ensure this).
     * <br/><br/>
     * In debug mode, should you attempt to access this Vec2 after disposal
     * and the Vec2 is still in the object pool, you will be given an Error.
     * The object pool operates on a First-In-Last-Out principal in debug
     * mode to help catch these sort of errors.
     * @throws # If this vector has already been disposed.
     * @throws # If this vector is immutable.
     * @throws # If this vector is in use in some other manner, such as being
     *           an element of a Polygon's vertex list.]]></haxe_doc>
		</dispose>
		<copy public="1" get="inline" set="null" line="425">
			<f a="?weak" v="false">
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Produce a copy of this Vec2.
     * <br/><br/>
     * The Vec2 will be allocated from the global object pool.
     * <br/><br/>
     * As would be expected, if you produce a copy of an 'immutable' Vec2, then
     * the copy will be 'mutable'.
     *
     * @param weak If true, then a weak Vec2 will be allocated which will be
     *             automatically released to the object pool when passed as an
     *             argument to any Nape function. (default false)
     * @return     The possibly weak copy of this Vec2.
     * @throws # If this vector has been disposed.]]></haxe_doc>
		</copy>
		<toPoint public="1" set="method" line="475">
			<f a="?output" v="null">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc><![CDATA[* Create an AS3 Point object from Vec2.
     * <br/><br/>
     * This method is only available on <code>flash</code> and
     * <code>openfl||nme</code> targets.
     *
     * @param output If supplied, this Point will have its x/y
     *               set instead of creating a new Point.
     * @return    The AS3 Point object representing Vec2.
     * @throws # If this vector has been disposed of.]]></haxe_doc>
		</toPoint>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* x coordinate of vector.
     *
     * @default 0</haxe_doc>
		</x>
		<get_x get="inline" set="null" line="523"><f a=""><x path="Float"/></f></get_x>
		<set_x get="inline" set="null" line="532"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* y coordinate of vector.
     *
     * @default 0</haxe_doc>
		</y>
		<get_y get="inline" set="null" line="559"><f a=""><x path="Float"/></f></get_y>
		<set_y get="inline" set="null" line="568"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<length public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Length of this Vec2.
     * <br/><br/>
     * This value can be set and may be set to negative values so that
     * <code>vec.length &#42= -1</code> is a valid - if sub-optimal - way of
     * negating a Vec2.
     *
     * @default 0]]></haxe_doc>
		</length>
		<get_length get="inline" set="null" line="599"><f a=""><x path="Float"/></f></get_length>
		<set_length get="inline" set="null" line="607"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<lsq public="1" set="method" line="650">
			<f a=""><x path="Float"/></f>
			<haxe_doc><![CDATA[* Compute squared length of this Vec2.
     * <br/><br/>
     * This is exactly the same as performing <code>vec.length &#42
     * vec.length</code> except for being more effecient.
     *
     * @return The squared length of this Vec2.
     * @throws # If this vector has been disposed.]]></haxe_doc>
		</lsq>
		<set public="1" get="inline" set="null" line="671">
			<f a="vector">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Set values of this Vec2 to those of the argument.
     * <br/><br/>
     * Note that <code>vec.set(p)</code> is semantically equivalent to
     * <code>vec.setxy(p.x, p.y)</code>.
     *
     * @param vector The Vec2 to set the values of this Vec2 with.
     * @return       A reference to 'this' Vec2.
     * @throws # If this vector, or vector argument  has been disposed.
     * @throws # If this vector is immutable.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</set>
		<setxy public="1" get="inline" set="null" line="808">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc>* Set values of this Vec2 given pair of x/y values.
     *
     * @param x The x value to set this Vec2's x value to.
     * @param y The y value to set this Vec2's y value to.
     * @return  A reference to 'this' Vec2.
     * @throws # If this vector has been disposed.
     * @throws # If this vector is immutable.</haxe_doc>
		</setxy>
		<angle public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angle of this Vec2.
     *
     * Measured in radians as measured clockwise from the positive x axis.
     * The value will be given in the range -pi to pi.
     * <br/><br/>
     * If the x/y values of this Vec2 are both 0, then the angle value will
     * default to 0.
     * <br/><br/>
     * This value can also be set (to any value) so that <code>vec.angle +=
     * Math.PI</code> is a valid - if sub-optimial - way of negating a Vec2.
     *
     * @default 0]]></haxe_doc>
		</angle>
		<get_angle get="inline" set="null" line="861"><f a=""><x path="Float"/></f></get_angle>
		<set_angle get="inline" set="null" line="874"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<rotate public="1" set="method" line="907">
			<f a="angle">
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Rotate Vec2 in-place by given number of radians..
     * <br/><br/>
     * Rotation performed in the clockwise direction.
     * <br/><br/>
     * The Vec2 will be mutated, with it's new x/y values being the result
     * of the rotation.
     *
     * @param angle The number of radians to rotate Vec2 by in the clockwise
     *              direction.
     * @return A reference to 'this' Vec2.
     * @throws # If this vector has been disposed.
     * @throws # If this vector is immutable.]]></haxe_doc>
		</rotate>
		<reflect public="1" set="method" line="942">
			<f a="vec:?weak" v=":false">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Reflect given Vec2 in plane whose normal is this Vec2.
     * <br/><br/>
     * @param vec The vector to be reflected.
     * @param weak If true, the returned Vec2 will be automatically released
     *             to object pool when used in another Nape function (default false)
     * @return The reflected Vec2.
     * @throws # If this vector or argument has been disposed.
     * @throws # If this vector has zero length.]]></haxe_doc>
		</reflect>
		<normalise public="1" set="method" line="984">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Normalise this vector.
     * <br/><br/>
     * Equivalent to setting the length of the vector to 1, and also to the
     * (less-optimal) <code>this.set(this.unit())</code>.
     *
     * @return A reference to 'this' vector.
     * @throws # If this vector has been disposed of or is immutable.
     * @throws # If length of this vector is 0.]]></haxe_doc>
		</normalise>
		<unit public="1" set="method" line="1035">
			<f a="?weak" v="false">
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc>* Return normalisation of this vector.
     *
     * @param weak If true then the allocated Vec2 will be automatically
     *             released to the global object pool when used as an argument
     *             to a Nape function. (default false)
     * @return A copy of this vector, normalised.
     * @throws # If this vector has been disposed of.
     * @throws # If length of this vector is 0.</haxe_doc>
		</unit>
		<add public="1" set="method" line="1066">
			<f a="vector:?weak" v=":false">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Add another vector to this vector.
     * <br/><br/>
     * Returns a newly allocated vector so that
     * this vector is not modified.
     * <br/><br/>
     * @param vector The vector to add to this vector. This value can not be
     *               null
     * @param weak   If true then the returned vector will be automatically
     *               released to the global object pool when used as an
     *               argument to another Nape function. (default false)
     * @return       The possibly weak vector representing the sum of this
     *               and the input vector.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</add>
		<addMul public="1" set="method" line="1119">
			<f a="vector:scalar:?weak" v="::false">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Add a multiple of a vector to this vector.
     * <br/><br/>
     * This operation is equivalent to:
     * <pre>
     * this.add(vector.mul(scalar, true));
     * </pre>
     * <br/><br/>
     * Returns a newly allocated vector so that
     * this vector is not modified.
     * <br/><br/>
     * @param vector The vector to add to this vector. This value can not be
     *               null
     * @param scalar The scalar multiplier for the vector being added.
     * @param weak   If true then the returned vector will be automatically
     *               released to the global object pool when used as an
     *               argument to another Nape function. (default false)
     * @return       The possibly weak vector representing the sum of this
     *               and the input vector by scalar multiplier.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</addMul>
		<sub public="1" set="method" line="1165">
			<f a="vector:?weak" v=":false">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Subtract another vector from this vector.
     * <br/><br/>
     * Returns a newly allocated vector so that this vector is not mutated.
     *
     * @param vector The vector to subtract from this vector. This value can
     *               not be null
     * @param weak   If true then the returned vector will be automatically
     *               released to the global object pool when used as an
     *               argument to another Nape function. (default false)
     * @return       The possibly weak vector representing the subtraction of
     *               the input vector from this vector.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</sub>
		<mul public="1" set="method" line="1209">
			<f a="scalar:?weak" v=":false">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Multiply this vector with a number.
     * <br/><br/>
     * Returns a newly allocated vector so that this vector is not mutated.
     *
     * @param scalar The number to multiply this vector with.
     * @param weak   If true then the returned vector will be automatically
     *               released to the global object pool when used as an
     *               argument to another Nape function. (default false)
     * @return       The possibly weak vector representing the multiplication
     *               of this vector and the input number.
     * @throws # If this vector has been disposed.]]></haxe_doc>
		</mul>
		<addeq public="1" set="method" line="1237">
			<f a="vector">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Add another vector into this vector.
     * <br/><br/>
     * This vector is mutated to be the result of the operation.
     * <br/><br/>
     * Semantically equivalent to (the less optimal)
     * <code>vec1.set(vec1.add(vec2))</code>
     *
     * @param vector The vector to add into this vector.
     * @return       A reference to this vector.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If this vector is immutable.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</addeq>
		<subeq public="1" set="method" line="1283">
			<f a="vector">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Subtract another vector from this vector.
     * <br/><br/>
     * This vector is mutated to be the result of the operation.
     * <br/><br/>
     * Semantically equivalent to (the less optimal)
     * <code>vec1.set(vec1.sub(vec2))</code>
     *
     * @param vector The vector to subtract from this vector.
     * @return       A reference to this vector.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If this vector is immutable.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</subeq>
		<muleq public="1" set="method" line="1328">
			<f a="scalar">
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Multiply this vector with a number.
     * <br/><br/>
     * This vector is mutated to be the result of the operation.
     * <br/><br/>
     * Semantically equivalent to (the less optimal)
     * <code>vec.set(vec.mul(scalar))</code>
     *
     * @param scalar The number to multiply this vector with.
     * @return       A reference to this vector.
     * @throws # If this vector has been disposed.
     * @throws # If this vector is immutable.]]></haxe_doc>
		</muleq>
		<dot public="1" set="method" line="1359">
			<f a="vector">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Dot product with another vector.
     * <br/><br/>
     * The dot product is equal to the product of the length of each
     * vector, multiplied by the cosine of the smallest angle between them.
     * <br/><br/>
     * If one of the vectors is of length 1. Then the dot product is the
     * length of the projection of the other vector onto it which may be
     * computed (assuming 'this' is of length 1) like:
     * <code>vec1.mul(vec1.dot(vec2))</code>
     *
     * @param vector The vector to compute dot product with.
     * @return       The dot product of this vector and the other.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</dot>
		<cross public="1" set="method" line="1419">
			<f a="vector">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Cross product with another vector.
     * <br/><br/>
     * Also known as the perp-dot product, this operation represents
     * the determinant of the matrix formed by having the 2 columns
     * as the two vectors. This is also the z-value of a 3D cross product
     * if you extend the input vectors with a z-value of 0.
     * <br/><br/>
     * Though not technically a cross-product in the way a 3D cross product
     * is, it shares many mathematical similarities.
     * <br/><br/>
     * If one of the vectors is of length 1. Then the cross product is the
     * length of the projection of the other vector onto the
     * right-perpendicular of the unit vector.
     * <br/><br/>
     * The cross and dot product are related like:
     * <code>vec1.cross(vec2) == vec1.perp().dot(vec2)</code>
     * Hence the name 'perp-dot'
     * <br/><br/>
     * Another useful property is that if the cross-product of two vectors
     * is 0, then the vectors are collinear, if positive then the second
     * vector is 'to the right' of the first vector, and if negative then
     * the second vector is 'to the left' of the first vector.
     *
     * @param vector The vector to compute cross product with.
     * @return       The cross product of this vector and the other.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</cross>
		<perp public="1" set="method" line="1470">
			<f a="?weak" v="false">
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* The right-perpendicular to this vector.
     * <br/><br/>
     * Computes the result of rotating this vector by 90 degrees clockwise
     * returning a newly allocated vector.
     * <br/><br/>
     * This is semantically equivalent to (the less optimal)
     * <code>vec.copy().rotate(Math.PI/2)</code>
     * <br/><br/>
     * The cross and dot product are related like:
     * <code>vec1.cross(vec2) == vec1.perp().dot(vec2)</code>
     * Hence the name 'perp-dot'
     *
     * @param weak If true then the returned vector will be automatically
     *             released to the global object pool when used as an argument
     *             to another Nape function. (default false)
     * @return     The possibly weakly allocated, right-perpendicular to this
     *             vector.
     * @throws # If this vector has been disposed.]]></haxe_doc>
		</perp>
		<toString public="1" set="method" line="1481">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="400">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Vec2.
     * <br/><br/>
     * This constructor will obviously not make use of
     * the global object pool: <code>Vec2.get</code> should be used in
     * preference noting that <code>new Vec2(x, y)</code> is semantically
     * equivalent to <code>Vec2.get(x, y)</code>.
     *
     * @param x The x coordinate for the vector. (default 0)
     * @param y The y coordinate for the vector. (default 0)
     * @return  The newly constructed Vec2 object with given x/y values.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* 2 Dimensional vector.
 * <br/><br/>
 * Note that in many cases of a Vec2 object being returned by a Nape function
 * the Vec2 object will be marked internally as an 'immutable' Vec2. This will
 * always be documented and trying to mutate such a Vec2 will result in an
 * error being thrown.
 * <br/><br/>
 * Vec2 objects can make use of a global object pool, attempting to make use
 * of a disposed Vec2 will also result in an error with the object pool
 * working in a FILO order to increase the likelihood of such misuse being
 * caught.
 * <br/><br/>
 * Additionally Vec2 objects can be created as 'weak'. Passing a weak Vec2 to
 * any Nape function as an argument will result in the automatic disposal of
 * the Vec2 once the method has finished with it. There may be exceptions to
 * this rule which will also be documented; a notable case being the appending
 * of a weak Vec2 to a Nape Vec2List in which case the disposal of the weak
 * Vec2 is performed when that Vec2List is handed to a Nape function instead.
 * <br/><br/>
 * Example:
 * <pre>
 * var vertices = Polygon.box(20, 20, true);
 * var polygon = new Polygon(vertices);
 * </pre>
 * In this example, passing <code>true</code> to the Polygon.box method means
 * that we will be returned a Vec2List containing only 'weak' Vec2s. Upon
 * passing this Vec2List to the Polygon constructor, all of the Vec2s from
 * that list will be automatically disposed.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Vec2Iterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/Vec2Iterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.Vec2Iterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.geom.Vec2List"/>
				<c path="nape.geom.Vec2Iterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.geom.Vec2List"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.geom.Vec2Iterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Vec2List" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/Vec2List.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.geom.Vec2"/></c>
				<c path="nape.geom.Vec2List"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Vec2</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_Vec2List"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="263"><f a=""><x path="Int"/></f></get_length>
		<zpp_gl public="1" set="method" line="269">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* @private</haxe_doc>
		</zpp_gl>
		<zpp_vm public="1" set="method" line="291">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</zpp_vm>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" set="method" line="563">
			<f a="obj">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" set="method" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" set="method" line="647">
			<f a=""><c path="nape.geom.Vec2Iterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.geom.Vec2List"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="678">
			<f a="xs">
				<c path="nape.geom.Vec2List"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="696">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" set="method" line="726">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.Vec2"/>
					<x path="Void"/>
				</f>
				<c path="nape.geom.Vec2List"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="773">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.Vec2"/>
					<x path="Bool"/>
				</f>
				<c path="nape.geom.Vec2List"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="689">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Vec2 type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Vec2 = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Vec2 = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Vec2 = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
	</class>
	<class path="nape.geom.Vec3" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/Vec3.hx">
		<get public="1" set="method" line="322" static="1">
			<f a="?x:?y:?z" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Allocate a Vec3 from the global object pool.
     * <br/><br/>
     * Use of this method should always be preferred to the constructor.
     *
     * @param x The x component of Vec3. (default 0)
     * @param y The y component of Vec3. (default 0)
     * @param z The z component of Vec3. (default 0)
     * @return A Vec3 allocated from global object pool with given components.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Vec3"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_pool public="1">
			<c path="nape.geom.Vec3"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<zpp_disp public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_disp>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The x component of Vec3.
     * @default 0</haxe_doc>
		</x>
		<get_x get="inline" set="null" line="225"><f a=""><x path="Float"/></f></get_x>
		<set_x get="inline" set="null" line="234"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The y component of Vec3.
     * @default 0</haxe_doc>
		</y>
		<get_y get="inline" set="null" line="256"><f a=""><x path="Float"/></f></get_y>
		<set_y get="inline" set="null" line="265"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<z public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The z component of Vec3.
     * @default 0</haxe_doc>
		</z>
		<get_z get="inline" set="null" line="287"><f a=""><x path="Float"/></f></get_z>
		<set_z get="inline" set="null" line="296"><f a="z">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<dispose public="1" set="method" line="406">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Produce a copy of this Vec3.
     *
     * @return The copy of this Vec3.
     * @throws # If this Vec3 has been disposed of.
    public function copy():Vec3{
        {
            #if(!NAPE_RELEASE_BUILD)
            if(this!=null&&this.zpp_disp)throw "Error: "+"Vec3"+" has been disposed and cannot be used!";
            #end
        };
        return Vec3.get(x,y,z);
    }
    /**
     * Release Vec3 object to global object pool.
     *
     * @throws # If this Vec3 has already been disposed of.
     * @throws # If this Vec3 is immutable.]]></haxe_doc>
		</dispose>
		<length public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Length of Vec3.
     * <br/><br/>
     * This value may also be set to any value including negatives, though
     * an error will be thrown if length of the Vec3 is already 0 as such
     * a scaling would be undefined. As well as if this Vec3 has been disposed
     * of, or is immutable.
     *
     * @default 0]]></haxe_doc>
		</length>
		<get_length get="inline" set="null" line="457"><f a=""><x path="Float"/></f></get_length>
		<set_length get="inline" set="null" line="465"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<lsq public="1" set="method" line="507">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Compute squared length of Vec3.
     *
     * @return The squared length of this Vec3.
     * @throws # If the Vec3 has been disposed of.</haxe_doc>
		</lsq>
		<set public="1" set="method" line="524">
			<f a="vector">
				<c path="nape.geom.Vec3"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* Set values of this Vec3 from another.
     *
     * @param vector The vector to set values from.
     * @return A reference to this Vec3.
     * @throws # If the vector argument is null.
     * @throws # If this, or the vector argument are disposed of.
     * @throws # If this Vec3 is immutable.</haxe_doc>
		</set>
		<setxyz public="1" set="method" line="552">
			<f a="x:y:z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* Set values of this Vec3 from numbers.
     *
     * @param x The new x component value for this vector.
     * @param y The new y component value for this vector.
     * @param z The new z component value for this vector.
     * @return A reference to this Vec3.
     * @throws # If this Vec3 has been disposed of.
     * @throws # If this Vec3 is immutable.</haxe_doc>
		</setxyz>
		<xy public="1" set="method" line="597">
			<f a="?weak" v="false">
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Produce copy of the xy components of Vec3.
     * <br/><br/>
     * This function will return a new Vec2 completely seperate
     * from this Vec3 with values equal to the xy components of
     * this Vec3.
     *
     * @param weak If true, then the allocated Vec2 will be weak
     *             so that when used as an argument to a Nape
     *             function it will be automatically released back
     *             to the global object pool. (default false)
     * @return An allocated Vec2 representing the xy components of
     *         this vector.]]></haxe_doc>
		</xy>
		<toString public="1" set="method" line="608">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="360">
			<f a="?x:?y:?z" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Vec3.
     * <br/><br/>
     * This method should not generally be used with preference for the
     * static get method which will make use of the global object pool.
     *
     * @param x The x component of Vec3. (default 0)
     * @param y The y component of Vec3. (default 0)
     * @param z The z component of Vec3. (default 0)
     * @return A newly constructed Vec3 with given components.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A 3 dimensional vector object.
 * <br/><br/>
 * In many instances a Vec3 will be accessible from Nape which is marked
 * as immutable, these cases will be documented and modifying such a Vec3
 * will result in an error.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Winding" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/geom/Winding.hx">
		<UNDEFINED public="1" get="accessor" set="null" static="1">
			<c path="nape.geom.Winding"/>
			<haxe_doc><![CDATA[* Value represents that the polygon has no discernible, or ambiguous winding
     * <br/><br/>
     * This may be because the polygon is degenerate, or because it is self
     * intersecting. In either case it is not well defined to say that the winding
     * is either clockwise or anticlockwise.]]></haxe_doc>
		</UNDEFINED>
		<get_UNDEFINED get="inline" set="null" line="213" static="1"><f a=""><c path="nape.geom.Winding"/></f></get_UNDEFINED>
		<CLOCKWISE public="1" get="accessor" set="null" static="1">
			<c path="nape.geom.Winding"/>
			<haxe_doc>* Value represents that the polygon is wound clockwise.</haxe_doc>
		</CLOCKWISE>
		<get_CLOCKWISE get="inline" set="null" line="226" static="1"><f a=""><c path="nape.geom.Winding"/></f></get_CLOCKWISE>
		<ANTICLOCKWISE public="1" get="accessor" set="null" static="1">
			<c path="nape.geom.Winding"/>
			<haxe_doc>* Value represents that the polygon is wound anticlockwise.</haxe_doc>
		</ANTICLOCKWISE>
		<get_ANTICLOCKWISE get="inline" set="null" line="239" static="1"><f a=""><c path="nape.geom.Winding"/></f></get_ANTICLOCKWISE>
		<toString public="1" set="method" line="196">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="188">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Enumeration represents the winding of a Polygon.
 * <br/><br/>
 * To appreciate what the winding of a polygon means, think of a polygon who's
 * vertices are the numbers on a clock face.
 *
 * If the vertices are ordered <code>12 -&gt; 1 -&gt; 2 ... -&gt; 12</code>
 * then this polygon is clockwise wound. The reverse order would mean the
 * polygon is wound anticlockwise.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.Interactor" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/Interactor.hx">
		<zpp_inner_i public="1">
			<c path="zpp_nape.phys.ZPP_Interactor"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_i>
		<id public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Unique id of this Interactor.</haxe_doc>
		</id>
		<get_id get="inline" set="null" line="184"><f a=""><x path="Int"/></f></get_id>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<get_userData get="inline" set="null" line="200"><f a=""><d><d/></d></f></get_userData>
		<isShape public="1" get="inline" set="null" line="211">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>Std.is(interactor, Shape)</code>
     * @return true if this Interactor is a Shape.]]></haxe_doc>
		</isShape>
		<isBody public="1" get="inline" set="null" line="219">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>Std.is(interactor, Body)</code>
     * @return true if this Interactor is a Body.]]></haxe_doc>
		</isBody>
		<isCompound public="1" get="inline" set="null" line="227">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>Std.is(interactor, Compound)</code>
     * @return true if this Interactor is a Compound.]]></haxe_doc>
		</isCompound>
		<castShape public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.shape.Shape"/></t>
			<haxe_doc><![CDATA[* Fast equivalent to <code>cast(interactor, Shape)</code>]]></haxe_doc>
		</castShape>
		<get_castShape get="inline" set="null" line="235"><f a=""><t path="Null"><c path="nape.shape.Shape"/></t></f></get_castShape>
		<castBody public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Fast equivalent to <code>cast(interactor, Body)</code>]]></haxe_doc>
		</castBody>
		<get_castBody get="inline" set="null" line="243"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_castBody>
		<castCompound public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.phys.Compound"/></t>
			<haxe_doc><![CDATA[* Fast equivalent to <code>cast(interactor, Compound)</code>]]></haxe_doc>
		</castCompound>
		<get_castCompound get="inline" set="null" line="251"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_castCompound>
		<group public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
			<haxe_doc>* InteractionGroup assigned to this Interactor.
     *
     * @default null</haxe_doc>
		</group>
		<get_group get="inline" set="null" line="261"><f a=""><t path="Null"><c path="nape.dynamics.InteractionGroup"/></t></f></get_group>
		<set_group get="inline" set="null" line="264"><f a="group">
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
</f></set_group>
		<cbTypes public="1" get="accessor" set="null">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc>* Set of CbType's assigned to this Interactor.
     *
     * @default []</haxe_doc>
		</cbTypes>
		<get_cbTypes get="inline" set="null" line="278"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_cbTypes>
		<toString public="1" set="method" line="293">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="285">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
	</class>
	<class path="nape.phys.Body" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/Body.hx">
		<extends path="nape.phys.Interactor"/>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_Body"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<debugDraw public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Set to disable debug drawing/
     * <br/><br/>
     * When true, this Body will not be drawn during debug draw operations
     * unless specifically given as argument to Debug draw() method.
     * @default true]]></haxe_doc>
		</debugDraw>
		<type public="1" get="accessor" set="accessor">
			<c path="nape.phys.BodyType"/>
			<haxe_doc><![CDATA[* Type of body.
     * <br/><br/>
     * This value can be changed even if Body is inside of a Space.]]></haxe_doc>
		</type>
		<get_type get="inline" set="null" line="197"><f a=""><c path="nape.phys.BodyType"/></f></get_type>
		<set_type get="inline" set="null" line="200"><f a="type">
	<c path="nape.phys.BodyType"/>
	<c path="nape.phys.BodyType"/>
</f></set_type>
		<isBullet public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Mark object for continuous collisions against other dynamic Bodies
     * <br/><br/>
     * If true, then this Body will undergo continuous collisions with other
     * dynamic Bodies. This flag has no effect for non-dynamic Bodies.
     * <br/><br/>
     * This flag should only be set for very fast, small moving dynamic bodies,
     * and due to the way continuous collisions are resolved it is not wise to
     * enable this for a large group of bodies that interact together as it
     * will lead to visual stalling.
     * <br/>
     * Bullets also do not play well when existing in a group with respect to
     * continuous collisions against kinematic objects and may cause
     * tunnelling against the kinematic.
     * @default false]]></haxe_doc>
		</isBullet>
		<get_isBullet get="inline" set="null" line="259"><f a=""><x path="Bool"/></f></get_isBullet>
		<set_isBullet get="inline" set="null" line="262"><f a="isBullet">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isBullet>
		<disableCCD public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Declare object should never be collided continuously
     * <br/><br/>
     * When performing continuous collisions, Nape will check both Bodies to see
     * if either has opted-out of CCD. If either Body has this flag true, then
     * no CCD will be performed for that pair.
     * @default false]]></haxe_doc>
		</disableCCD>
		<get_disableCCD get="inline" set="null" line="278"><f a=""><x path="Bool"/></f></get_disableCCD>
		<set_disableCCD get="inline" set="null" line="281"><f a="disableCCD">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_disableCCD>
		<integrate public="1" set="method" line="295">
			<f a="deltaTime">
				<x path="Float"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc>* Integrate body forward in time, taking only velocities into account.
     *
     * @param deltaTime The time to integrate body by. This value may be negative to
     *                  integrate back in time.
     * @return A refernce to 'this' Body</haxe_doc>
		</integrate>
		<isStatic public="1" get="inline" set="null" line="319">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>body.type == BodyType.STATIC</code>
     * @return True if body is Static.]]></haxe_doc>
		</isStatic>
		<isDynamic public="1" get="inline" set="null" line="328">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>body.type == BodyType.DYNAMIC</code>
     * @return True if body is Dynamic.]]></haxe_doc>
		</isDynamic>
		<isKinematic public="1" get="inline" set="null" line="337">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>body.type == BodyType.KINEMATIC</code>
     * @return True if body is Kinematic.]]></haxe_doc>
		</isKinematic>
		<shapes public="1" get="accessor" set="null">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc><![CDATA[* List of shapes owned by Body.
     * <br/><br/>
     * Appending a Shape to this list is equivalent to <code>shape.body = this</code>
     *
     * @default []]]></haxe_doc>
		</shapes>
		<get_shapes get="inline" set="null" line="349"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<compound public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Compound"/></t>
			<haxe_doc><![CDATA[* Compound this Body belongs to.
     * <br/><br/>
     * If this Body belongs to a Compound, then the Compound 'owns' this Body and
     * it is the Compound which would be added/removed from a Space rather than
     * this Body.
     *
     * @default null]]></haxe_doc>
		</compound>
		<get_compound get="inline" set="null" line="363"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_compound>
		<set_compound get="inline" set="null" line="366"><f a="compound">
	<t path="Null"><c path="nape.phys.Compound"/></t>
	<t path="Null"><c path="nape.phys.Compound"/></t>
</f></set_compound>
		<space public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.space.Space"/></t>
			<haxe_doc><![CDATA[* Space this Body is assigned to.
     * <br/><br/>
     * When this Body is part of a Compound, this value is immutable.
     * <br/>
     * When a Body is part of a Compound it is owned by that Compound and it
     * is the Compound that is added/removed from a Space.]]></haxe_doc>
		</space>
		<get_space get="inline" set="null" line="385"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<set_space get="inline" set="null" line="388"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<arbiters public="1" get="accessor" set="null">
			<c path="nape.dynamics.ArbiterList"/>
			<haxe_doc><![CDATA[* Set of active arbiters related to this Body.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</arbiters>
		<get_arbiters get="inline" set="null" line="412"><f a=""><c path="nape.dynamics.ArbiterList"/></f></get_arbiters>
		<isSleeping public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether this body is sleeping.
     * <br/><br/>
     * This value is immutable, In Nape you do not ever need to manually wake up a Body.
     * It will always be done automatically without error.
     * <br/><br/>
     * To manually put a Body to sleep is against the very nature of Nape API
     * and so is excluded from the core of Nape. If you really want to do this
     * then you should make use of the nape-hacks module.]]></haxe_doc>
		</isSleeping>
		<get_isSleeping get="inline" set="null" line="428"><f a=""><x path="Bool"/></f></get_isSleeping>
		<constraints public="1" get="accessor" set="null">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc><![CDATA[* Set of constraints using this Body.
     * <br/><br/>
     * This list contains those constraints that are inside of a Space only.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</constraints>
		<get_constraints get="inline" set="null" line="443"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<copy public="1" set="method" line="543">
			<f a=""><c path="nape.phys.Body"/></f>
			<haxe_doc><![CDATA[* Construct an exact copy of this Body.
     * <br/><br/>
     * All properties will be exactly copied, with Shapes also
     * being copied with the copied Body's and Shape's userData
     * objects being assigned the same fields as the existing ones with
     * values copied over by reference for object types.
     *
     * @return A copy of this Body.]]></haxe_doc>
		</copy>
		<position public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Position of Body's origin in px.
     * <br/><br/>
     * This value can be set and is equivalent to: <code>this.position.set(value)</code>
     * <br/><br/>
     * Attempting to set this value on a static Body that is in a Space will result
     * in a debug build error.
     * <br/><br/>
     * Please note that for kinematic objects, setting this value is equiavalent
     * to 'teleporting' the object, and for normal movement you should be using
     * the kinematic body's velocity.
     *
     * @default (0,0)]]></haxe_doc>
		</position>
		<get_position get="inline" set="null" line="565"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<set_position get="inline" set="null" line="569"><f a="position">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_position>
		<velocity public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Linear velocity of Body's origin in px/s.
     * <br/><br/>
     * This value can be set and is equivalent to: <code>this.velocity.set(value)</code>
     * <br/><br/>
     * A static body cannot have its velocity set.
     *
     * @default (0,0)]]></haxe_doc>
		</velocity>
		<get_velocity get="inline" set="null" line="594"><f a=""><c path="nape.geom.Vec2"/></f></get_velocity>
		<set_velocity get="inline" set="null" line="598"><f a="velocity">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_velocity>
		<setVelocityFromTarget public="1" set="method" line="629">
			<f a="targetPosition:targetRotation:deltaTime">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Set velocities to achieve desired position at end of time step.
     * <br/><br/>
     * This function is a utility to help with animating kinematic bodies.
     * Kinematic bodies should be moved through velocity, but it is often
     * easier to think in terms of position.
     * <br/><br/>
     * This method will set linear and angular velocities so that the target
     * position/rotation is achieved at end of time step.
     *
     * @param targetPosition The target position for Body.
     * @param targetRotation The target rotation for Body.
     * @param deltaTime The time step for next call to space.step().
     * @throws # If targetPosition is null or disposed of.
     * @returns A reference to 'this' Body.]]></haxe_doc>
		</setVelocityFromTarget>
		<kinematicVel public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Additional kinematic velocity of Body in px/s.
     * <br/><br/>
     * A bodies 'kinematic' velocity is an added velocity bias used in all physics
     * computations but that will not effect how the Body moves directly.
     * <br/><br/>
     * Even a static body can be given a kinematic velocity, and can be used for
     * such things as giving a body of water a fluid-velocity for fluid drag
     * computations.
     *
     * @default (0,0)]]></haxe_doc>
		</kinematicVel>
		<get_kinematicVel get="inline" set="null" line="669"><f a=""><c path="nape.geom.Vec2"/></f></get_kinematicVel>
		<set_kinematicVel get="inline" set="null" line="673"><f a="kinematicVel">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_kinematicVel>
		<surfaceVel public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Additional surface velocity for Body in px/s.
     * <br/><br/>
     * A bodies 'surface' velocity is an added velocity bias that is rotated to match
     * the angle of the contact surface used in contact physics and will not
     * effect how the Body moves directly.
     * <br/><br/>
     * Even a static body can be given a surface velocity, and can be used for
     * such things as conveyor belts (By setting the x-component of surfaceVel).
     *
     * @default (0,0)]]></haxe_doc>
		</surfaceVel>
		<get_surfaceVel get="inline" set="null" line="701"><f a=""><c path="nape.geom.Vec2"/></f></get_surfaceVel>
		<set_surfaceVel get="inline" set="null" line="705"><f a="surfaceVel">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_surfaceVel>
		<force public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Accumulated force acting on body in px.kg/s/s
     * <br/><br/>
     * This value is not used internally for any physics computations.
     * <br/><br/>
     * You may set this property only on dynamic bodies.
     *
     * @default (0,0)]]></haxe_doc>
		</force>
		<get_force get="inline" set="null" line="730"><f a=""><c path="nape.geom.Vec2"/></f></get_force>
		<set_force get="inline" set="null" line="734"><f a="force">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_force>
		<constraintVelocity public="1" get="accessor" set="null">
			<c path="nape.geom.Vec3"/>
			<haxe_doc><![CDATA[* This property represents the velocity seen by constraint physics.
     * <br/><br/>
     * You should not need to use this property unless writing your own
     * constraints using the UserConstraint API.]]></haxe_doc>
		</constraintVelocity>
		<get_constraintVelocity get="inline" set="null" line="756"><f a=""><c path="nape.geom.Vec3"/></f></get_constraintVelocity>
		<rotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Rotation of Body in clockwise rad.
     * <br/><br/>
     * Attempting to set this value on a static Body that is in a Space will result
     * in a debug build error.
     * <br/><br/>
     * Please note that for kinematic objects, setting this value is equiavalent
     * to 'teleporting' the object, and for normal movement you should be using
     * the kinematic body's angularVel.
     *
     * @default 0]]></haxe_doc>
		</rotation>
		<get_rotation get="inline" set="null" line="774"><f a=""><x path="Float"/></f></get_rotation>
		<set_rotation get="inline" set="null" line="777"><f a="rotation">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<angularVel public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular velocity of Body in clockwise rad/s
     * <br/><br/>
     * A static body cannot have its angular velocity set.
     *
     * @default 0]]></haxe_doc>
		</angularVel>
		<get_angularVel get="inline" set="null" line="806"><f a=""><x path="Float"/></f></get_angularVel>
		<set_angularVel get="inline" set="null" line="809"><f a="angularVel">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angularVel>
		<kinAngVel public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Additional kinematic angular velocity of Body in rad/s.
     * <br/><br/>
     * A bodies 'kinematic' velocity is an added velocity bias used in all physics
     * computations but that will not effect how the Body moves directly.
     * <br/><br/>
     * Even a static body can be given a kinematic velocity, and can be used for
     * such things as giving a body of water a fluid-velocity for fluid drag
     * computations.
     *
     * @default 0]]></haxe_doc>
		</kinAngVel>
		<get_kinAngVel get="inline" set="null" line="841"><f a=""><x path="Float"/></f></get_kinAngVel>
		<set_kinAngVel get="inline" set="null" line="844"><f a="kinAngVel">
	<x path="Float"/>
	<x path="Float"/>
</f></set_kinAngVel>
		<torque public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Accumulated torque acting on body in px.px.kg/s/s
     * <br/><br/>
     * This value is not used internally for any physics computations.
     * <br/><br/>
     * You may set this property only on dynamic bodies.
     *
     * @default 0]]></haxe_doc>
		</torque>
		<get_torque get="inline" set="null" line="870"><f a=""><x path="Float"/></f></get_torque>
		<set_torque get="inline" set="null" line="873"><f a="torque">
	<x path="Float"/>
	<x path="Float"/>
</f></set_torque>
		<bounds public="1" get="accessor" set="null">
			<c path="nape.geom.AABB"/>
			<haxe_doc><![CDATA[* Bounding box of Body in world space.
     * <br/><br/>
     * This value can be accessed even if there are no Shapes in the Body, but
     * attempting to query its values whilst there are no Shapes will result
     * in a debug build error.
     * <br/><br/>
     * This AABB is immutable.]]></haxe_doc>
		</bounds>
		<get_bounds get="inline" set="null" line="902"><f a=""><c path="nape.geom.AABB"/></f></get_bounds>
		<allowMovement public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether dynamic Body is permitted to be moved by physics linearly.
     * <br/><br/>
     * When this field is false, no physics will be able to cause a change in the
     * bodies linear velocity (It can still move, but only if you tell it to like
     * a kinematic body).
     *
     * @default true]]></haxe_doc>
		</allowMovement>
		<get_allowMovement get="inline" set="null" line="919"><f a=""><x path="Bool"/></f></get_allowMovement>
		<set_allowMovement get="inline" set="null" line="922"><f a="allowMovement">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowMovement>
		<allowRotation public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether dynamic Body is permitted to be rotated by physics.
     * <br/><br/>
     * When this field is false, no physics will be able to cause a change in the
     * bodies angular velocity (It can still rotate, but only if you tell it to like
     * a kinematic body).
     *
     * @default true]]></haxe_doc>
		</allowRotation>
		<get_allowRotation get="inline" set="null" line="943"><f a=""><x path="Bool"/></f></get_allowRotation>
		<set_allowRotation get="inline" set="null" line="946"><f a="allowRotation">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowRotation>
		<massMode public="1" get="accessor" set="accessor">
			<c path="nape.phys.MassMode"/>
			<haxe_doc><![CDATA[* Method of mass computation for Body.
     * <br/><br/>
     * This value will be set implicitly to FIXED when mass property is set.
     * <br/>Setting back to DEFAULT will then set mass implicitly back to the default
     * computed mass.
     *
     * @default MassMode.DEFAULT]]></haxe_doc>
		</massMode>
		<get_massMode get="inline" set="null" line="967"><f a=""><c path="nape.phys.MassMode"/></f></get_massMode>
		<set_massMode get="inline" set="null" line="970"><f a="massMode">
	<c path="nape.phys.MassMode"/>
	<c path="nape.phys.MassMode"/>
</f></set_massMode>
		<constraintMass public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Mass to be used for a Body in User built constraints.
     * <br/><br/>
     * This value is given as the inverse mass of the Body taking into account
     * Body type (Static and Kinematic Bodies will have constraintMass of 0)
     * as well as properties like allowMovement.]]></haxe_doc>
		</constraintMass>
		<get_constraintMass get="inline" set="null" line="993"><f a=""><x path="Float"/></f></get_constraintMass>
		<mass public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Mass of the Body.
     * <br/><br/>
     * This value is computed by default based on the Body's Shape's areas and
     * Material densities.
     * <br/>
     * When massMode is DEFAULT, accessing this value for an empty Body will thus
     * give an error as the value is undefined.
     * <br/><br/>
     * Setting this value will permit you to give a fixed mass to the Body
     * implicitly changing the massMode to MassMode.FIXED]]></haxe_doc>
		</mass>
		<get_mass get="inline" set="null" line="1011"><f a=""><x path="Float"/></f></get_mass>
		<set_mass get="inline" set="null" line="1021"><f a="mass">
	<x path="Float"/>
	<x path="Float"/>
</f></set_mass>
		<gravMassMode public="1" get="accessor" set="accessor">
			<c path="nape.phys.GravMassMode"/>
			<haxe_doc><![CDATA[* Method of computing mass as seen by gravity.
     * <br/><br/>
     * This value will be implicitly set by modifying gravMass or gravMassScale properties.
     *
     * @default GravMassMode.DEFAULT]]></haxe_doc>
		</gravMassMode>
		<get_gravMassMode get="inline" set="null" line="1047"><f a=""><c path="nape.phys.GravMassMode"/></f></get_gravMassMode>
		<set_gravMassMode get="inline" set="null" line="1050"><f a="gravMassMode">
	<c path="nape.phys.GravMassMode"/>
	<c path="nape.phys.GravMassMode"/>
</f></set_gravMassMode>
		<gravMass public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Mass used in gravity computations in a Space.
     * <br/><br/>
     * Setting this value will implicitly change the gravMassMode to FIXED.
     * <br/>
     * Set to 0 to disable gravity for this Body.]]></haxe_doc>
		</gravMass>
		<get_gravMass get="inline" set="null" line="1073"><f a=""><x path="Float"/></f></get_gravMass>
		<set_gravMass get="inline" set="null" line="1085"><f a="gravMass">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gravMass>
		<gravMassScale public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Mass scale used in computation of gravity for Body in Space.
     * <br/><br/>
     * Setting this value will implicitly change the gravMassMode to SCALED.
     * <br/>
     * When set, the gravMass of Body will be computed as this scaling factor
     * multiplied with the Body's mass.]]></haxe_doc>
		</gravMassScale>
		<get_gravMassScale get="inline" set="null" line="1110"><f a=""><x path="Float"/></f></get_gravMassScale>
		<set_gravMassScale get="inline" set="null" line="1119"><f a="gravMassScale">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gravMassScale>
		<inertiaMode public="1" get="accessor" set="accessor">
			<c path="nape.phys.InertiaMode"/>
			<haxe_doc><![CDATA[* Method of computing Body moment of inertia.
     * <br/><br/>
     * This value will be set implicitly by modifying Body inertia property.
     *
     * @default InertiaMode.DEFAULT]]></haxe_doc>
		</inertiaMode>
		<get_inertiaMode get="inline" set="null" line="1143"><f a=""><c path="nape.phys.InertiaMode"/></f></get_inertiaMode>
		<set_inertiaMode get="inline" set="null" line="1146"><f a="inertiaMode">
	<c path="nape.phys.InertiaMode"/>
	<c path="nape.phys.InertiaMode"/>
</f></set_inertiaMode>
		<constraintInertia public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Moment of inertia to be used in user defined Constraints.
     * <br/><br/>
     * This value is equal to the inverse inertia of the Body taking into account
     * Body type (Static and Kinematic bodies will have constraintInertia of 0).
     * As well as properties like allowRotation.]]></haxe_doc>
		</constraintInertia>
		<get_constraintInertia get="inline" set="null" line="1169"><f a=""><x path="Float"/></f></get_constraintInertia>
		<inertia public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Moment of inertia of this Body.
     * <br/><br/>
     * Setting this value will implicitly change the inertiaMode to FIXED.]]></haxe_doc>
		</inertia>
		<get_inertia get="inline" set="null" line="1180"><f a=""><x path="Float"/></f></get_inertia>
		<set_inertia get="inline" set="null" line="1190"><f a="inertia">
	<x path="Float"/>
	<x path="Float"/>
</f></set_inertia>
		<connectedBodies public="1" set="method" line="1224">
			<f a="?depth:?output" v="-1:null">
				<x path="Int"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Compute set of bodies connected via constraints.
     * <br/><br/>
     * Only constraints that are inside of a Space will be considered the
     * same way that the body's constraints list only tracks constraints
     * that are part of a simulation.
     *
     * @param depth Control the depth limit of the graph search. Negative
     *              values indicate an unlimited search. A depth value of
     *              0 would cause only the current Body to be returned.
     *              (default -1)
     * @param output An optional list to append results to, if left as null
     *               then a new list is created.
     * @return A list of the connected bodies up to
     *         the given graph depth.]]></haxe_doc>
		</connectedBodies>
		<interactingBodies public="1" set="method" line="1242">
			<f a="?type:?depth:?output" v="null:-1:null">
				<c path="nape.callbacks.InteractionType"/>
				<x path="Int"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc>* Compute set of bodies interacting with this body.
     *
     * @param type When not equal to null, this parameter controls what sort
     *             of interaction we permit in the search.
     * @param depth Control the depth limit of the graph search. Negative
     *              values indicate an unlimited search. A depth value of
     *              0 would cause only the current Body to be returned.
     *              (default -1)
     * @param output An optional list to append results to, if left as null
     *               then a new list is created.
     * @return A list of the interacting bodies up to
     *         the given graph depth.</haxe_doc>
		</interactingBodies>
		<crushFactor public="1" set="method" line="1264">
			<f a=""><x path="Float"/></f>
			<haxe_doc><![CDATA[* Determine how much this body is being crushed.
     * <br/><br/>
     * This is an approximate value, computed as:
     * <code>crushFactor = (sum(magnitude(impulse)) - magnitude(sum(impulse))) / mass</code>
     * <br/><br/>
     * In this way, it is a mass and time step invariant value which is 0 when all impulses
     * are acting on body in the same direction, and has maximum value when impulses
     * act in opposing directions 'crushing' the Body.
     *
     * @return A positive value representing an approximation to how much the
     *         body is being crushed.
     * @throws # If body is not in a Space.]]></haxe_doc>
		</crushFactor>
		<localPointToWorld public="1" set="method" line="1301">
			<f a="point:?weak" v=":false">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc>* Transform a point from Body's local coordinates to world coordinates.
     *
     * @param point The point to transform.
     * @param weak If true the returned Vec2 will be automatically released
     *             back to object pool when used as an argument to a Nape function.
     *             (default false)
     * @return The result of the transformation.
     * @throws # If point is null or disposed of.</haxe_doc>
		</localPointToWorld>
		<worldPointToLocal public="1" set="method" line="1341">
			<f a="point:?weak" v=":false">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc>* Transform a point from world coordinates to Body's local coordinates.
     *
     * @param point The point to transform.
     * @param weak If true the returned Vec2 will be automatically released
     *             back to object pool when used as an argument to a Nape function.
     *             (default false)
     * @return The result of the transformation.
     * @throws # If point is null or disposed of.</haxe_doc>
		</worldPointToLocal>
		<localVectorToWorld public="1" set="method" line="1388">
			<f a="vector:?weak" v=":false">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Transform vector from Body's local coordinates into world coordinates.
     * <br/><br/>
     *
     * @param vector The vector to transform.
     * @param weak If true the returned Vec2 will be automatically released
     *             back to object pool when used as an argument to a Nape function.
     *             (default false)
     * @return The result of the transformation.
     * @throws # If vector is null or disposed of.]]></haxe_doc>
		</localVectorToWorld>
		<worldVectorToLocal public="1" set="method" line="1429">
			<f a="vector:?weak" v=":false">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Transform vector from world coordinates to Body's local coordinates
     * <br/><br/>
     *
     * @param vector The vector to transform.
     * @param weak If true the returned Vec2 will be automatically released
     *             back to object pool when used as an argument to a Nape function.
     *             (default false)
     * @return The result of the transformation.
     * @throws # If vector is null or disposed of.]]></haxe_doc>
		</worldVectorToLocal>
		<applyImpulse public="1" set="method" line="1479">
			<f a="impulse:?pos:?sleepable" v=":null:false">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Apply impulse to a point on Body.
     * <br/><br/>
     * If position argument is not given, then body.position is assumed so that impulse
     * is applied at centre of Body.
     *
     * @param impulse The impulse to apply given in world coordinates.
     * @param pos The position to apply impulse given in world coordinates.
     *            (default body.position)
     * @param sleepable This parameter can be set to true, in the case that you
     *                  are constantly applying an impulse which is dependent only
     *                  on the position/velocity of the body meaning that application
     *                  of this impulse does not need to prevent the object from sleeping.
     *                  When true, and the body is sleeping, this method call will not
     *                  apply any impulse.
     *                  (default false).
     * @throws # If impulse is null or disposed of.
     * @throws # If pos is non-null and disposed of.
     * @returns A reference to 'this' Body.]]></haxe_doc>
		</applyImpulse>
		<applyAngularImpulse public="1" set="method" line="1588">
			<f a="impulse:?sleepable" v=":false">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc>* Apply a pure angular impulse to Body.
     *
     * @param impulse The angular impulse to apply.
     * @param sleepable This parameter can be set to true, in the case that you
     *                  are constantly applying an impulse which is dependent only
     *                  on the position/velocity of the body meaning that application
     *                  of this impulse does not need to prevent the object from sleeping.
     *                  When true, and the body is sleeping, this method call will not
     *                  apply any impulse.
     *                  (default false).
     * @returns A reference to 'this' Body.</haxe_doc>
		</applyAngularImpulse>
		<translateShapes public="1" set="method" line="1614">
			<f a="translation">
				<c path="nape.geom.Vec2"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Translate each shape in local coordinates.
     * <br/><br/>
     * This operation does not effect the Body's position, but the position
     * of the shapes 'inside' of the Body.
     *
     * @param translation The local translation to apply to Shapes.
     * @return A reference to this Body.
     * @throws # If translation is null or has been disposed of.
     * @throws # If this Body is static, and inside of a Space.]]></haxe_doc>
		</translateShapes>
		<rotateShapes public="1" set="method" line="1662">
			<f a="angle">
				<x path="Float"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Rotate each shape in local coordinates.
     * <br/><br/>
     * This operation does not effect the Body's rotation, but rotates
     * each of the shapes 'inside' of the Body.
     *
     * @param angle The angle to rotate shapes by in clockwise radians.
     * @return A reference to this Body.
     * @throws # If this Body is static, and inside of a Space.]]></haxe_doc>
		</rotateShapes>
		<scaleShapes public="1" set="method" line="1690">
			<f a="scaleX:scaleY">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Scale each shape in local coordinates.
     * <br/><br/>
     * This operation does not affect the Body itself, but affects each
     * Shape 'inside' of the Body instead.
     *
     * @param scaleX The x-coordinate factor of scaling.
     * @param scaleY The y-coordinate factor of scaling.
     * @return A reference to this Body.
     * @throws # If this Body is static, and inside of a Space.
     * @throws # If Body contains Circle shapes, and scaleX != scaleY]]></haxe_doc>
		</scaleShapes>
		<transformShapes public="1" set="method" line="1719">
			<f a="matrix">
				<c path="nape.geom.Mat23"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Transform each shape in local coordiantes.
     * <br/><br/>
     * This operation does not affect the Body itself, but affects each
     * Shape 'inside' of the Body instead.
     *
     * @param matrix The transformation matrix to apply to each Shape.
     * @return A reference to this Body.
     * @throws # If this Body is static, and inside of a Space.
     * @throws # If matrix is null or singular.
     * @throws # If Body contains Circle shapes, and input matrix is
     *           not equiorthogonal.]]></haxe_doc>
		</transformShapes>
		<align public="1" set="method" line="1750">
			<f a=""><c path="nape.phys.Body"/></f>
			<haxe_doc><![CDATA[* Align rigid body so that its origin is also its centre of mass.
     * <br/><br/>
     * This operation will both translate the Shapes inside of the Body,
     * as well as translating the Body itself so that its 'apparent' position
     * has not been modified.
     * <br/><br/>
     * Alignment of Rigid bodies is necessary for dynamic bodies so that
     * they will interact and rotate as expected.
     * <br/><br/>
     * Simple Body's created with a single Polygon.box() or basic Circle
     * will already be aligned.
     *
     * @return A reference to this Body.]]></haxe_doc>
		</align>
		<rotate public="1" set="method" line="1793">
			<f a="centre:angle">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Rotate body about about given point.
     * <br/><br/>
     * Please note that this method is equivalent to teleporting the body,
     * the same way direct manipulation of position and rotation is.
     *
     * @param centre The centre of rotation in world coordinates.
     * @param angle The angle to rotate body by in clockwise radians.
     * @return A reference to this Body.
     * @throws # If this Body is static, and inside of a Space.
     * @throws # If centre is null or disposed of.]]></haxe_doc>
		</rotate>
		<setShapeMaterials public="1" set="method" line="1835">
			<f a="material">
				<c path="nape.phys.Material"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Set material of all shapes.
     * <br/><br/>
     * Equivalent to: <code>body.shapes.foreach(function (shape) shape.material = material)</code>
     *
     * @param material The material to set Shape's material to.
     * @return A reference to this Body.]]></haxe_doc>
		</setShapeMaterials>
		<setShapeFilters public="1" set="method" line="1859">
			<f a="filter">
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Set interaction filter of all shapes.
     * <br/><br/>
     * Equivalent to: <code>body.shapes.foreach(function (shape) shape.filter = filter)</code>
     *
     * @param filter The filter to set Shape's filter to.
     * @return A reference to this Body.]]></haxe_doc>
		</setShapeFilters>
		<setShapeFluidProperties public="1" set="method" line="1883">
			<f a="fluidProperties">
				<c path="nape.phys.FluidProperties"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Set fluidProperties of all shapes.
     * <br/><br/>
     * Equivalent to: <code>body.shapes.foreach(function (shape) shape.fluidProperties = fluidProperties)</code>
     *
     * @param fluidProperties The fluidProperties to set Shape's fluidProperties to.
     * @return A reference to this Body.]]></haxe_doc>
		</setShapeFluidProperties>
		<localCOM public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Local centre of mass of Body.
     * <br/><br/>
     * This value can be accessed even if Body has no shapes, but attempting
     * to query its values will result in a debug build error.
     * <br/><br/>
     * This Vec2 is immutable.]]></haxe_doc>
		</localCOM>
		<get_localCOM get="inline" set="null" line="1908"><f a=""><c path="nape.geom.Vec2"/></f></get_localCOM>
		<worldCOM public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* World centre of mass of Body.
     * <br/><br/>
     * This value can be accessed even if Body has no shapes, but attempting
     * to query its values will result in a debug build error.
     * <br/><br/>
     * This Vec2 is immutable.]]></haxe_doc>
		</worldCOM>
		<get_worldCOM get="inline" set="null" line="1930"><f a=""><c path="nape.geom.Vec2"/></f></get_worldCOM>
		<normalImpulse public="1" set="method" line="1955">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all normal contact impulses on Body.
     * <br/><br/>
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered.
     *             (default false)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</normalImpulse>
		<tangentImpulse public="1" set="method" line="2019">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all tangent contact impulses on Body.
     * <br/><br/>
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered.
     *             (default false)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</tangentImpulse>
		<totalContactsImpulse public="1" set="method" line="2083">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all contact impulses on Body.
     * <br/><br/>
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered.
     *             (default false)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</totalContactsImpulse>
		<rollingImpulse public="1" set="method" line="2147">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all rolling friction contact impulses on Body.
     * <br/><br/
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered.
     *             (default false)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</rollingImpulse>
		<buoyancyImpulse public="1" set="method" line="2173">
			<f a="?body" v="null">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all buoyancy impulses acting on Body.
     * <br/><br/
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</buoyancyImpulse>
		<dragImpulse public="1" set="method" line="2235">
			<f a="?body" v="null">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all fluid drag impulses acting on Body.
     * <br/><br/
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</dragImpulse>
		<totalFluidImpulse public="1" set="method" line="2297">
			<f a="?body" v="null">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all fluid impulses acting on Body.
     * <br/><br/
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</totalFluidImpulse>
		<constraintsImpulse public="1" set="method" line="2354">
			<f a=""><c path="nape.geom.Vec3"/></f>
			<haxe_doc>* Evaluate sum effect of all constraint impulses on this Body.
     *
     * @return The summed effect of constraint impulses acting on Body.</haxe_doc>
		</constraintsImpulse>
		<totalImpulse public="1" set="method" line="2420">
			<f a="?body:?freshOnly" v="null:false">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all impulses on Body.
     * <br/><br/
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered when evaluating interaction impulses.
     * <br/>
     * Constraint impulses are not effected by the body argument.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered
     *             when evaluating contact impulses.
     *             (default false)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</totalImpulse>
		<contains public="1" set="method" line="2505">
			<f a="point">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determine if point is contained in Body.
     *
     * @param point The point to test containment for in world coordinates.
     * @return True if point is contained.
     * @throws # If point is null or has been disposed.</haxe_doc>
		</contains>
		<toString public="1" set="method" line="2550" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="457">
			<f a="?type:?position" v="null:null">
				<c path="nape.phys.BodyType"/>
				<c path="nape.geom.Vec2"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Body.
     * <br/><br/>
     * @param type The type of Body to create. (default DYNAMIC)
     * @param position The initial position for object. (default &#40;0,0&#41;)
     * @return The newly constructed Body.
     * @throws # If position is non-null, and has been disposed of.]]></haxe_doc>
		</new>
		<haxe_doc>* Class representing a physics Rigid Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.BodyIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/BodyIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.phys.BodyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.phys.BodyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.phys.BodyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.phys.Body"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.BodyList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/BodyList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.phys.Body"/></c>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Body</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_BodyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.phys.Body"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.phys.Body"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.phys.BodyIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.phys.BodyList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Bool"/>
				</f>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Body type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Body = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Body = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Body = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.BodyType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/BodyType.hx">
		<STATIC public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.BodyType"/>
			<haxe_doc>* Static objects are not permitted to move, and due to this several
     * optimisatinos can be made for them.</haxe_doc>
		</STATIC>
		<get_STATIC get="inline" set="null" line="203" static="1"><f a=""><c path="nape.phys.BodyType"/></f></get_STATIC>
		<DYNAMIC public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.BodyType"/>
			<haxe_doc>* Standard dynamic object, this object will be effected by the physics
     * as usual.</haxe_doc>
		</DYNAMIC>
		<get_DYNAMIC get="inline" set="null" line="217" static="1"><f a=""><c path="nape.phys.BodyType"/></f></get_DYNAMIC>
		<KINEMATIC public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.BodyType"/>
			<haxe_doc>* Kinematic objects are static objects which 'are' permitted to move,
     * you have complete control over their velocity to make them move how
     * you wish and are not effected by any physics.</haxe_doc>
		</KINEMATIC>
		<get_KINEMATIC get="inline" set="null" line="232" static="1"><f a=""><c path="nape.phys.BodyType"/></f></get_KINEMATIC>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of rigid body types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.Compound" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/Compound.hx">
		<extends path="nape.phys.Interactor"/>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_Compound"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<bodies public="1" get="accessor" set="null">
			<c path="nape.phys.BodyList"/>
			<haxe_doc><![CDATA[* List of bodies directly owned by this Compound.
     * <br/><br/>
     * This list does not include those bodies belonging to sub-compounds.
     *
     * @default []]]></haxe_doc>
		</bodies>
		<get_bodies get="inline" set="null" line="210"><f a=""><c path="nape.phys.BodyList"/></f></get_bodies>
		<constraints public="1" get="accessor" set="null">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc><![CDATA[* List of constraints directly owned by this Compound.
     * <br/><br/>
     * This list does not include those constraints belonging to sub-compounds.
     *
     * @default []]]></haxe_doc>
		</constraints>
		<get_constraints get="inline" set="null" line="222"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<compounds public="1" get="accessor" set="null">
			<c path="nape.phys.CompoundList"/>
			<haxe_doc><![CDATA[* List of compounds directly owned by this Compound.
     * <br/><br/>
     * This list does not include those compounds belonging to sub-compounds.
     *
     * @default []]]></haxe_doc>
		</compounds>
		<get_compounds get="inline" set="null" line="234"><f a=""><c path="nape.phys.CompoundList"/></f></get_compounds>
		<compound public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Compound"/></t>
			<haxe_doc>* Compound that this compound belongs to.
     *
     * @default null</haxe_doc>
		</compound>
		<get_compound get="inline" set="null" line="244"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_compound>
		<set_compound get="inline" set="null" line="247"><f a="compound">
	<t path="Null"><c path="nape.phys.Compound"/></t>
	<t path="Null"><c path="nape.phys.Compound"/></t>
</f></set_compound>
		<space public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.space.Space"/></t>
			<haxe_doc><![CDATA[* Space this compound belongs to.
     * <br/><br/>
     * This value is immutable when this compound belongs to another parent Compound.
     *
     * @default null]]></haxe_doc>
		</space>
		<get_space get="inline" set="null" line="266"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<set_space get="inline" set="null" line="269"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<toString public="1" set="method" line="306" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<copy public="1" set="method" line="330">
			<f a=""><c path="nape.phys.Compound"/></f>
			<haxe_doc><![CDATA[* Produce an exact copy of this Compound.
     * <br/><br/>
     * This copy will remap owned constraints so that their body properties
     * refer to the newly copied bodies also owned by this compound.
     * <br/><br/>
     * If this compound tree contains any constraints that make references
     * to outside of this compound; then these properties will be made null.
     * <pre>
     *       ____Cmp1____               [Cmp2.copy()]
     *      /    /        &#92;
     * Body1 Body2___     Cmp2        null    Cmp2'
     *   |     |     &#92;     /  &#92;         &#92;    /    &#92;
     * Shp1  Shp2     Joint--Body3       Joint'--Body3'
     *                         |                   |
     *                        Shp3               Shp3'
     * </pre>
     * For instance if copying Cmp1 then all is well, but if we copy Cmp2 the
     * copied Joint will have one of it's body references null as that body is
     * not owned directly, or indirectly by the compound.]]></haxe_doc>
		</copy>
		<breakApart public="1" set="method" line="344">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Breaking compound apart in-place.
     * <br/><br/>
     * This method will destroy the compound, moving all of it's components
     * to the assigned Space if this is the root compound, otherwise to the
     * parent compound.
     * <br/><br/>
     * Apart from being easier than doing this manually it also means that we
     * do not have to temporarigly remove objects from the space meaning that
     * things like PreListener ignored interactions will be unaffected.]]></haxe_doc>
		</breakApart>
		<visitBodies public="1" set="method" line="354">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Method to iterate over all bodies contained directly or indirectly by
     * this Compound.
     *
     * @param lambda The method to apply to each Body.
     * @throws # If lambda is null.</haxe_doc>
		</visitBodies>
		<visitConstraints public="1" set="method" line="368">
			<f a="lambda">
				<f a="">
					<c path="nape.constraint.Constraint"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Method to iterate over all constraints contained directly or indirectly by
     * this Compound.
     *
     * @param lambda The method to apply to each Constraint.
     * @throws # If lambda is null.</haxe_doc>
		</visitConstraints>
		<visitCompounds public="1" set="method" line="382">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Compound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Method to iterate over all compounds contained directly or indirectly by
     * this Compound.
     *
     * @param lambda The method to apply to each Compound.
     * @throws # If lambda is null.</haxe_doc>
		</visitCompounds>
		<COM public="1" set="method" line="401">
			<f a="?weak" v="false">
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc>* Compute centre of mass of Compound.
     *
     * @param weak If true, the returned Vec2 will be automatically released
     *             to the object pool when passed as an argument to a Nape
     *             function. (default false)
     * @return The centre of mass of compound.
     * @throws # If Compound has no Bodies contained directly or indirectly
     *           that contain at least one Shape.</haxe_doc>
		</COM>
		<translate public="1" set="method" line="426">
			<f a="translation">
				<c path="nape.geom.Vec2"/>
				<c path="nape.phys.Compound"/>
			</f>
			<haxe_doc><![CDATA[* Translate entire compound.
     * <br/><br/>
     * This is equivalent to: <code>compound.visitBodies(function (b) b.translate(translation))</code>
     *
     * @param translation The translation to apply to the Compound.
     * @return A reference to this Compound.
     * @throws # If translation is null or disposed of.
     * @throws # If any Body in the compound is static, and this compound is in a Space.]]></haxe_doc>
		</translate>
		<rotate public="1" set="method" line="463">
			<f a="centre:angle">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<c path="nape.phys.Compound"/>
			</f>
			<haxe_doc><![CDATA[* Rotate entire compound about a point.
     * <br/><br/>
     * This is equivalent to: <code>compound.visitBodies(function (b) b.rotate(centre, angle))</code>
     *
     * @param centre The centre of rotation in world coordinates.
     * @param angle The clockwise angle of rotation in radians.
     * @return A reference to this Compound.
     * @throws # If centre is null or disposed of.
     * @throws # If any Body in the compound is static, and this compound is in a Space.]]></haxe_doc>
		</rotate>
		<new public="1" set="method" line="287">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new Compound.
     *
     * @result The constructed Compound.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Compound represents a grouping of physics objects into a single object.
 * <br/><br/>
 * This compound owns its constituents and works in the callback system and with
 * respect to adding/removing from a Space as a single object.
 * <pre>
 *       ____Cmp1_____
 *      /    /    &#92;   &#92;
 * Body1 Body2--Joint Cmp2
 *   |     |        &#92;  |
 * Shp1  Shp2        Body3
 *                     |
 *                    Shp3
 * </pre>
 * For example if you have a complex car built with several bodies and
 * constraints you might store this in a Compound providing an easy way
 * of removing/adding/copying the Car as well as being able to get a single
 * callback for when the car collides with something.
 * <br/><br/>
 * When you add a compound to a Space, all of it's constituents get added
 * and furthermore, those constituents cannot be added seperately.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.CompoundIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/CompoundIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.phys.CompoundIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.phys.CompoundList"/>
				<c path="nape.phys.CompoundIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.phys.CompoundList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.phys.CompoundIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.phys.Compound"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.CompoundList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/CompoundList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.phys.Compound"/></c>
				<c path="nape.phys.CompoundList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Compound</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_CompoundList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.phys.Compound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.phys.Compound"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.phys.Compound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.phys.Compound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.phys.Compound"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.phys.Compound"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.phys.Compound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.phys.Compound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.phys.CompoundIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.phys.CompoundList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.phys.CompoundList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Compound"/>
					<x path="Void"/>
				</f>
				<c path="nape.phys.CompoundList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Compound"/>
					<x path="Bool"/>
				</f>
				<c path="nape.phys.CompoundList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Compound type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Compound = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Compound = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Compound = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.FluidProperties" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/FluidProperties.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_FluidProperties"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<shapes public="1" get="accessor" set="null">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc><![CDATA[* Set of all active shapes using this object.
     * <br/><br/>
     * Activeness of a shape in the sense that the Shape's Body is inside of a Space.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</shapes>
		<get_shapes get="inline" set="null" line="210"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<copy public="1" set="method" line="254">
			<f a=""><c path="nape.phys.FluidProperties"/></f>
			<haxe_doc><![CDATA[* Produce a copy of this FluidProperties object.
     * <br/><br/>
     * The copied object will be identical in all properties with the the
     * copied userData being assigned the same fields as 'this' Shape with the
     * same values copied over by reference for object types.
     *
     * @return The copied FluidProperties.]]></haxe_doc>
		</copy>
		<density public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Density of fluid.
     * <br/><br/>
     * This value, like Material density is of g/pixel/pixel.
     * @default 1]]></haxe_doc>
		</density>
		<get_density get="inline" set="null" line="268"><f a=""><x path="Float"/></f></get_density>
		<set_density get="inline" set="null" line="271"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<viscosity public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Viscosity of fluid.
     * <br/><br/>
     * This value is used in drag comutations, the higher the viscosity the
     * more quickly objects will come to rest in the fluid.
     * @default 1]]></haxe_doc>
		</viscosity>
		<get_viscosity get="inline" set="null" line="293"><f a=""><x path="Float"/></f></get_viscosity>
		<set_viscosity get="inline" set="null" line="296"><f a="viscosity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_viscosity>
		<gravity public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.geom.Vec2"/></t>
			<haxe_doc><![CDATA[* Local gravity for buoyancy computations.
     * <br/><br/>
     * When this value is not null, it will be used in place of the Space gravity
     * when performing buoyancy computations.]]></haxe_doc>
		</gravity>
		<get_gravity get="inline" set="null" line="317"><f a=""><t path="Null"><c path="nape.geom.Vec2"/></t></f></get_gravity>
		<set_gravity get="inline" set="null" line="320"><f a="gravity">
	<t path="Null"><c path="nape.geom.Vec2"/></t>
	<t path="Null"><c path="nape.geom.Vec2"/></t>
</f></set_gravity>
		<toString public="1" set="method" line="344">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="222">
			<f a="?density:?viscosity" v="1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new FluidProperties objects.
     *
     * @param density The density of the fluid in g/px/px. (default 1)
     * @param viscosity The viscosity of the fluid for drag computations in kg/px/s
     *                  (default 1)
     * @return The constructed FluidProperties object.</haxe_doc>
		</new>
		<haxe_doc>* FluidProperties providing shared parameters for fluid interaction.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.GravMassMode" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/GravMassMode.hx">
		<DEFAULT public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.GravMassMode"/>
			<haxe_doc><![CDATA[* Default method of computation.
     * <br/><br/>
     * Mass seen by gravity equal to the Body mass.]]></haxe_doc>
		</DEFAULT>
		<get_DEFAULT get="inline" set="null" line="204" static="1"><f a=""><c path="nape.phys.GravMassMode"/></f></get_DEFAULT>
		<FIXED public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.GravMassMode"/>
			<haxe_doc><![CDATA[* Fixed method of computation.
     * <br/><br/>
     * Mass seen by gravity set by user.]]></haxe_doc>
		</FIXED>
		<get_FIXED get="inline" set="null" line="219" static="1"><f a=""><c path="nape.phys.GravMassMode"/></f></get_FIXED>
		<SCALED public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.GravMassMode"/>
			<haxe_doc><![CDATA[* Scaled method of computation.
     * <br/><br/>
     * Mass seen by gravity computed as a factor of the Body mass with
     * scaling factor set by user.]]></haxe_doc>
		</SCALED>
		<get_SCALED get="inline" set="null" line="235" static="1"><f a=""><c path="nape.phys.GravMassMode"/></f></get_SCALED>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of GravMassMode values for a Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.InertiaMode" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/InertiaMode.hx">
		<DEFAULT public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.InertiaMode"/>
			<haxe_doc><![CDATA[* Default method of computation.
     * <br/><br/>
     * Moment of inertia will be computed based on Body's Shape's inertias and densities.]]></haxe_doc>
		</DEFAULT>
		<get_DEFAULT get="inline" set="null" line="203" static="1"><f a=""><c path="nape.phys.InertiaMode"/></f></get_DEFAULT>
		<FIXED public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.InertiaMode"/>
			<haxe_doc><![CDATA[* Fixed method of computation.
     * <br/><br/>
     * Moment of inertia set by user.]]></haxe_doc>
		</FIXED>
		<get_FIXED get="inline" set="null" line="218" static="1"><f a=""><c path="nape.phys.InertiaMode"/></f></get_FIXED>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of InertiaMode values for a Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.InteractorIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/InteractorIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.phys.InteractorIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.phys.InteractorList"/>
				<c path="nape.phys.InteractorIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.phys.InteractorList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.phys.InteractorIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.phys.Interactor"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.InteractorList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/InteractorList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.phys.Interactor"/></c>
				<c path="nape.phys.InteractorList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Interactor</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_InteractorList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.phys.Interactor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.phys.Interactor"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.phys.Interactor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.phys.Interactor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.phys.Interactor"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.phys.Interactor"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.phys.Interactor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.phys.Interactor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.phys.InteractorIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.phys.InteractorList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.phys.InteractorList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Interactor"/>
					<x path="Void"/>
				</f>
				<c path="nape.phys.InteractorList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Interactor"/>
					<x path="Bool"/>
				</f>
				<c path="nape.phys.InteractorList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Interactor type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Interactor = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Interactor = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Interactor = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.MassMode" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/MassMode.hx">
		<DEFAULT public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.MassMode"/>
			<haxe_doc><![CDATA[* Default method of computation.
     * <br/><br/>
     * Mass will be computed based on Body's Shape's areas and densities.]]></haxe_doc>
		</DEFAULT>
		<get_DEFAULT get="inline" set="null" line="203" static="1"><f a=""><c path="nape.phys.MassMode"/></f></get_DEFAULT>
		<FIXED public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.MassMode"/>
			<haxe_doc><![CDATA[* Fixed method of computation.
     * <br/><br/>
     * Mass set by user.]]></haxe_doc>
		</FIXED>
		<get_FIXED get="inline" set="null" line="218" static="1"><f a=""><c path="nape.phys.MassMode"/></f></get_FIXED>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of MassMode values for a Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.Material" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/phys/Material.hx">
		<wood public="1" set="method" line="434" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a wood style Material.
     *
     * @return <code>new Material(0.4,0.2,0.38,0.7,0.005)</code>]]></haxe_doc>
		</wood>
		<steel public="1" set="method" line="443" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a steel style Material.
     *
     * @return <code>new Material(0.2,0.57,0.74,7.8,0.001)</code>]]></haxe_doc>
		</steel>
		<ice public="1" set="method" line="452" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a ice style Material.
     *
     * @return <code>new Material(0.3,0.03,0.1,0.9,0.0001)</code>]]></haxe_doc>
		</ice>
		<rubber public="1" set="method" line="461" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a rubber style Material.
     *
     * @return <code>new Material(0.8,1.0,1.4,1.5,0.01)</code>]]></haxe_doc>
		</rubber>
		<glass public="1" set="method" line="470" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a glass style Material.
     *
     * @return <code>new Material(0.4,0.4,0.94,2.6,0.002)</code>]]></haxe_doc>
		</glass>
		<sand public="1" set="method" line="479" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a sand style Material.
     *
     * @return <code>new Material(-1.0,0.45,0.6,1.6,16.0)</code>]]></haxe_doc>
		</sand>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_Material"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<shapes public="1" get="accessor" set="null">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc><![CDATA[* Set of all active shapes using this object.
     * <br/><br/>
     * Activeness of a shape in the sense that the Shape's Body is inside of a Space.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</shapes>
		<get_shapes get="inline" set="null" line="210"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<copy public="1" set="method" line="264">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Produce a copy of this Material object.
     * <br/><br/>
     * The copied object will be identical in all properties with the the
     * copied userData being assigned the same fields as 'this' Shape with the
     * same values copied over by reference for object types.
     *
     * @return The copied Material.]]></haxe_doc>
		</copy>
		<elasticity public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Elasticity of material.
     * <br/><br/>
     * This property may take any value. Coeffecients of elasticity are combined
     * by taking their average, and then clamping to the range [0,1]. In this way
     * you may give very large values (even infinites) to this property to bias
     * the result of combining elasticities.
     * <br/><br/>
     * A combined, clamped value of 0 results in no bouncing whatsoever.
     * <br/>
     * A combine, clamped value of 1 results in complete elasticity where if
     * possible, the objects will not lose any energy at all.
     *
     * @default 0.0]]></haxe_doc>
		</elasticity>
		<get_elasticity get="inline" set="null" line="286"><f a=""><x path="Float"/></f></get_elasticity>
		<set_elasticity get="inline" set="null" line="289"><f a="elasticity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_elasticity>
		<dynamicFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of dynamic friction for material.
     * <br/><br/>
     * This property may take any zero or positive value. Coeffecients of
     * dynamicFriction are combined by taking the square root of their product.
     * <br/><br/>
     * The higher this value the more quickly objects will slow down from speed
     * when sliding.
     *
     * @default 1]]></haxe_doc>
		</dynamicFriction>
		<get_dynamicFriction get="inline" set="null" line="316"><f a=""><x path="Float"/></f></get_dynamicFriction>
		<set_dynamicFriction get="inline" set="null" line="319"><f a="dynamicFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_dynamicFriction>
		<staticFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of static friction for material.
     * <br/><br/>
     * This property may take any zero or positive value. Coeffecients of
     * staticFriction are combined by taking the square root of their product.
     * <br/><br/>
     * The higher this value the more quickly objects will come to rest once moving
     * very slowly, and the harder it will be to cause the objcet to begin to slide.
     *
     * @default 2]]></haxe_doc>
		</staticFriction>
		<get_staticFriction get="inline" set="null" line="346"><f a=""><x path="Float"/></f></get_staticFriction>
		<set_staticFriction get="inline" set="null" line="349"><f a="staticFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_staticFriction>
		<density public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Density of Shape's using this Material.
     * <br/><br/>
     * This property has units of g/pixel/pixel, not Kg/pixel/pixel for the
     * simple reason that we get more reasonable values like 1 instead of 0.001
     * to attain reasonable mass values for Bodys.
     *
     * @default 1]]></haxe_doc>
		</density>
		<get_density get="inline" set="null" line="374"><f a=""><x path="Float"/></f></get_density>
		<set_density get="inline" set="null" line="377"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<rollingFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of rolling friction for circle interactions.
     * <br/><br/>
     * This property may take any zero or positive value. Coeffecients of
     * staticFriction are combined by taking the square root of their product.
     * <br/><br/>
     * The higher this value, the more quickly a rolling circle - which would
     * otherwise roll forever ignoring drag and numerical issues - will come to
     * rest.
     *
     * @default 0.01]]></haxe_doc>
		</rollingFriction>
		<get_rollingFriction get="inline" set="null" line="405"><f a=""><x path="Float"/></f></get_rollingFriction>
		<set_rollingFriction get="inline" set="null" line="408"><f a="rollingFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rollingFriction>
		<toString public="1" set="method" line="425">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="229">
			<f a="?elasticity:?dynamicFriction:?staticFriction:?density:?rollingFriction" v="0.0f:1.0f:2.0f:1:0.001f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new Material object.
     *
     * @param elasticity The coeffecient of elasticity for material.
     *                   (default 0.0)
     * @param dynamicFriction The coeffecient of dynamic friction for
     *                        material. (default 1.0)
     * @param staticFriction The coeffecient of static friction for
     *                       material. (default 2.0)
     * @param density The density of the shape using this material in units
     *                of g/pixel/pixel. (default 1.0)
     * @param rollingFriction The coeffecient of rolling friction for material
     *                        used in circle friction computations. (default 0.001)
     * @return The constructed Material object.</haxe_doc>
		</new>
		<haxe_doc>* Material property providing physical attributes to a Shape.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.Shape" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/shape/Shape.hx">
		<extends path="nape.phys.Interactor"/>
		<zpp_inner public="1">
			<c path="zpp_nape.shape.ZPP_Shape"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<type public="1" get="accessor" set="null">
			<c path="nape.shape.ShapeType"/>
			<haxe_doc>* Type of shape.</haxe_doc>
		</type>
		<get_type get="inline" set="null" line="187"><f a=""><c path="nape.shape.ShapeType"/></f></get_type>
		<isCircle public="1" get="inline" set="null" line="197">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Faster equivalent to <code>type == ShapeType.CIRCLE</code>
     *
     * @return True if shape is a Circle type.]]></haxe_doc>
		</isCircle>
		<isPolygon public="1" get="inline" set="null" line="207">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Faster equivalent to <code>type == ShapeType.POLYGON</code>
     *
     * @return True if shape is a Polygon type.]]></haxe_doc>
		</isPolygon>
		<body public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Body this Shape is assigned to.
     * <br/><br/>
     * This value can be set to add Shape to the given Body, and set to null
     * to remove it from its present Body.
     *
     * @default null]]></haxe_doc>
		</body>
		<get_body get="inline" set="null" line="237"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body>
		<set_body get="inline" set="null" line="240"><f a="body">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body>
		<castCircle public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.shape.Circle"/></t>
			<haxe_doc>* Faster equivalent to casting this to Circle type</haxe_doc>
		</castCircle>
		<get_castCircle get="inline" set="null" line="255"><f a=""><t path="Null"><c path="nape.shape.Circle"/></t></f></get_castCircle>
		<castPolygon public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.shape.Polygon"/></t>
			<haxe_doc>* Faster equivalent to casting this to Polygon type</haxe_doc>
		</castPolygon>
		<get_castPolygon get="inline" set="null" line="263"><f a=""><t path="Null"><c path="nape.shape.Polygon"/></t></f></get_castPolygon>
		<worldCOM public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* World space centre of mass of this Shape.
     * <br/><br/>
     * This value can be accessed even if Shape is not in a Body, but
     * attempting to query the values of it will return an error in debug
     * builds unless the Shape is in a Body.
     * <br/><br/>
     * This Vec2 is immutable.]]></haxe_doc>
		</worldCOM>
		<get_worldCOM get="inline" set="null" line="277"><f a=""><c path="nape.geom.Vec2"/></f></get_worldCOM>
		<localCOM public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Local space centre of mass of this Shape.
     * <br/><br/>
     * This Vec2 can be set and is equivalent to performing the necessary
     * translation of the Shape in local coordinates, and also equivalent
     * to <code>this.localCOM.set(value)</code>.
     * <br/>
     * Setting this value whilst this shape is part of a static Body that
     * is part of a Space is not permitted.]]></haxe_doc>
		</localCOM>
		<get_localCOM get="inline" set="null" line="298"><f a=""><c path="nape.geom.Vec2"/></f></get_localCOM>
		<set_localCOM get="inline" set="null" line="305"><f a="localCOM">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_localCOM>
		<area public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Area of the Hhape.</haxe_doc>
		</area>
		<get_area get="inline" set="null" line="326"><f a=""><x path="Float"/></f></get_area>
		<inertia public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Non-mass weighted moment of inertia for Shape.</haxe_doc>
		</inertia>
		<get_inertia get="inline" set="null" line="335"><f a=""><x path="Float"/></f></get_inertia>
		<angDrag public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Coeffecient of angular fluid drag for this Shape.</haxe_doc>
		</angDrag>
		<get_angDrag get="inline" set="null" line="344"><f a=""><x path="Float"/></f></get_angDrag>
		<material public="1" get="accessor" set="accessor">
			<c path="nape.phys.Material"/>
			<haxe_doc>* Material used by this shape.
     *
     * @default new Material()</haxe_doc>
		</material>
		<get_material get="inline" set="null" line="355"><f a=""><c path="nape.phys.Material"/></f></get_material>
		<set_material get="inline" set="null" line="358"><f a="material">
	<c path="nape.phys.Material"/>
	<c path="nape.phys.Material"/>
</f></set_material>
		<filter public="1" get="accessor" set="accessor">
			<c path="nape.dynamics.InteractionFilter"/>
			<haxe_doc>* InteractionFilter used by this shape.
     *
     * @default new InteractionFilter()</haxe_doc>
		</filter>
		<get_filter get="inline" set="null" line="375"><f a=""><c path="nape.dynamics.InteractionFilter"/></f></get_filter>
		<set_filter get="inline" set="null" line="378"><f a="filter">
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.dynamics.InteractionFilter"/>
</f></set_filter>
		<fluidProperties public="1" get="accessor" set="accessor">
			<c path="nape.phys.FluidProperties"/>
			<haxe_doc><![CDATA[* FluidProperties used by this shape.
     * <br/><br/>
     * This object provides information for buoyancy and fluid drag computations
     * when this shape is interacting as a fluid.
     *
     * @default new FluidProperties();]]></haxe_doc>
		</fluidProperties>
		<get_fluidProperties get="inline" set="null" line="398"><f a=""><c path="nape.phys.FluidProperties"/></f></get_fluidProperties>
		<set_fluidProperties get="inline" set="null" line="403"><f a="fluidProperties">
	<c path="nape.phys.FluidProperties"/>
	<c path="nape.phys.FluidProperties"/>
</f></set_fluidProperties>
		<fluidEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether this shape is able to interact as a fluid.
     * <br/><br/>
     * Unless this field is true, this Shape can never interact as a fluid.
     * <br/><br/>
     * Just because this field is true however, does not mean this shape will always
     * interact as a fluid, the final result is down to the combination of
     * InteractionFilters on the pairing of shapes and sensory interaction
     * takes higher priority.
     *
     * @default false]]></haxe_doc>
		</fluidEnabled>
		<get_fluidEnabled get="inline" set="null" line="426"><f a=""><x path="Bool"/></f></get_fluidEnabled>
		<set_fluidEnabled get="inline" set="null" line="429"><f a="fluidEnabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fluidEnabled>
		<sensorEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether this shape is able to interact as sensor.
     * <br/><br/>
     * Unless this field is true, this Shape can never interact as a sensor.
     * <br/><br/>
     * Just because this field is true however, does not mean this shape will always
     * interact as a sensor, the final result is down to the combination of
     * InteractionFilters on the pairing of shapes. Sensor interaction has highest priority.
     *
     * @default false]]></haxe_doc>
		</sensorEnabled>
		<get_sensorEnabled get="inline" set="null" line="451"><f a=""><x path="Bool"/></f></get_sensorEnabled>
		<set_sensorEnabled get="inline" set="null" line="454"><f a="sensorEnabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_sensorEnabled>
		<bounds public="1" get="accessor" set="null">
			<c path="nape.geom.AABB"/>
			<haxe_doc><![CDATA[* World space bounding box for this shape.
     * <br/><br/>
     * This value can be accessed even if the Shape is not part of a Body,
     * however attempting to query its values would result in an error in
     * debug builds.
     * <br/><br/>
     * This AABB is immutable.]]></haxe_doc>
		</bounds>
		<get_bounds get="inline" set="null" line="473"><f a=""><c path="nape.geom.AABB"/></f></get_bounds>
		<translate public="1" set="method" line="487">
			<f a="translation">
				<c path="nape.geom.Vec2"/>
				<c path="nape.shape.Shape"/>
			</f>
			<haxe_doc><![CDATA[* Translate this shape in its local coordinate system.
     * <br/><br/>
     * This is equivalent to: <code>shape.localCOM.addeq(displacement)</code>
     *
     * @param translation The local translation to apply to Shape.
     * @return A reference to 'this' Shape.
     * @throws # If translation is null or has been disposed of.
     * @throws # If this shape is part of a static body that is inside of a Space.]]></haxe_doc>
		</translate>
		<scale public="1" set="method" line="527">
			<f a="scalex:scaley">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.shape.Shape"/>
			</f>
			<haxe_doc><![CDATA[* Scale this shape in its local coordinate system.
     * <br/><br/>
     * For Circle shapes, scalex and scaley must be exactly equal.
     *
     * @param scalex The x-coordinate scaling to apply to Shape.
     * @param scaley The y-coordinate scaling to apply to Shape.
     * @return A reference to 'this' Shape.
     * @throws # If this shape is part of a static body that is inside of a Space.
     * @throws # If scalex or scaley is 0. Negative values 'are' permitted.]]></haxe_doc>
		</scale>
		<rotate public="1" set="method" line="557">
			<f a="angle">
				<x path="Float"/>
				<c path="nape.shape.Shape"/>
			</f>
			<haxe_doc>* Rotate this shape in its local coordinate system.
     *
     * @param angle The number of radians to rotate this Shape by in a clockwise
     *              direction.
     * @return A reference to 'this' Shape.
     * @throws # If this shape is part of a static body that is inside of a Space.</haxe_doc>
		</rotate>
		<transform public="1" set="method" line="584">
			<f a="matrix">
				<c path="nape.geom.Mat23"/>
				<c path="nape.shape.Shape"/>
			</f>
			<haxe_doc><![CDATA[* Apply local transformation matrix to Shape.
     * <br/><br/>
     * For Circle shapes, the matrix must be equiorthogonal.
     *
     * @param matrix The matrix to transform Shape by.
     * @return A reference to 'this' Shape.
     * @throws # If matrix is null or singular.
     * @throws # If shape is a Circle, and matrix is not equiorthogonal.
     * @throws # If this shape is part of a static body that is inside of a Space.]]></haxe_doc>
		</transform>
		<contains public="1" set="method" line="616">
			<f a="point">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Test containment of world-space coordinate in Shape.
     * <br/><br/>
     * This Shape must be part of a Body so that world coordinates are
     * defined.
     *
     * @param point The point to check for containment.
     * @return True if point is contained within the Shape.
     * @throws If point is null or disposed of.
     * @throws If this shape is not part of a Body.]]></haxe_doc>
		</contains>
		<copy public="1" set="method" line="654">
			<f a=""><c path="nape.shape.Shape"/></f>
			<haxe_doc><![CDATA[* Produce an exact copy of this Shape.
     * <br/><br/>
     * The copied shape will be identical with the copied Shape's userData
     * object being assigned the same fields as 'this' Shape with the same
     * values copied over by reference for object types.
     *
     * @return A copy of this shape.]]></haxe_doc>
		</copy>
		<toString public="1" set="method" line="660" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new set="method" line="213">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Base type for Nape Shape's</haxe_doc>
	</class>
	<class path="nape.shape.Circle" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/shape/Circle.hx">
		<extends path="nape.shape.Shape"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.shape.ZPP_Circle"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<radius public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Radius of circle
     * <br/><br/>
     * This value must be strictly positive, and attempting to set this value
     * whilst this Circle is part of a static Body inside a Space will result
     * in a debug time error.]]></haxe_doc>
		</radius>
		<get_radius get="inline" set="null" line="318"><f a=""><x path="Float"/></f></get_radius>
		<set_radius get="inline" set="null" line="321"><f a="radius">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<new public="1" set="method" line="196">
			<f a="radius:?localCOM:?material:?filter" v=":null:null:null">
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.phys.Material"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Circle
     *
     * @param radius The radius of the circle, this value must be positive.
     * @param localCOM The local offset for the circle. (default &#40;0,0&#41;)
     * @param material The material for this circle. (default new Material&#40;&#41;)
     * @param filter The interaction filter for this circle.
     *               (default new InteractionFilter&#40;&#41;)
     * @return The constructed Circle
     * @throws # If radius is not strictly positive
     * @throws # If localCOM is non-null, but has been disposed of.]]></haxe_doc>
		</new>
		<haxe_doc>* Shape subtype representing a Circle</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.Edge" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/shape/Edge.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.shape.ZPP_Edge"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<polygon public="1" get="accessor" set="null">
			<c path="nape.shape.Polygon"/>
			<haxe_doc>* Reference to Polygon this Edge belongs to.</haxe_doc>
		</polygon>
		<get_polygon get="inline" set="null" line="195"><f a=""><c path="nape.shape.Polygon"/></f></get_polygon>
		<localNormal public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Normal of edge in local coordinates.
     * <br/><br/>
     * This Vec2 is immutable.]]></haxe_doc>
		</localNormal>
		<get_localNormal get="inline" set="null" line="208"><f a=""><c path="nape.geom.Vec2"/></f></get_localNormal>
		<worldNormal public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Normal of edge in world coordinates.
     * <br/><br/>
     * This Vec2 is immutable, and may be accessed even if the related Polygon
     * is not part of a Body but queries to its values will result in a debug
     * build error.]]></haxe_doc>
		</worldNormal>
		<get_worldNormal get="inline" set="null" line="224"><f a=""><c path="nape.geom.Vec2"/></f></get_worldNormal>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Length of edge.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="236"><f a=""><x path="Float"/></f></get_length>
		<localProjection public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Local projection of polygon onto edge axis.</haxe_doc>
		</localProjection>
		<get_localProjection get="inline" set="null" line="248"><f a=""><x path="Float"/></f></get_localProjection>
		<worldProjection public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* World projection of polygon to edge axis.
     * <br/><br/>
     * This value can only be accessed if related Polygon is part of a Body.]]></haxe_doc>
		</worldProjection>
		<get_worldProjection get="inline" set="null" line="262"><f a=""><x path="Float"/></f></get_worldProjection>
		<localVertex1 public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* Reference to first local vertex for edge.</haxe_doc>
		</localVertex1>
		<get_localVertex1 get="inline" set="null" line="275"><f a=""><c path="nape.geom.Vec2"/></f></get_localVertex1>
		<localVertex2 public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* Reference to second local vertex for edge.</haxe_doc>
		</localVertex2>
		<get_localVertex2 get="inline" set="null" line="287"><f a=""><c path="nape.geom.Vec2"/></f></get_localVertex2>
		<worldVertex1 public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* Reference to first world vertex for edge.</haxe_doc>
		</worldVertex1>
		<get_worldVertex1 get="inline" set="null" line="299"><f a=""><c path="nape.geom.Vec2"/></f></get_worldVertex1>
		<worldVertex2 public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* Reference to second world vertex for edge.</haxe_doc>
		</worldVertex2>
		<get_worldVertex2 get="inline" set="null" line="311"><f a=""><c path="nape.geom.Vec2"/></f></get_worldVertex2>
		<toString public="1" set="method" line="321">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="185">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Edge class providing internal details of Polygon.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.EdgeIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/shape/EdgeIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.shape.EdgeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.shape.EdgeList"/>
				<c path="nape.shape.EdgeIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.shape.EdgeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.shape.EdgeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.shape.Edge"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.EdgeList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/shape/EdgeList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.shape.Edge"/></c>
				<c path="nape.shape.EdgeList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Edge</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_EdgeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.shape.Edge"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.shape.Edge"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.shape.Edge"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.shape.Edge"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.shape.Edge"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.shape.Edge"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.shape.Edge"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.shape.Edge"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.shape.EdgeIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.shape.EdgeList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.shape.EdgeList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.shape.Edge"/>
					<x path="Void"/>
				</f>
				<c path="nape.shape.EdgeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.shape.Edge"/>
					<x path="Bool"/>
				</f>
				<c path="nape.shape.EdgeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Edge type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Edge = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Edge = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Edge = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.Polygon" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/shape/Polygon.hx">
		<extends path="nape.shape.Shape"/>
		<rect public="1" set="method" line="209" static="1">
			<f a="x:y:width:height:?weak" v="::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="nape.geom.Vec2"/></c>
			</f>
			<haxe_doc><![CDATA[* Construct a polygon representing a rectangle.
     * <br/><br/>
     * For a dynamic object, you may consider use of the box method instead
     * as dynamic bodies will only respond as expected if their centre of mass
     * is equal to the origin.
     * <br/><br/>
     * The generate polygon will have coordinates equal to:
     * <pre>
     * (x, y) -> (x + width, y + height)
     * </pre>
     * Negative values of width/height are permitted so that the given x/y values
     * may not necessarigly be the top-left corner of rectangle.
     *
     * @param x The x coordinate of rectangle.
     * @param y The y coordinate of rectangle.
     * @param width The width of the ractangle. This value may be negative.
     * @param height The height of the rectangle This value may be negative.
     * @param weak If true, the generated list of vertices will be allocated as
     *             weak Vec2s so that when this list is passed to a Nape function
     *             these Vec2s will be automatically sent back to object pool.
     *             (default false)
     * @return An array of Vec2 representing the given rectangle.]]></haxe_doc>
		</rect>
		<box public="1" set="method" line="231" static="1">
			<f a="width:height:?weak" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="nape.geom.Vec2"/></c>
			</f>
			<haxe_doc><![CDATA[* Construct a polygon representing an origin centred box.
     * <br/><br/>
     * This method is equivalent to calling: <code>Polygon.rect(-width/2,-height/2,width,height)</code>
     *
     * @param width The width of the box (This value may be negative but will
     *              make no difference).
     * @param height The height of the box (This value may be negative but will
     *              make no difference).
     * @param weak If true, the generated list of vertices will be allocated as
     *             weak Vec2s so that when this list is passed to a Nape function
     *             these Vec2s will be automatically sent back to object pool.
     *             (default false)
     * @return An array of Vec2 representing the given box.]]></haxe_doc>
		</box>
		<regular public="1" set="method" line="257" static="1">
			<f a="xRadius:yRadius:edgeCount:?angleOffset:?weak" v=":::0.0f:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="nape.geom.Vec2"/></c>
			</f>
			<haxe_doc><![CDATA[* Construct a regular polygon centred at origin.
     * <br/><br/>
     * Vertices are created at positions on the edge of an ellipsoid of given
     * radii, when radii are not equal the vertices will not have an equal
     * angle between them; it will be as though an actual regular polygon were
     * created, and then squashed to conform to the input radii.
     *
     * @param xRadius The x radius of polygon before angleOffset rotation.
     * @param yRadius The y radius of polygon before angleOffset rotation.
     * @param edgeCount The number of edges/vertices in polygon.
     * @param angleOffset The clockwise angular offset to generate vertices at
     *                    in radians. (default 0.0)
     * @param weak If true, the generated list of vertices will be allocated as
     *             weak Vec2s so that when this list is passed to a Nape function
     *             these Vec2s will be automatically sent back to object pool.
     *             (default false)
     * @return An array of Vec2 representing the polygon.]]></haxe_doc>
		</regular>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.shape.ZPP_Polygon"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<localVerts public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2List"/>
			<haxe_doc><![CDATA[* Local coordinates of vertices.
     * <br/><br/>
     * This list can be modified, but modifications to a Polygon that is
     * part of a static Body inside of a Space will given an error in
     * debug builds.]]></haxe_doc>
		</localVerts>
		<get_localVerts get="inline" set="null" line="279"><f a=""><c path="nape.geom.Vec2List"/></f></get_localVerts>
		<worldVerts public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2List"/>
			<haxe_doc><![CDATA[* World coordinates of vertices.
     * <br/><br/>
     * This list can be accessed, but any queries of values will result
     * in an error in debug builds unless this Polygon is part of a Body.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</worldVerts>
		<get_worldVerts get="inline" set="null" line="293"><f a=""><c path="nape.geom.Vec2List"/></f></get_worldVerts>
		<edges public="1" get="accessor" set="null">
			<c path="nape.shape.EdgeList"/>
			<haxe_doc><![CDATA[* Set of edges on polygon.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</edges>
		<get_edges get="inline" set="null" line="304"><f a=""><c path="nape.shape.EdgeList"/></f></get_edges>
		<validity public="1" set="method" line="312">
			<f a=""><c path="nape.shape.ValidationResult"/></f>
			<haxe_doc>* Determine validity of polygon for use in a Nape simulation.</haxe_doc>
		</validity>
		<new public="1" set="method" line="331">
			<f a="localVerts:?material:?filter" v=":null:null">
				<d/>
				<c path="nape.phys.Material"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Polygon.
     * <br/><br/>
     * The localVerts parameter is typed Dynamic and may be one of:
     * <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
     *
     * @param localVerts The local vertices of polygon.
     * @param material The material for this polygon. (default new Material&#40;&#41;)
     * @param filter The interaction filter for this polygon.
     *               (default new InteractionFilter&#40;&#41;)
     * @return The constructed Polygon.
     * @throws # If localVerts is null, or not of the expected Type.
     * @throws # If localVerts contains any disposed or null Vec2.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Polygon subtype of Shape.
 * <br/><br/>
 * Can be used to simulate any convex polygon.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ShapeIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/shape/ShapeIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.shape.ShapeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<zpp_inner public="1">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_next public="1">
			<c path="nape.shape.ShapeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.shape.Shape"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ShapeList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/shape/ShapeList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.shape.Shape"/></c>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Shape</haxe_doc>
		</fromArray>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ShapeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.shape.Shape"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.shape.Shape"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.shape.Shape"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.shape.ShapeIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<copy public="1" set="method" line="662">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.shape.ShapeList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.shape.Shape"/>
					<x path="Void"/>
				</f>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.shape.Shape"/>
					<x path="Bool"/>
				</f>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Shape type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Shape = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Shape = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Shape = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ShapeType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/shape/ShapeType.hx">
		<CIRCLE public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ShapeType"/>
			<haxe_doc>* Circle shape type</haxe_doc>
		</CIRCLE>
		<get_CIRCLE get="inline" set="null" line="201" static="1"><f a=""><c path="nape.shape.ShapeType"/></f></get_CIRCLE>
		<POLYGON public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ShapeType"/>
			<haxe_doc>* Polygon shape type</haxe_doc>
		</POLYGON>
		<get_POLYGON get="inline" set="null" line="214" static="1"><f a=""><c path="nape.shape.ShapeType"/></f></get_POLYGON>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Nape Shape types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ValidationResult" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/shape/ValidationResult.hx">
		<VALID public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ValidationResult"/>
			<haxe_doc>* Denotes polygon is valid for simulation in Nape.</haxe_doc>
		</VALID>
		<get_VALID get="inline" set="null" line="203" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_VALID>
		<DEGENERATE public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ValidationResult"/>
			<haxe_doc>* Denotes polygon is degenerate (has zero area).</haxe_doc>
		</DEGENERATE>
		<get_DEGENERATE get="inline" set="null" line="216" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_DEGENERATE>
		<CONCAVE public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ValidationResult"/>
			<haxe_doc>* Denotes polygon is concave.</haxe_doc>
		</CONCAVE>
		<get_CONCAVE get="inline" set="null" line="229" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_CONCAVE>
		<SELF_INTERSECTING public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ValidationResult"/>
			<haxe_doc>* Denotes polygon is self-intersecting.</haxe_doc>
		</SELF_INTERSECTING>
		<get_SELF_INTERSECTING get="inline" set="null" line="242" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_SELF_INTERSECTING>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of validation results for a Polygon.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.space.Broadphase" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/space/Broadphase.hx">
		<DYNAMIC_AABB_TREE public="1" get="accessor" set="null" static="1">
			<c path="nape.space.Broadphase"/>
			<haxe_doc><![CDATA[* Dynamic AABB Tree broadphase.
     * <br/><br/>
     * This broadphase uses a pair of binary trees with objects inserted based
     * on containment of their AABB.
     * <br/><br/>
     * This is a general purpose broadphase which does not suffer for objects
     * of varying sizes, or objects moving very quickly and is well set for such
     * acts as ray casting and spatial queries like objectsInAABB of the Space type.
     * <br/><br/>
     * This is the default broadphase nape will use.]]></haxe_doc>
		</DYNAMIC_AABB_TREE>
		<get_DYNAMIC_AABB_TREE get="inline" set="null" line="210" static="1"><f a=""><c path="nape.space.Broadphase"/></f></get_DYNAMIC_AABB_TREE>
		<SWEEP_AND_PRUNE public="1" get="accessor" set="null" static="1">
			<c path="nape.space.Broadphase"/>
			<haxe_doc><![CDATA[* Sweep and prune broadphase.
     * <br/><br/>
     * This is a very simple broadphase using the x-axis to keep objects
     * sorted by their minimum x coordinate.
     * <br/><br/>
     * Performance of this broadphase is generally good and in some circumstances
     * superior to the DYNAMIC_AABB_TREE broadphase.
     * <br/><br/>
     * This broadphase will however be much slower for things such as ray casts and
     * spatial queries like objectsInAABB on the Space type.
     * Also in cases where lots of objects are moving very quickly or when there is a
     * large variety in the size of objects.
     * <br/><br/>
     * Due to the simplicity of this broadphase, it serves as a good test should you
     * ever feel there might be something going wrong with the DYNAMIC_AABB_TREE
     * broadphase type.]]></haxe_doc>
		</SWEEP_AND_PRUNE>
		<get_SWEEP_AND_PRUNE get="inline" set="null" line="238" static="1"><f a=""><c path="nape.space.Broadphase"/></f></get_SWEEP_AND_PRUNE>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of available broadphase collision types that Spaces may use.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.space.Space" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/space/Space.hx">
		<zpp_inner public="1">
			<c path="zpp_nape.space.ZPP_Space"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<gravity public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Space gravity.
     * <br/><br/>
     * Units are of pixels/second/second
     * @default (0,0)]]></haxe_doc>
		</gravity>
		<get_gravity get="inline" set="null" line="209"><f a=""><c path="nape.geom.Vec2"/></f></get_gravity>
		<set_gravity get="inline" set="null" line="213"><f a="gravity">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_gravity>
		<broadphase public="1" get="accessor" set="null">
			<c path="nape.space.Broadphase"/>
			<haxe_doc>* Broadphase type in use.</haxe_doc>
		</broadphase>
		<get_broadphase get="inline" set="null" line="232"><f a=""><c path="nape.space.Broadphase"/></f></get_broadphase>
		<sortContacts public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Flag controlling sorting of contact points.
     * <br/><br/>
     * If true, then collisions will be resolved in an order defined by their
     * penetration depths. This can be shown to improve stability of the physics
     * as well as making simulations more consistent regardless of which broadphase
     * is used.
     * <br/><br/>
     * Having sorting enabled obviously incurs a cost, and you may consider
     * disabling it if you are having issues with performance (Though things
     * such as number of physics iterations will have much greater bearing on
     * performance than this, especcialy since enabling this may permit you
     * to use less iterations).
     *
     * @default true]]></haxe_doc>
		</sortContacts>
		<get_sortContacts get="inline" set="null" line="253"><f a=""><x path="Bool"/></f></get_sortContacts>
		<set_sortContacts get="inline" set="null" line="256"><f a="sortContacts">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_sortContacts>
		<worldAngularDrag public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular drag applied to all bodies in Space.
     * <br/><br/>
     * This represents the fraction of a body's angular velocity which will be
     * removed per second. This value has no unit attached.
     *
     * @default 0.015]]></haxe_doc>
		</worldAngularDrag>
		<get_worldAngularDrag get="inline" set="null" line="272"><f a=""><x path="Float"/></f></get_worldAngularDrag>
		<set_worldAngularDrag get="inline" set="null" line="275"><f a="worldAngularDrag">
	<x path="Float"/>
	<x path="Float"/>
</f></set_worldAngularDrag>
		<worldLinearDrag public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear drag applied to all bodies in Space.
     * <br/><br/>
     * This represents the fraction of a body's linear velocity which will be
     * removed per second. This value has no unit attached.
     *
     * @default 0.015]]></haxe_doc>
		</worldLinearDrag>
		<get_worldLinearDrag get="inline" set="null" line="295"><f a=""><x path="Float"/></f></get_worldLinearDrag>
		<set_worldLinearDrag get="inline" set="null" line="298"><f a="worldLinearDrag">
	<x path="Float"/>
	<x path="Float"/>
</f></set_worldLinearDrag>
		<compounds public="1" get="accessor" set="null">
			<c path="nape.phys.CompoundList"/>
			<haxe_doc><![CDATA[* List of all Compounds directly placed in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Compound to this Space equivalent to: <code>compound.space = space</code>
     * <br/><br/>
     * This list is only those compounds directly placed in the space, any
     * compound that is a child of another compound will not be in this list.]]></haxe_doc>
		</compounds>
		<get_compounds get="inline" set="null" line="319"><f a=""><c path="nape.phys.CompoundList"/></f></get_compounds>
		<bodies public="1" get="accessor" set="null">
			<c path="nape.phys.BodyList"/>
			<haxe_doc><![CDATA[* List of all Bodys directly placed in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Body to this Space equivalent to: <code>body.space = space</code>
     * <br/><br/>
     * This list is only those bodies directly placed in the space, any
     * body that is a child of a Compound will not be in this list.]]></haxe_doc>
		</bodies>
		<get_bodies get="inline" set="null" line="333"><f a=""><c path="nape.phys.BodyList"/></f></get_bodies>
		<liveBodies public="1" get="accessor" set="null">
			<c path="nape.phys.BodyList"/>
			<haxe_doc><![CDATA[* List of all active dynamic Bodies in space.
     * <br/><br/>
     * This list contains all dynamic bodies that are awake regardless of their containment in a Compound.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</liveBodies>
		<get_liveBodies get="inline" set="null" line="345"><f a=""><c path="nape.phys.BodyList"/></f></get_liveBodies>
		<constraints public="1" get="accessor" set="null">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc><![CDATA[* List of all Constraints directly placed in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Constraint to this Space equivalent to: <code>constraint.space = space</code>
     * <br/><br/>
     * This list is only those bodies directly placed in the space, any
     * constraint that is a child of a Compound will not be in this list.]]></haxe_doc>
		</constraints>
		<get_constraints get="inline" set="null" line="359"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<liveConstraints public="1" get="accessor" set="null">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc><![CDATA[* List of all active Constraints in space.
     * <br/><br/>
     * This list contains all constraints regardless of their containment in a Compound.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</liveConstraints>
		<get_liveConstraints get="inline" set="null" line="371"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_liveConstraints>
		<visitBodies public="1" set="method" line="383">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Apply given function to all bodies in space.
     * <br/><br/>
     * This method is a way to iterate over 'every' Body in the Space
     * regardless of containment in a Compound.
     *
     * @param lambda The function to apply to each Body.
     * @throws # If lambda is null.]]></haxe_doc>
		</visitBodies>
		<visitConstraints public="1" set="method" line="399">
			<f a="lambda">
				<f a="">
					<c path="nape.constraint.Constraint"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Apply given function to all constraints in space.
     * <br/><br/>
     * This method is a way to iterate over 'every' Constraint in the Space
     * regardless of containment in a Compound.
     *
     * @param lambda The function to apply to each Constraint.
     * @throws # If lambda is null.]]></haxe_doc>
		</visitConstraints>
		<visitCompounds public="1" set="method" line="415">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Compound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Apply given function to all compounds in space.
     * <br/><br/>
     * This method is a way to iterate over 'every' Compound in the Space
     * regardless of containment in another Compound.
     *
     * @param lambda The function to apply to each Compound.
     * @throws # If lambda is null.]]></haxe_doc>
		</visitCompounds>
		<world public="1" get="accessor" set="null">
			<c path="nape.phys.Body"/>
			<haxe_doc><![CDATA[* Static, immutable Body for constraint purposes.
     * <br/><br/>
     * This is a completely static, uncollidable, uninteractable Body
     * with no Shapes, that cannot be modified in any way.
     * <br/><br/>
     * Its purpose is to provide a means for attaching Constraints
     * from one Body to the Space itself, for instance pinning a body
     * against a static point in space.]]></haxe_doc>
		</world>
		<get_world get="inline" set="null" line="436"><f a=""><c path="nape.phys.Body"/></f></get_world>
		<arbiters public="1" get="accessor" set="null">
			<c path="nape.dynamics.ArbiterList"/>
			<haxe_doc><![CDATA[* List of all active arbiters in Space.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</arbiters>
		<get_arbiters get="inline" set="null" line="446"><f a=""><c path="nape.dynamics.ArbiterList"/></f></get_arbiters>
		<listeners public="1" get="accessor" set="null">
			<c path="nape.callbacks.ListenerList"/>
			<haxe_doc><![CDATA[* List of all Listeners in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Listener to this Space equivalent to: <code>listener.space = space</code>]]></haxe_doc>
		</listeners>
		<get_listeners get="inline" set="null" line="462"><f a=""><c path="nape.callbacks.ListenerList"/></f></get_listeners>
		<clear public="1" set="method" line="475">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Clear the Space of all objects.
     * <br/><br/>
     * Things such as the elapsed simulation time, and time step will too be
     * reset to 0.
     * <br/><br/>
     * Parameters such as gravity, and worldLinearDrag will be untouched by
     * this operation.]]></haxe_doc>
		</clear>
		<step public="1" set="method" line="501">
			<f a="deltaTime:?velocityIterations:?positionIterations" v=":10:10">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Step simulation forward in time.
     *
     * @param deltaTime The number of seconds to simulate. For 60fps physics
     *                  you would use a value of 1/60.
     * @param velocityIterations The number of iterations to use in resolving
     *                           errors in the velocities of objects. This is
     *                           together with collision detection the most
     *                           expensive phase of a simulation update, as well
     *                           as the most important for stable results.
     *                           (default 10)
     * @param positionIterations The number of iterations to use in resolving
     *                           errors in the positions of objects. This is
     *                           far more lightweight than velocity iterations,
     *                           as well as being less important for the
     *                           stability of results. (default 10)
     * @throws # If deltaTime is not strictly positive.
     * @throws # If either of the number of iterations is not strictly positive.</haxe_doc>
		</step>
		<timeStamp public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The time stamp of this Space object.
     * <br/><br/>
     * This is equal to the number of times that space.step(..) has been invoked.]]></haxe_doc>
		</timeStamp>
		<get_timeStamp get="inline" set="null" line="517"><f a=""><x path="Int"/></f></get_timeStamp>
		<elapsedTime public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The elapsed simulation time.
     * <br/><br/>
     * This is the total amount of 'time' that has elapsed in the Space simulation.]]></haxe_doc>
		</elapsedTime>
		<get_elapsedTime get="inline" set="null" line="527"><f a=""><x path="Float"/></f></get_elapsedTime>
		<interactionType public="1" set="method" line="578">
			<f a="shape1:shape2">
				<c path="nape.shape.Shape"/>
				<c path="nape.shape.Shape"/>
				<t path="Null"><c path="nape.callbacks.InteractionType"/></t>
			</f>
			<haxe_doc><![CDATA[* Determine the interaction type that would occur between a pair of Shapes.
     * <br/><br/>
     * This function takes into account everything possible, and ignoring the
     * callback system will tell you precisely the type of interaction (if any
     * at all) which will occur between these Shapes.
     * <br/><br/>
     * This function can only work if the Shapes belong to a Body.
     * <br/><br/>
     * This function can only make use of any constraints 'ignore' property
     * to determine if 'null' should be returned if the constraints being used
     * are inside of a Space.
     *
     * @param shape1 The first Shape to test.
     * @param shape2 The second Shape to test.
     * @return The interaction type that will occur between these shapes, or null
     *         if no interaction will occur.
     * @throws # If either shape is null, or is not contained within a body.]]></haxe_doc>
		</interactionType>
		<shapesUnderPoint public="1" set="method" line="610">
			<f a="point:?filter:?output" v=":null:null">
				<c path="nape.geom.Vec2"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Shapes under a given Point.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered.
     *
     * @param point The point to evaluate shapes.
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the Shapes containing the given point.
     * @throws # If point is null or disposed of.]]></haxe_doc>
		</shapesUnderPoint>
		<bodiesUnderPoint public="1" set="method" line="647">
			<f a="point:?filter:?output" v=":null:null">
				<c path="nape.geom.Vec2"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Bodies under a given Point.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape containing
     * the given point whose filter agrees to 'collide' will be considered.
     *
     * @param point The point to evaluate bodies.
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the Bodies containing the given point.
     * @throws # If point is null or disposed of.]]></haxe_doc>
		</bodiesUnderPoint>
		<shapesInAABB public="1" set="method" line="690">
			<f a="aabb:?containment:?strict:?filter:?output" v=":false:true:null:null">
				<c path="nape.geom.AABB"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Shapes given an AABB.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered.
     *
     * @param aabb The bounding box to query shapes by,
     * @param containment If true, then only Shapes entirely contained (Rather
     *                    than simply intersected) will be considered.
     *                    (default false)
     * @param strict If false, then the Shape's bounding box will be used to
     *               classify the Shape, instead of the Shape itself.
     *               (default true)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given AABB.
     * @throws # If AABB is null, or is degenerate.]]></haxe_doc>
		</shapesInAABB>
		<bodiesInAABB public="1" set="method" line="718">
			<f a="aabb:?containment:?strict:?filter:?output" v=":false:true:null:null">
				<c path="nape.geom.AABB"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Bodies given an AABB.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the AABB, whose filter agrees to collide
     * will be considered.
     *
     * @param aabb The bounding box to query bodies by,
     * @param containment If true, then only Bodies entirely contained (Rather
     *                    than simply intersecting) will be considered.
     *                    (default false)
     * @param strict If false, then the body's shape's bounding box will be used to
     *               classify the shapes of the body, instead of the Shape itself.
     *               (default true)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given AABB.
     * @throws # If AABB is null, or is degenerate.]]></haxe_doc>
		</bodiesInAABB>
		<shapesInCircle public="1" set="method" line="744">
			<f a="position:radius:?containment:?filter:?output" v="::false:null:null">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Shapes given a circle.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered.
     *
     * @param position The position of the centre of the circle.
     * @param radius The radius of the circle.
     * @param containment If true, then only Shapes entirely contained (Rather
     *                    than simply intersected) will be considered.
     *                    (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given circle.
     * @throws # If positions is null or disposed of.
     * @throws # If radius is not strictly positive.]]></haxe_doc>
		</shapesInCircle>
		<bodiesInCircle public="1" set="method" line="791">
			<f a="position:radius:?containment:?filter:?output" v="::false:null:null">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Bodies given a circle.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the circle, whose filter agrees to collide
     * will be considered.
     *
     * @param position The position of the centre of the circle.
     * @param radius The radius of the circle.
     * @param containment If true, then only Bodies entirely contained (Rather
     *                    than simply intersecting) will be considered. If a
     *                    filter is supplied, only shapes that agree to collide
     *                    will be used in this containment check.
     *                    (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given circle.
     * @throws # If positions is null or disposed of.
     * @throws # If radius is not strictly positive.]]></haxe_doc>
		</bodiesInCircle>
		<shapesInShape public="1" set="method" line="838">
			<f a="shape:?containment:?filter:?output" v=":false:null:null">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Shapes given another shape.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered. The input shape's own filter
     * is never used in this method. The input shape is considered a purely
     * geometric object.
     * <br/><br/>
     * The input shape must be part of a Body so as to be well defined.
     *
     * @param shape The shape to use in classifying other shapes.
     * @param containment If true, then only Shapes entirely contained (Rather
     *                    than simply intersected) will be considered.
     *                    (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given shape.
     * @throws # If shape is null or not part of a body.
     * @throws # If shape is a polygon, and that polygon is not 'valid']]></haxe_doc>
		</shapesInShape>
		<bodiesInShape public="1" set="method" line="870">
			<f a="shape:?containment:?filter:?output" v=":false:null:null">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Bodies given a shape.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the input shape, whose filter agrees to collide
     * will be considered. The input shape is considered a purely geometric
     * <br/><br/>
     * The input shape must be part of a Body so as to be well defined.
     *
     * @param shape The shape to use in classifying other shapes.
     * @param containment If true, then only Bodies entirely contained (Rather
     *                    than simply intersecting) will be considered.
     *                    (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the bodies for given shape.
     * @throws # If shape is null or not part of a body.
     * @throws # If shape is a polygon, and that polygon is not 'valid']]></haxe_doc>
		</bodiesInShape>
		<shapesInBody public="1" set="method" line="898">
			<f a="body:?filter:?output" v=":null:null">
				<c path="nape.phys.Body"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Shapes given a Body.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered. The input body's shape's own filters
     * are never used in this method. The input body is considered a purely
     * geometric object.
     *
     * @param body The body to use in classifying other shapes.
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given body.
     * @throws # If body is null.
     * @throws # If body has a shape that is a polygon, and that polygon is not 'valid']]></haxe_doc>
		</shapesInBody>
		<bodiesInBody public="1" set="method" line="924">
			<f a="body:?filter:?output" v=":null:null">
				<c path="nape.phys.Body"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Bodies given a Body.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the input body, whose filter agrees to collide
     * will be considered. The input body is considered a purely geometric
     *
     * @param body The body to use in classifying other bodies.
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the bodies for given body.
     * @throws # If body is null.
     * @throws # If body has a shape that is a polygon, and that polygon is not 'valid']]></haxe_doc>
		</bodiesInBody>
		<convexCast public="1" set="method" line="957">
			<f a="shape:deltaTime:?liveSweep:?filter" v="::false:null">
				<c path="nape.shape.Shape"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<t path="Null"><c path="nape.geom.ConvexResult"/></t>
			</f>
			<haxe_doc><![CDATA[* Perform a convex cast for soonest collision.
     * <br/><br/>
     * This method will return only the soonest collision result (if any), to find
     * more than this, use the convexMultiCast method. The shape will not be
     * swept further than the time delta provided.
     * Shapes already intersecting
     * the sweep shape at t = 0 are ignored.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be collidable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * @param shape The Shape to be cast through space. This shape must belong
     *              to a body whose velocity is used to define the sweep.
     * @param deltaTime The amount of time to sweep the shape forward.
     * @param liveSweep If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @return The soonest result (if any) of convex intersection.
     * @throws # If shape is null, or not part of a body.
     * @throws # If deltaTime is negative.]]></haxe_doc>
		</convexCast>
		<convexMultiCast public="1" set="method" line="992">
			<f a="shape:deltaTime:?liveSweep:?filter:output" v="::false:null:">
				<c path="nape.shape.Shape"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.geom.ConvexResultList"/>
				<c path="nape.geom.ConvexResultList"/>
			</f>
			<haxe_doc><![CDATA[* Perform a convex cast for all collisions in time order.
     * <br/><br/>
     * This method will return all collisions, or an empty list if there are none.
     * The shape will not be
     * swept further than the time delta provided. Shapes already intersecting
     * the sweep shape at t = 0 are ignored.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be collidable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * @param shape The Shape to be cast through space. This shape must belong
     *              to a body whose velocity is used to define the sweep.
     * @param deltaTime The amount of time to sweep the shape forward.
     * @param liveSweep If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output A list to append results to instead of allocating a new one (default null)
     * @return The collision results in time order.
     * @throws # If shape is null, or not part of a body.
     * @throws # If deltaTime is negative.]]></haxe_doc>
		</convexMultiCast>
		<rayCast public="1" set="method" line="1023">
			<f a="ray:?inner:?filter" v=":false:null">
				<c path="nape.geom.Ray"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<t path="Null"><c path="nape.geom.RayResult"/></t>
			</f>
			<haxe_doc><![CDATA[* Perform a ray cast for closest result.
     * <br/><br/>
     * This method will return only the closest result (if any), to find more
     * the first result, use the rayMultiCast method. The ray will not be
     * cast beyond its maxDistance.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be intersectable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * @param ray The ray to cast through space.
     * @param inner If true then inner surfaces of shapes will also be intersected.
     *              otherwise only the outer surfaces. (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @return The closest result (if any) of ray intersection.
     * @throws # If ray is null.]]></haxe_doc>
		</rayCast>
		<rayMultiCast public="1" set="method" line="1048">
			<f a="ray:?inner:?filter:?output" v=":false:null:null">
				<c path="nape.geom.Ray"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.geom.RayResultList"/>
				<c path="nape.geom.RayResultList"/>
			</f>
			<haxe_doc><![CDATA[* Perform a ray cast for all valid results.
     * <br/><br/>
     * This method will return all intersections (in distance order) of ray
     * with shapes in the space up to the ray's maxDistance.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be intersectable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * @param ray The ray to cast through space.
     * @param inner If true then inner surfaces of shapes will also be intersected.
     *              otherwise only the outer surfaces. (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output A list to append results to instead of allocating a new one (default null)
     * @return All valid results of ray cast in distance order from closest to furthest.
     * @throws # If ray is null.]]></haxe_doc>
		</rayMultiCast>
		<new public="1" set="method" line="538">
			<f a="?gravity:?broadphase" v="null:null">
				<c path="nape.geom.Vec2"/>
				<c path="nape.space.Broadphase"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Space object.
     *
     * @param gravity The gravity of this space. (default &#40;0,0&#41;)
     * @param broadphase The broadphase type to use. (default DYNAMIC_AABB_TREE)
     * @return The constructed Space object.
     * @throws # If gravity is non-null, and has been disposed of.]]></haxe_doc>
		</new>
		<haxe_doc>* The heart of all Nape simulations.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.util.Debug" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/util/Debug.hx">
		<version public="1" set="method" line="183" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Query Nape version</haxe_doc>
		</version>
		<clearObjectPools public="1" set="method" line="189" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Force clear all object pools, both internal and public.</haxe_doc>
		</clearObjectPools>
		<createGraphic public="1" set="method" line="1091" static="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="flash.display.Shape"/>
			</f>
			<haxe_doc>* Create a flash/openfl||nme Shape representing the given Body.
     *
     * @param body The body to create display Shape for.
     * @return A flash/openfl||nme.display.Shape representing Body.
     * @throws # If body is null.</haxe_doc>
		</createGraphic>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_Debug"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<drawCollisionArbiters public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, a representation of contact patches will be drawn.
     * <br/><br/>
     * Only active arbiters are drawn.
     * @default false]]></haxe_doc>
		</drawCollisionArbiters>
		<drawFluidArbiters public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, a representation of centres of buoyancy and overlap will be drawn.
     * <br/><br/>
     * Only active arbiters are drawn.
     * @default false]]></haxe_doc>
		</drawFluidArbiters>
		<drawSensorArbiters public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, a representation of sensor interactions will be drawn.
     * <br/><br/>
     * Only active arbiters are drawn.
     * @default false]]></haxe_doc>
		</drawSensorArbiters>
		<drawBodies public="1">
			<x path="Bool"/>
			<haxe_doc>* If true, then all bodies in the space (whether active or not) will be drawn.
     * @default true</haxe_doc>
		</drawBodies>
		<drawBodyDetail public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, then things like the body centre of mass, and bouncing box will be drawn.
     * <br/><br/>
     * This will only have an effect if drawBodies is true.
     * @default false]]></haxe_doc>
		</drawBodyDetail>
		<drawShapeDetail public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, then things like shape centre of mass and bounding box will be drawn.
     * <br/><br/>
     * This will only have an effect if drawBodies is true.
     * @default false]]></haxe_doc>
		</drawShapeDetail>
		<drawShapeAngleIndicators public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, then indicators of the shapes rotation will be drawn.
     * <br/><br/>
     * This will only have an effect if drawBodies is true.
     * @default true]]></haxe_doc>
		</drawShapeAngleIndicators>
		<drawConstraints public="1">
			<x path="Bool"/>
			<haxe_doc>* If true, then representations of the active constraints will be drawn.
     * @default false</haxe_doc>
		</drawConstraints>
		<bgColour public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Background colour for debug draw display.
     * <br/><br/>
     * This value does not have much use for ShapeDebug, or for
     * a transparent BitmapDebug but will still be used in tinting
     * object colours to better fit an idealised background colour.]]></haxe_doc>
		</bgColour>
		<get_bgColour get="inline" set="null" line="1191"><f a=""><x path="Int"/></f></get_bgColour>
		<set_bgColour get="inline" set="null" line="1194"><f a="bgColour">
	<x path="Int"/>
	<x path="Int"/>
</f></set_bgColour>
		<colour public="1">
			<t path="Null"><f a="">
	<x path="Int"/>
	<x path="Int"/>
</f></t>
			<haxe_doc><![CDATA[* User defined colour picking.
     * <br/><br/>
     * When not null, this method will be called to decide which colour
     * to use for an object with argument being the id of that object.
     * <br/><br/>
     * The return value should be an RGB value.
     *
     * @default null]]></haxe_doc>
		</colour>
		<display public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObject"/>
			<haxe_doc><![CDATA[* The flash/openfl||nme native display object representing debug draw.
     * <br/><br/>
     * When using debug drawer, you should add this to your display list.]]></haxe_doc>
		</display>
		<get_display get="inline" set="null" line="1239"><f a=""><c path="flash.display.DisplayObject"/></f></get_display>
		<cullingEnabled public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* When true, objects outside the debug draw screen will not be drawn.
     * <br/><br/>
     * The debug draw screen is defined as the rectangle (0,0) -> (width,height).
     * To 'move' the debug draw screen in your world, you should modify the transform
     * property.
     * <br/><br/>
     * This culling has a cost, so is not worth enabling if everything is always on
     * screen anyways.
     *
     * @default false]]></haxe_doc>
		</cullingEnabled>
		<transform public="1" get="accessor" set="accessor">
			<c path="nape.geom.Mat23"/>
			<haxe_doc><![CDATA[* Transformation to apply to all debug draw operations.
     * <br/><br/>
     * This transform can be used to 'move' the debug draw screen through your
     * world as well as rotating and zooming in etc.
     * <br/><br/>
     * This transform effects 'all' debug draw operations and optimisation is in
     * place to not perform any transformation if matrix is the identity matrix.
     *
     * @default new Mat23()]]></haxe_doc>
		</transform>
		<get_transform get="inline" set="null" line="1273"><f a=""><c path="nape.geom.Mat23"/></f></get_transform>
		<set_transform get="inline" set="null" line="1277"><f a="transform">
	<c path="nape.geom.Mat23"/>
	<c path="nape.geom.Mat23"/>
</f></set_transform>
		<clear public="1" set="method" line="1289">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the debug view.</haxe_doc>
		</clear>
		<flush public="1" set="method" line="1295">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Flush any pending draw operations to debug view.
     * <br/><br/>
     * This operation is not needed for ShapeDebug at present.]]></haxe_doc>
		</flush>
		<draw public="1" set="method" line="1310">
			<f a="object">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draw a Nape object to debug draw.
     * <br/><br/>
     * Possible argument types are: <code>Space, Compound, Body, Shape, Constraint</code>
     * <br/><br/>
     * To draw a Shape it must be part of a Body.
     * <br/><br/>
     * Debug draw settings like 'drawBodies' are overriden by a direct call to draw
     * with a Body or Shape. Equally even if drawConstraints is false, should
     * you call draw with a Constraint object directly it will be drawn regardless.
     *
     * @param object The object to draw.
     * @throws # If object is null or not of the expected Type.]]></haxe_doc>
		</draw>
		<drawLine public="1" set="method" line="1321">
			<f a="start:end:colour">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draw a line segment.
     * <br/><br/>
     * This line will be drawn with no thickness.
     *
     * @param start The start point of line segment.
     * @param end   The end point of line segment.
     * @param colour The colour of line in RGB.
     * @throws # If either start or end are null or disposed of.]]></haxe_doc>
		</drawLine>
		<drawCurve public="1" set="method" line="1333">
			<f a="start:control:end:colour">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draw quadratic bezier curve.
     * <br/><br/>
     * This curve will be drawn with no thickness.
     *
     * @param start The start point of curve.
     * @param control The control point for curve.
     * @param end The end point of curve.
     * @param colour The colour of curve in RGB.
     * @throws # If any Vec2 argument is null or disposed of.]]></haxe_doc>
		</drawCurve>
		<drawCircle public="1" set="method" line="1346">
			<f a="position:radius:colour">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draw circle.
     * <br/><br/>
     * This circle will be drawn with no thickness or fill.
     *
     * @param position The position of circle centre.
     * @param radius The radius of the circle.
     * @param colour The colour of circle in RGB.
     * @throws # If position is null or disposed of.
     * @throws # If radius is negative.
     * @throws # If transform is not equiorthogonal.]]></haxe_doc>
		</drawCircle>
		<drawAABB public="1" set="method" line="1356">
			<f a="aabb:colour">
				<c path="nape.geom.AABB"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draw AABB.
     * <br/><br/>
     * This AABB will be drawn with no thickness or fill.
     *
     * @param aabb The AABB to draw.
     * @param colour The colour to draw AABB with in RGB.
     * @throws # If AABB is null.]]></haxe_doc>
		</drawAABB>
		<drawFilledTriangle public="1" set="method" line="1368">
			<f a="p0:p1:p2:colour">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draw filled triangle.
     * <br/><br/>
     * This triangle will be drawn with no edges, only a solid fill.
     *
     * @param p0 The first point in triangle.
     * @param p1 The second point in triangle.
     * @param p2 The third point in triangle.
     * @param colour The colour to draw triangle with in RGB.
     * @throws # If any point argument is null or disposed of.]]></haxe_doc>
		</drawFilledTriangle>
		<drawFilledCircle public="1" set="method" line="1381">
			<f a="position:radius:colour">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draw filled circle.
     * <br/><br/>
     * This circle will be drawn with no edges, only a solid fill.
     *
     * @param position The position of centre of circle.
     * @param radius The radius of circle.
     * @param colour The colour to draw circle with in RGB.
     * @throws # If position is null or disposed of.
     * @throws # If radius is negative.
     * @throws # If transform is not equiorthogonal.]]></haxe_doc>
		</drawFilledCircle>
		<drawPolygon public="1" set="method" line="1395">
			<f a="polygon:colour">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draw polygon.
     * <br/><br/>
     * This polygon will be drawn with no thickness or fill.
     * <br/><br/>
     * The polygon argument is typed Dynamic and may be one of:
     * <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
     *
     * @param polygon The polygon to draw.
     * @param colour The colour to draw polygon with in RGB.
     * @throws # If polygon is null, or not of expected type.
     * @throws # If polygon contains disposed Vec2.]]></haxe_doc>
		</drawPolygon>
		<drawFilledPolygon public="1" set="method" line="1409">
			<f a="polygon:colour">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draw filled polygon.
     * <br/><br/>
     * This polygon will be drawn no edges, only a solid fill.
     * <br/><br/>
     * The polygon argument is typed Dynamic and may be one of:
     * <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
     *
     * @param polygon The polygon to draw.
     * @param colour The colour to draw polygon with in RGB.
     * @throws # If polygon is null, or not of expected type.
     * @throws # If polygon contains disposed Vec2.]]></haxe_doc>
		</drawFilledPolygon>
		<drawSpring public="1" set="method" line="1423">
			<f a="start:end:colour:?coils:?radius" v=":::3:3.0f">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draw linear spring.
     * <br/><br/>
     * This spring will be drawn with no thickness.
     *
     * @param start The start point of spring.
     * @param end The end point of spring.
     * @param colour The colour of spring in RGB.
     * @param coils The number of coils in spring. (default 3)
     * @param radius The radius of spring. (default 3.0)
     * @throws # If start or end are either null or disposed of.
     * @throws # If number of coils is negative.]]></haxe_doc>
		</drawSpring>
		<new public="1" set="method" line="1217">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Debug class providing general utilities
 * <br/><br/>
 * Also serves as the base type for Debug draws.]]></haxe_doc>
	</class>
	<class path="nape.util.ShapeDebug" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/nape/util/ShapeDebug.hx">
		<extends path="nape.util.Debug"/>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.util.ZPP_ShapeDebug"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<thickness public="1">
			<x path="Float"/>
			<haxe_doc>* Thickness to draw lines with.
     * @default 0.1</haxe_doc>
		</thickness>
		<clear public="1" set="method" line="231" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</clear>
		<drawLine public="1" set="method" line="237" override="1">
			<f a="start:end:colour">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</drawLine>
		<drawCurve public="1" set="method" line="295" override="1">
			<f a="start:control:end:colour">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</drawCurve>
		<drawCircle public="1" set="method" line="372" override="1">
			<f a="position:radius:colour">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</drawCircle>
		<drawAABB public="1" set="method" line="410" override="1">
			<f a="aabb:colour">
				<c path="nape.geom.AABB"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</drawAABB>
		<drawFilledTriangle public="1" set="method" line="441" override="1">
			<f a="p0:p1:p2:colour">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</drawFilledTriangle>
		<drawFilledCircle public="1" set="method" line="520" override="1">
			<f a="position:radius:colour">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</drawFilledCircle>
		<drawPolygon public="1" set="method" line="560" override="1">
			<f a="polygon:colour">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</drawPolygon>
		<drawFilledPolygon public="1" set="method" line="874" override="1">
			<f a="polygon:colour">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</drawFilledPolygon>
		<draw public="1" set="method" line="1190" override="1">
			<f a="object">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</draw>
		<drawSpring public="1" set="method" line="1223" override="1">
			<f a="start:end:colour:?coils:?radius" v=":::3:3.0f">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</drawSpring>
		<new public="1" set="method" line="207">
			<f a="width:height:?bgColour" v="::3355443">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct new ShapeDebug with given viewport size and backgruond.
     * <br/><br/>
     * Background colour does not have much weight for a ShapeDebug which
     * always has a transparent background, but serves to bias the colours
     * chosen for drawing objects.
     *
     * @param width The width of Debug draw viewport.
     * @param height The height of Debug draw viewport.
     * @param bgColour the background colour for debug draw. (default 0x333333)
     * @return The constructed ShapeDebug.
     * @throws # If width or height are not strictly positive.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Implementation of nape debug draw using flash/openfl||nme graphics API.
 * <br/><br/>
 * This debug draw is slower than BitmapDebug which is available in flash10+
 * however the BitmapDebug draw makes use of Alchemy opcodes so you may wish
 * not to use it if you are also using Stage3D and do not wish to be subject
 * to Adobe licensing.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="openfl.AssetCache" params="" file="C:\HaxeToolkit\haxe\lib/openfl/1,4,0/openfl/Assets.hx" module="openfl.Assets">
		<bitmapData public="1"><x path="Map">
	<c path="String"/>
	<c path="flash.display.BitmapData"/>
</x></bitmapData>
		<enabled public="1"><x path="Bool"/></enabled>
		<font public="1"><x path="Map">
	<c path="String"/>
	<c path="flash.text.Font"/>
</x></font>
		<sound public="1"><x path="Map">
	<c path="String"/>
	<c path="flash.media.Sound"/>
</x></sound>
		<clear public="1" set="method" line="1300"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="1291"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.Assets" params="" file="C:\HaxeToolkit\haxe\lib/openfl/1,4,0/openfl/Assets.hx">
		<cache public="1" line="36" static="1"><c path="openfl.AssetCache"/></cache>
		<libraries public="1" set="null" line="37" static="1"><x path="Map">
	<c path="String"/>
	<c path="openfl.AssetLibrary"/>
</x></libraries>
		<initialized line="39" static="1"><x path="Bool"/></initialized>
		<exists public="1" set="method" line="42" static="1"><f a="id:?type" v=":null">
	<c path="String"/>
	<e path="openfl.AssetType"/>
	<x path="Bool"/>
</f></exists>
		<getBitmapData public="1" set="method" line="78" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap(Assets.getBitmapData("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache(Default: true)
	 * @return		A new BitmapData object</haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="147" static="1">
			<f a="id">
				<c path="String"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="196" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="flash.text.Font"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getLibrary set="method" line="253" static="1"><f a="name">
	<c path="String"/>
	<c path="openfl.AssetLibrary"/>
</f></getLibrary>
		<getMovieClip public="1" set="method" line="272" static="1">
			<f a="id">
				<c path="String"/>
				<c path="flash.display.MovieClip"/>
			</f>
			<haxe_doc>* Gets an instance of a library MovieClip
	 * @usage		var movieClip = Assets.getMovieClip("library:BouncingBall");
	 * @param	id		The library and ID for the MovieClip
	 * @return		A new Sound object</haxe_doc>
		</getMovieClip>
		<getMusic public="1" set="method" line="321" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="flash.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded streaming sound
	 * @usage		var sound = Assets.getMusic("sound.ogg");
	 * @param	id		The ID or asset path for the music track
	 * @return		A new Sound object</haxe_doc>
		</getMusic>
		<getPath public="1" set="method" line="390" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets the file path (if available) for an asset
	 * @usage		var path = Assets.getPath("image.jpg");
	 * @param	id		The ID or asset path for the asset
	 * @return		The path to the asset (or null)</haxe_doc>
		</getPath>
		<getSound public="1" set="method" line="431" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="flash.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getSound>
		<getText public="1" set="method" line="500" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<initialize set="method" line="543" static="1"><f a=""><x path="Void"/></f></initialize>
		<isLocal public="1" set="method" line="560" static="1"><f a="id:?type:?useCache" v=":null:true">
	<c path="String"/>
	<e path="openfl.AssetType"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></isLocal>
		<isValidBitmapData set="method" line="605" static="1"><f a="bitmapData">
	<c path="flash.display.BitmapData"/>
	<x path="Bool"/>
</f></isValidBitmapData>
		<isValidSound set="method" line="636" static="1"><f a="sound">
	<c path="flash.media.Sound"/>
	<x path="Bool"/>
</f></isValidSound>
		<loadBitmapData public="1" set="method" line="651" static="1"><f a="id:handler:?useCache" v="::true">
	<c path="String"/>
	<f a="">
		<c path="flash.display.BitmapData"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></loadBitmapData>
		<loadBytes public="1" set="method" line="714" static="1"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="flash.utils.ByteArray"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBytes>
		<loadFont public="1" set="method" line="750" static="1"><f a="id:handler:?useCache" v="::true">
	<c path="String"/>
	<f a="">
		<c path="flash.text.Font"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></loadFont>
		<loadLibrary public="1" set="method" line="807" static="1"><f a="name:handler">
	<c path="String"/>
	<f a="">
		<c path="openfl.AssetLibrary"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadLibrary>
		<loadMusic public="1" set="method" line="835" static="1"><f a="id:handler:?useCache" v="::true">
	<c path="String"/>
	<f a="">
		<c path="flash.media.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></loadMusic>
		<loadMovieClip public="1" set="method" line="898" static="1"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="flash.display.MovieClip"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMovieClip>
		<loadSound public="1" set="method" line="934" static="1"><f a="id:handler:?useCache" v="::true">
	<c path="String"/>
	<f a="">
		<c path="flash.media.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></loadSound>
		<loadText public="1" set="method" line="997" static="1"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadText>
		<registerLibrary public="1" set="method" line="1033" static="1"><f a="name:library">
	<c path="String"/>
	<c path="openfl.AssetLibrary"/>
	<x path="Void"/>
</f></registerLibrary>
		<resolveClass set="method" line="1046" static="1"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<resolveEnum set="method" line="1053" static="1"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
		<unloadLibrary public="1" set="method" line="1072" static="1"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></unloadLibrary>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the OpenFL command-line tools, based on the
 * contents of the *.nmml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>]]></haxe_doc>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl.AssetLibrary" params="" file="C:\HaxeToolkit\haxe\lib/openfl/1,4,0/openfl/Assets.hx" module="openfl.Assets">
		<exists public="1" set="method" line="1113"><f a="id:type">
	<c path="String"/>
	<e path="openfl.AssetType"/>
	<x path="Bool"/>
</f></exists>
		<getBitmapData public="1" set="method" line="1120"><f a="id">
	<c path="String"/>
	<c path="flash.display.BitmapData"/>
</f></getBitmapData>
		<getBytes public="1" set="method" line="1127"><f a="id">
	<c path="String"/>
	<c path="flash.utils.ByteArray"/>
</f></getBytes>
		<getFont public="1" set="method" line="1134"><f a="id">
	<c path="String"/>
	<c path="flash.text.Font"/>
</f></getFont>
		<getMovieClip public="1" set="method" line="1141"><f a="id">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></getMovieClip>
		<getMusic public="1" set="method" line="1148"><f a="id">
	<c path="String"/>
	<c path="flash.media.Sound"/>
</f></getMusic>
		<getPath public="1" set="method" line="1155"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<getSound public="1" set="method" line="1162"><f a="id">
	<c path="String"/>
	<c path="flash.media.Sound"/>
</f></getSound>
		<getText public="1" set="method" line="1169"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getText>
		<isLocal public="1" set="method" line="1194"><f a="id:type">
	<c path="String"/>
	<e path="openfl.AssetType"/>
	<x path="Bool"/>
</f></isLocal>
		<load set="method" line="1201"><f a="handler">
	<f a="">
		<c path="openfl.AssetLibrary"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<loadBitmapData public="1" set="method" line="1208"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="flash.display.BitmapData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmapData>
		<loadBytes public="1" set="method" line="1215"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="flash.utils.ByteArray"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBytes>
		<loadFont public="1" set="method" line="1222"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="flash.text.Font"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadFont>
		<loadMovieClip public="1" set="method" line="1229"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="flash.display.MovieClip"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMovieClip>
		<loadMusic public="1" set="method" line="1236"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="flash.media.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMusic>
		<loadSound public="1" set="method" line="1243"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="flash.media.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadSound>
		<loadText public="1" set="method" line="1250"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadText>
		<new public="1" set="method" line="1106"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.AssetData" params="" file="C:\HaxeToolkit\haxe\lib/openfl/1,4,0/openfl/Assets.hx" module="openfl.Assets">
		<id public="1"><c path="String"/></id>
		<path public="1"><c path="String"/></path>
		<type public="1"><e path="openfl.AssetType"/></type>
		<new public="1" set="method" line="1319"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="openfl.AssetType" params="" file="C:\HaxeToolkit\haxe\lib/openfl/1,4,0/openfl/Assets.hx" module="openfl.Assets">
		<BINARY/>
		<FONT/>
		<IMAGE/>
		<MOVIE_CLIP/>
		<MUSIC/>
		<SOUND/>
		<TEMPLATE/>
		<TEXT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.display.DirectRenderer" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/display/DirectRenderer.hx">
		<extends path="flash.display.DisplayObject"/>
		<lime_direct_renderer_create line="44" static="1"><f a=""><unknown/></f></lime_direct_renderer_create>
		<lime_direct_renderer_set line="45" static="1"><f a=":">
	<d/>
	<f a="rect">
		<d/>
		<x path="Void"/>
	</f>
	<unknown/>
</f></lime_direct_renderer_set>
		<render public="1" set="dynamic" line="23"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></render>
		<__onRender set="method" line="30">
			<f a="rect">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onRender>
		<new public="1" set="method" line="13"><f a="?type" v="'DirectRenderer'">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.display.ManagedStage" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/display/ManagedStage.hx">
		<extends path="flash.display.Stage"/>
		<etUnknown public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></etUnknown>
		<etKeyDown public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></etKeyDown>
		<etChar public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></etChar>
		<etKeyUp public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></etKeyUp>
		<etMouseMove public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></etMouseMove>
		<etMouseDown public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></etMouseDown>
		<etMouseClick public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></etMouseClick>
		<etMouseUp public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></etMouseUp>
		<etResize public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></etResize>
		<etPoll public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></etPoll>
		<etQuit public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></etQuit>
		<etFocus public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></etFocus>
		<etShouldRotate public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></etShouldRotate>
		<etDestroyHandler public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></etDestroyHandler>
		<etRedraw public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></etRedraw>
		<etTouchBegin public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></etTouchBegin>
		<etTouchMove public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></etTouchMove>
		<etTouchEnd public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></etTouchEnd>
		<etTouchTap public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></etTouchTap>
		<etChange public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></etChange>
		<efLeftDown public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></efLeftDown>
		<efShiftDown public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></efShiftDown>
		<efCtrlDown public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></efCtrlDown>
		<efAltDown public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></efAltDown>
		<efCommandDown public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></efCommandDown>
		<efMiddleDown public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></efMiddleDown>
		<efRightDown public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></efRightDown>
		<efLocationRight public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></efLocationRight>
		<efPrimaryTouch public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></efPrimaryTouch>
		<lime_managed_stage_create line="119" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_managed_stage_create>
		<lime_managed_stage_pump_event line="120" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></lime_managed_stage_pump_event>
		<beginRender public="1" set="dynamic" line="49"><f a=""><x path="Void"/></f></beginRender>
		<endRender public="1" set="dynamic" line="56"><f a=""><x path="Void"/></f></endRender>
		<pumpEvent public="1" set="method" line="63"><f a="event">
	<d/>
	<x path="Void"/>
</f></pumpEvent>
		<resize public="1" set="method" line="70" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<sendQuit public="1" set="method" line="77"><f a=""><x path="Void"/></f></sendQuit>
		<setNextWake public="1" set="dynamic" line="84"><f a="delay">
	<x path="Float"/>
	<x path="Void"/>
</f></setNextWake>
		<__doProcessStageEvent set="method" line="91" override="1">
			<f a="event">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__doProcessStageEvent>
		<__render public="1" set="method" line="103" override="1">
			<f a="sendEnterFrame">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__render>
		<new public="1" set="method" line="42"><f a="width:height:?flags" v="::0">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.display.OpenGLView" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/display/OpenGLView.hx">
		<extends path="openfl.display.DirectRenderer"/>
		<CONTEXT_LOST public="1" get="inline" set="null" line="11" static="1"><c path="String"/></CONTEXT_LOST>
		<CONTEXT_RESTORED public="1" get="inline" set="null" line="12" static="1"><c path="String"/></CONTEXT_RESTORED>
		<isSupported public="1" get="accessor" set="null" static="1"><x path="Bool"/></isSupported>
		<get_isSupported get="inline" set="null" line="31" static="1"><f a=""><x path="Bool"/></f></get_isSupported>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.events.JoystickEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/events/JoystickEvent.hx">
		<extends path="flash.events.Event"/>
		<AXIS_MOVE public="1" get="inline" set="null" line="10" static="1"><c path="String"/></AXIS_MOVE>
		<BALL_MOVE public="1" get="inline" set="null" line="11" static="1"><c path="String"/></BALL_MOVE>
		<BUTTON_DOWN public="1" get="inline" set="null" line="12" static="1"><c path="String"/></BUTTON_DOWN>
		<BUTTON_UP public="1" get="inline" set="null" line="13" static="1"><c path="String"/></BUTTON_UP>
		<HAT_MOVE public="1" get="inline" set="null" line="14" static="1"><c path="String"/></HAT_MOVE>
		<DEVICE_ADDED public="1" get="inline" set="null" line="15" static="1"><c path="String"/></DEVICE_ADDED>
		<DEVICE_REMOVED public="1" get="inline" set="null" line="16" static="1"><c path="String"/></DEVICE_REMOVED>
		<axis public="1"><c path="Array"><x path="Float"/></c></axis>
		<device public="1"><x path="Int"/></device>
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<clone public="1" set="method" line="40" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="47" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="25"><f a="type:?bubbles:?cancelable:?device:?id:?x:?y:?z" v=":false:false:0:0:0:0:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.SystemEvent" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/events/SystemEvent.hx">
		<extends path="flash.events.Event"/>
		<SYSTEM public="1" line="10" static="1"><c path="String"/></SYSTEM>
		<data public="1" set="null"><x path="Int"/></data>
		<clone public="1" set="method" line="23" override="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<toString public="1" set="method" line="30" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="15"><f a="type:?bubbles:?cancelable:?data" v=":false:false:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.gl.GL" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GL.hx">
		<DEPTH_BUFFER_BIT public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></DEPTH_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></STENCIL_BUFFER_BIT>
		<COLOR_BUFFER_BIT public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></COLOR_BUFFER_BIT>
		<POINTS public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></POINTS>
		<LINES public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></LINES>
		<LINE_LOOP public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></LINE_LOOP>
		<LINE_STRIP public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></LINE_STRIP>
		<TRIANGLES public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></TRIANGLES>
		<TRIANGLE_STRIP public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></TRIANGLE_FAN>
		<ZERO public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></ZERO>
		<ONE public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></ONE>
		<SRC_COLOR public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" line="47" static="1"><x path="Int"/></DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" get="inline" set="null" line="53" static="1"><x path="Int"/></DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" line="54" static="1"><x path="Int"/></ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" line="55" static="1"><x path="Int"/></SRC_ALPHA_SATURATE>
		<FUNC_ADD public="1" get="inline" set="null" line="61" static="1"><x path="Int"/></FUNC_ADD>
		<BLEND_EQUATION public="1" get="inline" set="null" line="62" static="1"><x path="Int"/></BLEND_EQUATION>
		<BLEND_EQUATION_RGB public="1" get="inline" set="null" line="63" static="1"><x path="Int"/></BLEND_EQUATION_RGB>
		<BLEND_EQUATION_ALPHA public="1" get="inline" set="null" line="64" static="1"><x path="Int"/></BLEND_EQUATION_ALPHA>
		<FUNC_SUBTRACT public="1" get="inline" set="null" line="67" static="1"><x path="Int"/></FUNC_SUBTRACT>
		<FUNC_REVERSE_SUBTRACT public="1" get="inline" set="null" line="68" static="1"><x path="Int"/></FUNC_REVERSE_SUBTRACT>
		<BLEND_DST_RGB public="1" get="inline" set="null" line="71" static="1"><x path="Int"/></BLEND_DST_RGB>
		<BLEND_SRC_RGB public="1" get="inline" set="null" line="72" static="1"><x path="Int"/></BLEND_SRC_RGB>
		<BLEND_DST_ALPHA public="1" get="inline" set="null" line="73" static="1"><x path="Int"/></BLEND_DST_ALPHA>
		<BLEND_SRC_ALPHA public="1" get="inline" set="null" line="74" static="1"><x path="Int"/></BLEND_SRC_ALPHA>
		<CONSTANT_COLOR public="1" get="inline" set="null" line="75" static="1"><x path="Int"/></CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1" get="inline" set="null" line="76" static="1"><x path="Int"/></ONE_MINUS_CONSTANT_COLOR>
		<CONSTANT_ALPHA public="1" get="inline" set="null" line="77" static="1"><x path="Int"/></CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1" get="inline" set="null" line="78" static="1"><x path="Int"/></ONE_MINUS_CONSTANT_ALPHA>
		<BLEND_COLOR public="1" get="inline" set="null" line="79" static="1"><x path="Int"/></BLEND_COLOR>
		<ARRAY_BUFFER public="1" get="inline" set="null" line="82" static="1"><x path="Int"/></ARRAY_BUFFER>
		<ELEMENT_ARRAY_BUFFER public="1" get="inline" set="null" line="83" static="1"><x path="Int"/></ELEMENT_ARRAY_BUFFER>
		<ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="84" static="1"><x path="Int"/></ARRAY_BUFFER_BINDING>
		<ELEMENT_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="85" static="1"><x path="Int"/></ELEMENT_ARRAY_BUFFER_BINDING>
		<STREAM_DRAW public="1" get="inline" set="null" line="87" static="1"><x path="Int"/></STREAM_DRAW>
		<STATIC_DRAW public="1" get="inline" set="null" line="88" static="1"><x path="Int"/></STATIC_DRAW>
		<DYNAMIC_DRAW public="1" get="inline" set="null" line="89" static="1"><x path="Int"/></DYNAMIC_DRAW>
		<BUFFER_SIZE public="1" get="inline" set="null" line="91" static="1"><x path="Int"/></BUFFER_SIZE>
		<BUFFER_USAGE public="1" get="inline" set="null" line="92" static="1"><x path="Int"/></BUFFER_USAGE>
		<CURRENT_VERTEX_ATTRIB public="1" get="inline" set="null" line="94" static="1"><x path="Int"/></CURRENT_VERTEX_ATTRIB>
		<FRONT public="1" get="inline" set="null" line="97" static="1"><x path="Int"/></FRONT>
		<BACK public="1" get="inline" set="null" line="98" static="1"><x path="Int"/></BACK>
		<FRONT_AND_BACK public="1" get="inline" set="null" line="99" static="1"><x path="Int"/></FRONT_AND_BACK>
		<CULL_FACE public="1" get="inline" set="null" line="112" static="1"><x path="Int"/></CULL_FACE>
		<BLEND public="1" get="inline" set="null" line="113" static="1"><x path="Int"/></BLEND>
		<DITHER public="1" get="inline" set="null" line="114" static="1"><x path="Int"/></DITHER>
		<STENCIL_TEST public="1" get="inline" set="null" line="115" static="1"><x path="Int"/></STENCIL_TEST>
		<DEPTH_TEST public="1" get="inline" set="null" line="116" static="1"><x path="Int"/></DEPTH_TEST>
		<SCISSOR_TEST public="1" get="inline" set="null" line="117" static="1"><x path="Int"/></SCISSOR_TEST>
		<POLYGON_OFFSET_FILL public="1" get="inline" set="null" line="118" static="1"><x path="Int"/></POLYGON_OFFSET_FILL>
		<SAMPLE_ALPHA_TO_COVERAGE public="1" get="inline" set="null" line="119" static="1"><x path="Int"/></SAMPLE_ALPHA_TO_COVERAGE>
		<SAMPLE_COVERAGE public="1" get="inline" set="null" line="120" static="1"><x path="Int"/></SAMPLE_COVERAGE>
		<NO_ERROR public="1" get="inline" set="null" line="123" static="1"><x path="Int"/></NO_ERROR>
		<INVALID_ENUM public="1" get="inline" set="null" line="124" static="1"><x path="Int"/></INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" line="125" static="1"><x path="Int"/></INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" line="126" static="1"><x path="Int"/></INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" line="127" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<CW public="1" get="inline" set="null" line="130" static="1"><x path="Int"/></CW>
		<CCW public="1" get="inline" set="null" line="131" static="1"><x path="Int"/></CCW>
		<LINE_WIDTH public="1" get="inline" set="null" line="134" static="1"><x path="Int"/></LINE_WIDTH>
		<ALIASED_POINT_SIZE_RANGE public="1" get="inline" set="null" line="135" static="1"><x path="Int"/></ALIASED_POINT_SIZE_RANGE>
		<ALIASED_LINE_WIDTH_RANGE public="1" get="inline" set="null" line="136" static="1"><x path="Int"/></ALIASED_LINE_WIDTH_RANGE>
		<CULL_FACE_MODE public="1" get="inline" set="null" line="137" static="1"><x path="Int"/></CULL_FACE_MODE>
		<FRONT_FACE public="1" get="inline" set="null" line="138" static="1"><x path="Int"/></FRONT_FACE>
		<DEPTH_RANGE public="1" get="inline" set="null" line="139" static="1"><x path="Int"/></DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1" get="inline" set="null" line="140" static="1"><x path="Int"/></DEPTH_WRITEMASK>
		<DEPTH_CLEAR_VALUE public="1" get="inline" set="null" line="141" static="1"><x path="Int"/></DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1" get="inline" set="null" line="142" static="1"><x path="Int"/></DEPTH_FUNC>
		<STENCIL_CLEAR_VALUE public="1" get="inline" set="null" line="143" static="1"><x path="Int"/></STENCIL_CLEAR_VALUE>
		<STENCIL_FUNC public="1" get="inline" set="null" line="144" static="1"><x path="Int"/></STENCIL_FUNC>
		<STENCIL_FAIL public="1" get="inline" set="null" line="145" static="1"><x path="Int"/></STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_FAIL public="1" get="inline" set="null" line="146" static="1"><x path="Int"/></STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1" get="inline" set="null" line="147" static="1"><x path="Int"/></STENCIL_PASS_DEPTH_PASS>
		<STENCIL_REF public="1" get="inline" set="null" line="148" static="1"><x path="Int"/></STENCIL_REF>
		<STENCIL_VALUE_MASK public="1" get="inline" set="null" line="149" static="1"><x path="Int"/></STENCIL_VALUE_MASK>
		<STENCIL_WRITEMASK public="1" get="inline" set="null" line="150" static="1"><x path="Int"/></STENCIL_WRITEMASK>
		<STENCIL_BACK_FUNC public="1" get="inline" set="null" line="151" static="1"><x path="Int"/></STENCIL_BACK_FUNC>
		<STENCIL_BACK_FAIL public="1" get="inline" set="null" line="152" static="1"><x path="Int"/></STENCIL_BACK_FAIL>
		<STENCIL_BACK_PASS_DEPTH_FAIL public="1" get="inline" set="null" line="153" static="1"><x path="Int"/></STENCIL_BACK_PASS_DEPTH_FAIL>
		<STENCIL_BACK_PASS_DEPTH_PASS public="1" get="inline" set="null" line="154" static="1"><x path="Int"/></STENCIL_BACK_PASS_DEPTH_PASS>
		<STENCIL_BACK_REF public="1" get="inline" set="null" line="155" static="1"><x path="Int"/></STENCIL_BACK_REF>
		<STENCIL_BACK_VALUE_MASK public="1" get="inline" set="null" line="156" static="1"><x path="Int"/></STENCIL_BACK_VALUE_MASK>
		<STENCIL_BACK_WRITEMASK public="1" get="inline" set="null" line="157" static="1"><x path="Int"/></STENCIL_BACK_WRITEMASK>
		<VIEWPORT public="1" get="inline" set="null" line="158" static="1"><x path="Int"/></VIEWPORT>
		<SCISSOR_BOX public="1" get="inline" set="null" line="159" static="1"><x path="Int"/></SCISSOR_BOX>
		<COLOR_CLEAR_VALUE public="1" get="inline" set="null" line="161" static="1"><x path="Int"/></COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1" get="inline" set="null" line="162" static="1"><x path="Int"/></COLOR_WRITEMASK>
		<UNPACK_ALIGNMENT public="1" get="inline" set="null" line="163" static="1"><x path="Int"/></UNPACK_ALIGNMENT>
		<PACK_ALIGNMENT public="1" get="inline" set="null" line="164" static="1"><x path="Int"/></PACK_ALIGNMENT>
		<MAX_TEXTURE_SIZE public="1" get="inline" set="null" line="165" static="1"><x path="Int"/></MAX_TEXTURE_SIZE>
		<MAX_VIEWPORT_DIMS public="1" get="inline" set="null" line="166" static="1"><x path="Int"/></MAX_VIEWPORT_DIMS>
		<SUBPIXEL_BITS public="1" get="inline" set="null" line="167" static="1"><x path="Int"/></SUBPIXEL_BITS>
		<RED_BITS public="1" get="inline" set="null" line="168" static="1"><x path="Int"/></RED_BITS>
		<GREEN_BITS public="1" get="inline" set="null" line="169" static="1"><x path="Int"/></GREEN_BITS>
		<BLUE_BITS public="1" get="inline" set="null" line="170" static="1"><x path="Int"/></BLUE_BITS>
		<ALPHA_BITS public="1" get="inline" set="null" line="171" static="1"><x path="Int"/></ALPHA_BITS>
		<DEPTH_BITS public="1" get="inline" set="null" line="172" static="1"><x path="Int"/></DEPTH_BITS>
		<STENCIL_BITS public="1" get="inline" set="null" line="173" static="1"><x path="Int"/></STENCIL_BITS>
		<POLYGON_OFFSET_UNITS public="1" get="inline" set="null" line="174" static="1"><x path="Int"/></POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_FACTOR public="1" get="inline" set="null" line="176" static="1"><x path="Int"/></POLYGON_OFFSET_FACTOR>
		<TEXTURE_BINDING_2D public="1" get="inline" set="null" line="177" static="1"><x path="Int"/></TEXTURE_BINDING_2D>
		<SAMPLE_BUFFERS public="1" get="inline" set="null" line="178" static="1"><x path="Int"/></SAMPLE_BUFFERS>
		<SAMPLES public="1" get="inline" set="null" line="179" static="1"><x path="Int"/></SAMPLES>
		<SAMPLE_COVERAGE_VALUE public="1" get="inline" set="null" line="180" static="1"><x path="Int"/></SAMPLE_COVERAGE_VALUE>
		<SAMPLE_COVERAGE_INVERT public="1" get="inline" set="null" line="181" static="1"><x path="Int"/></SAMPLE_COVERAGE_INVERT>
		<COMPRESSED_TEXTURE_FORMATS public="1" get="inline" set="null" line="188" static="1"><x path="Int"/></COMPRESSED_TEXTURE_FORMATS>
		<DONT_CARE public="1" get="inline" set="null" line="191" static="1"><x path="Int"/></DONT_CARE>
		<FASTEST public="1" get="inline" set="null" line="192" static="1"><x path="Int"/></FASTEST>
		<NICEST public="1" get="inline" set="null" line="193" static="1"><x path="Int"/></NICEST>
		<GENERATE_MIPMAP_HINT public="1" get="inline" set="null" line="196" static="1"><x path="Int"/></GENERATE_MIPMAP_HINT>
		<BYTE public="1" get="inline" set="null" line="199" static="1"><x path="Int"/></BYTE>
		<UNSIGNED_BYTE public="1" get="inline" set="null" line="200" static="1"><x path="Int"/></UNSIGNED_BYTE>
		<SHORT public="1" get="inline" set="null" line="201" static="1"><x path="Int"/></SHORT>
		<UNSIGNED_SHORT public="1" get="inline" set="null" line="202" static="1"><x path="Int"/></UNSIGNED_SHORT>
		<INT public="1" get="inline" set="null" line="203" static="1"><x path="Int"/></INT>
		<UNSIGNED_INT public="1" get="inline" set="null" line="204" static="1"><x path="Int"/></UNSIGNED_INT>
		<FLOAT public="1" get="inline" set="null" line="205" static="1"><x path="Int"/></FLOAT>
		<DEPTH_COMPONENT public="1" get="inline" set="null" line="208" static="1"><x path="Int"/></DEPTH_COMPONENT>
		<ALPHA public="1" get="inline" set="null" line="209" static="1"><x path="Int"/></ALPHA>
		<RGB public="1" get="inline" set="null" line="210" static="1"><x path="Int"/></RGB>
		<RGBA public="1" get="inline" set="null" line="211" static="1"><x path="Int"/></RGBA>
		<LUMINANCE public="1" get="inline" set="null" line="212" static="1"><x path="Int"/></LUMINANCE>
		<LUMINANCE_ALPHA public="1" get="inline" set="null" line="213" static="1"><x path="Int"/></LUMINANCE_ALPHA>
		<UNSIGNED_SHORT_4_4_4_4 public="1" get="inline" set="null" line="217" static="1"><x path="Int"/></UNSIGNED_SHORT_4_4_4_4>
		<UNSIGNED_SHORT_5_5_5_1 public="1" get="inline" set="null" line="218" static="1"><x path="Int"/></UNSIGNED_SHORT_5_5_5_1>
		<UNSIGNED_SHORT_5_6_5 public="1" get="inline" set="null" line="219" static="1"><x path="Int"/></UNSIGNED_SHORT_5_6_5>
		<FRAGMENT_SHADER public="1" get="inline" set="null" line="222" static="1"><x path="Int"/></FRAGMENT_SHADER>
		<VERTEX_SHADER public="1" get="inline" set="null" line="223" static="1"><x path="Int"/></VERTEX_SHADER>
		<MAX_VERTEX_ATTRIBS public="1" get="inline" set="null" line="224" static="1"><x path="Int"/></MAX_VERTEX_ATTRIBS>
		<MAX_VERTEX_UNIFORM_VECTORS public="1" get="inline" set="null" line="225" static="1"><x path="Int"/></MAX_VERTEX_UNIFORM_VECTORS>
		<MAX_VARYING_VECTORS public="1" get="inline" set="null" line="226" static="1"><x path="Int"/></MAX_VARYING_VECTORS>
		<MAX_COMBINED_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="227" static="1"><x path="Int"/></MAX_COMBINED_TEXTURE_IMAGE_UNITS>
		<MAX_VERTEX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="228" static="1"><x path="Int"/></MAX_VERTEX_TEXTURE_IMAGE_UNITS>
		<MAX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="229" static="1"><x path="Int"/></MAX_TEXTURE_IMAGE_UNITS>
		<MAX_FRAGMENT_UNIFORM_VECTORS public="1" get="inline" set="null" line="230" static="1"><x path="Int"/></MAX_FRAGMENT_UNIFORM_VECTORS>
		<SHADER_TYPE public="1" get="inline" set="null" line="231" static="1"><x path="Int"/></SHADER_TYPE>
		<DELETE_STATUS public="1" get="inline" set="null" line="232" static="1"><x path="Int"/></DELETE_STATUS>
		<LINK_STATUS public="1" get="inline" set="null" line="233" static="1"><x path="Int"/></LINK_STATUS>
		<VALIDATE_STATUS public="1" get="inline" set="null" line="234" static="1"><x path="Int"/></VALIDATE_STATUS>
		<ATTACHED_SHADERS public="1" get="inline" set="null" line="235" static="1"><x path="Int"/></ATTACHED_SHADERS>
		<ACTIVE_UNIFORMS public="1" get="inline" set="null" line="236" static="1"><x path="Int"/></ACTIVE_UNIFORMS>
		<ACTIVE_ATTRIBUTES public="1" get="inline" set="null" line="237" static="1"><x path="Int"/></ACTIVE_ATTRIBUTES>
		<SHADING_LANGUAGE_VERSION public="1" get="inline" set="null" line="238" static="1"><x path="Int"/></SHADING_LANGUAGE_VERSION>
		<CURRENT_PROGRAM public="1" get="inline" set="null" line="239" static="1"><x path="Int"/></CURRENT_PROGRAM>
		<NEVER public="1" get="inline" set="null" line="242" static="1"><x path="Int"/></NEVER>
		<LESS public="1" get="inline" set="null" line="243" static="1"><x path="Int"/></LESS>
		<EQUAL public="1" get="inline" set="null" line="244" static="1"><x path="Int"/></EQUAL>
		<LEQUAL public="1" get="inline" set="null" line="245" static="1"><x path="Int"/></LEQUAL>
		<GREATER public="1" get="inline" set="null" line="246" static="1"><x path="Int"/></GREATER>
		<NOTEQUAL public="1" get="inline" set="null" line="247" static="1"><x path="Int"/></NOTEQUAL>
		<GEQUAL public="1" get="inline" set="null" line="248" static="1"><x path="Int"/></GEQUAL>
		<ALWAYS public="1" get="inline" set="null" line="249" static="1"><x path="Int"/></ALWAYS>
		<KEEP public="1" get="inline" set="null" line="253" static="1"><x path="Int"/></KEEP>
		<REPLACE public="1" get="inline" set="null" line="254" static="1"><x path="Int"/></REPLACE>
		<INCR public="1" get="inline" set="null" line="255" static="1"><x path="Int"/></INCR>
		<DECR public="1" get="inline" set="null" line="256" static="1"><x path="Int"/></DECR>
		<INVERT public="1" get="inline" set="null" line="257" static="1"><x path="Int"/></INVERT>
		<INCR_WRAP public="1" get="inline" set="null" line="258" static="1"><x path="Int"/></INCR_WRAP>
		<DECR_WRAP public="1" get="inline" set="null" line="259" static="1"><x path="Int"/></DECR_WRAP>
		<VENDOR public="1" get="inline" set="null" line="262" static="1"><x path="Int"/></VENDOR>
		<RENDERER public="1" get="inline" set="null" line="263" static="1"><x path="Int"/></RENDERER>
		<VERSION public="1" get="inline" set="null" line="264" static="1"><x path="Int"/></VERSION>
		<NEAREST public="1" get="inline" set="null" line="267" static="1"><x path="Int"/></NEAREST>
		<LINEAR public="1" get="inline" set="null" line="268" static="1"><x path="Int"/></LINEAR>
		<NEAREST_MIPMAP_NEAREST public="1" get="inline" set="null" line="273" static="1"><x path="Int"/></NEAREST_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_NEAREST public="1" get="inline" set="null" line="274" static="1"><x path="Int"/></LINEAR_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1" get="inline" set="null" line="275" static="1"><x path="Int"/></NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_LINEAR public="1" get="inline" set="null" line="276" static="1"><x path="Int"/></LINEAR_MIPMAP_LINEAR>
		<TEXTURE_MAG_FILTER public="1" get="inline" set="null" line="279" static="1"><x path="Int"/></TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1" get="inline" set="null" line="280" static="1"><x path="Int"/></TEXTURE_MIN_FILTER>
		<TEXTURE_WRAP_S public="1" get="inline" set="null" line="281" static="1"><x path="Int"/></TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1" get="inline" set="null" line="282" static="1"><x path="Int"/></TEXTURE_WRAP_T>
		<TEXTURE_2D public="1" get="inline" set="null" line="285" static="1"><x path="Int"/></TEXTURE_2D>
		<TEXTURE public="1" get="inline" set="null" line="286" static="1"><x path="Int"/></TEXTURE>
		<TEXTURE_CUBE_MAP public="1" get="inline" set="null" line="288" static="1"><x path="Int"/></TEXTURE_CUBE_MAP>
		<TEXTURE_BINDING_CUBE_MAP public="1" get="inline" set="null" line="289" static="1"><x path="Int"/></TEXTURE_BINDING_CUBE_MAP>
		<TEXTURE_CUBE_MAP_POSITIVE_X public="1" get="inline" set="null" line="290" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_X>
		<TEXTURE_CUBE_MAP_NEGATIVE_X public="1" get="inline" set="null" line="291" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_X>
		<TEXTURE_CUBE_MAP_POSITIVE_Y public="1" get="inline" set="null" line="292" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_Y>
		<TEXTURE_CUBE_MAP_NEGATIVE_Y public="1" get="inline" set="null" line="293" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_Y>
		<TEXTURE_CUBE_MAP_POSITIVE_Z public="1" get="inline" set="null" line="294" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_Z>
		<TEXTURE_CUBE_MAP_NEGATIVE_Z public="1" get="inline" set="null" line="295" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_Z>
		<MAX_CUBE_MAP_TEXTURE_SIZE public="1" get="inline" set="null" line="296" static="1"><x path="Int"/></MAX_CUBE_MAP_TEXTURE_SIZE>
		<TEXTURE0 public="1" get="inline" set="null" line="299" static="1"><x path="Int"/></TEXTURE0>
		<TEXTURE1 public="1" get="inline" set="null" line="300" static="1"><x path="Int"/></TEXTURE1>
		<TEXTURE2 public="1" get="inline" set="null" line="301" static="1"><x path="Int"/></TEXTURE2>
		<TEXTURE3 public="1" get="inline" set="null" line="302" static="1"><x path="Int"/></TEXTURE3>
		<TEXTURE4 public="1" get="inline" set="null" line="303" static="1"><x path="Int"/></TEXTURE4>
		<TEXTURE5 public="1" get="inline" set="null" line="304" static="1"><x path="Int"/></TEXTURE5>
		<TEXTURE6 public="1" get="inline" set="null" line="305" static="1"><x path="Int"/></TEXTURE6>
		<TEXTURE7 public="1" get="inline" set="null" line="306" static="1"><x path="Int"/></TEXTURE7>
		<TEXTURE8 public="1" get="inline" set="null" line="307" static="1"><x path="Int"/></TEXTURE8>
		<TEXTURE9 public="1" get="inline" set="null" line="308" static="1"><x path="Int"/></TEXTURE9>
		<TEXTURE10 public="1" get="inline" set="null" line="309" static="1"><x path="Int"/></TEXTURE10>
		<TEXTURE11 public="1" get="inline" set="null" line="310" static="1"><x path="Int"/></TEXTURE11>
		<TEXTURE12 public="1" get="inline" set="null" line="311" static="1"><x path="Int"/></TEXTURE12>
		<TEXTURE13 public="1" get="inline" set="null" line="312" static="1"><x path="Int"/></TEXTURE13>
		<TEXTURE14 public="1" get="inline" set="null" line="313" static="1"><x path="Int"/></TEXTURE14>
		<TEXTURE15 public="1" get="inline" set="null" line="314" static="1"><x path="Int"/></TEXTURE15>
		<TEXTURE16 public="1" get="inline" set="null" line="315" static="1"><x path="Int"/></TEXTURE16>
		<TEXTURE17 public="1" get="inline" set="null" line="316" static="1"><x path="Int"/></TEXTURE17>
		<TEXTURE18 public="1" get="inline" set="null" line="317" static="1"><x path="Int"/></TEXTURE18>
		<TEXTURE19 public="1" get="inline" set="null" line="318" static="1"><x path="Int"/></TEXTURE19>
		<TEXTURE20 public="1" get="inline" set="null" line="319" static="1"><x path="Int"/></TEXTURE20>
		<TEXTURE21 public="1" get="inline" set="null" line="320" static="1"><x path="Int"/></TEXTURE21>
		<TEXTURE22 public="1" get="inline" set="null" line="321" static="1"><x path="Int"/></TEXTURE22>
		<TEXTURE23 public="1" get="inline" set="null" line="322" static="1"><x path="Int"/></TEXTURE23>
		<TEXTURE24 public="1" get="inline" set="null" line="323" static="1"><x path="Int"/></TEXTURE24>
		<TEXTURE25 public="1" get="inline" set="null" line="324" static="1"><x path="Int"/></TEXTURE25>
		<TEXTURE26 public="1" get="inline" set="null" line="325" static="1"><x path="Int"/></TEXTURE26>
		<TEXTURE27 public="1" get="inline" set="null" line="326" static="1"><x path="Int"/></TEXTURE27>
		<TEXTURE28 public="1" get="inline" set="null" line="327" static="1"><x path="Int"/></TEXTURE28>
		<TEXTURE29 public="1" get="inline" set="null" line="328" static="1"><x path="Int"/></TEXTURE29>
		<TEXTURE30 public="1" get="inline" set="null" line="329" static="1"><x path="Int"/></TEXTURE30>
		<TEXTURE31 public="1" get="inline" set="null" line="330" static="1"><x path="Int"/></TEXTURE31>
		<ACTIVE_TEXTURE public="1" get="inline" set="null" line="331" static="1"><x path="Int"/></ACTIVE_TEXTURE>
		<REPEAT public="1" get="inline" set="null" line="334" static="1"><x path="Int"/></REPEAT>
		<CLAMP_TO_EDGE public="1" get="inline" set="null" line="335" static="1"><x path="Int"/></CLAMP_TO_EDGE>
		<MIRRORED_REPEAT public="1" get="inline" set="null" line="336" static="1"><x path="Int"/></MIRRORED_REPEAT>
		<FLOAT_VEC2 public="1" get="inline" set="null" line="339" static="1"><x path="Int"/></FLOAT_VEC2>
		<FLOAT_VEC3 public="1" get="inline" set="null" line="340" static="1"><x path="Int"/></FLOAT_VEC3>
		<FLOAT_VEC4 public="1" get="inline" set="null" line="341" static="1"><x path="Int"/></FLOAT_VEC4>
		<INT_VEC2 public="1" get="inline" set="null" line="342" static="1"><x path="Int"/></INT_VEC2>
		<INT_VEC3 public="1" get="inline" set="null" line="343" static="1"><x path="Int"/></INT_VEC3>
		<INT_VEC4 public="1" get="inline" set="null" line="344" static="1"><x path="Int"/></INT_VEC4>
		<BOOL public="1" get="inline" set="null" line="345" static="1"><x path="Int"/></BOOL>
		<BOOL_VEC2 public="1" get="inline" set="null" line="346" static="1"><x path="Int"/></BOOL_VEC2>
		<BOOL_VEC3 public="1" get="inline" set="null" line="347" static="1"><x path="Int"/></BOOL_VEC3>
		<BOOL_VEC4 public="1" get="inline" set="null" line="348" static="1"><x path="Int"/></BOOL_VEC4>
		<FLOAT_MAT2 public="1" get="inline" set="null" line="349" static="1"><x path="Int"/></FLOAT_MAT2>
		<FLOAT_MAT3 public="1" get="inline" set="null" line="350" static="1"><x path="Int"/></FLOAT_MAT3>
		<FLOAT_MAT4 public="1" get="inline" set="null" line="351" static="1"><x path="Int"/></FLOAT_MAT4>
		<SAMPLER_2D public="1" get="inline" set="null" line="352" static="1"><x path="Int"/></SAMPLER_2D>
		<SAMPLER_CUBE public="1" get="inline" set="null" line="353" static="1"><x path="Int"/></SAMPLER_CUBE>
		<VERTEX_ATTRIB_ARRAY_ENABLED public="1" get="inline" set="null" line="356" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_ENABLED>
		<VERTEX_ATTRIB_ARRAY_SIZE public="1" get="inline" set="null" line="357" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_SIZE>
		<VERTEX_ATTRIB_ARRAY_STRIDE public="1" get="inline" set="null" line="358" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_STRIDE>
		<VERTEX_ATTRIB_ARRAY_TYPE public="1" get="inline" set="null" line="359" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_TYPE>
		<VERTEX_ATTRIB_ARRAY_NORMALIZED public="1" get="inline" set="null" line="360" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_NORMALIZED>
		<VERTEX_ATTRIB_ARRAY_POINTER public="1" get="inline" set="null" line="361" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_POINTER>
		<VERTEX_ATTRIB_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="362" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_BUFFER_BINDING>
		<VERTEX_PROGRAM_POINT_SIZE public="1" get="inline" set="null" line="365" static="1"><x path="Int"/></VERTEX_PROGRAM_POINT_SIZE>
		<POINT_SPRITE public="1" get="inline" set="null" line="366" static="1"><x path="Int"/></POINT_SPRITE>
		<COMPILE_STATUS public="1" get="inline" set="null" line="369" static="1"><x path="Int"/></COMPILE_STATUS>
		<LOW_FLOAT public="1" get="inline" set="null" line="372" static="1"><x path="Int"/></LOW_FLOAT>
		<MEDIUM_FLOAT public="1" get="inline" set="null" line="373" static="1"><x path="Int"/></MEDIUM_FLOAT>
		<HIGH_FLOAT public="1" get="inline" set="null" line="374" static="1"><x path="Int"/></HIGH_FLOAT>
		<LOW_INT public="1" get="inline" set="null" line="375" static="1"><x path="Int"/></LOW_INT>
		<MEDIUM_INT public="1" get="inline" set="null" line="376" static="1"><x path="Int"/></MEDIUM_INT>
		<HIGH_INT public="1" get="inline" set="null" line="377" static="1"><x path="Int"/></HIGH_INT>
		<FRAMEBUFFER public="1" get="inline" set="null" line="380" static="1"><x path="Int"/></FRAMEBUFFER>
		<RENDERBUFFER public="1" get="inline" set="null" line="381" static="1"><x path="Int"/></RENDERBUFFER>
		<RGBA4 public="1" get="inline" set="null" line="383" static="1"><x path="Int"/></RGBA4>
		<RGB5_A1 public="1" get="inline" set="null" line="384" static="1"><x path="Int"/></RGB5_A1>
		<RGB565 public="1" get="inline" set="null" line="385" static="1"><x path="Int"/></RGB565>
		<DEPTH_COMPONENT16 public="1" get="inline" set="null" line="386" static="1"><x path="Int"/></DEPTH_COMPONENT16>
		<STENCIL_INDEX public="1" get="inline" set="null" line="387" static="1"><x path="Int"/></STENCIL_INDEX>
		<STENCIL_INDEX8 public="1" get="inline" set="null" line="388" static="1"><x path="Int"/></STENCIL_INDEX8>
		<DEPTH_STENCIL public="1" get="inline" set="null" line="389" static="1"><x path="Int"/></DEPTH_STENCIL>
		<RENDERBUFFER_WIDTH public="1" get="inline" set="null" line="391" static="1"><x path="Int"/></RENDERBUFFER_WIDTH>
		<RENDERBUFFER_HEIGHT public="1" get="inline" set="null" line="392" static="1"><x path="Int"/></RENDERBUFFER_HEIGHT>
		<RENDERBUFFER_INTERNAL_FORMAT public="1" get="inline" set="null" line="393" static="1"><x path="Int"/></RENDERBUFFER_INTERNAL_FORMAT>
		<RENDERBUFFER_RED_SIZE public="1" get="inline" set="null" line="394" static="1"><x path="Int"/></RENDERBUFFER_RED_SIZE>
		<RENDERBUFFER_GREEN_SIZE public="1" get="inline" set="null" line="395" static="1"><x path="Int"/></RENDERBUFFER_GREEN_SIZE>
		<RENDERBUFFER_BLUE_SIZE public="1" get="inline" set="null" line="396" static="1"><x path="Int"/></RENDERBUFFER_BLUE_SIZE>
		<RENDERBUFFER_ALPHA_SIZE public="1" get="inline" set="null" line="397" static="1"><x path="Int"/></RENDERBUFFER_ALPHA_SIZE>
		<RENDERBUFFER_DEPTH_SIZE public="1" get="inline" set="null" line="398" static="1"><x path="Int"/></RENDERBUFFER_DEPTH_SIZE>
		<RENDERBUFFER_STENCIL_SIZE public="1" get="inline" set="null" line="399" static="1"><x path="Int"/></RENDERBUFFER_STENCIL_SIZE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE public="1" get="inline" set="null" line="401" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_NAME public="1" get="inline" set="null" line="402" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_OBJECT_NAME>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL public="1" get="inline" set="null" line="403" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE public="1" get="inline" set="null" line="404" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE>
		<COLOR_ATTACHMENT0 public="1" get="inline" set="null" line="406" static="1"><x path="Int"/></COLOR_ATTACHMENT0>
		<DEPTH_ATTACHMENT public="1" get="inline" set="null" line="407" static="1"><x path="Int"/></DEPTH_ATTACHMENT>
		<STENCIL_ATTACHMENT public="1" get="inline" set="null" line="408" static="1"><x path="Int"/></STENCIL_ATTACHMENT>
		<DEPTH_STENCIL_ATTACHMENT public="1" get="inline" set="null" line="409" static="1"><x path="Int"/></DEPTH_STENCIL_ATTACHMENT>
		<NONE public="1" get="inline" set="null" line="411" static="1"><x path="Int"/></NONE>
		<FRAMEBUFFER_COMPLETE public="1" get="inline" set="null" line="413" static="1"><x path="Int"/></FRAMEBUFFER_COMPLETE>
		<FRAMEBUFFER_INCOMPLETE_ATTACHMENT public="1" get="inline" set="null" line="414" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT public="1" get="inline" set="null" line="415" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_DIMENSIONS public="1" get="inline" set="null" line="416" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_DIMENSIONS>
		<FRAMEBUFFER_UNSUPPORTED public="1" get="inline" set="null" line="417" static="1"><x path="Int"/></FRAMEBUFFER_UNSUPPORTED>
		<FRAMEBUFFER_BINDING public="1" get="inline" set="null" line="419" static="1"><x path="Int"/></FRAMEBUFFER_BINDING>
		<RENDERBUFFER_BINDING public="1" get="inline" set="null" line="420" static="1"><x path="Int"/></RENDERBUFFER_BINDING>
		<MAX_RENDERBUFFER_SIZE public="1" get="inline" set="null" line="421" static="1"><x path="Int"/></MAX_RENDERBUFFER_SIZE>
		<INVALID_FRAMEBUFFER_OPERATION public="1" get="inline" set="null" line="423" static="1"><x path="Int"/></INVALID_FRAMEBUFFER_OPERATION>
		<UNPACK_FLIP_Y_WEBGL public="1" get="inline" set="null" line="426" static="1"><x path="Int"/></UNPACK_FLIP_Y_WEBGL>
		<UNPACK_PREMULTIPLY_ALPHA_WEBGL public="1" get="inline" set="null" line="427" static="1"><x path="Int"/></UNPACK_PREMULTIPLY_ALPHA_WEBGL>
		<CONTEXT_LOST_WEBGL public="1" get="inline" set="null" line="428" static="1"><x path="Int"/></CONTEXT_LOST_WEBGL>
		<UNPACK_COLORSPACE_CONVERSION_WEBGL public="1" get="inline" set="null" line="429" static="1"><x path="Int"/></UNPACK_COLORSPACE_CONVERSION_WEBGL>
		<BROWSER_DEFAULT_WEBGL public="1" get="inline" set="null" line="430" static="1"><x path="Int"/></BROWSER_DEFAULT_WEBGL>
		<drawingBufferHeight public="1" get="accessor" set="null" static="1"><x path="Int"/></drawingBufferHeight>
		<drawingBufferWidth public="1" get="accessor" set="null" static="1"><x path="Int"/></drawingBufferWidth>
		<version public="1" get="accessor" set="null" static="1"><x path="Int"/></version>
		<activeTexture public="1" get="inline" set="null" line="436" static="1"><f a="texture">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<attachShader public="1" get="inline" set="null" line="438" static="1"><f a="program:shader">
	<c path="openfl.gl.GLProgram"/>
	<c path="openfl.gl.GLShader"/>
	<x path="Void"/>
</f></attachShader>
		<bindAttribLocation public="1" get="inline" set="null" line="444" static="1"><f a="program:index:name">
	<c path="openfl.gl.GLProgram"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></bindAttribLocation>
		<bindBitmapDataTexture public="1" get="inline" set="null" line="449" static="1"><f a="texture">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></bindBitmapDataTexture>
		<bindBuffer public="1" get="inline" set="null" line="454" static="1"><f a="target:buffer">
	<x path="Int"/>
	<c path="openfl.gl.GLBuffer"/>
	<x path="Void"/>
</f></bindBuffer>
		<bindFramebuffer public="1" get="inline" set="null" line="459" static="1"><f a="target:framebuffer">
	<x path="Int"/>
	<c path="openfl.gl.GLFramebuffer"/>
	<x path="Void"/>
</f></bindFramebuffer>
		<bindRenderbuffer public="1" get="inline" set="null" line="464" static="1"><f a="target:renderbuffer">
	<x path="Int"/>
	<c path="openfl.gl.GLRenderbuffer"/>
	<x path="Void"/>
</f></bindRenderbuffer>
		<bindTexture public="1" get="inline" set="null" line="469" static="1"><f a="target:texture">
	<x path="Int"/>
	<c path="openfl.gl.GLTexture"/>
	<x path="Void"/>
</f></bindTexture>
		<blendColor public="1" get="inline" set="null" line="474" static="1"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></blendColor>
		<blendEquation public="1" get="inline" set="null" line="479" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquation>
		<blendEquationSeparate public="1" get="inline" set="null" line="484" static="1"><f a="modeRGB:modeAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquationSeparate>
		<blendFunc public="1" get="inline" set="null" line="489" static="1"><f a="sfactor:dfactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFunc>
		<blendFuncSeparate public="1" get="inline" set="null" line="494" static="1"><f a="srcRGB:dstRGB:srcAlpha:dstAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFuncSeparate>
		<bufferData public="1" get="inline" set="null" line="499" static="1"><f a="target:data:usage">
	<x path="Int"/>
	<c path="openfl.utils.IMemoryRange"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<bufferSubData public="1" get="inline" set="null" line="504" static="1"><f a="target:offset:data">
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl.utils.IMemoryRange"/>
	<x path="Void"/>
</f></bufferSubData>
		<checkFramebufferStatus public="1" get="inline" set="null" line="509" static="1"><f a="target">
	<x path="Int"/>
	<x path="Int"/>
</f></checkFramebufferStatus>
		<clear public="1" get="inline" set="null" line="514" static="1"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clearColor public="1" get="inline" set="null" line="519" static="1"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearColor>
		<clearDepth public="1" get="inline" set="null" line="524" static="1"><f a="depth">
	<x path="Float"/>
	<x path="Void"/>
</f></clearDepth>
		<clearStencil public="1" get="inline" set="null" line="529" static="1"><f a="s">
	<x path="Int"/>
	<x path="Void"/>
</f></clearStencil>
		<colorMask public="1" get="inline" set="null" line="534" static="1"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorMask>
		<compileShader public="1" get="inline" set="null" line="539" static="1"><f a="shader">
	<c path="openfl.gl.GLShader"/>
	<x path="Void"/>
</f></compileShader>
		<compressedTexImage2D public="1" get="inline" set="null" line="544" static="1"><f a="target:level:internalformat:width:height:border:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl.utils.IMemoryRange"/>
	<x path="Void"/>
</f></compressedTexImage2D>
		<compressedTexSubImage2D public="1" get="inline" set="null" line="549" static="1"><f a="target:level:xoffset:yoffset:width:height:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl.utils.IMemoryRange"/>
	<x path="Void"/>
</f></compressedTexSubImage2D>
		<copyTexImage2D public="1" get="inline" set="null" line="554" static="1"><f a="target:level:internalformat:x:y:width:height:border">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexImage2D>
		<copyTexSubImage2D public="1" get="inline" set="null" line="559" static="1"><f a="target:level:xoffset:yoffset:x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexSubImage2D>
		<createBuffer public="1" get="inline" set="null" line="564" static="1"><f a=""><c path="openfl.gl.GLBuffer"/></f></createBuffer>
		<createFramebuffer public="1" get="inline" set="null" line="569" static="1"><f a=""><c path="openfl.gl.GLFramebuffer"/></f></createFramebuffer>
		<createProgram public="1" get="inline" set="null" line="574" static="1"><f a=""><c path="openfl.gl.GLProgram"/></f></createProgram>
		<createRenderbuffer public="1" get="inline" set="null" line="579" static="1"><f a=""><c path="openfl.gl.GLRenderbuffer"/></f></createRenderbuffer>
		<createShader public="1" get="inline" set="null" line="584" static="1"><f a="type">
	<x path="Int"/>
	<c path="openfl.gl.GLShader"/>
</f></createShader>
		<createTexture public="1" get="inline" set="null" line="589" static="1"><f a=""><c path="openfl.gl.GLTexture"/></f></createTexture>
		<cullFace public="1" get="inline" set="null" line="594" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></cullFace>
		<deleteBuffer public="1" get="inline" set="null" line="599" static="1"><f a="buffer">
	<c path="openfl.gl.GLBuffer"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteFramebuffer public="1" get="inline" set="null" line="605" static="1"><f a="framebuffer">
	<c path="openfl.gl.GLFramebuffer"/>
	<x path="Void"/>
</f></deleteFramebuffer>
		<deleteProgram public="1" get="inline" set="null" line="611" static="1"><f a="program">
	<c path="openfl.gl.GLProgram"/>
	<x path="Void"/>
</f></deleteProgram>
		<deleteRenderbuffer public="1" set="method" line="617" static="1"><f a="renderbuffer">
	<c path="openfl.gl.GLRenderbuffer"/>
	<x path="Void"/>
</f></deleteRenderbuffer>
		<deleteShader public="1" get="inline" set="null" line="623" static="1"><f a="shader">
	<c path="openfl.gl.GLShader"/>
	<x path="Void"/>
</f></deleteShader>
		<deleteTexture public="1" get="inline" set="null" line="629" static="1"><f a="texture">
	<c path="openfl.gl.GLTexture"/>
	<x path="Void"/>
</f></deleteTexture>
		<depthFunc public="1" get="inline" set="null" line="635" static="1"><f a="func">
	<x path="Int"/>
	<x path="Void"/>
</f></depthFunc>
		<depthMask public="1" get="inline" set="null" line="640" static="1"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></depthMask>
		<depthRange public="1" get="inline" set="null" line="645" static="1"><f a="zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></depthRange>
		<detachShader public="1" get="inline" set="null" line="650" static="1"><f a="program:shader">
	<c path="openfl.gl.GLProgram"/>
	<c path="openfl.gl.GLShader"/>
	<x path="Void"/>
</f></detachShader>
		<disable public="1" get="inline" set="null" line="655" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<disableVertexAttribArray public="1" get="inline" set="null" line="660" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></disableVertexAttribArray>
		<drawArrays public="1" get="inline" set="null" line="665" static="1"><f a="mode:first:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawArrays>
		<drawElements public="1" get="inline" set="null" line="670" static="1"><f a="mode:count:type:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawElements>
		<enable public="1" get="inline" set="null" line="675" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<enableVertexAttribArray public="1" get="inline" set="null" line="680" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribArray>
		<finish public="1" get="inline" set="null" line="685" static="1"><f a=""><x path="Void"/></f></finish>
		<flush public="1" get="inline" set="null" line="690" static="1"><f a=""><x path="Void"/></f></flush>
		<framebufferRenderbuffer public="1" get="inline" set="null" line="695" static="1"><f a="target:attachment:renderbuffertarget:renderbuffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl.gl.GLRenderbuffer"/>
	<x path="Void"/>
</f></framebufferRenderbuffer>
		<framebufferTexture2D public="1" get="inline" set="null" line="700" static="1"><f a="target:attachment:textarget:texture:level">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl.gl.GLTexture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></framebufferTexture2D>
		<frontFace public="1" get="inline" set="null" line="705" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></frontFace>
		<generateMipmap public="1" get="inline" set="null" line="710" static="1"><f a="target">
	<x path="Int"/>
	<x path="Void"/>
</f></generateMipmap>
		<getActiveAttrib public="1" get="inline" set="null" line="715" static="1"><f a="program:index">
	<c path="openfl.gl.GLProgram"/>
	<x path="Int"/>
	<t path="openfl.gl.GLActiveInfo"/>
</f></getActiveAttrib>
		<getActiveUniform public="1" get="inline" set="null" line="720" static="1"><f a="program:index">
	<c path="openfl.gl.GLProgram"/>
	<x path="Int"/>
	<t path="openfl.gl.GLActiveInfo"/>
</f></getActiveUniform>
		<getAttachedShaders public="1" get="inline" set="null" line="725" static="1"><f a="program">
	<c path="openfl.gl.GLProgram"/>
	<c path="Array"><c path="openfl.gl.GLShader"/></c>
</f></getAttachedShaders>
		<getAttribLocation public="1" get="inline" set="null" line="730" static="1"><f a="program:name">
	<c path="openfl.gl.GLProgram"/>
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getBufferParameter public="1" get="inline" set="null" line="735" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getBufferParameter>
		<getContextAttributes public="1" get="inline" set="null" line="740" static="1"><f a=""><t path="openfl.gl.GLContextAttributes"/></f></getContextAttributes>
		<getError public="1" get="inline" set="null" line="748" static="1"><f a=""><x path="Int"/></f></getError>
		<getExtension public="1" get="inline" set="null" line="753" static="1"><f a="name">
	<c path="String"/>
	<d/>
</f></getExtension>
		<getFramebufferAttachmentParameter public="1" get="inline" set="null" line="759" static="1"><f a="target:attachment:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getFramebufferAttachmentParameter>
		<getParameter public="1" get="inline" set="null" line="764" static="1"><f a="pname">
	<x path="Int"/>
	<d/>
</f></getParameter>
		<getProgramInfoLog public="1" get="inline" set="null" line="769" static="1"><f a="program">
	<c path="openfl.gl.GLProgram"/>
	<c path="String"/>
</f></getProgramInfoLog>
		<getProgramParameter public="1" get="inline" set="null" line="774" static="1"><f a="program:pname">
	<c path="openfl.gl.GLProgram"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getProgramParameter>
		<getRenderbufferParameter public="1" get="inline" set="null" line="779" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getRenderbufferParameter>
		<getShaderInfoLog public="1" get="inline" set="null" line="784" static="1"><f a="shader">
	<c path="openfl.gl.GLShader"/>
	<c path="String"/>
</f></getShaderInfoLog>
		<getShaderParameter public="1" get="inline" set="null" line="789" static="1"><f a="shader:pname">
	<c path="openfl.gl.GLShader"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getShaderParameter>
		<getShaderPrecisionFormat public="1" get="inline" set="null" line="794" static="1"><f a="shadertype:precisiontype">
	<x path="Int"/>
	<x path="Int"/>
	<t path="openfl.gl.ShaderPrecisionFormat"/>
</f></getShaderPrecisionFormat>
		<getShaderSource public="1" get="inline" set="null" line="799" static="1"><f a="shader">
	<c path="openfl.gl.GLShader"/>
	<c path="String"/>
</f></getShaderSource>
		<getSupportedExtensions public="1" get="inline" set="null" line="804" static="1"><f a=""><c path="Array"><c path="String"/></c></f></getSupportedExtensions>
		<getTexParameter public="1" get="inline" set="null" line="811" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getTexParameter>
		<getUniform public="1" get="inline" set="null" line="816" static="1"><f a="program:location">
	<c path="openfl.gl.GLProgram"/>
	<t path="openfl.gl.GLUniformLocation"/>
	<d/>
</f></getUniform>
		<getUniformLocation public="1" get="inline" set="null" line="821" static="1"><f a="program:name">
	<c path="openfl.gl.GLProgram"/>
	<c path="String"/>
	<d/>
</f></getUniformLocation>
		<getVertexAttrib public="1" get="inline" set="null" line="826" static="1"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getVertexAttrib>
		<getVertexAttribOffset public="1" get="inline" set="null" line="831" static="1"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttribOffset>
		<hint public="1" get="inline" set="null" line="836" static="1"><f a="target:mode">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hint>
		<isBuffer public="1" get="inline" set="null" line="841" static="1"><f a="buffer">
	<c path="openfl.gl.GLBuffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" get="inline" set="null" line="848" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isFramebuffer public="1" get="inline" set="null" line="853" static="1"><f a="framebuffer">
	<c path="openfl.gl.GLFramebuffer"/>
	<x path="Bool"/>
</f></isFramebuffer>
		<isProgram public="1" get="inline" set="null" line="858" static="1"><f a="program">
	<c path="openfl.gl.GLProgram"/>
	<x path="Bool"/>
</f></isProgram>
		<isRenderbuffer public="1" get="inline" set="null" line="863" static="1"><f a="renderbuffer">
	<c path="openfl.gl.GLRenderbuffer"/>
	<x path="Bool"/>
</f></isRenderbuffer>
		<isShader public="1" get="inline" set="null" line="868" static="1"><f a="shader">
	<c path="openfl.gl.GLShader"/>
	<x path="Bool"/>
</f></isShader>
		<isTexture public="1" get="inline" set="null" line="873" static="1"><f a="texture">
	<c path="openfl.gl.GLTexture"/>
	<x path="Bool"/>
</f></isTexture>
		<lineWidth public="1" get="inline" set="null" line="878" static="1"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<linkProgram public="1" get="inline" set="null" line="883" static="1"><f a="program">
	<c path="openfl.gl.GLProgram"/>
	<x path="Void"/>
</f></linkProgram>
		<load set="method" line="888" static="1"><f a="inName:inArgCount">
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<pixelStorei public="1" get="inline" set="null" line="901" static="1"><f a="pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pixelStorei>
		<polygonOffset public="1" get="inline" set="null" line="906" static="1"><f a="factor:units">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></polygonOffset>
		<readPixels public="1" get="inline" set="null" line="911" static="1"><f a="x:y:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></readPixels>
		<renderbufferStorage public="1" get="inline" set="null" line="916" static="1"><f a="target:internalformat:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderbufferStorage>
		<sampleCoverage public="1" get="inline" set="null" line="921" static="1"><f a="value:invert">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sampleCoverage>
		<scissor public="1" get="inline" set="null" line="926" static="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scissor>
		<shaderSource public="1" get="inline" set="null" line="931" static="1"><f a="shader:source">
	<c path="openfl.gl.GLShader"/>
	<c path="String"/>
	<x path="Void"/>
</f></shaderSource>
		<stencilFunc public="1" get="inline" set="null" line="936" static="1"><f a="func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFunc>
		<stencilFuncSeparate public="1" get="inline" set="null" line="941" static="1"><f a="face:func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFuncSeparate>
		<stencilMask public="1" get="inline" set="null" line="946" static="1"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMask>
		<stencilMaskSeparate public="1" get="inline" set="null" line="951" static="1"><f a="face:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMaskSeparate>
		<stencilOp public="1" get="inline" set="null" line="956" static="1"><f a="fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOp>
		<stencilOpSeparate public="1" get="inline" set="null" line="961" static="1"><f a="face:fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOpSeparate>
		<texImage2D public="1" get="inline" set="null" line="966" static="1"><f a="target:level:internalformat:width:height:border:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texImage2D>
		<texParameterf public="1" get="inline" set="null" line="971" static="1"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texParameterf>
		<texParameteri public="1" get="inline" set="null" line="976" static="1"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></texParameteri>
		<texSubImage2D public="1" get="inline" set="null" line="981" static="1"><f a="target:level:xoffset:yoffset:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texSubImage2D>
		<uniform1f public="1" get="inline" set="null" line="986" static="1"><f a="location:x">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform1f>
		<uniform1fv public="1" get="inline" set="null" line="991" static="1"><f a="location:x">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></uniform1fv>
		<uniform1i public="1" get="inline" set="null" line="996" static="1"><f a="location:x">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform1i>
		<uniform1iv public="1" get="inline" set="null" line="1001" static="1"><f a="location:v">
	<t path="openfl.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform1iv>
		<uniform2f public="1" get="inline" set="null" line="1006" static="1"><f a="location:x:y">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform2f>
		<uniform2fv public="1" get="inline" set="null" line="1011" static="1"><f a="location:v">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></uniform2fv>
		<uniform2i public="1" get="inline" set="null" line="1016" static="1"><f a="location:x:y">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform2i>
		<uniform2iv public="1" get="inline" set="null" line="1021" static="1"><f a="location:v">
	<t path="openfl.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform2iv>
		<uniform3f public="1" get="inline" set="null" line="1026" static="1"><f a="location:x:y:z">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform3f>
		<uniform3fv public="1" get="inline" set="null" line="1031" static="1"><f a="location:v">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></uniform3fv>
		<uniform3i public="1" get="inline" set="null" line="1036" static="1"><f a="location:x:y:z">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform3i>
		<uniform3iv public="1" get="inline" set="null" line="1041" static="1"><f a="location:v">
	<t path="openfl.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform3iv>
		<uniform4f public="1" get="inline" set="null" line="1046" static="1"><f a="location:x:y:z:w">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform4f>
		<uniform4fv public="1" get="inline" set="null" line="1051" static="1"><f a="location:v">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></uniform4fv>
		<uniform4i public="1" get="inline" set="null" line="1056" static="1"><f a="location:x:y:z:w">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform4i>
		<uniform4iv public="1" get="inline" set="null" line="1061" static="1"><f a="location:v">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></uniform4iv>
		<uniformMatrix2fv public="1" get="inline" set="null" line="1066" static="1"><f a="location:transpose:v">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></uniformMatrix2fv>
		<uniformMatrix3fv public="1" get="inline" set="null" line="1076" static="1"><f a="location:transpose:v">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></uniformMatrix3fv>
		<uniformMatrix4fv public="1" get="inline" set="null" line="1087" static="1"><f a="location:transpose:v">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></uniformMatrix4fv>
		<uniformMatrix3D public="1" get="inline" set="null" line="1097" static="1"><f a="location:transpose:matrix">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></uniformMatrix3D>
		<useProgram public="1" get="inline" set="null" line="1102" static="1"><f a="program">
	<c path="openfl.gl.GLProgram"/>
	<x path="Void"/>
</f></useProgram>
		<validateProgram public="1" get="inline" set="null" line="1107" static="1"><f a="program">
	<c path="openfl.gl.GLProgram"/>
	<x path="Void"/>
</f></validateProgram>
		<vertexAttrib1f public="1" get="inline" set="null" line="1112" static="1"><f a="indx:x">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib1f>
		<vertexAttrib1fv public="1" get="inline" set="null" line="1117" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></vertexAttrib1fv>
		<vertexAttrib2f public="1" get="inline" set="null" line="1122" static="1"><f a="indx:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib2f>
		<vertexAttrib2fv public="1" get="inline" set="null" line="1127" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></vertexAttrib2fv>
		<vertexAttrib3f public="1" get="inline" set="null" line="1132" static="1"><f a="indx:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib3f>
		<vertexAttrib3fv public="1" get="inline" set="null" line="1137" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></vertexAttrib3fv>
		<vertexAttrib4f public="1" get="inline" set="null" line="1142" static="1"><f a="indx:x:y:z:w">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib4f>
		<vertexAttrib4fv public="1" get="inline" set="null" line="1147" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Void"/>
</f></vertexAttrib4fv>
		<vertexAttribPointer public="1" get="inline" set="null" line="1152" static="1"><f a="indx:size:type:normalized:stride:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vertexAttribPointer>
		<viewport public="1" get="inline" set="null" line="1157" static="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></viewport>
		<get_drawingBufferHeight set="method" line="1170" static="1"><f a=""><x path="Int"/></f></get_drawingBufferHeight>
		<get_drawingBufferWidth set="method" line="1171" static="1"><f a=""><x path="Int"/></f></get_drawingBufferWidth>
		<get_version set="method" line="1172" static="1"><f a=""><x path="Int"/></f></get_version>
		<lime_gl_active_texture line="1182" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_active_texture>
		<lime_gl_attach_shader line="1183" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></lime_gl_attach_shader>
		<lime_gl_bind_attrib_location line="1184" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<c path="String"/>
	<unknown/>
</f></lime_gl_bind_attrib_location>
		<lime_gl_bind_bitmap_data_texture line="1185" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_bind_bitmap_data_texture>
		<lime_gl_bind_buffer line="1186" static="1"><f a=":">
	<x path="Int"/>
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_gl_bind_buffer>
		<lime_gl_bind_framebuffer line="1187" static="1"><f a=":">
	<x path="Int"/>
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_gl_bind_framebuffer>
		<lime_gl_bind_renderbuffer line="1188" static="1"><f a=":">
	<x path="Int"/>
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_gl_bind_renderbuffer>
		<lime_gl_bind_texture line="1189" static="1"><f a=":">
	<x path="Int"/>
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_gl_bind_texture>
		<lime_gl_blend_color line="1190" static="1"><f a=":::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_blend_color>
		<lime_gl_blend_equation line="1191" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_blend_equation>
		<lime_gl_blend_equation_separate line="1192" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_blend_equation_separate>
		<lime_gl_blend_func line="1193" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_blend_func>
		<lime_gl_blend_func_separate line="1194" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_blend_func_separate>
		<lime_gl_buffer_data line="1195" static="1"><f a="::::">
	<x path="Int"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_buffer_data>
		<lime_gl_buffer_sub_data line="1196" static="1"><f a="::::">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_buffer_sub_data>
		<lime_gl_check_framebuffer_status line="1197" static="1"><f a="">
	<x path="Int"/>
	<x path="Int"/>
</f></lime_gl_check_framebuffer_status>
		<lime_gl_clear line="1198" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_clear>
		<lime_gl_clear_color line="1199" static="1"><f a=":::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_clear_color>
		<lime_gl_clear_depth line="1200" static="1"><f a="">
	<x path="Float"/>
	<unknown/>
</f></lime_gl_clear_depth>
		<lime_gl_clear_stencil line="1201" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_clear_stencil>
		<lime_gl_color_mask line="1202" static="1"><f a=":::">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_gl_color_mask>
		<lime_gl_compile_shader line="1203" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_compile_shader>
		<lime_gl_compressed_tex_image_2d line="1204" static="1"><f a=":::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="flash.utils.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_gl_compressed_tex_image_2d>
		<lime_gl_compressed_tex_sub_image_2d line="1205" static="1"><f a="::::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="flash.utils.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_gl_compressed_tex_sub_image_2d>
		<lime_gl_copy_tex_image_2d line="1206" static="1"><f a=":::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_copy_tex_image_2d>
		<lime_gl_copy_tex_sub_image_2d line="1207" static="1"><f a=":::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_copy_tex_sub_image_2d>
		<lime_gl_create_buffer line="1208" static="1"><f a=""><unknown/></f></lime_gl_create_buffer>
		<lime_gl_create_framebuffer line="1209" static="1"><f a=""><unknown/></f></lime_gl_create_framebuffer>
		<lime_gl_create_program line="1210" static="1"><f a=""><unknown/></f></lime_gl_create_program>
		<lime_gl_create_render_buffer line="1211" static="1"><f a=""><unknown/></f></lime_gl_create_render_buffer>
		<lime_gl_create_shader line="1212" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_create_shader>
		<lime_gl_create_texture line="1213" static="1"><f a=""><unknown/></f></lime_gl_create_texture>
		<lime_gl_cull_face line="1214" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_cull_face>
		<lime_gl_delete_buffer line="1215" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_buffer>
		<lime_gl_delete_framebuffer line="1216" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_framebuffer>
		<lime_gl_delete_program line="1217" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_program>
		<lime_gl_delete_render_buffer line="1218" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_render_buffer>
		<lime_gl_delete_shader line="1219" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_shader>
		<lime_gl_delete_texture line="1220" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_texture>
		<lime_gl_depth_func line="1221" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_depth_func>
		<lime_gl_depth_mask line="1222" static="1"><f a="">
	<x path="Bool"/>
	<unknown/>
</f></lime_gl_depth_mask>
		<lime_gl_depth_range line="1223" static="1"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_depth_range>
		<lime_gl_detach_shader line="1224" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></lime_gl_detach_shader>
		<lime_gl_disable line="1225" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_disable>
		<lime_gl_disable_vertex_attrib_array line="1226" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_disable_vertex_attrib_array>
		<lime_gl_draw_arrays line="1227" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_draw_arrays>
		<lime_gl_draw_elements line="1228" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_draw_elements>
		<lime_gl_enable line="1229" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_enable>
		<lime_gl_enable_vertex_attrib_array line="1230" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_enable_vertex_attrib_array>
		<lime_gl_finish line="1231" static="1"><f a=""><unknown/></f></lime_gl_finish>
		<lime_gl_flush line="1232" static="1"><f a=""><unknown/></f></lime_gl_flush>
		<lime_gl_framebuffer_renderbuffer line="1233" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<unknown/>
</f></lime_gl_framebuffer_renderbuffer>
		<lime_gl_framebuffer_texture2D line="1234" static="1"><f a="::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_framebuffer_texture2D>
		<lime_gl_front_face line="1235" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_front_face>
		<lime_gl_generate_mipmap line="1236" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_generate_mipmap>
		<lime_gl_get_active_attrib line="1237" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<t path="openfl.gl.GLActiveInfo"/>
</f></lime_gl_get_active_attrib>
		<lime_gl_get_active_uniform line="1238" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<t path="openfl.gl.GLActiveInfo"/>
</f></lime_gl_get_active_uniform>
		<lime_gl_get_attrib_location line="1239" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<x path="Int"/>
</f></lime_gl_get_attrib_location>
		<lime_gl_get_buffer_paramerter line="1240" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_buffer_paramerter>
		<lime_gl_get_context_attributes line="1241" static="1"><f a=""><a>
	<stencil><x path="Bool"/></stencil>
	<preserveDrawingBuffer><x path="Bool"/></preserveDrawingBuffer>
	<premultipliedAlpha><x path="Bool"/></premultipliedAlpha>
	<depth><x path="Bool"/></depth>
	<antialias><x path="Bool"/></antialias>
	<alpha><x path="Bool"/></alpha>
</a></f></lime_gl_get_context_attributes>
		<lime_gl_get_error line="1242" static="1"><f a=""><x path="Int"/></f></lime_gl_get_error>
		<lime_gl_get_framebuffer_attachment_parameter line="1243" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_framebuffer_attachment_parameter>
		<lime_gl_get_parameter line="1244" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_parameter>
		<lime_gl_get_program_info_log line="1245" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_gl_get_program_info_log>
		<lime_gl_get_program_parameter line="1246" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></lime_gl_get_program_parameter>
		<lime_gl_get_render_buffer_parameter line="1247" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_render_buffer_parameter>
		<lime_gl_get_shader_info_log line="1248" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_gl_get_shader_info_log>
		<lime_gl_get_shader_parameter line="1249" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></lime_gl_get_shader_parameter>
		<lime_gl_get_shader_precision_format line="1250" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<t path="openfl.gl.ShaderPrecisionFormat"/>
</f></lime_gl_get_shader_precision_format>
		<lime_gl_get_shader_source line="1251" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_gl_get_shader_source>
		<lime_gl_get_supported_extensions line="1252" static="1"><f a="">
	<c path="Array"><c path="String"/></c>
	<unknown/>
</f></lime_gl_get_supported_extensions>
		<lime_gl_get_tex_parameter line="1253" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_tex_parameter>
		<lime_gl_get_uniform line="1254" static="1"><f a=":">
	<d/>
	<t path="openfl.gl.GLUniformLocation"/>
	<unknown/>
</f></lime_gl_get_uniform>
		<lime_gl_get_uniform_location line="1255" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></lime_gl_get_uniform_location>
		<lime_gl_get_vertex_attrib line="1256" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_vertex_attrib>
		<lime_gl_get_vertex_attrib_offset line="1257" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lime_gl_get_vertex_attrib_offset>
		<lime_gl_hint line="1258" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_hint>
		<lime_gl_is_buffer line="1259" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_buffer>
		<lime_gl_is_enabled line="1260" static="1"><f a="">
	<x path="Int"/>
	<x path="Bool"/>
</f></lime_gl_is_enabled>
		<lime_gl_is_framebuffer line="1261" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_framebuffer>
		<lime_gl_is_program line="1262" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_program>
		<lime_gl_is_renderbuffer line="1263" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_renderbuffer>
		<lime_gl_is_shader line="1264" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_shader>
		<lime_gl_is_texture line="1265" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_texture>
		<lime_gl_line_width line="1266" static="1"><f a="">
	<x path="Float"/>
	<unknown/>
</f></lime_gl_line_width>
		<lime_gl_link_program line="1267" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_link_program>
		<lime_gl_pixel_storei line="1268" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_pixel_storei>
		<lime_gl_polygon_offset line="1269" static="1"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_polygon_offset>
		<lime_gl_read_pixels line="1270" static="1"><f a=":::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="flash.utils.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_gl_read_pixels>
		<lime_gl_renderbuffer_storage line="1271" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_renderbuffer_storage>
		<lime_gl_sample_coverage line="1272" static="1"><f a=":">
	<x path="Float"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_gl_sample_coverage>
		<lime_gl_scissor line="1273" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_scissor>
		<lime_gl_shader_source line="1274" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></lime_gl_shader_source>
		<lime_gl_stencil_func line="1275" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_func>
		<lime_gl_stencil_func_separate line="1276" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_func_separate>
		<lime_gl_stencil_mask line="1277" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_mask>
		<lime_gl_stencil_mask_separate line="1278" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_mask_separate>
		<lime_gl_stencil_op line="1279" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_op>
		<lime_gl_stencil_op_separate line="1280" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_op_separate>
		<lime_gl_tex_image_2d line="1281" static="1"><f a=":::::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="flash.utils.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_gl_tex_image_2d>
		<lime_gl_tex_parameterf line="1282" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_tex_parameterf>
		<lime_gl_tex_parameteri line="1283" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_tex_parameteri>
		<lime_gl_tex_sub_image_2d line="1284" static="1"><f a=":::::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="flash.utils.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_gl_tex_sub_image_2d>
		<lime_gl_uniform1f line="1285" static="1"><f a=":">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_uniform1f>
		<lime_gl_uniform1fv line="1286" static="1"><f a=":">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="openfl.gl.Float32Data"/>
	<unknown/>
</f></lime_gl_uniform1fv>
		<lime_gl_uniform1i line="1287" static="1"><f a=":">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_uniform1i>
		<lime_gl_uniform1iv line="1288" static="1"><f a=":">
	<t path="openfl.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></lime_gl_uniform1iv>
		<lime_gl_uniform2f line="1289" static="1"><f a="::">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_uniform2f>
		<lime_gl_uniform2fv line="1290" static="1"><f a=":">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="openfl.gl.Float32Data"/>
	<unknown/>
</f></lime_gl_uniform2fv>
		<lime_gl_uniform2i line="1291" static="1"><f a="::">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_uniform2i>
		<lime_gl_uniform2iv line="1292" static="1"><f a=":">
	<t path="openfl.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></lime_gl_uniform2iv>
		<lime_gl_uniform3f line="1293" static="1"><f a=":::">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_uniform3f>
		<lime_gl_uniform3fv line="1294" static="1"><f a=":">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="openfl.gl.Float32Data"/>
	<unknown/>
</f></lime_gl_uniform3fv>
		<lime_gl_uniform3i line="1295" static="1"><f a=":::">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_uniform3i>
		<lime_gl_uniform3iv line="1296" static="1"><f a=":">
	<t path="openfl.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></lime_gl_uniform3iv>
		<lime_gl_uniform4f line="1297" static="1"><f a="::::">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_uniform4f>
		<lime_gl_uniform4fv line="1298" static="1"><f a=":">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="openfl.gl.Float32Data"/>
	<unknown/>
</f></lime_gl_uniform4fv>
		<lime_gl_uniform4i line="1299" static="1"><f a="::::">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_uniform4i>
		<lime_gl_uniform4iv line="1300" static="1"><f a=":">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="openfl.gl.Float32Data"/>
	<unknown/>
</f></lime_gl_uniform4iv>
		<lime_gl_uniform_matrix line="1301" static="1"><f a=":::">
	<t path="openfl.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<x path="openfl.gl.Float32Data"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_uniform_matrix>
		<lime_gl_use_program line="1302" static="1"><f a="">
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_gl_use_program>
		<lime_gl_validate_program line="1303" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_validate_program>
		<lime_gl_version line="1304" static="1"><f a=""><x path="Int"/></f></lime_gl_version>
		<lime_gl_vertex_attrib1f line="1305" static="1"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_vertex_attrib1f>
		<lime_gl_vertex_attrib1fv line="1306" static="1"><f a=":">
	<x path="Int"/>
	<x path="openfl.gl.Float32Data"/>
	<unknown/>
</f></lime_gl_vertex_attrib1fv>
		<lime_gl_vertex_attrib2f line="1307" static="1"><f a="::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_vertex_attrib2f>
		<lime_gl_vertex_attrib2fv line="1308" static="1"><f a=":">
	<x path="Int"/>
	<x path="openfl.gl.Float32Data"/>
	<unknown/>
</f></lime_gl_vertex_attrib2fv>
		<lime_gl_vertex_attrib3f line="1309" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_vertex_attrib3f>
		<lime_gl_vertex_attrib3fv line="1310" static="1"><f a=":">
	<x path="Int"/>
	<x path="openfl.gl.Float32Data"/>
	<unknown/>
</f></lime_gl_vertex_attrib3fv>
		<lime_gl_vertex_attrib4f line="1311" static="1"><f a="::::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_vertex_attrib4f>
		<lime_gl_vertex_attrib4fv line="1312" static="1"><f a=":">
	<x path="Int"/>
	<x path="openfl.gl.Float32Data"/>
	<unknown/>
</f></lime_gl_vertex_attrib4fv>
		<lime_gl_vertex_attrib_pointer line="1313" static="1"><f a=":::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_vertex_attrib_pointer>
		<lime_gl_viewport line="1314" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_viewport>
	</class>
	<typedef path="openfl.gl.ShaderPrecisionFormat" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GL.hx" module="openfl.gl.GL"><a>
	<rangeMin><x path="Int"/></rangeMin>
	<rangeMax><x path="Int"/></rangeMax>
	<precision><x path="Int"/></precision>
</a></typedef>
	<abstract path="openfl.gl.Float32Data" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GL.hx" module="openfl.gl.GL">
		<from>
			<icast field="fromFloat32Array"><c path="openfl.utils.Float32Array"/></icast>
			<icast field="fromArrayFloat"><c path="Array"><x path="Float"/></c></icast>
		</from>
		<this><d/></this>
		<to><icast field="toDynamic"><c path="Array"><x path="Float"/></c></icast></to>
		<impl><class path="openfl.gl._GL.Float32Data_Impl_" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GL.hx" private="1" module="openfl.gl.GL">
	<_new public="1" get="inline" set="null" line="1331" static="1">
		<f a="data">
			<d/>
			<d/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<toDynamic get="inline" set="null" line="1332" static="1">
		<f a="this">
			<d/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toDynamic>
	<fromFloat32Array get="inline" set="null" line="1333" static="1">
		<f a="f">
			<c path="openfl.utils.Float32Array"/>
			<x path="openfl.gl.Float32Data"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromFloat32Array>
	<fromArrayFloat get="inline" set="null" line="1335" static="1">
		<f a="f">
			<c path="Array"><x path="Float"/></c>
			<x path="openfl.gl.Float32Data"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromArrayFloat>
</class></impl>
	</abstract>
	<class path="openfl.gl._GL.Float32Data_Impl_" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GL.hx" private="1" module="openfl.gl.GL">
		<_new public="1" get="inline" set="null" line="1331" static="1">
			<f a="data">
				<d/>
				<d/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<toDynamic get="inline" set="null" line="1332" static="1">
			<f a="this">
				<d/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toDynamic>
		<fromFloat32Array get="inline" set="null" line="1333" static="1">
			<f a="f">
				<c path="openfl.utils.Float32Array"/>
				<x path="openfl.gl.Float32Data"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromFloat32Array>
		<fromArrayFloat get="inline" set="null" line="1335" static="1">
			<f a="f">
				<c path="Array"><x path="Float"/></c>
				<x path="openfl.gl.Float32Data"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromArrayFloat>
	</class>
	<typedef path="openfl.gl.GLActiveInfo" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GLActiveInfo.hx"><a>
	<type><x path="Int"/></type>
	<size><x path="Int"/></size>
	<name><c path="String"/></name>
</a></typedef>
	<class path="openfl.gl.GLObject" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GLObject.hx">
		<id public="1" set="null"><d/></id>
		<invalidated public="1" get="accessor" set="null"><x path="Bool"/></invalidated>
		<valid public="1" get="accessor" set="null"><x path="Bool"/></valid>
		<version><x path="Int"/></version>
		<getType set="method" line="22"><f a=""><c path="String"/></f></getType>
		<invalidate public="1" set="method" line="29"><f a=""><x path="Void"/></f></invalidate>
		<isValid public="1" set="method" line="36"><f a=""><x path="Bool"/></f></isValid>
		<isInvalid public="1" set="method" line="43"><f a=""><x path="Bool"/></f></isInvalid>
		<toString public="1" set="method" line="50"><f a=""><c path="String"/></f></toString>
		<get_invalidated set="method" line="64"><f a=""><x path="Bool"/></f></get_invalidated>
		<get_valid set="method" line="71"><f a=""><x path="Bool"/></f></get_valid>
		<new set="method" line="14"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.gl.GLBuffer" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GLBuffer.hx">
		<extends path="openfl.gl.GLObject"/>
		<getType set="method" line="14" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="7"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="openfl.gl.GLContextAttributes" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GLContextAttributes.hx"><a>
	<stencil><x path="Bool"/></stencil>
	<preserveDrawingBuffer><x path="Bool"/></preserveDrawingBuffer>
	<premultipliedAlpha><x path="Bool"/></premultipliedAlpha>
	<depth><x path="Bool"/></depth>
	<antialias><x path="Bool"/></antialias>
	<alpha><x path="Bool"/></alpha>
</a></typedef>
	<class path="openfl.gl.GLFramebuffer" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GLFramebuffer.hx">
		<extends path="openfl.gl.GLObject"/>
		<getType set="method" line="14" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="7"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.gl.GLProgram" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GLProgram.hx">
		<extends path="openfl.gl.GLObject"/>
		<shaders public="1"><c path="Array"><c path="openfl.gl.GLShader"/></c></shaders>
		<attach public="1" set="method" line="18"><f a="shader">
	<c path="openfl.gl.GLShader"/>
	<x path="Void"/>
</f></attach>
		<getShaders public="1" set="method" line="25"><f a=""><c path="Array"><c path="openfl.gl.GLShader"/></c></f></getShaders>
		<getType set="method" line="32" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="10"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.gl.GLRenderbuffer" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GLRenderbuffer.hx">
		<extends path="openfl.gl.GLObject"/>
		<getType set="method" line="14" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="7"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.gl.GLShader" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GLShader.hx">
		<extends path="openfl.gl.GLObject"/>
		<getType set="method" line="14" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="7"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.gl.GLTexture" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GLTexture.hx">
		<extends path="openfl.gl.GLObject"/>
		<getType set="method" line="14" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="7"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="openfl.gl.GLUniformLocation" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/gl/GLUniformLocation.hx"><d/></typedef>
	<typedef path="openfl.utils.ArrayBuffer" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/utils/ArrayBuffer.hx"><c path="flash.utils.ByteArray"/></typedef>
	<class path="openfl.utils.ArrayBufferView" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/utils/ArrayBufferView.hx">
		<implements path="openfl.utils.IMemoryRange"/>
		<invalidDataIndex line="18" static="1"><c path="String"/></invalidDataIndex>
		<buffer public="1" set="null"><c path="flash.utils.ByteArray"/></buffer>
		<byteOffset public="1" set="null"><x path="Int"/></byteOffset>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<bytes><t path="haxe.io.BytesData"/></bytes>
		<getByteBuffer public="1" set="method" line="77"><f a=""><c path="flash.utils.ByteArray"/></f></getByteBuffer>
		<getFloat32 public="1" get="inline" set="null" line="84"><f a="position">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat32>
		<getInt16 public="1" get="inline" set="null" line="96"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt16>
		<getInt32 public="1" get="inline" set="null" line="108"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt32>
		<getLength public="1" set="method" line="120"><f a=""><x path="Int"/></f></getLength>
		<getNativePointer public="1" set="method" line="127"><f a=""><d/></f></getNativePointer>
		<getStart public="1" set="method" line="134"><f a=""><x path="Int"/></f></getStart>
		<getUInt8 public="1" get="inline" set="null" line="141"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getUInt8>
		<setFloat32 public="1" get="inline" set="null" line="153"><f a="position:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat32>
		<setInt16 public="1" get="inline" set="null" line="165"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt16>
		<setInt32 public="1" get="inline" set="null" line="177"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt32>
		<setUInt8 public="1" get="inline" set="null" line="189"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUInt8>
		<new set="method" line="24"><f a="lengthOrBuffer:?byteOffset:?length" v=":0:null">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.utils.Float32Array" params="" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/utils/Float32Array.hx">
		<extends path="openfl.utils.ArrayBufferView"/>
		<SBYTES_PER_ELEMENT public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></SBYTES_PER_ELEMENT>
		<fromMatrix public="1" set="method" line="78" static="1"><f a="matrix">
	<c path="flash.geom.Matrix3D"/>
	<c path="openfl.utils.Float32Array"/>
</f></fromMatrix>
		<BYTES_PER_ELEMENT public="1" set="null"><x path="Int"/></BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<__get public="1" get="inline" set="null" line="85">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="86">
			<f a="index:value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<new public="1" set="method" line="16"><f a="bufferOrArray:?start:?length" v=":0:null">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.utils.WeakRef" params="T" file="C:\HaxeToolkit\haxe\lib/openfl-native/1,4,0/openfl/utils/WeakRef.hx">
		<lime_weak_ref_create line="77" static="1"><d/></lime_weak_ref_create>
		<lime_weak_ref_get line="78" static="1"><d/></lime_weak_ref_get>
		<hardRef><c path="openfl.utils.WeakRef.T"/></hardRef>
		<weakRef><x path="Int"/></weakRef>
		<get public="1" set="method" line="31"><f a=""><c path="openfl.utils.WeakRef.T"/></f></get>
		<toString public="1" set="method" line="57"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="14"><f a="object:?makeWeak" v=":true">
	<c path="openfl.utils.WeakRef.T"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.Animation" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Animation.hx">
		<binarySearch public="1" set="method" line="87" static="1">
			<f a="values:target:step">
				<x path="haxe.ds.Vector"><x path="Float"/></x>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@param target After the first and before the last entry.</haxe_doc>
		</binarySearch>
		<linearSearch set="method" line="102" static="1"><f a="values:target:step">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
</f></linearSearch>
		<name public="1"><c path="String"/></name>
		<timelines><c path="Array"><c path="spinehx.Timeline"/></c></timelines>
		<duration><x path="Float"/></duration>
		<getTimelines public="1" set="method" line="45"><f a=""><c path="Array"><c path="spinehx.Timeline"/></c></f></getTimelines>
		<getDuration public="1" set="method" line="50">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the duration of the animation in seconds.</haxe_doc>
		</getDuration>
		<setDuration public="1" set="method" line="54"><f a="duration">
	<x path="Float"/>
	<x path="Void"/>
</f></setDuration>
		<apply public="1" set="method" line="59">
			<f a="skeleton:time:loop">
				<c path="spinehx.Skeleton"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Poses the skeleton at the specified time for this animation.</haxe_doc>
		</apply>
		<mix public="1" set="method" line="69">
			<f a="skeleton:time:loop:alpha">
				<c path="spinehx.Skeleton"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Poses the skeleton at the specified time for this animation mixed with the current pose.
	 * @param alpha The amount of this animation that affects the current pose.</haxe_doc>
		</mix>
		<getName public="1" set="method" line="78"><f a=""><c path="String"/></f></getName>
		<toString public="1" set="method" line="82"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="37"><f a="name:timelines:duration">
	<c path="String"/>
	<c path="Array"><c path="spinehx.Timeline"/></c>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.Timeline" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Animation.hx" module="spinehx.Animation" interface="1"><apply public="1" set="method">
	<f a="skeleton:time:alpha">
		<c path="spinehx.Skeleton"/>
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<haxe_doc>Sets the value(s) for the specified time.</haxe_doc>
</apply></class>
	<class path="spinehx.CurveTimeline" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Animation.hx" module="spinehx.Animation">
		<implements path="spinehx.Timeline"/>
		<LINEAR get="inline" set="null" line="119" static="1"><x path="Float"/></LINEAR>
		<STEPPED get="inline" set="null" line="120" static="1"><x path="Float"/></STEPPED>
		<BEZIER_SEGMENTS get="inline" set="null" line="121" static="1"><x path="Int"/></BEZIER_SEGMENTS>
		<curves><x path="haxe.ds.Vector"><x path="Float"/></x></curves>
		<apply public="1" set="method" line="129"><f a="skeleton:time:alpha">
	<c path="spinehx.Skeleton"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></apply>
		<getFrameCount public="1" set="method" line="133"><f a=""><x path="Int"/></f></getFrameCount>
		<setLinear public="1" set="method" line="137"><f a="frameIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></setLinear>
		<setStepped public="1" set="method" line="141"><f a="frameIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></setStepped>
		<setCurve public="1" set="method" line="148">
			<f a="frameIndex:cx1:cy1:cx2:cy2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
     * the difference between the keyframe's values.</haxe_doc>
		</setCurve>
		<getCurvePercent public="1" set="method" line="169"><f a="frameIndex:percent">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getCurvePercent>
		<new public="1" set="method" line="125"><f a="frameCount">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Base class for frames that use an interpolation bezier curve.</haxe_doc>
	</class>
	<class path="spinehx.RotateTimeline" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Animation.hx" module="spinehx.Animation">
		<extends path="spinehx.CurveTimeline"/>
		<LAST_FRAME_TIME get="inline" set="null" line="201" static="1"><x path="Int"/></LAST_FRAME_TIME>
		<FRAME_VALUE get="inline" set="null" line="202" static="1"><x path="Int"/></FRAME_VALUE>
		<boneIndex><x path="Int"/></boneIndex>
		<frames><x path="haxe.ds.Vector"><x path="Float"/></x></frames>
		<setBoneIndex public="1" set="method" line="212"><f a="boneIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></setBoneIndex>
		<getBoneIndex public="1" set="method" line="216"><f a=""><x path="Int"/></f></getBoneIndex>
		<getFrames public="1" set="method" line="220"><f a=""><x path="haxe.ds.Vector"><x path="Float"/></x></f></getFrames>
		<setFrame public="1" set="method" line="225">
			<f a="frameIndex:time:angle">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the time and angle of the specified keyframe.</haxe_doc>
		</setFrame>
		<apply public="1" set="method" line="231" override="1"><f a="skeleton:time:alpha">
	<c path="spinehx.Skeleton"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="207"><f a="frameCount">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.TranslateTimeline" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Animation.hx" module="spinehx.Animation">
		<extends path="spinehx.CurveTimeline"/>
		<LAST_FRAME_TIME get="inline" set="null" line="268" static="1"><x path="Int"/></LAST_FRAME_TIME>
		<FRAME_X get="inline" set="null" line="269" static="1"><x path="Int"/></FRAME_X>
		<FRAME_Y get="inline" set="null" line="270" static="1"><x path="Int"/></FRAME_Y>
		<boneIndex><x path="Int"/></boneIndex>
		<frames><x path="haxe.ds.Vector"><x path="Float"/></x></frames>
		<setBoneIndex public="1" set="method" line="280"><f a="boneIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></setBoneIndex>
		<getBoneIndex public="1" set="method" line="284"><f a=""><x path="Int"/></f></getBoneIndex>
		<getFrames public="1" set="method" line="288"><f a=""><x path="haxe.ds.Vector"><x path="Float"/></x></f></getFrames>
		<setFrame public="1" set="method" line="293">
			<f a="frameIndex:time:x:y">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the time and value of the specified keyframe.</haxe_doc>
		</setFrame>
		<apply public="1" set="method" line="300" override="1"><f a="skeleton:time:alpha">
	<c path="spinehx.Skeleton"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="275"><f a="frameCount">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.ScaleTimeline" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Animation.hx" module="spinehx.Animation">
		<extends path="spinehx.TranslateTimeline"/>
		<apply public="1" set="method" line="329" override="1"><f a="skeleton:time:alpha">
	<c path="spinehx.Skeleton"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="325"><f a="frameCount">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.ColorTimeline" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Animation.hx" module="spinehx.Animation">
		<extends path="spinehx.CurveTimeline"/>
		<LAST_FRAME_TIME get="inline" set="null" line="355" static="1"><x path="Int"/></LAST_FRAME_TIME>
		<FRAME_R get="inline" set="null" line="356" static="1"><x path="Int"/></FRAME_R>
		<FRAME_G get="inline" set="null" line="357" static="1"><x path="Int"/></FRAME_G>
		<FRAME_B get="inline" set="null" line="358" static="1"><x path="Int"/></FRAME_B>
		<FRAME_A get="inline" set="null" line="359" static="1"><x path="Int"/></FRAME_A>
		<slotIndex><x path="Int"/></slotIndex>
		<frames><x path="haxe.ds.Vector"><x path="Float"/></x></frames>
		<setSlotIndex public="1" set="method" line="369"><f a="slotIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></setSlotIndex>
		<getSlotIndex public="1" set="method" line="373"><f a=""><x path="Int"/></f></getSlotIndex>
		<getFrames public="1" set="method" line="377"><f a=""><x path="haxe.ds.Vector"><x path="Float"/></x></f></getFrames>
		<setFrame public="1" set="method" line="382">
			<f a="frameIndex:time:r:g:b:a">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the time and value of the specified keyframe.</haxe_doc>
		</setFrame>
		<apply public="1" set="method" line="391" override="1"><f a="skeleton:time:alpha">
	<c path="spinehx.Skeleton"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="364"><f a="frameCount">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.AttachmentTimeline" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Animation.hx" module="spinehx.Animation">
		<implements path="spinehx.Timeline"/>
		<slotIndex><x path="Int"/></slotIndex>
		<frames><x path="haxe.ds.Vector"><x path="Float"/></x></frames>
		<attachmentNames><x path="haxe.ds.Vector"><c path="String"/></x></attachmentNames>
		<getFrameCount public="1" set="method" line="437"><f a=""><x path="Int"/></f></getFrameCount>
		<getSlotIndex public="1" set="method" line="441"><f a=""><x path="Int"/></f></getSlotIndex>
		<setSlotIndex public="1" set="method" line="445"><f a="slotIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></setSlotIndex>
		<getFrames public="1" set="method" line="449"><f a=""><x path="haxe.ds.Vector"><x path="Float"/></x></f></getFrames>
		<getAttachmentNames public="1" set="method" line="453"><f a=""><x path="haxe.ds.Vector"><c path="String"/></x></f></getAttachmentNames>
		<setFrame public="1" set="method" line="458">
			<f a="frameIndex:time:attachmentName">
				<x path="Int"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the time and value of the specified keyframe.</haxe_doc>
		</setFrame>
		<apply public="1" set="method" line="463"><f a="skeleton:time:alpha">
	<c path="spinehx.Skeleton"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="432"><f a="frameCount">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.AnimationState" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/AnimationState.hx">
		<data><c path="spinehx.AnimationStateData"/></data>
		<current><c path="spinehx.Animation"/></current>
		<previous><c path="spinehx.Animation"/></previous>
		<currentTime><x path="Float"/></currentTime>
		<previousTime><x path="Float"/></previousTime>
		<currentLoop><x path="Bool"/></currentLoop>
		<previousLoop><x path="Bool"/></previousLoop>
		<mixTime><x path="Float"/></mixTime>
		<mixDuration><x path="Float"/></mixDuration>
		<queue><c path="Array"><c path="spinehx.QueueEntry"/></c></queue>
		<update public="1" set="method" line="44"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<apply public="1" set="method" line="59"><f a="skeleton">
	<c path="spinehx.Skeleton"/>
	<x path="Void"/>
</f></apply>
		<clearAnimation public="1" set="method" line="73"><f a=""><x path="Void"/></f></clearAnimation>
		<clearQueue public="1" set="method" line="79"><f a=""><x path="Void"/></f></clearQueue>
		<setAnimationInternal set="method" line="86">
			<f a="animation:loop">
				<c path="spinehx.Animation"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the current animation. The current animation time is set to 0.
	 * @param animation May be null.</haxe_doc>
		</setAnimationInternal>
		<setAnimationByName public="1" set="method" line="103">
			<f a="animationName:loop">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@see #setAnimation(Animation, boolean)</haxe_doc>
		</setAnimationByName>
		<setAnimation public="1" set="method" line="111">
			<f a="animation:loop">
				<c path="spinehx.Animation"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the current animation. Any queued animations are cleared and the current animation time is set to 0.
	 * @param animation May be null.</haxe_doc>
		</setAnimation>
		<addAnimationByNameSimple public="1" set="method" line="117">
			<f a="animationName:loop">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@see #addAnimation(Animation, boolean)</haxe_doc>
		</addAnimationByNameSimple>
		<addAnimationByName public="1" set="method" line="122">
			<f a="animationName:loop:delay">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@see #addAnimation(Animation, boolean, float)</haxe_doc>
		</addAnimationByName>
		<addAnimationSimple public="1" set="method" line="130">
			<f a="animation:loop">
				<c path="spinehx.Animation"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds an animation to be played delay seconds after the current or last queued animation, taking into account any mix
	 * duration.</haxe_doc>
		</addAnimationSimple>
		<addAnimation public="1" set="method" line="136">
			<f a="animation:loop:delay">
				<c path="spinehx.Animation"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Adds an animation to be played delay seconds after the current or last queued animation.
	 * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay.]]></haxe_doc>
		</addAnimation>
		<getAnimation public="1" set="method" line="154">
			<f a=""><c path="spinehx.Animation"/></f>
			<haxe_doc>@return May be null.</haxe_doc>
		</getAnimation>
		<getTime public="1" set="method" line="159">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the time within the current animation.</haxe_doc>
		</getTime>
		<setTime public="1" set="method" line="163"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></setTime>
		<isComplete public="1" set="method" line="168">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if no animation is set or if the current time is greater than the animation duration, regardless of looping.</haxe_doc>
		</isComplete>
		<getData public="1" set="method" line="172"><f a=""><c path="spinehx.AnimationStateData"/></f></getData>
		<toString public="1" set="method" line="176"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="38"><f a="data">
	<c path="spinehx.AnimationStateData"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Stores state for an animation and automatically mixes between animations.</haxe_doc>
	</class>
	<class path="spinehx.QueueEntry" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/AnimationState.hx" module="spinehx.AnimationState">
		<animation public="1"><c path="spinehx.Animation"/></animation>
		<loop public="1"><x path="Bool"/></loop>
		<delay public="1"><x path="Float"/></delay>
		<new public="1" set="method" line="186"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="spinehx.AnimationStateData" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/AnimationStateData.hx">
		<makeIdByName get="inline" set="null" line="67" static="1"><f a="name1:name2">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></makeIdByName>
		<makeId get="inline" set="null" line="70" static="1"><f a="a1:a2">
	<c path="spinehx.Animation"/>
	<c path="spinehx.Animation"/>
	<c path="String"/>
</f></makeId>
		<skeletonData><c path="spinehx.SkeletonData"/></skeletonData>
		<animationToMixTime><x path="Map">
	<c path="String"/>
	<t path="Null"><x path="Float"/></t>
</x></animationToMixTime>
		<getSkeletonData public="1" set="method" line="39"><f a=""><c path="spinehx.SkeletonData"/></f></getSkeletonData>
		<setMixByName public="1" set="method" line="43"><f a="fromName:toName:duration">
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMixByName>
		<setMix public="1" set="method" line="52"><f a="_from:_to:duration">
	<c path="spinehx.Animation"/>
	<c path="spinehx.Animation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMix>
		<getMix public="1" set="method" line="59"><f a="_from:_to">
	<c path="spinehx.Animation"/>
	<c path="spinehx.Animation"/>
	<x path="Float"/>
</f></getMix>
		<new public="1" set="method" line="34"><f a="skeletonData">
	<c path="spinehx.SkeletonData"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Stores mixing times between animations.</haxe_doc>
	</class>
	<class path="spinehx.ArrayUtils" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/ArrayUtils.hx">
		<allocFloat public="1" set="method" line="5" static="1"><f a="n">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
</f></allocFloat>
		<allocString public="1" set="method" line="16" static="1"><f a="n">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><c path="String"/></x>
</f></allocString>
	</class>
	<class path="spinehx.Bone" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Bone.hx">
		<copy public="1" set="method" line="54" static="1">
			<f a="bone:parent">
				<c path="spinehx.Bone"/>
				<c path="spinehx.Bone"/>
				<c path="spinehx.Bone"/>
			</f>
			<haxe_doc>Copy constructor.
	 * @param parent May be null.</haxe_doc>
		</copy>
		<data public="1"><c path="spinehx.BoneData"/></data>
		<parent public="1"><c path="spinehx.Bone"/></parent>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<rotation public="1"><x path="Float"/></rotation>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<m00 public="1"><x path="Float"/></m00>
		<m01 public="1"><x path="Float"/></m01>
		<worldX public="1"><x path="Float"/></worldX>
		<m10 public="1"><x path="Float"/></m10>
		<m11 public="1"><x path="Float"/></m11>
		<worldY public="1"><x path="Float"/></worldY>
		<worldRotation public="1"><x path="Float"/></worldRotation>
		<worldScaleX public="1"><x path="Float"/></worldScaleX>
		<worldScaleY public="1"><x path="Float"/></worldScaleY>
		<updateWorldTransform public="1" set="method" line="66">
			<f a="flipX:flipY">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Computes the world SRT using the parent bone and the local SRT.</haxe_doc>
		</updateWorldTransform>
		<setToSetupPose public="1" set="method" line="103"><f a=""><x path="Void"/></f></setToSetupPose>
		<getData public="1" set="method" line="112"><f a=""><c path="spinehx.BoneData"/></f></getData>
		<getParent public="1" set="method" line="116"><f a=""><c path="spinehx.Bone"/></f></getParent>
		<getX public="1" set="method" line="120"><f a=""><x path="Float"/></f></getX>
		<setX public="1" set="method" line="124"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></setX>
		<getY public="1" set="method" line="128"><f a=""><x path="Float"/></f></getY>
		<setY public="1" set="method" line="132"><f a="y">
	<x path="Float"/>
	<x path="Void"/>
</f></setY>
		<getRotation public="1" set="method" line="136"><f a=""><x path="Float"/></f></getRotation>
		<setRotation public="1" set="method" line="140"><f a="rotation">
	<x path="Float"/>
	<x path="Void"/>
</f></setRotation>
		<getScaleX public="1" set="method" line="144"><f a=""><x path="Float"/></f></getScaleX>
		<setScaleX public="1" set="method" line="148"><f a="scaleX">
	<x path="Float"/>
	<x path="Void"/>
</f></setScaleX>
		<getScaleY public="1" set="method" line="152"><f a=""><x path="Float"/></f></getScaleY>
		<setScaleY public="1" set="method" line="156"><f a="scaleY">
	<x path="Float"/>
	<x path="Void"/>
</f></setScaleY>
		<getM00 public="1" set="method" line="160"><f a=""><x path="Float"/></f></getM00>
		<getM01 public="1" set="method" line="164"><f a=""><x path="Float"/></f></getM01>
		<getM10 public="1" set="method" line="168"><f a=""><x path="Float"/></f></getM10>
		<getM11 public="1" set="method" line="172"><f a=""><x path="Float"/></f></getM11>
		<getWorldX public="1" set="method" line="176"><f a=""><x path="Float"/></f></getWorldX>
		<getWorldY public="1" set="method" line="180"><f a=""><x path="Float"/></f></getWorldY>
		<getWorldRotation public="1" set="method" line="184"><f a=""><x path="Float"/></f></getWorldRotation>
		<getWorldScaleX public="1" set="method" line="188"><f a=""><x path="Float"/></f></getWorldScaleX>
		<getWorldScaleY public="1" set="method" line="192"><f a=""><x path="Float"/></f></getWorldScaleY>
		<toString public="1" set="method" line="211"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="45">
			<f a="data:parent">
				<c path="spinehx.BoneData"/>
				<c path="spinehx.Bone"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param parent May be null.</haxe_doc>
		</new>
	</class>
	<class path="spinehx.BoneData" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/BoneData.hx">
		<copy public="1" set="method" line="49" static="1">
			<f a="bone:?parent" v=":null">
				<c path="spinehx.BoneData"/>
				<c path="spinehx.BoneData"/>
				<c path="spinehx.BoneData"/>
			</f>
			<haxe_doc>Copy constructor.
	 * @param parent May be null.</haxe_doc>
		</copy>
		<parent public="1"><c path="spinehx.BoneData"/></parent>
		<name public="1"><c path="String"/></name>
		<length public="1"><x path="Float"/></length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<rotation public="1"><x path="Float"/></rotation>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<inheritScale public="1"><x path="Bool"/></inheritScale>
		<inheritRotation public="1"><x path="Bool"/></inheritRotation>
		<getParent public="1" set="method" line="62">
			<f a=""><c path="spinehx.BoneData"/></f>
			<haxe_doc>@return May be null.</haxe_doc>
		</getParent>
		<getName public="1" set="method" line="66"><f a=""><c path="String"/></f></getName>
		<getLength public="1" set="method" line="70"><f a=""><x path="Float"/></f></getLength>
		<setLength public="1" set="method" line="74"><f a="length">
	<x path="Float"/>
	<x path="Void"/>
</f></setLength>
		<getX public="1" set="method" line="78"><f a=""><x path="Float"/></f></getX>
		<setX public="1" set="method" line="82"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></setX>
		<getY public="1" set="method" line="86"><f a=""><x path="Float"/></f></getY>
		<setY public="1" set="method" line="90"><f a="y">
	<x path="Float"/>
	<x path="Void"/>
</f></setY>
		<getRotation public="1" set="method" line="94"><f a=""><x path="Float"/></f></getRotation>
		<setRotation public="1" set="method" line="98"><f a="rotation">
	<x path="Float"/>
	<x path="Void"/>
</f></setRotation>
		<getScaleX public="1" set="method" line="102"><f a=""><x path="Float"/></f></getScaleX>
		<setScaleX public="1" set="method" line="106"><f a="scaleX">
	<x path="Float"/>
	<x path="Void"/>
</f></setScaleX>
		<getScaleY public="1" set="method" line="110"><f a=""><x path="Float"/></f></getScaleY>
		<setScaleY public="1" set="method" line="114"><f a="scaleY">
	<x path="Float"/>
	<x path="Void"/>
</f></setScaleY>
		<getInheritScale public="1" set="method" line="118"><f a=""><x path="Bool"/></f></getInheritScale>
		<setInheritScale public="1" set="method" line="122"><f a="inheritScale">
	<x path="Bool"/>
	<x path="Void"/>
</f></setInheritScale>
		<getInheritRotation public="1" set="method" line="126"><f a=""><x path="Bool"/></f></getInheritRotation>
		<setInheritRotation public="1" set="method" line="130"><f a="inheritRotation">
	<x path="Bool"/>
	<x path="Void"/>
</f></setInheritRotation>
		<toString public="1" set="method" line="134"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="41">
			<f a="name:parent">
				<c path="String"/>
				<c path="spinehx.BoneData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param parent May be null.</haxe_doc>
		</new>
	</class>
	<class path="spinehx.Color" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Color.hx">
		<copy public="1" set="method" line="13" static="1"><f a="c">
	<c path="spinehx.Color"/>
	<c path="spinehx.Color"/>
</f></copy>
		<valueOf public="1" set="method" line="33" static="1"><f a="s">
	<c path="String"/>
	<c path="spinehx.Color"/>
</f></valueOf>
		<r public="1"><x path="Float"/></r>
		<g public="1"><x path="Float"/></g>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<set2 public="1" set="method" line="9"><f a="c">
	<c path="spinehx.Color"/>
	<x path="Void"/>
</f></set2>
		<add public="1" set="method" line="17"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></add>
		<set public="1" set="method" line="26"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<new public="1" set="method" line="35"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.Exception" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Exception.hx">
		<msg public="1"><c path="String"/></msg>
		<new public="1" set="method" line="4"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="spinehx.RuntimeException" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Exception.hx" module="spinehx.Exception"><c path="spinehx.Exception"/></typedef>
	<typedef path="spinehx.IllegalArgumentException" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Exception.hx" module="spinehx.Exception"><c path="spinehx.Exception"/></typedef>
	<typedef path="spinehx.IllegalStateException" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Exception.hx" module="spinehx.Exception"><c path="spinehx.Exception"/></typedef>
	<typedef path="spinehx.SerializationException" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Exception.hx" module="spinehx.Exception"><c path="spinehx.Exception"/></typedef>
	<typedef path="spinehx.JsonNode" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/JsonUtils.hx" module="spinehx.JsonUtils"><d/></typedef>
	<class path="spinehx.JsonUtils" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/JsonUtils.hx">
		<parse public="1" set="method" line="9" static="1"><f a="data">
	<c path="String"/>
	<t path="spinehx.JsonNode"/>
</f></parse>
		<fields public="1" set="method" line="13" static="1"><f a="node">
	<t path="spinehx.JsonNode"/>
	<c path="Array"><c path="String"/></c>
</f></fields>
		<getNode public="1" set="method" line="17" static="1"><f a="node:field">
	<t path="spinehx.JsonNode"/>
	<c path="String"/>
	<t path="spinehx.JsonNode"/>
</f></getNode>
		<getDynamic public="1" set="method" line="21" static="1"><f a="node:field">
	<t path="spinehx.JsonNode"/>
	<c path="String"/>
	<d/>
</f></getDynamic>
		<getNodesArray public="1" set="method" line="25" static="1"><f a="node:field">
	<t path="spinehx.JsonNode"/>
	<c path="String"/>
	<c path="Array"><t path="spinehx.JsonNode"/></c>
</f></getNodesArray>
		<getInt public="1" set="method" line="29" static="1"><f a="node:field">
	<t path="spinehx.JsonNode"/>
	<c path="String"/>
	<x path="Int"/>
</f></getInt>
		<getStr public="1" set="method" line="33" static="1"><f a="node:field">
	<t path="spinehx.JsonNode"/>
	<c path="String"/>
	<c path="String"/>
</f></getStr>
		<getBool public="1" set="method" line="36" static="1"><f a="node:field:?defaultValue" v="::false">
	<t path="spinehx.JsonNode"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></getBool>
	</class>
	<class path="spinehx.MathUtils" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/MathUtils.hx">
		<radToDeg public="1" get="inline" set="null" line="10" static="1">
			<f a="rad">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Converts specified angle in radians to degrees.
     * @return angle in degrees (not normalized to 0...360)</haxe_doc>
		</radToDeg>
		<degToRad public="1" get="inline" set="null" line="18" static="1">
			<f a="deg">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Converts specified angle in degrees to radians.
     * @return angle in radians (not normalized to 0...Math.PI*2)</haxe_doc>
		</degToRad>
		<clamp public="1" get="inline" set="null" line="29" static="1">
			<f a="value:min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* "Clamps" a value to boundaries [min, max].
     * Example:
     * clamp(2, 1, 5) == 2;
     * clamp(0, 1, 5) == 1;
     * clamp(6, 1, 5) == 5;</haxe_doc>
		</clamp>
		<random public="1" get="inline" set="null" line="38" static="1"><f a="max">
	<x path="Int"/>
	<x path="Int"/>
</f></random>
		<minInt public="1" get="inline" set="null" line="42" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></minInt>
		<maxInt public="1" get="inline" set="null" line="46" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></maxInt>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="spinehx.Skeleton" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Skeleton.hx">
		<create public="1" set="method" line="53" static="1"><f a="data">
	<c path="spinehx.SkeletonData"/>
	<c path="spinehx.Skeleton"/>
</f></create>
		<copy public="1" set="method" line="73" static="1">
			<f a="skeleton">
				<c path="spinehx.Skeleton"/>
				<c path="spinehx.Skeleton"/>
			</f>
			<haxe_doc>Copy constructor.</haxe_doc>
		</copy>
		<data public="1"><c path="spinehx.SkeletonData"/></data>
		<bones public="1"><c path="Array"><c path="spinehx.Bone"/></c></bones>
		<slots public="1"><c path="Array"><c path="spinehx.Slot"/></c></slots>
		<drawOrder public="1"><c path="Array"><c path="spinehx.Slot"/></c></drawOrder>
		<skin public="1"><c path="spinehx.Skin"/></skin>
		<color public="1"><c path="spinehx.Color"/></color>
		<time public="1"><x path="Float"/></time>
		<flipX public="1"><x path="Bool"/></flipX>
		<flipY public="1"><x path="Bool"/></flipY>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<updateWorldTransform public="1" set="method" line="99">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Updates the world transform for each bone.</haxe_doc>
		</updateWorldTransform>
		<setToSetupPose public="1" set="method" line="107">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Sets the bones and slots to their setup pose values.</haxe_doc>
		</setToSetupPose>
		<setBonesToSetupPose public="1" set="method" line="112"><f a=""><x path="Void"/></f></setBonesToSetupPose>
		<setSlotsToSetupPose public="1" set="method" line="117"><f a=""><x path="Void"/></f></setSlotsToSetupPose>
		<getData public="1" set="method" line="122"><f a=""><c path="spinehx.SkeletonData"/></f></getData>
		<getBones public="1" set="method" line="126"><f a=""><c path="Array"><c path="spinehx.Bone"/></c></f></getBones>
		<getRootBone public="1" set="method" line="131">
			<f a=""><c path="spinehx.Bone"/></f>
			<haxe_doc>@return May return null.</haxe_doc>
		</getRootBone>
		<findBone public="1" set="method" line="137">
			<f a="boneName">
				<c path="String"/>
				<c path="spinehx.Bone"/>
			</f>
			<haxe_doc>@return May be null.</haxe_doc>
		</findBone>
		<findBoneIndex public="1" set="method" line="146">
			<f a="boneName">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@return -1 if the bone was not found.</haxe_doc>
		</findBoneIndex>
		<getSlots public="1" set="method" line="153"><f a=""><c path="Array"><c path="spinehx.Slot"/></c></f></getSlots>
		<findSlot public="1" set="method" line="158">
			<f a="slotName">
				<c path="String"/>
				<c path="spinehx.Slot"/>
			</f>
			<haxe_doc>@return May be null.</haxe_doc>
		</findSlot>
		<findSlotIndex public="1" set="method" line="167">
			<f a="slotName">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@return -1 if the bone was not found.</haxe_doc>
		</findSlotIndex>
		<getDrawOrder public="1" set="method" line="175">
			<f a=""><c path="Array"><c path="spinehx.Slot"/></c></f>
			<haxe_doc>Returns the slots in the order they will be drawn. The returned array may be modified to change the draw order.</haxe_doc>
		</getDrawOrder>
		<getSkin public="1" set="method" line="180">
			<f a=""><c path="spinehx.Skin"/></f>
			<haxe_doc>@return May be null.</haxe_doc>
		</getSkin>
		<setSkinByName public="1" set="method" line="186">
			<f a="skinName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a skin by name.
	 * @see #setSkin(Skin)</haxe_doc>
		</setSkinByName>
		<setSkin public="1" set="method" line="195">
			<f a="newSkin">
				<c path="spinehx.Skin"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the skin used to look up attachments not found in the {@link SkeletonData#getDefaultSkin() default skin}. Attachments
	 * from the new skin are attached if the corresponding attachment from the old skin was attached.
	 * @param newSkin May be null.</haxe_doc>
		</setSkin>
		<getAttachmentByName public="1" set="method" line="201">
			<f a="slotName:attachmentName">
				<c path="String"/>
				<c path="String"/>
				<c path="spinehx.attachments.Attachment"/>
			</f>
			<haxe_doc>@return May be null.</haxe_doc>
		</getAttachmentByName>
		<getAttachment public="1" set="method" line="206">
			<f a="slotIndex:attachmentName">
				<x path="Int"/>
				<c path="String"/>
				<c path="spinehx.attachments.Attachment"/>
			</f>
			<haxe_doc>@return May be null.</haxe_doc>
		</getAttachment>
		<setAttachment public="1" set="method" line="217">
			<f a="slotName:attachmentName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param attachmentName May be null.</haxe_doc>
		</setAttachment>
		<getColor public="1" set="method" line="235"><f a=""><c path="spinehx.Color"/></f></getColor>
		<getFlipX public="1" set="method" line="239"><f a=""><x path="Bool"/></f></getFlipX>
		<setFlipX public="1" set="method" line="243"><f a="flipX">
	<x path="Bool"/>
	<x path="Void"/>
</f></setFlipX>
		<getFlipY public="1" set="method" line="247"><f a=""><x path="Bool"/></f></getFlipY>
		<setFlipY public="1" set="method" line="251"><f a="flipY">
	<x path="Bool"/>
	<x path="Void"/>
</f></setFlipY>
		<getX public="1" set="method" line="255"><f a=""><x path="Float"/></f></getX>
		<setX public="1" set="method" line="259"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></setX>
		<getY public="1" set="method" line="263"><f a=""><x path="Float"/></f></getY>
		<setY public="1" set="method" line="267"><f a="y">
	<x path="Float"/>
	<x path="Void"/>
</f></setY>
		<getTime public="1" set="method" line="271"><f a=""><x path="Float"/></f></getTime>
		<setTime public="1" set="method" line="275"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></setTime>
		<update public="1" set="method" line="279"><f a="delta">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<toString public="1" set="method" line="283"><f a=""><c path="String"/></f></toString>
		<new set="method" line="46"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="spinehx.SkeletonData" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/SkeletonData.hx">
		<name public="1"><c path="String"/></name>
		<bones public="1"><c path="Array"><c path="spinehx.BoneData"/></c></bones>
		<slots public="1"><c path="Array"><c path="spinehx.SlotData"/></c></slots>
		<skins public="1"><c path="Array"><c path="spinehx.Skin"/></c></skins>
		<animations public="1"><c path="Array"><c path="spinehx.Animation"/></c></animations>
		<defaultSkin public="1"><c path="spinehx.Skin"/></defaultSkin>
		<clear public="1" set="method" line="43"><f a=""><x path="Void"/></f></clear>
		<addBone public="1" set="method" line="53"><f a="bone">
	<c path="spinehx.BoneData"/>
	<x path="Void"/>
</f></addBone>
		<getBones public="1" set="method" line="58"><f a=""><c path="Array"><c path="spinehx.BoneData"/></c></f></getBones>
		<findBone public="1" set="method" line="63">
			<f a="boneName">
				<c path="String"/>
				<c path="spinehx.BoneData"/>
			</f>
			<haxe_doc>@return May be null.</haxe_doc>
		</findBone>
		<findBoneIndex public="1" set="method" line="72">
			<f a="boneName">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@return -1 if the bone was not found.</haxe_doc>
		</findBoneIndex>
		<addSlot public="1" set="method" line="81"><f a="slot">
	<c path="spinehx.SlotData"/>
	<x path="Void"/>
</f></addSlot>
		<getSlots public="1" set="method" line="86"><f a=""><c path="Array"><c path="spinehx.SlotData"/></c></f></getSlots>
		<findSlot public="1" set="method" line="91">
			<f a="slotName">
				<c path="String"/>
				<c path="spinehx.SlotData"/>
			</f>
			<haxe_doc>@return May be null.</haxe_doc>
		</findSlot>
		<findSlotIndex public="1" set="method" line="100">
			<f a="slotName">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@return -1 if the bone was not found.</haxe_doc>
		</findSlotIndex>
		<getDefaultSkin public="1" set="method" line="110">
			<f a=""><c path="spinehx.Skin"/></f>
			<haxe_doc>@return May be null.</haxe_doc>
		</getDefaultSkin>
		<setDefaultSkin public="1" set="method" line="115">
			<f a="defaultSkin">
				<c path="spinehx.Skin"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param defaultSkin May be null.</haxe_doc>
		</setDefaultSkin>
		<addSkin public="1" set="method" line="119"><f a="skin">
	<c path="spinehx.Skin"/>
	<x path="Void"/>
</f></addSkin>
		<findSkin public="1" set="method" line="125">
			<f a="skinName">
				<c path="String"/>
				<c path="spinehx.Skin"/>
			</f>
			<haxe_doc>@return May be null.</haxe_doc>
		</findSkin>
		<getSkins public="1" set="method" line="133">
			<f a=""><c path="Array"><c path="spinehx.Skin"/></c></f>
			<haxe_doc>Returns all skins, including the default skin.</haxe_doc>
		</getSkins>
		<addAnimation public="1" set="method" line="139"><f a="animation">
	<c path="spinehx.Animation"/>
	<x path="Void"/>
</f></addAnimation>
		<getAnimations public="1" set="method" line="144"><f a=""><c path="Array"><c path="spinehx.Animation"/></c></f></getAnimations>
		<findAnimation public="1" set="method" line="149">
			<f a="animationName">
				<c path="String"/>
				<c path="spinehx.Animation"/>
			</f>
			<haxe_doc>@return May be null.</haxe_doc>
		</findAnimation>
		<getName public="1" set="method" line="160">
			<f a=""><c path="String"/></f>
			<haxe_doc>@return May be null.</haxe_doc>
		</getName>
		<setName public="1" set="method" line="165">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param name May be null.</haxe_doc>
		</setName>
		<toString public="1" set="method" line="169"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="spinehx.SkeletonJson" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/SkeletonJson.hx">
		<TIMELINE_SCALE public="1" get="inline" set="null" line="43" static="1"><c path="String"/></TIMELINE_SCALE>
		<TIMELINE_ROTATE public="1" get="inline" set="null" line="44" static="1"><c path="String"/></TIMELINE_ROTATE>
		<TIMELINE_TRANSLATE public="1" get="inline" set="null" line="45" static="1"><c path="String"/></TIMELINE_TRANSLATE>
		<TIMELINE_ATTACHMENT public="1" get="inline" set="null" line="46" static="1"><c path="String"/></TIMELINE_ATTACHMENT>
		<TIMELINE_COLOR public="1" get="inline" set="null" line="47" static="1"><c path="String"/></TIMELINE_COLOR>
		<create public="1" set="method" line="52" static="1"><f a="atlas">
	<c path="spinehx.atlas.TextureAtlas"/>
	<c path="spinehx.SkeletonJson"/>
</f></create>
		<getFloat set="method" line="185" static="1"><f a="map:name:?defaultValue" v="::0">
	<t path="spinehx.JsonNode"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getFloat>
		<getFloatAt set="method" line="192" static="1"><f a="array:index">
	<c path="Array"><d/></c>
	<x path="Int"/>
	<x path="Float"/>
</f></getFloatAt>
		<attachmentLoader><c path="spinehx.attachments.AttachmentLoader"/></attachmentLoader>
		<scale><x path="Float"/></scale>
		<getScale public="1" set="method" line="60"><f a=""><x path="Float"/></f></getScale>
		<setScale public="1" set="method" line="65">
			<f a="scale">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scales the bones, images, and animations as they are loaded.</haxe_doc>
		</setScale>
		<readSkeletonData public="1" set="method" line="69"><f a="name:fileData">
	<c path="String"/>
	<c path="String"/>
	<c path="spinehx.SkeletonData"/>
</f></readSkeletonData>
		<readAttachment set="method" line="151"><f a="skin:name:map">
	<c path="spinehx.Skin"/>
	<c path="String"/>
	<t path="spinehx.JsonNode"/>
	<c path="spinehx.attachments.Attachment"/>
</f></readAttachment>
		<readAnimation set="method" line="199"><f a="name:map:skeletonData">
	<c path="String"/>
	<t path="spinehx.JsonNode"/>
	<c path="spinehx.SkeletonData"/>
	<x path="Void"/>
</f></readAnimation>
		<readCurve set="method" line="301"><f a="timeline:frameIndex:valueMap">
	<c path="spinehx.CurveTimeline"/>
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></readCurve>
		<new public="1" set="method" line="56"><f a="attachmentLoader">
	<c path="spinehx.attachments.AttachmentLoader"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.Skin" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Skin.hx">
		<name public="1"><c path="String"/></name>
		<attachments public="1"><x path="Map">
	<c path="String"/>
	<c path="spinehx.AttachmentEntry"/>
</x></attachments>
		<addAttachment public="1" set="method" line="43"><f a="slotIndex:name:attachment">
	<x path="Int"/>
	<c path="String"/>
	<c path="spinehx.attachments.Attachment"/>
	<x path="Void"/>
</f></addAttachment>
		<getAttachment public="1" set="method" line="50">
			<f a="slotIndex:name">
				<x path="Int"/>
				<c path="String"/>
				<c path="spinehx.attachments.Attachment"/>
			</f>
			<haxe_doc>@return May be null.</haxe_doc>
		</getAttachment>
		<findNamesForSlot public="1" set="method" line="56"><f a="slotIndex:names">
	<x path="Int"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></findNamesForSlot>
		<findAttachmentsForSlot public="1" set="method" line="62"><f a="slotIndex:attachments">
	<x path="Int"/>
	<c path="Array"><c path="spinehx.attachments.Attachment"/></c>
	<x path="Void"/>
</f></findAttachmentsForSlot>
		<clear public="1" set="method" line="68"><f a=""><x path="Void"/></f></clear>
		<getName public="1" set="method" line="72"><f a=""><c path="String"/></f></getName>
		<toString public="1" set="method" line="76"><f a=""><c path="String"/></f></toString>
		<attachAll public="1" set="method" line="81">
			<f a="skeleton:oldSkin">
				<c path="spinehx.Skeleton"/>
				<c path="spinehx.Skin"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached.</haxe_doc>
		</attachAll>
		<new public="1" set="method" line="37"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Stores attachments by slot index and attachment name.</haxe_doc>
	</class>
	<class path="spinehx.AttachmentEntry" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Skin.hx" module="spinehx.Skin">
		<makeId public="1" set="method" line="109" static="1"><f a="slotIndex:name">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></makeId>
		<slotIndex public="1"><x path="Int"/></slotIndex>
		<name public="1"><c path="String"/></name>
		<id public="1"><c path="String"/></id>
		<attachment public="1"><c path="spinehx.attachments.Attachment"/></attachment>
		<getId public="1" set="method" line="113"><f a=""><c path="String"/></f></getId>
		<toString public="1" set="method" line="117"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="100"><f a="slotIndex:name:attachment">
	<x path="Int"/>
	<c path="String"/>
	<c path="spinehx.attachments.Attachment"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.Slot" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/Slot.hx">
		<copy public="1" set="method" line="61" static="1">
			<f a="slot:skeleton:bone">
				<c path="spinehx.Slot"/>
				<c path="spinehx.Skeleton"/>
				<c path="spinehx.Bone"/>
				<c path="spinehx.Slot"/>
			</f>
			<haxe_doc>Copy constructor.</haxe_doc>
		</copy>
		<data public="1"><c path="spinehx.SlotData"/></data>
		<bone public="1"><c path="spinehx.Bone"/></bone>
		<skeleton><c path="spinehx.Skeleton"/></skeleton>
		<color public="1"><c path="spinehx.Color"/></color>
		<attachment public="1"><c path="spinehx.attachments.Attachment"/></attachment>
		<attachmentTime><x path="Float"/></attachmentTime>
		<getData public="1" set="method" line="72"><f a=""><c path="spinehx.SlotData"/></f></getData>
		<getSkeleton public="1" set="method" line="76"><f a=""><c path="spinehx.Skeleton"/></f></getSkeleton>
		<getBone public="1" set="method" line="80"><f a=""><c path="spinehx.Bone"/></f></getBone>
		<getColor public="1" set="method" line="84"><f a=""><c path="spinehx.Color"/></f></getColor>
		<getAttachment public="1" set="method" line="89">
			<f a=""><c path="spinehx.attachments.Attachment"/></f>
			<haxe_doc>@return May be null.</haxe_doc>
		</getAttachment>
		<setAttachment public="1" set="method" line="95">
			<f a="attachment">
				<c path="spinehx.attachments.Attachment"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the attachment and resets {@link #getAttachmentTime()}.
	 * @param attachment May be null.</haxe_doc>
		</setAttachment>
		<setAttachmentTime public="1" set="method" line="100"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></setAttachmentTime>
		<getAttachmentTime public="1" set="method" line="105">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the time since the attachment was set.</haxe_doc>
		</getAttachmentTime>
		<setToSetupPose public="1" set="method" line="109"><f a="slotIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></setToSetupPose>
		<setToSetupPoseDefault public="1" set="method" line="114"><f a=""><x path="Void"/></f></setToSetupPoseDefault>
		<toString public="1" set="method" line="118"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="49"><f a="data:skeleton:bone">
	<c path="spinehx.SlotData"/>
	<c path="spinehx.Skeleton"/>
	<c path="spinehx.Bone"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.SlotData" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/SlotData.hx">
		<name public="1"><c path="String"/></name>
		<boneData public="1"><c path="spinehx.BoneData"/></boneData>
		<color public="1"><c path="spinehx.Color"/></color>
		<attachmentName public="1"><c path="String"/></attachmentName>
		<additiveBlending public="1"><x path="Bool"/></additiveBlending>
		<getName public="1" set="method" line="51"><f a=""><c path="String"/></f></getName>
		<getBoneData public="1" set="method" line="55"><f a=""><c path="spinehx.BoneData"/></f></getBoneData>
		<getColor public="1" set="method" line="59"><f a=""><c path="spinehx.Color"/></f></getColor>
		<setAttachmentName public="1" set="method" line="64">
			<f a="attachmentName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param attachmentName May be null.</haxe_doc>
		</setAttachmentName>
		<getAttachmentName public="1" set="method" line="69">
			<f a=""><c path="String"/></f>
			<haxe_doc>@return May be null.</haxe_doc>
		</getAttachmentName>
		<getAdditiveBlending public="1" set="method" line="73"><f a=""><x path="Bool"/></f></getAdditiveBlending>
		<setAdditiveBlending public="1" set="method" line="77"><f a="additiveBlending">
	<x path="Bool"/>
	<x path="Void"/>
</f></setAdditiveBlending>
		<toString public="1" set="method" line="81"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="43"><f a="name:boneData">
	<c path="String"/>
	<c path="spinehx.BoneData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.atlas.Page" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/atlas/TextureAtlas.hx" module="spinehx.atlas.TextureAtlas">
		<textureFile public="1"><c path="String"/></textureFile>
		<texture public="1"><c path="spinehx.atlas.Texture"/></texture>
		<useMipMaps public="1"><x path="Bool"/></useMipMaps>
		<format public="1"><c path="String"/></format>
		<minFilter public="1"><c path="String"/></minFilter>
		<magFilter public="1"><c path="String"/></magFilter>
		<uWrap public="1"><c path="String"/></uWrap>
		<vWrap public="1"><c path="String"/></vWrap>
		<new public="1" set="method" line="41"><f a="textureFile:useMipMaps:format:minFilter:magFilter:uWrap:vWrap">
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.atlas.Region" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/atlas/TextureAtlas.hx" module="spinehx.atlas.TextureAtlas">
		<page public="1"><c path="spinehx.atlas.Page"/></page>
		<index public="1"><x path="Int"/></index>
		<name public="1"><c path="String"/></name>
		<offsetX public="1"><x path="Float"/></offsetX>
		<offsetY public="1"><x path="Float"/></offsetY>
		<originalWidth public="1"><x path="Int"/></originalWidth>
		<originalHeight public="1"><x path="Int"/></originalHeight>
		<rotate public="1"><x path="Bool"/></rotate>
		<left public="1"><x path="Int"/></left>
		<top public="1"><x path="Int"/></top>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<flip public="1"><x path="Bool"/></flip>
		<splits public="1"><c path="Array"><x path="Int"/></c></splits>
		<pads public="1"><c path="Array"><x path="Int"/></c></pads>
		<new public="1" set="method" line="69"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="spinehx.atlas.TextureAtlasData" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/atlas/TextureAtlas.hx" module="spinehx.atlas.TextureAtlas">
		<pages public="1"><c path="Array"><c path="spinehx.atlas.Page"/></c></pages>
		<regions public="1"><c path="Array"><c path="spinehx.atlas.Region"/></c></regions>
		<tuple><c path="Array"><c path="String"/></c></tuple>
		<readValue set="method" line="180"><f a="reader">
	<c path="haxe.io.Input"/>
	<c path="String"/>
</f></readValue>
		<readTuple set="method" line="188">
			<f a="reader">
				<c path="haxe.io.Input"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of tuple values read (2 or 4).</haxe_doc>
		</readTuple>
		<getPages public="1" set="method" line="209"><f a=""><c path="Array"><c path="spinehx.atlas.Page"/></c></f></getPages>
		<getRegions public="1" set="method" line="213"><f a=""><c path="Array"><c path="spinehx.atlas.Region"/></c></f></getRegions>
		<new public="1" set="method" line="81"><f a="packFileData:imagesDir:flip">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.atlas.TextureAtlas" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/atlas/TextureAtlas.hx">
		<create public="1" set="method" line="259" static="1">
			<f a="packFileData:imagesDir:textureLoader:?flip" v=":::false">
				<c path="String"/>
				<c path="String"/>
				<c path="spinehx.atlas.TextureLoader"/>
				<x path="Bool"/>
				<c path="spinehx.atlas.TextureAtlas"/>
			</f>
			<haxe_doc>@param flip If true, all regions loaded will be flipped for use with a perspective where 0,0 is the upper left corner.</haxe_doc>
		</create>
		<textures><c path="Array"><c path="spinehx.atlas.Texture"/></c></textures>
		<regions><c path="Array"><c path="spinehx.atlas.AtlasRegion"/></c></regions>
		<addTexture set="method" line="227"><f a="texture">
	<c path="spinehx.atlas.Texture"/>
	<x path="Void"/>
</f></addTexture>
		<load set="method" line="271"><f a="data:textureLoader">
	<c path="spinehx.atlas.TextureAtlasData"/>
	<c path="spinehx.atlas.TextureLoader"/>
	<x path="Void"/>
</f></load>
		<addRegion public="1" set="method" line="308">
			<f a="name:texture:x:y:width:height">
				<c path="String"/>
				<c path="spinehx.atlas.Texture"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="spinehx.atlas.AtlasRegion"/>
			</f>
			<haxe_doc>Adds a region to the atlas. The specified texture will be disposed when the atlas is disposed.</haxe_doc>
		</addRegion>
		<addRegionTex public="1" set="method" line="320">
			<f a="name:textureRegion">
				<c path="String"/>
				<c path="spinehx.atlas.TextureRegion"/>
				<c path="spinehx.atlas.AtlasRegion"/>
			</f>
			<haxe_doc>Adds a region to the atlas. The texture for the specified region will be disposed when the atlas is disposed.</haxe_doc>
		</addRegionTex>
		<getRegions public="1" set="method" line="326">
			<f a=""><c path="Array"><c path="spinehx.atlas.AtlasRegion"/></c></f>
			<haxe_doc>Returns all regions in the atlas.</haxe_doc>
		</getRegions>
		<findRegion public="1" set="method" line="333">
			<f a="name">
				<c path="String"/>
				<c path="spinehx.atlas.AtlasRegion"/>
			</f>
			<haxe_doc>Returns the first region found with the specified name. This method uses string comparison to find the region, so the result
	 * should be cached rather than calling this method multiple times.
	 * @return The region, or null.</haxe_doc>
		</findRegion>
		<findRegionIdx public="1" set="method" line="342">
			<f a="name:index">
				<c path="String"/>
				<x path="Int"/>
				<c path="spinehx.atlas.AtlasRegion"/>
			</f>
			<haxe_doc>Returns the first region found with the specified name and index. This method uses string comparison to find the region, so
	 * the result should be cached rather than calling this method multiple times.
	 * @return The region, or null.</haxe_doc>
		</findRegionIdx>
		<findRegions public="1" set="method" line="352">
			<f a="name">
				<c path="String"/>
				<c path="Array"><c path="spinehx.atlas.AtlasRegion"/></c>
			</f>
			<haxe_doc>Returns all regions with the specified name, ordered by smallest to largest {@link AtlasRegion#index index}. This method
	 * uses string comparison to find the regions, so the result should be cached rather than calling this method multiple times.</haxe_doc>
		</findRegions>
		<getTextures public="1" set="method" line="439">
			<f a=""><c path="Array"><c path="spinehx.atlas.Texture"/></c></f>
			<haxe_doc>@return the textures of the pages, unordered</haxe_doc>
		</getTextures>
		<dispose public="1" set="method" line="445">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Releases all resources associated with this TextureAtlas instance. This releases all the textures backing all TextureRegions
	 * and Sprites, which should no longer be used after calling dispose.</haxe_doc>
		</dispose>
		<new public="1" set="method" line="263"><f a="data:textureLoader">
	<c path="spinehx.atlas.TextureAtlasData"/>
	<c path="spinehx.atlas.TextureLoader"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[Loads images from texture atlases created by TexturePacker.<br>
 * <br>
 * A TextureAtlas must be disposed to free up the resources consumed by the backing textures.
 * @author Nathan Sweet]]></haxe_doc>
	</class>
	<class path="spinehx.atlas.TextureRegion" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/atlas/TextureRegion.hx">
		<fromTexture public="1" set="method" line="41" static="1">
			<f a="texture">
				<c path="spinehx.atlas.Texture"/>
				<c path="spinehx.atlas.TextureRegion"/>
			</f>
			<haxe_doc>Constructs a region the size of the specified texture.</haxe_doc>
		</fromTexture>
		<fromTextureWH public="1" set="method" line="51" static="1">
			<f a="texture:width:height">
				<c path="spinehx.atlas.Texture"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="spinehx.atlas.TextureRegion"/>
			</f>
			<haxe_doc>@param width The width of the texture region. May be negative to flip the sprite when drawn.
	 * @param height The height of the texture region. May be negative to flip the sprite when drawn.</haxe_doc>
		</fromTextureWH>
		<fromTextureXYWH public="1" set="method" line="60" static="1">
			<f a="texture:x:y:width:height">
				<c path="spinehx.atlas.Texture"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="spinehx.atlas.TextureRegion"/>
			</f>
			<haxe_doc>@param width The width of the texture region. May be negative to flip the sprite when drawn.
	 * @param height The height of the texture region. May be negative to flip the sprite when drawn.</haxe_doc>
		</fromTextureXYWH>
		<fromTextureUVUV public="1" set="method" line="67" static="1"><f a="texture:u:v:u2:v2">
	<c path="spinehx.atlas.Texture"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="spinehx.atlas.TextureRegion"/>
</f></fromTextureUVUV>
		<copy public="1" set="method" line="75" static="1">
			<f a="region">
				<c path="spinehx.atlas.TextureRegion"/>
				<c path="spinehx.atlas.TextureRegion"/>
			</f>
			<haxe_doc>Constructs a region with the same texture and coordinates of the specified region.</haxe_doc>
		</copy>
		<createRelXYWH public="1" set="method" line="84" static="1">
			<f a="region:x:y:width:height">
				<c path="spinehx.atlas.TextureRegion"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="spinehx.atlas.TextureRegion"/>
			</f>
			<haxe_doc>Constructs a region with the same texture as the specified region and sets the coordinates relative to the specified region.
	 * @param width The width of the texture region. May be negative to flip the sprite when drawn.
	 * @param height The height of the texture region. May be negative to flip the sprite when drawn.</haxe_doc>
		</createRelXYWH>
		<splitTex public="1" set="method" line="283" static="1">
			<f a="texture:tileWidth:tileHeight">
				<c path="spinehx.atlas.Texture"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array"><c path="spinehx.atlas.TextureRegion"/></c></c>
			</f>
			<haxe_doc>Helper function to create tiles out of the given {@link Texture} starting from the top left corner going to the left and
	 * ending at the bottom right corner. Only complete tiles will be returned so if the texture's width or height are not a
	 * multiple of the tile width and height not all of the texture will be used.
	 * 
	 * @param texture the Texture
	 * @param tileWidth a tile's width in pixels
	 * @param tileHeight a tile's height in pixels
	 * @return a 2D array of TextureRegions indexed by [row][column].</haxe_doc>
		</splitTex>
		<texture public="1"><c path="spinehx.atlas.Texture"/></texture>
		<u public="1"><x path="Float"/></u>
		<v public="1"><x path="Float"/></v>
		<u2 public="1"><x path="Float"/></u2>
		<v2 public="1"><x path="Float"/></v2>
		<regionWidth public="1"><x path="Int"/></regionWidth>
		<regionHeight public="1"><x path="Int"/></regionHeight>
		<setRegionTex public="1" set="method" line="91">
			<f a="texture">
				<c path="spinehx.atlas.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the texture and sets the coordinates to the size of the specified texture.</haxe_doc>
		</setRegionTex>
		<setRegionXYWH public="1" set="method" line="98">
			<f a="x:y:width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param width The width of the texture region. May be negative to flip the sprite when drawn.
	 * @param height The height of the texture region. May be negative to flip the sprite when drawn.</haxe_doc>
		</setRegionXYWH>
		<setRegionUV public="1" set="method" line="106"><f a="u:v:u2:v2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRegionUV>
		<setRegionCopy public="1" set="method" line="116">
			<f a="region">
				<c path="spinehx.atlas.TextureRegion"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the texture and coordinates to the specified region.</haxe_doc>
		</setRegionCopy>
		<setRegionRelXYWH public="1" set="method" line="122">
			<f a="region:x:y:width:height">
				<c path="spinehx.atlas.TextureRegion"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the texture to that of the specified region and sets the coordinates relative to the specified region.</haxe_doc>
		</setRegionRelXYWH>
		<getTexture public="1" set="method" line="127"><f a=""><c path="spinehx.atlas.Texture"/></f></getTexture>
		<setTexture public="1" set="method" line="131"><f a="texture">
	<c path="spinehx.atlas.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<getU public="1" set="method" line="135"><f a=""><x path="Float"/></f></getU>
		<setU public="1" set="method" line="139"><f a="u">
	<x path="Float"/>
	<x path="Void"/>
</f></setU>
		<getV public="1" set="method" line="144"><f a=""><x path="Float"/></f></getV>
		<setV public="1" set="method" line="148"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></setV>
		<getU2 public="1" set="method" line="153"><f a=""><x path="Float"/></f></getU2>
		<setU2 public="1" set="method" line="157"><f a="u2">
	<x path="Float"/>
	<x path="Void"/>
</f></setU2>
		<getV2 public="1" set="method" line="162"><f a=""><x path="Float"/></f></getV2>
		<setV2 public="1" set="method" line="166"><f a="v2">
	<x path="Float"/>
	<x path="Void"/>
</f></setV2>
		<getRegionX public="1" set="method" line="171"><f a=""><x path="Int"/></f></getRegionX>
		<setRegionX public="1" set="method" line="175"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></setRegionX>
		<getRegionY public="1" set="method" line="179"><f a=""><x path="Int"/></f></getRegionY>
		<setRegionY public="1" set="method" line="183"><f a="y">
	<x path="Int"/>
	<x path="Void"/>
</f></setRegionY>
		<getRegionWidth public="1" set="method" line="188">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the region's width.</haxe_doc>
		</getRegionWidth>
		<setRegionWidth public="1" set="method" line="192"><f a="width">
	<x path="Int"/>
	<x path="Void"/>
</f></setRegionWidth>
		<getRegionHeight public="1" set="method" line="197">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the region's height.</haxe_doc>
		</getRegionHeight>
		<setRegionHeight public="1" set="method" line="201"><f a="height">
	<x path="Int"/>
	<x path="Void"/>
</f></setRegionHeight>
		<flip public="1" set="method" line="205"><f a="x:y">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></flip>
		<isFlipX public="1" set="method" line="218"><f a=""><x path="Bool"/></f></isFlipX>
		<isFlipY public="1" set="method" line="222"><f a=""><x path="Bool"/></f></isFlipY>
		<scroll public="1" set="method" line="230">
			<f a="xAmount:yAmount">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Offsets the region relative to the current region. Generally the region's size should be the entire size of the texture in
	 * the direction(s) it is scrolled.
	 * @param xAmount The percentage to offset horizontally.
	 * @param yAmount The percentage to offset vertically. This is done in texture space, so up is negative.</haxe_doc>
		</scroll>
		<split public="1" set="method" line="250">
			<f a="tileWidth:tileHeight">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array"><c path="spinehx.atlas.TextureRegion"/></c></c>
			</f>
			<haxe_doc>Helper function to create tiles out of this TextureRegion starting from the top left corner going to the left and ending at
	 * the bottom right corner. Only complete tiles will be returned so if the region's width or height are not a multiple of the
	 * tile width and height not all of the region will be used.
	 * 
	 * @param tileWidth a tile's width in pixels
	 * @param tileHeight a tile's height in pixels
	 * @return a 2D array of TextureRegions indexed by [row][column].</haxe_doc>
		</split>
		<new public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Constructs a region with no texture and no coordinates defined.</haxe_doc>
		</new>
	</class>
	<class path="spinehx.atlas.AtlasRegion" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/atlas/TextureAtlas.hx" module="spinehx.atlas.TextureAtlas">
		<extends path="spinehx.atlas.TextureRegion"/>
		<create public="1" set="method" line="498" static="1"><f a="texture:x:y:width:height">
	<c path="spinehx.atlas.Texture"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="spinehx.atlas.AtlasRegion"/>
</f></create>
		<copy public="1" set="method" line="507" static="1"><f a="region">
	<c path="spinehx.atlas.AtlasRegion"/>
	<c path="spinehx.atlas.AtlasRegion"/>
</f></copy>
		<index public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[The number at the end of the original image file name, or -1 if none.<br>
     * <br>
     * When sprites are packed, if the original file name ends with a number, it is stored as the index and is not considered as
     * part of the sprite's name. This is useful for keeping animation frames in order.
     * @see TextureAtlas#findRegions(String)]]></haxe_doc>
		</index>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the original image file, up to the first underscore. Underscores denote special instructions to the texture
     * packer.</haxe_doc>
		</name>
		<offsetX public="1">
			<x path="Float"/>
			<haxe_doc>The offset from the left of the original image to the left of the packed image, after whitespace was removed for packing.</haxe_doc>
		</offsetX>
		<offsetY public="1">
			<x path="Float"/>
			<haxe_doc>The offset from the bottom of the original image to the bottom of the packed image, after whitespace was removed for
     * packing.</haxe_doc>
		</offsetY>
		<packedWidth public="1">
			<x path="Int"/>
			<haxe_doc>The width of the image, after whitespace was removed for packing.</haxe_doc>
		</packedWidth>
		<packedHeight public="1">
			<x path="Int"/>
			<haxe_doc>The height of the image, after whitespace was removed for packing.</haxe_doc>
		</packedHeight>
		<originalWidth public="1">
			<x path="Int"/>
			<haxe_doc>The width of the image, before whitespace was removed and rotation was applied for packing.</haxe_doc>
		</originalWidth>
		<originalHeight public="1">
			<x path="Int"/>
			<haxe_doc>The height of the image, before whitespace was removed for packing.</haxe_doc>
		</originalHeight>
		<rotate public="1">
			<x path="Bool"/>
			<haxe_doc>If true, the region has been rotated 90 degrees counter clockwise.</haxe_doc>
		</rotate>
		<splits public="1">
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>The ninepatch splits, or null if not a ninepatch. Has 4 elements: left, right, top, bottom.</haxe_doc>
		</splits>
		<pads public="1">
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>The ninepatch pads, or null if not a ninepatch or the has no padding. Has 4 elements: left, right, top, bottom.</haxe_doc>
		</pads>
		<flip public="1" set="method" line="524" override="1">
			<f a="x:y">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Flips the region, adjusting the offset so the image appears to be flip as if no whitespace has been removed for packing.</haxe_doc>
		</flip>
		<getRotatedPackedWidth public="1" set="method" line="532">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the packed width considering the rotate value, if it is true then it returns the packedHeight, otherwise it
     * returns the packedWidth.</haxe_doc>
		</getRotatedPackedWidth>
		<getRotatedPackedHeight public="1" set="method" line="538">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the packed height considering the rotate value, if it is true then it returns the packedWidth, otherwise it
     * returns the packedHeight.</haxe_doc>
		</getRotatedPackedHeight>
		<new public="1" set="method" line="494"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Describes the region of a packed image and provides information about the original image before it was packed.</haxe_doc>
	</class>
	<class path="spinehx.attachments.AttachmentLoader" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/attachments/AttachmentLoader.hx" interface="1"><newAttachment public="1" set="method">
	<f a="skin:type:name">
		<c path="spinehx.Skin"/>
		<e path="spinehx.attachments.AttachmentType"/>
		<c path="String"/>
		<c path="spinehx.attachments.Attachment"/>
	</f>
	<haxe_doc>@return May be null to not load any attachment.</haxe_doc>
</newAttachment></class>
	<class path="spinehx.attachments.AtlasAttachmentLoader" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/attachments/AtlasAttachmentLoader.hx">
		<implements path="spinehx.attachments.AttachmentLoader"/>
		<atlas><c path="spinehx.atlas.TextureAtlas"/></atlas>
		<newAttachment public="1" set="method" line="39"><f a="skin:type:name">
	<c path="spinehx.Skin"/>
	<e path="spinehx.attachments.AttachmentType"/>
	<c path="String"/>
	<c path="spinehx.attachments.Attachment"/>
</f></newAttachment>
		<new public="1" set="method" line="34"><f a="atlas">
	<c path="spinehx.atlas.TextureAtlas"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.attachments.Attachment" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/attachments/Attachment.hx">
		<name public="1"><c path="String"/></name>
		<getName public="1" set="method" line="37"><f a=""><c path="String"/></f></getName>
		<toString public="1" set="method" line="41"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="32"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="spinehx.attachments.AttachmentType" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/attachments/AttachmentType.hx">
		<region/>
		<regionSequence/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="spinehx.attachments.AttachmentTypes" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/attachments/AttachmentType.hx" module="spinehx.attachments.AttachmentType"><valueOf public="1" set="method" line="31" static="1"><f a="t:?def" v=":null">
	<c path="String"/>
	<e path="spinehx.attachments.AttachmentType"/>
	<e path="spinehx.attachments.AttachmentType"/>
</f></valueOf></class>
	<enum path="spinehx.attachments.Mode" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/attachments/Mode.hx">
		<forward/>
		<backward/>
		<forwardLoop/>
		<backwardLoop/>
		<pingPong/>
		<random/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="spinehx.attachments.Modes" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/attachments/Mode.hx" module="spinehx.attachments.Mode"><valueOf public="1" set="method" line="31" static="1"><f a="t:?def" v=":null">
	<c path="String"/>
	<e path="spinehx.attachments.Mode"/>
	<e path="spinehx.attachments.Mode"/>
</f></valueOf></class>
	<class path="spinehx.attachments.RegionAttachment" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/attachments/RegionAttachment.hx">
		<extends path="spinehx.attachments.Attachment"/>
		<X1 public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></X1>
		<Y1 public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></Y1>
		<C1 public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></C1>
		<U1 public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></U1>
		<V1 public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></V1>
		<X2 public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></X2>
		<Y2 public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></Y2>
		<C2 public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></C2>
		<U2 public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></U2>
		<V2 public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></V2>
		<X3 public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></X3>
		<Y3 public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></Y3>
		<C3 public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></C3>
		<U3 public="1" get="inline" set="null" line="47" static="1"><x path="Int"/></U3>
		<V3 public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></V3>
		<X4 public="1" get="inline" set="null" line="49" static="1"><x path="Int"/></X4>
		<Y4 public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></Y4>
		<C4 public="1" get="inline" set="null" line="51" static="1"><x path="Int"/></C4>
		<U4 public="1" get="inline" set="null" line="52" static="1"><x path="Int"/></U4>
		<V4 public="1" get="inline" set="null" line="53" static="1"><x path="Int"/></V4>
		<region public="1"><c path="spinehx.atlas.TextureRegion"/></region>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<rotation public="1"><x path="Float"/></rotation>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<vertices public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></vertices>
		<offset public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></offset>
		<updateOffset public="1" set="method" line="72"><f a=""><x path="Void"/></f></updateOffset>
		<setRegion public="1" set="method" line="122"><f a="region">
	<c path="spinehx.atlas.TextureRegion"/>
	<x path="Void"/>
</f></setRegion>
		<getRegion public="1" set="method" line="147"><f a=""><c path="spinehx.atlas.TextureRegion"/></f></getRegion>
		<updateVertices public="1" set="method" line="152"><f a="slot">
	<c path="spinehx.Slot"/>
	<x path="Void"/>
</f></updateVertices>
		<getVertices public="1" set="method" line="183"><f a=""><x path="haxe.ds.Vector"><x path="Float"/></x></f></getVertices>
		<getX public="1" set="method" line="187"><f a=""><x path="Float"/></f></getX>
		<setX public="1" set="method" line="191"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></setX>
		<getY public="1" set="method" line="195"><f a=""><x path="Float"/></f></getY>
		<setY public="1" set="method" line="199"><f a="y">
	<x path="Float"/>
	<x path="Void"/>
</f></setY>
		<getScaleX public="1" set="method" line="203"><f a=""><x path="Float"/></f></getScaleX>
		<setScaleX public="1" set="method" line="207"><f a="scaleX">
	<x path="Float"/>
	<x path="Void"/>
</f></setScaleX>
		<getScaleY public="1" set="method" line="211"><f a=""><x path="Float"/></f></getScaleY>
		<setScaleY public="1" set="method" line="215"><f a="scaleY">
	<x path="Float"/>
	<x path="Void"/>
</f></setScaleY>
		<getRotation public="1" set="method" line="219"><f a=""><x path="Float"/></f></getRotation>
		<setRotation public="1" set="method" line="223"><f a="rotation">
	<x path="Float"/>
	<x path="Void"/>
</f></setRotation>
		<getWidth public="1" set="method" line="227"><f a=""><x path="Float"/></f></getWidth>
		<setWidth public="1" set="method" line="231"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></setWidth>
		<getHeight public="1" set="method" line="235"><f a=""><x path="Float"/></f></getHeight>
		<setHeight public="1" set="method" line="239"><f a="height">
	<x path="Float"/>
	<x path="Void"/>
</f></setHeight>
		<new public="1" set="method" line="66"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="spinehx.attachments.NumberUtils" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/attachments/RegionAttachment.hx" module="spinehx.attachments.RegionAttachment"><intToFloatColor public="1" set="method" line="246" static="1"><f a="value">
	<x path="Int"/>
	<x path="Float"/>
</f></intToFloatColor></class>
	<class path="spinehx.attachments.RegionSequenceAttachment" params="" file="C:\HaxeToolkit\haxe\lib/spinehx/0,2,0/spinehx/attachments/RegionSequenceAttachment.hx">
		<extends path="spinehx.attachments.RegionAttachment"/>
		<mode><e path="spinehx.attachments.Mode"/></mode>
		<frameTime><x path="Float"/></frameTime>
		<regions><c path="Array"><c path="spinehx.atlas.TextureRegion"/></c></regions>
		<updateVertices public="1" set="method" line="38" override="1"><f a="slot">
	<c path="spinehx.Slot"/>
	<x path="Void"/>
</f></updateVertices>
		<getRegions public="1" set="method" line="63"><f a=""><c path="Array"><c path="spinehx.atlas.TextureRegion"/></c></f></getRegions>
		<setRegions public="1" set="method" line="68"><f a="regions">
	<c path="Array"><c path="spinehx.atlas.TextureRegion"/></c>
	<x path="Void"/>
</f></setRegions>
		<setFrameTime public="1" set="method" line="73">
			<f a="frameTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the time in seconds each frame is shown.</haxe_doc>
		</setFrameTime>
		<setMode public="1" set="method" line="77"><f a="mode">
	<e path="spinehx.attachments.Mode"/>
	<x path="Void"/>
</f></setMode>
		<new public="1" set="method" line="34"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="sys.FileStat" params="" file="C:\HaxeToolkit\haxe\std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>the user id for the file</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>the size of the file</haxe_doc>
			</size>
			<rdev><x path="Int"/></rdev>
			<nlink><x path="Int"/></nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>the last modification time for the file</haxe_doc>
			</mtime>
			<mode><x path="Int"/></mode>
			<ino><x path="Int"/></ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>the user group id for the file</haxe_doc>
			</gid>
			<dev><x path="Int"/></dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>the creation time for the file</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>the last access time for the file (when enabled by the file system)</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File informations, as given by [sys.FileSystem.stat]</haxe_doc>
	</typedef>
	<enum path="sys._FileSystem.FileKind" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/sys/FileSystem.hx" private="1" module="sys.FileSystem">
		<kdir/>
		<kfile/>
		<kother a="k"><c path="String"/></kother>
	</enum>
	<class path="sys.FileSystem" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/sys/FileSystem.hx">
		<exists public="1" get="inline" set="null" line="33" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the file or directory specified by `path` exists.

		If `path` is null, the result is unspecified.</haxe_doc>
		</exists>
		<rename public="1" set="method" line="37" static="1">
			<f a="path:newPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Renames/moves the file or directory specified by `path` to `newPath`.

		If `path` is not a valid file system entry, or if it is not accessible,
		or if `newPath` is not accessible, an exception is thrown.

		If `path` or `newPath` are null, the result is unspecified.</haxe_doc>
		</rename>
		<stat public="1" set="method" line="42" static="1">
			<f a="path">
				<c path="String"/>
				<t path="sys.FileStat"/>
			</f>
			<haxe_doc>Returns `FileStat` information on the file or directory specified by
		`path`.

		If `path` is null, the result is unspecified.</haxe_doc>
		</stat>
		<fullPath public="1" set="method" line="52" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory.

		If `relPath` is null, the result is unspecified.</haxe_doc>
		</fullPath>
		<kind set="method" line="56" static="1"><f a="path">
	<c path="String"/>
	<e path="sys._FileSystem.FileKind"/>
</f></kind>
		<isDirectory public="1" set="method" line="65" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the file or directory specified by `path` is a directory.

		If `path` is not a valid file system entry or if its destination is no
		accessible, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" line="69" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" line="79" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</deleteFile>
		<deleteDirectory public="1" set="method" line="84" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the directory specified by `path`.

		If `path` does not denote a valid directory, or if that directory cannot
		be deleted, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</deleteDirectory>
		<readDirectory public="1" set="method" line="89" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`.

		If `path` does not denote a valid directory, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</readDirectory>
		<sys_exists line="93" static="1"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></sys_exists>
		<file_delete line="94" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></file_delete>
		<sys_rename line="95" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></sys_rename>
		<sys_stat line="96" static="1"><f a="">
	<c path="String"/>
	<t path="sys.FileStat"/>
</f></sys_stat>
		<sys_file_type line="97" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></sys_file_type>
		<sys_create_dir line="98" static="1"><f a=":">
	<c path="String"/>
	<x path="Int"/>
	<unknown/>
</f></sys_create_dir>
		<sys_remove_dir line="99" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></sys_remove_dir>
		<sys_read_dir line="100" static="1"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></sys_read_dir>
		<file_full_path line="101" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></file_full_path>
		<haxe_doc>This class allows you to get information about the files and directories.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="sys.io.File" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/sys/io/File.hx">
		<getContent public="1" set="method" line="27" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.
		
		If the file does not exist or can not be read, an exception is thrown.
		
		`sys.FileSystem.exists` can be used to check for existence.
		
		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<getBytes public="1" set="method" line="32" static="1">
			<f a="path">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Retrieves the binary content of the file specified by `path`.
		
		If the file does not exist or can not be read, an exception is thrown.
		
		`sys.FileSystem.exists` can be used to check for existence.
		
		If `path` is null, the result is unspecified.</haxe_doc>
		</getBytes>
		<saveContent public="1" set="method" line="37" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.
		
		If the file cannot be written to, an exception is thrown.
		
		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<saveBytes public="1" set="method" line="43" static="1">
			<f a="path:bytes">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `bytes` in the file specified by `path` in binary mode.
		
		If the file cannot be written to, an exception is thrown.
		
		If `path` or `bytes` are null, the result is unspecified.</haxe_doc>
		</saveBytes>
		<read public="1" set="method" line="49" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileInput"/>
			</f>
			<haxe_doc>Returns an `FileInput` handle to the file specified by `path`.
		
		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.
		
		If the file does not exist or can not be read, an exception is thrown.
		
		Operations on the returned `FileInput` handle read on the opened file.
		
		File handles should be closed via `FileInput.close` once the operation
		is complete.
		
		If `path` is null, the result is unspecified.</haxe_doc>
		</read>
		<write public="1" set="method" line="53" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.
		
		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.
		
		If the file cannot be written to, an exception is thrown.
		
		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.
		
		File handles should be closed via `FileOutput.close` once the operation
		is complete.
		
		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<append public="1" set="method" line="57" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<haxe_doc>Similar to `sys.io.File.write`, but appends to the file if it exists
		instead of overwriting its contents.</haxe_doc>
		</append>
		<copy public="1" set="method" line="61" static="1">
			<f a="srcPath:dstPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the contents of the file specified by `srcPath` to the file
		specified by `dstPath`.
		
		If the `srcPath` does not exist or cannot be read, or if the `dstPath`
		file cannot be written to, an exception is thrown.
		
		If the file at `dstPath` exists, its contents are overwritten.
		
		If `srcPath` or `dstPath` are null, the result is unspecified.</haxe_doc>
		</copy>
		<file_contents line="69" static="1"><f a="">
	<c path="String"/>
	<t path="haxe.io.BytesData"/>
</f></file_contents>
		<file_open line="70" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></file_open>
		<haxe_doc>API for reading and writing to files.
	
	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="sys.io.FileInput" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<file_eof line="74" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></file_eof>
		<file_read line="76" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></file_read>
		<file_read_char line="77" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></file_read_char>
		<file_close line="79" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_close>
		<file_seek line="80" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="81" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></file_tell>
		<__f><d/></__f>
		<readByte public="1" set="method" line="34" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="45" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="56" override="1"><f a=""><x path="Void"/></f></close>
		<seek public="1" set="method" line="61"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method" line="65"><f a=""><x path="Int"/></f></tell>
		<eof public="1" set="method" line="70"><f a=""><x path="Bool"/></f></eof>
		<new set="method" line="30"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.read] to create a [FileInput]</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="C:\HaxeToolkit\haxe\std/cpp/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close line="59" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_close>
		<file_seek line="60" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="61" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></file_tell>
		<file_flush line="63" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_flush>
		<file_write line="64" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></file_write>
		<file_write_char line="65" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></file_write_char>
		<__f><d/></__f>
		<writeByte public="1" set="method" line="34" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="38" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="42" override="1"><f a=""><x path="Void"/></f></flush>
		<close public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></close>
		<seek public="1" set="method" line="51"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method" line="55"><f a=""><x path="Int"/></f></tell>
		<new set="method" line="30"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.write] to create a [FileOutput]</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<enum path="sys.io.FileSeek" params="" file="C:\HaxeToolkit\haxe\std/sys/io/FileSeek.hx">
		<SeekBegin/>
		<SeekCur/>
		<SeekEnd/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="zpp_nape.ZPP_Const" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/Const.hx" module="zpp_nape.Const">
		<POSINF public="1" get="inline" set="null" line="184" static="1"><f a=""><x path="Float"/></f></POSINF>
		<NEGINF public="1" get="inline" set="null" line="188" static="1"><f a=""><x path="Float"/></f></NEGINF>
		<FMAX public="1" get="inline" set="null" line="193" static="1"><x path="Float"/></FMAX>
	</class>
	<class path="zpp_nape.ZPP_ID" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/ID.hx" module="zpp_nape.ID">
		<_Constraint public="1" line="176" static="1"><x path="Int"/></_Constraint>
		<Constraint public="1" set="method" line="177" static="1"><f a=""><x path="Int"/></f></Constraint>
		<_Interactor public="1" line="180" static="1"><x path="Int"/></_Interactor>
		<Interactor public="1" set="method" line="181" static="1"><f a=""><x path="Int"/></f></Interactor>
		<_CbType public="1" line="184" static="1"><x path="Int"/></_CbType>
		<CbType public="1" set="method" line="185" static="1"><f a=""><x path="Int"/></f></CbType>
		<_CbSet public="1" line="188" static="1"><x path="Int"/></_CbSet>
		<CbSet public="1" set="method" line="189" static="1"><f a=""><x path="Int"/></f></CbSet>
		<_Listener public="1" line="192" static="1"><x path="Int"/></_Listener>
		<Listener public="1" set="method" line="193" static="1"><f a=""><x path="Int"/></f></Listener>
		<_ZPP_SimpleVert public="1" line="196" static="1"><x path="Int"/></_ZPP_SimpleVert>
		<ZPP_SimpleVert public="1" set="method" line="197" static="1"><f a=""><x path="Int"/></f></ZPP_SimpleVert>
		<_ZPP_SimpleSeg public="1" line="200" static="1"><x path="Int"/></_ZPP_SimpleSeg>
		<ZPP_SimpleSeg public="1" set="method" line="201" static="1"><f a=""><x path="Int"/></f></ZPP_SimpleSeg>
		<_InteractionGroup public="1" line="204" static="1"><x path="Int"/></_InteractionGroup>
		<InteractionGroup public="1" set="method" line="205" static="1"><f a=""><x path="Int"/></f></InteractionGroup>
		<_Space public="1" line="208" static="1"><x path="Int"/></_Space>
		<Space public="1" set="method" line="209" static="1"><f a=""><x path="Int"/></f></Space>
	</class>
	<class path="zpp_nape.callbacks.ZPP_Callback" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/callbacks/Callback.hx" module="zpp_nape.callbacks.Callback">
		<internal public="1" line="179" static="1"><x path="Bool"/></internal>
		<zpp_pool public="1" line="369" static="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></zpp_pool>
		<outer_body public="1"><t path="Null"><c path="nape.callbacks.BodyCallback"/></t></outer_body>
		<outer_con public="1"><t path="Null"><c path="nape.callbacks.ConstraintCallback"/></t></outer_con>
		<outer_int public="1"><t path="Null"><c path="nape.callbacks.InteractionCallback"/></t></outer_int>
		<wrapper_body public="1" set="method" line="181"><f a=""><t path="Null"><c path="nape.callbacks.BodyCallback"/></t></f></wrapper_body>
		<wrapper_con public="1" set="method" line="194"><f a=""><t path="Null"><c path="nape.callbacks.ConstraintCallback"/></t></f></wrapper_con>
		<wrapper_int public="1" set="method" line="207"><f a=""><t path="Null"><c path="nape.callbacks.InteractionCallback"/></t></f></wrapper_int>
		<event public="1"><x path="Int"/></event>
		<listener public="1"><c path="zpp_nape.callbacks.ZPP_Listener"/></listener>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<index public="1"><x path="Int"/></index>
		<next public="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></next>
		<prev public="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></prev>
		<length public="1"><x path="Int"/></length>
		<push public="1" set="method" line="228"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<x path="Void"/>
</f></push>
		<push_rev public="1" set="method" line="244"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<x path="Void"/>
</f></push_rev>
		<pop public="1" set="method" line="260"><f a=""><c path="zpp_nape.callbacks.ZPP_Callback"/></f></pop>
		<pop_rev public="1" set="method" line="276"><f a=""><c path="zpp_nape.callbacks.ZPP_Callback"/></f></pop_rev>
		<empty public="1" set="method" line="292"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="295"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="298"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></splice>
		<rotateL public="1" set="method" line="313"><f a=""><x path="Void"/></f></rotateL>
		<rotateR public="1" set="method" line="316"><f a=""><x path="Void"/></f></rotateR>
		<cycleNext public="1" set="method" line="319"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></cycleNext>
		<cyclePrev public="1" set="method" line="331"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></cyclePrev>
		<at public="1" set="method" line="343"><f a="i">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></at>
		<rev_at public="1" set="method" line="356"><f a="i">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></rev_at>
		<free public="1" get="inline" set="null" line="395"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="407"><f a=""><x path="Void"/></f></alloc>
		<int1 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int1>
		<int2 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int2>
		<set public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></set>
		<wrap_arbiters public="1"><c path="nape.dynamics.ArbiterList"/></wrap_arbiters>
		<pre_arbiter public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></pre_arbiter>
		<pre_swapped public="1"><x path="Bool"/></pre_swapped>
		<genarbs public="1" get="inline" set="null" line="416"><f a=""><x path="Void"/></f></genarbs>
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<constraint public="1"><c path="zpp_nape.constraint.ZPP_Constraint"/></constraint>
		<new public="1" set="method" line="436"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_CbSet" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/callbacks/CbSet.hx" module="zpp_nape.callbacks.CbSet">
		<zpp_pool public="1" line="178" static="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></zpp_pool>
		<setlt public="1" set="method" line="440" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></setlt>
		<get public="1" set="method" line="545" static="1"><f a="cbTypes">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></get>
		<compatible get="inline" set="null" line="581" static="1"><f a="i:a:b">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></compatible>
		<empty_intersection public="1" get="inline" set="null" line="585" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></empty_intersection>
		<single_intersection public="1" set="method" line="588" static="1"><f a="a:b:i">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></single_intersection>
		<find_all public="1" get="inline" set="null" line="592" static="1"><f a="a:b:event:cb">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Int"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></find_all>
		<cbTypes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></cbTypes>
		<count public="1"><x path="Int"/></count>
		<next public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></next>
		<id public="1"><x path="Int"/></id>
		<manager public="1"><c path="zpp_nape.space.ZPP_CbSetManager"/></manager>
		<cbpairs public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSetPair"/></cbpairs>
		<increment public="1" get="inline" set="null" line="207"><f a=""><x path="Void"/></f></increment>
		<decrement public="1" get="inline" set="null" line="212"><f a=""><x path="Bool"/></f></decrement>
		<invalidate_pairs public="1" set="method" line="223"><f a=""><x path="Void"/></f></invalidate_pairs>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></listeners>
		<zip_listeners public="1"><x path="Bool"/></zip_listeners>
		<invalidate_listeners public="1" get="inline" set="null" line="237"><f a=""><x path="Void"/></f></invalidate_listeners>
		<validate_listeners public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></validate_listeners>
		<realvalidate_listeners public="1" set="method" line="250"><f a=""><x path="Void"/></f></realvalidate_listeners>
		<bodylisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_BodyListener"/></bodylisteners>
		<zip_bodylisteners public="1"><x path="Bool"/></zip_bodylisteners>
		<invalidate_bodylisteners public="1" get="inline" set="null" line="296"><f a=""><x path="Void"/></f></invalidate_bodylisteners>
		<validate_bodylisteners public="1" get="inline" set="null" line="303"><f a=""><x path="Void"/></f></validate_bodylisteners>
		<realvalidate_bodylisteners public="1" set="method" line="309"><f a=""><x path="Void"/></f></realvalidate_bodylisteners>
		<conlisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_ConstraintListener"/></conlisteners>
		<zip_conlisteners public="1"><x path="Bool"/></zip_conlisteners>
		<invalidate_conlisteners public="1" get="inline" set="null" line="355"><f a=""><x path="Void"/></f></invalidate_conlisteners>
		<validate_conlisteners public="1" get="inline" set="null" line="362"><f a=""><x path="Void"/></f></validate_conlisteners>
		<realvalidate_conlisteners public="1" set="method" line="368"><f a=""><x path="Void"/></f></realvalidate_conlisteners>
		<validate public="1" set="method" line="410"><f a=""><x path="Void"/></f></validate>
		<interactors public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></interactors>
		<wrap_interactors public="1"><c path="nape.phys.InteractorList"/></wrap_interactors>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<addConstraint public="1" get="inline" set="null" line="422"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></addConstraint>
		<addInteractor public="1" get="inline" set="null" line="427"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></addInteractor>
		<remConstraint public="1" get="inline" set="null" line="432"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remConstraint>
		<remInteractor public="1" get="inline" set="null" line="437"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></remInteractor>
		<free public="1" get="inline" set="null" line="471"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="520"><f a=""><x path="Void"/></f></alloc>
		<new public="1" set="method" line="455"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_CbSetPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/callbacks/CbSetPair.hx" module="zpp_nape.callbacks.CbSetPair">
		<zpp_pool public="1" line="178" static="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></zpp_pool>
		<get public="1" get="inline" set="null" line="217" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></get>
		<setlt public="1" get="inline" set="null" line="247" static="1"><f a="x:y">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></setlt>
		<a public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></a>
		<b public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></b>
		<next public="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></next>
		<free public="1" get="inline" set="null" line="204"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="210"><f a=""><x path="Void"/></f></alloc>
		<compatible get="inline" set="null" line="260"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></compatible>
		<zip_listeners public="1"><x path="Bool"/></zip_listeners>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></listeners>
		<invalidate public="1" get="inline" set="null" line="267"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" get="inline" set="null" line="272"><f a=""><x path="Void"/></f></validate>
		<__validate public="1" set="method" line="278"><f a=""><x path="Void"/></f></__validate>
		<empty_intersection public="1" get="inline" set="null" line="314"><f a=""><x path="Bool"/></f></empty_intersection>
		<single_intersection public="1" get="inline" set="null" line="327"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></single_intersection>
		<forall public="1" get="inline" set="null" line="341"><f a="event:cb">
	<x path="Int"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></forall>
		<new public="1" set="method" line="213"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_InteractionListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></head>
		<begin public="1" get="inline" set="null" line="3099"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="3107"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="3112"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="3117"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
</f></inlined_add>
		<addAll public="1" set="method" line="3154"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="3172"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="3177"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></inlined_insert>
		<pop public="1" set="method" line="3220"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="3225"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="3258"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="3263"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="3276"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="3287"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="3312"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="3325"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="3348"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="3353"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></inlined_erase>
		<splice public="1" set="method" line="3399"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></splice>
		<clear public="1" set="method" line="3403"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="3408"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="3414"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="3429"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="3434"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="3437"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="3442"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="3472"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></front>
		<back public="1" set="method" line="3475"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></back>
		<iterator_at public="1" set="method" line="3484"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></iterator_at>
		<at public="1" set="method" line="3497"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
</f></at>
		<new public="1" set="method" line="3096"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_BodyListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></head>
		<begin public="1" get="inline" set="null" line="4350"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="4358"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="4363"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="4368"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
</f></inlined_add>
		<addAll public="1" set="method" line="4405"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_BodyListener"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="4423"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="4428"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></inlined_insert>
		<pop public="1" set="method" line="4471"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="4476"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="4509"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="4514"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="4527"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="4538"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="4563"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="4576"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="4599"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="4604"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></inlined_erase>
		<splice public="1" set="method" line="4650"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></splice>
		<clear public="1" set="method" line="4654"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="4659"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="4665"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="4680"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="4685"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="4688"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="4693"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="4723"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></front>
		<back public="1" set="method" line="4726"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></back>
		<iterator_at public="1" set="method" line="4735"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></iterator_at>
		<at public="1" set="method" line="4748"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
</f></at>
		<new public="1" set="method" line="4347"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_ConstraintListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></head>
		<begin public="1" get="inline" set="null" line="5184"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="5192"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="5197"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="5202"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
</f></inlined_add>
		<addAll public="1" set="method" line="5239"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="5257"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="5262"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></inlined_insert>
		<pop public="1" set="method" line="5305"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="5310"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="5343"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="5348"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="5361"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="5372"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="5397"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="5410"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="5433"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="5438"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></inlined_erase>
		<splice public="1" set="method" line="5484"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></splice>
		<clear public="1" set="method" line="5488"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="5493"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="5499"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="5514"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="5519"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="5522"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="5527"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="5557"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></front>
		<back public="1" set="method" line="5560"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></back>
		<iterator_at public="1" set="method" line="5569"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></iterator_at>
		<at public="1" set="method" line="5582"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
</f></at>
		<new public="1" set="method" line="5181"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Constraint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></head>
		<begin public="1" get="inline" set="null" line="1848"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="1856"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="1861"><f a="o">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="1866"><f a="o">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
</f></inlined_add>
		<addAll public="1" set="method" line="1903"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Constraint"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="1921"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="1926"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></inlined_insert>
		<pop public="1" set="method" line="1969"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="1974"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="2007"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="2012"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="2025"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="2036"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="2061"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="2074"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="2097"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="2102"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></inlined_erase>
		<splice public="1" set="method" line="2148"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></splice>
		<clear public="1" set="method" line="2152"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="2157"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="2163"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="2178"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="2183"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="2186"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="2191"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="2221"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></front>
		<back public="1" set="method" line="2224"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></back>
		<iterator_at public="1" set="method" line="2233"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></iterator_at>
		<at public="1" set="method" line="2246"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
</f></at>
		<new public="1" set="method" line="1845"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Interactor" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></head>
		<begin public="1" get="inline" set="null" line="3933"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="3941"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="3946"><f a="o">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="3951"><f a="o">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
</f></inlined_add>
		<addAll public="1" set="method" line="3988"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Interactor"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="4006"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="4011"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></inlined_insert>
		<pop public="1" set="method" line="4054"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="4059"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="4092"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="4097"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="4110"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="4121"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="4146"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="4159"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="4182"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="4187"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></inlined_erase>
		<splice public="1" set="method" line="4233"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></splice>
		<clear public="1" set="method" line="4237"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="4242"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="4248"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="4263"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="4268"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="4271"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="4276"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="4306"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></front>
		<back public="1" set="method" line="4309"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></back>
		<iterator_at public="1" set="method" line="4318"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></iterator_at>
		<at public="1" set="method" line="4331"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
</f></at>
		<new public="1" set="method" line="3930"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CbSet" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></head>
		<begin public="1" get="inline" set="null" line="3516"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="3524"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="3529"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="3534"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></inlined_add>
		<addAll public="1" set="method" line="3571"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CbSet"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="3589"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="3594"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></inlined_insert>
		<pop public="1" set="method" line="3637"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="3642"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="3675"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="3680"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="3693"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="3704"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="3729"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="3742"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="3765"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="3770"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></inlined_erase>
		<splice public="1" set="method" line="3816"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></splice>
		<clear public="1" set="method" line="3820"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="3825"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="3831"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="3846"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="3851"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="3854"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="3859"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="3889"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></front>
		<back public="1" set="method" line="3892"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></back>
		<iterator_at public="1" set="method" line="3901"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></iterator_at>
		<at public="1" set="method" line="3914"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></at>
		<new public="1" set="method" line="3513"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_CbType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/callbacks/CbType.hx" module="zpp_nape.callbacks.CbType">
		<setlt public="1" get="inline" set="null" line="180" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></setlt>
		<ANY_SHAPE public="1" line="348" static="1"><c path="nape.callbacks.CbType"/></ANY_SHAPE>
		<ANY_BODY public="1" line="349" static="1"><c path="nape.callbacks.CbType"/></ANY_BODY>
		<ANY_COMPOUND public="1" line="350" static="1"><c path="nape.callbacks.CbType"/></ANY_COMPOUND>
		<ANY_CONSTRAINT public="1" line="351" static="1"><c path="nape.callbacks.CbType"/></ANY_CONSTRAINT>
		<outer public="1"><c path="nape.callbacks.CbType"/></outer>
		<userData public="1"><d><d/></d></userData>
		<id public="1"><x path="Int"/></id>
		<cbsets public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></cbsets>
		<interactors public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></interactors>
		<wrap_interactors public="1"><c path="nape.phys.InteractorList"/></wrap_interactors>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<addConstraint public="1" get="inline" set="null" line="189"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></addConstraint>
		<addInteractor public="1" get="inline" set="null" line="194"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></addInteractor>
		<remConstraint public="1" get="inline" set="null" line="199"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remConstraint>
		<remInteractor public="1" get="inline" set="null" line="204"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></remInteractor>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></listeners>
		<addint public="1" get="inline" set="null" line="210"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></addint>
		<removeint public="1" get="inline" set="null" line="238"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></removeint>
		<invalidateint public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></invalidateint>
		<bodylisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_BodyListener"/></bodylisteners>
		<addbody public="1" get="inline" set="null" line="257"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></addbody>
		<removebody public="1" get="inline" set="null" line="285"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></removebody>
		<invalidatebody public="1" get="inline" set="null" line="291"><f a=""><x path="Void"/></f></invalidatebody>
		<conlisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_ConstraintListener"/></conlisteners>
		<addconstraint public="1" get="inline" set="null" line="304"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></addconstraint>
		<removeconstraint public="1" get="inline" set="null" line="332"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></removeconstraint>
		<invalidateconstraint public="1" get="inline" set="null" line="338"><f a=""><x path="Void"/></f></invalidateconstraint>
		<new public="1" set="method" line="352"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Flags" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Flags.hx" module="zpp_nape.util.Flags">
		<internal public="1" line="175" static="1"><x path="Bool"/></internal>
		<id_ImmState_ACCEPT public="1" line="177" static="1"><x path="Int"/></id_ImmState_ACCEPT>
		<id_ImmState_IGNORE public="1" line="178" static="1"><x path="Int"/></id_ImmState_IGNORE>
		<id_ImmState_ALWAYS public="1" line="179" static="1"><x path="Int"/></id_ImmState_ALWAYS>
		<id_GravMassMode_DEFAULT public="1" line="180" static="1"><x path="Int"/></id_GravMassMode_DEFAULT>
		<id_GravMassMode_FIXED public="1" line="181" static="1"><x path="Int"/></id_GravMassMode_FIXED>
		<id_GravMassMode_SCALED public="1" line="182" static="1"><x path="Int"/></id_GravMassMode_SCALED>
		<id_InertiaMode_DEFAULT public="1" line="183" static="1"><x path="Int"/></id_InertiaMode_DEFAULT>
		<id_InertiaMode_FIXED public="1" line="184" static="1"><x path="Int"/></id_InertiaMode_FIXED>
		<id_MassMode_DEFAULT public="1" line="185" static="1"><x path="Int"/></id_MassMode_DEFAULT>
		<id_MassMode_FIXED public="1" line="186" static="1"><x path="Int"/></id_MassMode_FIXED>
		<id_BodyType_STATIC public="1" line="187" static="1"><x path="Int"/></id_BodyType_STATIC>
		<id_BodyType_DYNAMIC public="1" line="188" static="1"><x path="Int"/></id_BodyType_DYNAMIC>
		<id_BodyType_KINEMATIC public="1" line="189" static="1"><x path="Int"/></id_BodyType_KINEMATIC>
		<id_ListenerType_BODY public="1" line="190" static="1"><x path="Int"/></id_ListenerType_BODY>
		<id_PreFlag_ACCEPT public="1" line="191" static="1"><x path="Int"/></id_PreFlag_ACCEPT>
		<id_ListenerType_CONSTRAINT public="1" line="192" static="1"><x path="Int"/></id_ListenerType_CONSTRAINT>
		<id_PreFlag_IGNORE public="1" line="193" static="1"><x path="Int"/></id_PreFlag_IGNORE>
		<id_ListenerType_INTERACTION public="1" line="194" static="1"><x path="Int"/></id_ListenerType_INTERACTION>
		<id_PreFlag_ACCEPT_ONCE public="1" line="195" static="1"><x path="Int"/></id_PreFlag_ACCEPT_ONCE>
		<id_ListenerType_PRE public="1" line="196" static="1"><x path="Int"/></id_ListenerType_PRE>
		<id_PreFlag_IGNORE_ONCE public="1" line="197" static="1"><x path="Int"/></id_PreFlag_IGNORE_ONCE>
		<id_CbEvent_BEGIN public="1" line="198" static="1"><x path="Int"/></id_CbEvent_BEGIN>
		<id_InteractionType_COLLISION public="1" line="199" static="1"><x path="Int"/></id_InteractionType_COLLISION>
		<id_CbEvent_ONGOING public="1" line="200" static="1"><x path="Int"/></id_CbEvent_ONGOING>
		<id_InteractionType_SENSOR public="1" line="201" static="1"><x path="Int"/></id_InteractionType_SENSOR>
		<id_CbEvent_END public="1" line="202" static="1"><x path="Int"/></id_CbEvent_END>
		<id_InteractionType_FLUID public="1" line="203" static="1"><x path="Int"/></id_InteractionType_FLUID>
		<id_CbEvent_WAKE public="1" line="204" static="1"><x path="Int"/></id_CbEvent_WAKE>
		<id_InteractionType_ANY public="1" line="205" static="1"><x path="Int"/></id_InteractionType_ANY>
		<id_CbEvent_SLEEP public="1" line="206" static="1"><x path="Int"/></id_CbEvent_SLEEP>
		<id_CbEvent_BREAK public="1" line="207" static="1"><x path="Int"/></id_CbEvent_BREAK>
		<id_CbEvent_PRE public="1" line="208" static="1"><x path="Int"/></id_CbEvent_PRE>
		<id_Winding_UNDEFINED public="1" line="209" static="1"><x path="Int"/></id_Winding_UNDEFINED>
		<id_Winding_CLOCKWISE public="1" line="210" static="1"><x path="Int"/></id_Winding_CLOCKWISE>
		<id_Winding_ANTICLOCKWISE public="1" line="211" static="1"><x path="Int"/></id_Winding_ANTICLOCKWISE>
		<id_ValidationResult_VALID public="1" line="212" static="1"><x path="Int"/></id_ValidationResult_VALID>
		<id_ValidationResult_DEGENERATE public="1" line="213" static="1"><x path="Int"/></id_ValidationResult_DEGENERATE>
		<id_ValidationResult_CONCAVE public="1" line="214" static="1"><x path="Int"/></id_ValidationResult_CONCAVE>
		<id_ValidationResult_SELF_INTERSECTING public="1" line="215" static="1"><x path="Int"/></id_ValidationResult_SELF_INTERSECTING>
		<id_ShapeType_CIRCLE public="1" line="216" static="1"><x path="Int"/></id_ShapeType_CIRCLE>
		<id_ShapeType_POLYGON public="1" line="217" static="1"><x path="Int"/></id_ShapeType_POLYGON>
		<id_Broadphase_DYNAMIC_AABB_TREE public="1" line="218" static="1"><x path="Int"/></id_Broadphase_DYNAMIC_AABB_TREE>
		<id_Broadphase_SWEEP_AND_PRUNE public="1" line="219" static="1"><x path="Int"/></id_Broadphase_SWEEP_AND_PRUNE>
		<id_ArbiterType_COLLISION public="1" line="220" static="1"><x path="Int"/></id_ArbiterType_COLLISION>
		<id_ArbiterType_SENSOR public="1" line="221" static="1"><x path="Int"/></id_ArbiterType_SENSOR>
		<id_ArbiterType_FLUID public="1" line="222" static="1"><x path="Int"/></id_ArbiterType_FLUID>
		<GravMassMode_DEFAULT public="1" static="1"><c path="nape.phys.GravMassMode"/></GravMassMode_DEFAULT>
		<GravMassMode_FIXED public="1" static="1"><c path="nape.phys.GravMassMode"/></GravMassMode_FIXED>
		<GravMassMode_SCALED public="1" static="1"><c path="nape.phys.GravMassMode"/></GravMassMode_SCALED>
		<InertiaMode_DEFAULT public="1" static="1"><c path="nape.phys.InertiaMode"/></InertiaMode_DEFAULT>
		<InertiaMode_FIXED public="1" static="1"><c path="nape.phys.InertiaMode"/></InertiaMode_FIXED>
		<MassMode_DEFAULT public="1" static="1"><c path="nape.phys.MassMode"/></MassMode_DEFAULT>
		<MassMode_FIXED public="1" static="1"><c path="nape.phys.MassMode"/></MassMode_FIXED>
		<BodyType_STATIC public="1" static="1"><c path="nape.phys.BodyType"/></BodyType_STATIC>
		<BodyType_DYNAMIC public="1" static="1"><c path="nape.phys.BodyType"/></BodyType_DYNAMIC>
		<BodyType_KINEMATIC public="1" static="1"><c path="nape.phys.BodyType"/></BodyType_KINEMATIC>
		<ListenerType_BODY public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_BODY>
		<PreFlag_ACCEPT public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_ACCEPT>
		<ListenerType_CONSTRAINT public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_CONSTRAINT>
		<PreFlag_IGNORE public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_IGNORE>
		<ListenerType_INTERACTION public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_INTERACTION>
		<PreFlag_ACCEPT_ONCE public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_ACCEPT_ONCE>
		<ListenerType_PRE public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_PRE>
		<PreFlag_IGNORE_ONCE public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_IGNORE_ONCE>
		<CbEvent_BEGIN public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_BEGIN>
		<InteractionType_COLLISION public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_COLLISION>
		<CbEvent_ONGOING public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_ONGOING>
		<InteractionType_SENSOR public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_SENSOR>
		<CbEvent_END public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_END>
		<InteractionType_FLUID public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_FLUID>
		<CbEvent_WAKE public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_WAKE>
		<InteractionType_ANY public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_ANY>
		<CbEvent_SLEEP public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_SLEEP>
		<CbEvent_BREAK public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_BREAK>
		<CbEvent_PRE public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_PRE>
		<Winding_UNDEFINED public="1" static="1"><c path="nape.geom.Winding"/></Winding_UNDEFINED>
		<Winding_CLOCKWISE public="1" static="1"><c path="nape.geom.Winding"/></Winding_CLOCKWISE>
		<Winding_ANTICLOCKWISE public="1" static="1"><c path="nape.geom.Winding"/></Winding_ANTICLOCKWISE>
		<ValidationResult_VALID public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_VALID>
		<ValidationResult_DEGENERATE public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_DEGENERATE>
		<ValidationResult_CONCAVE public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_CONCAVE>
		<ValidationResult_SELF_INTERSECTING public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_SELF_INTERSECTING>
		<ShapeType_CIRCLE public="1" static="1"><c path="nape.shape.ShapeType"/></ShapeType_CIRCLE>
		<ShapeType_POLYGON public="1" static="1"><c path="nape.shape.ShapeType"/></ShapeType_POLYGON>
		<Broadphase_DYNAMIC_AABB_TREE public="1" static="1"><c path="nape.space.Broadphase"/></Broadphase_DYNAMIC_AABB_TREE>
		<Broadphase_SWEEP_AND_PRUNE public="1" static="1"><c path="nape.space.Broadphase"/></Broadphase_SWEEP_AND_PRUNE>
		<ArbiterType_COLLISION public="1" static="1"><c path="nape.dynamics.ArbiterType"/></ArbiterType_COLLISION>
		<ArbiterType_SENSOR public="1" static="1"><c path="nape.dynamics.ArbiterType"/></ArbiterType_SENSOR>
		<ArbiterType_FLUID public="1" static="1"><c path="nape.dynamics.ArbiterType"/></ArbiterType_FLUID>
	</class>
	<class path="zpp_nape.callbacks.ZPP_Listener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<internal public="1" line="177" static="1"><x path="Bool"/></internal>
		<types public="1" line="182" static="1"><c path="Array"><c path="nape.callbacks.ListenerType"/></c></types>
		<events public="1" line="183" static="1"><c path="Array"><c path="nape.callbacks.CbEvent"/></c></events>
		<setlt public="1" get="inline" set="null" line="193" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></setlt>
		<outer public="1"><c path="nape.callbacks.Listener"/></outer>
		<id public="1"><x path="Int"/></id>
		<type public="1"><x path="Int"/></type>
		<event public="1"><x path="Int"/></event>
		<precedence public="1"><x path="Int"/></precedence>
		<body public="1"><t path="Null"><c path="zpp_nape.callbacks.ZPP_BodyListener"/></t></body>
		<constraint public="1"><t path="Null"><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></t></constraint>
		<interaction public="1"><t path="Null"><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></t></interaction>
		<space public="1"><t path="Null"><c path="zpp_nape.space.ZPP_Space"/></t></space>
		<swapEvent public="1" set="method" line="196"><f a="event">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<invalidate_precedence public="1" set="method" line="197"><f a=""><x path="Void"/></f></invalidate_precedence>
		<addedToSpace public="1" set="method" line="198"><f a=""><x path="Void"/></f></addedToSpace>
		<removedFromSpace public="1" set="method" line="199"><f a=""><x path="Void"/></f></removedFromSpace>
		<new set="method" line="189"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_BodyListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<extends path="zpp_nape.callbacks.ZPP_Listener"/>
		<outer_zn public="1"><c path="nape.callbacks.BodyListener"/></outer_zn>
		<options public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options>
		<handler public="1"><f a="">
	<c path="nape.callbacks.BodyCallback"/>
	<x path="Void"/>
</f></handler>
		<immutable_options set="method" line="207"><f a=""><x path="Void"/></f></immutable_options>
		<addedToSpace public="1" set="method" line="221" override="1"><f a=""><x path="Void"/></f></addedToSpace>
		<removedFromSpace public="1" set="method" line="234" override="1"><f a=""><x path="Void"/></f></removedFromSpace>
		<cbtype_change set="method" line="247"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change>
		<invalidate_precedence public="1" set="method" line="252" override="1"><f a=""><x path="Void"/></f></invalidate_precedence>
		<swapEvent public="1" set="method" line="258" override="1"><f a="newev">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<new public="1" set="method" line="213"><f a="options:event:handler">
	<c path="nape.callbacks.OptionType"/>
	<x path="Int"/>
	<f a="">
		<c path="nape.callbacks.BodyCallback"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_ConstraintListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<extends path="zpp_nape.callbacks.ZPP_Listener"/>
		<outer_zn public="1"><c path="nape.callbacks.ConstraintListener"/></outer_zn>
		<options public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options>
		<handler public="1"><f a="">
	<c path="nape.callbacks.ConstraintCallback"/>
	<x path="Void"/>
</f></handler>
		<immutable_options set="method" line="275"><f a=""><x path="Void"/></f></immutable_options>
		<addedToSpace public="1" set="method" line="289" override="1"><f a=""><x path="Void"/></f></addedToSpace>
		<removedFromSpace public="1" set="method" line="302" override="1"><f a=""><x path="Void"/></f></removedFromSpace>
		<cbtype_change set="method" line="315"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change>
		<invalidate_precedence public="1" set="method" line="320" override="1"><f a=""><x path="Void"/></f></invalidate_precedence>
		<swapEvent public="1" set="method" line="326" override="1"><f a="newev">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<new public="1" set="method" line="281"><f a="options:event:handler">
	<c path="nape.callbacks.OptionType"/>
	<x path="Int"/>
	<f a="">
		<c path="nape.callbacks.ConstraintCallback"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CbType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></head>
		<begin public="1" get="inline" set="null" line="180"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="188"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="193"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="198"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
</f></inlined_add>
		<addAll public="1" set="method" line="235"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="253"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="258"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></inlined_insert>
		<pop public="1" set="method" line="301"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="306"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="339"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="344"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="357"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="368"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="393"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="406"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="429"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="434"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></inlined_erase>
		<splice public="1" set="method" line="480"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></splice>
		<clear public="1" set="method" line="484"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="489"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="495"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="510"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="515"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="518"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="523"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="553"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></front>
		<back public="1" set="method" line="556"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></back>
		<iterator_at public="1" set="method" line="565"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></iterator_at>
		<at public="1" set="method" line="578"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
</f></at>
		<new public="1" set="method" line="177"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_InteractionListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<extends path="zpp_nape.callbacks.ZPP_Listener"/>
		<UCbSet line="385" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></UCbSet>
		<VCbSet line="386" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></VCbSet>
		<WCbSet line="387" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></WCbSet>
		<UCbType line="464" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></UCbType>
		<VCbType line="465" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></VCbType>
		<WCbType line="466" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></WCbType>
		<outer_zni public="1"><t path="Null"><c path="nape.callbacks.InteractionListener"/></t></outer_zni>
		<outer_znp public="1"><t path="Null"><c path="nape.callbacks.PreListener"/></t></outer_znp>
		<itype public="1"><x path="Int"/></itype>
		<options1 public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options1>
		<options2 public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options2>
		<handleri public="1"><t path="Null"><f a="">
	<c path="nape.callbacks.InteractionCallback"/>
	<x path="Void"/>
</f></t></handleri>
		<allowSleepingCallbacks public="1"><x path="Bool"/></allowSleepingCallbacks>
		<pure public="1"><x path="Bool"/></pure>
		<handlerp public="1"><t path="Null"><f a="">
	<c path="nape.callbacks.PreCallback"/>
	<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
</f></t></handlerp>
		<setInteractionType public="1" get="inline" set="null" line="350"><f a="itype">
	<x path="Int"/>
	<x path="Void"/>
</f></setInteractionType>
		<wake public="1" set="method" line="362"><f a=""><x path="Void"/></f></wake>
		<CbSetset get="inline" set="null" line="390"><f a="A:B:lambda">
	<c path="zpp_nape.util.ZNPList_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPList_ZPP_CbSet"/>
	<f a=":">
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></CbSetset>
		<CbTypeset get="inline" set="null" line="469"><f a="A:B:lambda">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<f a=":">
		<c path="zpp_nape.callbacks.ZPP_CbType"/>
		<c path="zpp_nape.callbacks.ZPP_CbType"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></CbTypeset>
		<with_uniquesets set="method" line="543"><f a="fresh">
	<x path="Bool"/>
	<x path="Void"/>
</f></with_uniquesets>
		<with_union get="inline" set="null" line="613"><f a="lambda">
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbType"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></with_union>
		<addedToSpace public="1" set="method" line="642" override="1"><f a=""><x path="Void"/></f></addedToSpace>
		<removedFromSpace public="1" set="method" line="661" override="1"><f a=""><x path="Void"/></f></removedFromSpace>
		<invalidate_precedence public="1" set="method" line="680" override="1"><f a=""><x path="Void"/></f></invalidate_precedence>
		<cbtype_change1 set="method" line="699"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change1>
		<cbtype_change2 set="method" line="702"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change2>
		<cbtype_change set="method" line="705"><f a="options:cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_OptionType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change>
		<swapEvent public="1" set="method" line="712" override="1"><f a="newev">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<new public="1" set="method" line="353"><f a="options1:options2:event:type">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_OptionType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/callbacks/OptionType.hx" module="zpp_nape.callbacks.OptionType">
		<argument public="1" set="method" line="350" static="1"><f a="val">
	<d/>
	<c path="nape.callbacks.OptionType"/>
</f></argument>
		<outer public="1"><c path="nape.callbacks.OptionType"/></outer>
		<handler public="1"><t path="Null"><f a="::">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></t></handler>
		<includes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></includes>
		<excludes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></excludes>
		<wrap_includes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_includes>
		<wrap_excludes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_excludes>
		<setup_includes public="1" set="method" line="185"><f a=""><x path="Void"/></f></setup_includes>
		<setup_excludes public="1" set="method" line="188"><f a=""><x path="Void"/></f></setup_excludes>
		<excluded public="1" get="inline" set="null" line="192"><f a="xs">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></excluded>
		<included public="1" get="inline" set="null" line="196"><f a="xs">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></included>
		<compatible public="1" get="inline" set="null" line="200"><f a="xs">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></compatible>
		<nonemptyintersection public="1" set="method" line="203"><f a="xs:ys">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></nonemptyintersection>
		<effect_change public="1" get="inline" set="null" line="225"><f a="val:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></effect_change>
		<append_type set="method" line="263"><f a="list:val">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></append_type>
		<set public="1" set="method" line="289"><f a="options">
	<c path="zpp_nape.callbacks.ZPP_OptionType"/>
	<c path="zpp_nape.callbacks.ZPP_OptionType"/>
</f></set>
		<append public="1" set="method" line="312"><f a="list:val">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<d/>
	<x path="Void"/>
</f></append>
		<new public="1" set="method" line="179"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_Constraint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/Constraint.hx" module="zpp_nape.constraint.Constraint">
		<outer public="1"><c path="nape.constraint.Constraint"/></outer>
		<clear public="1" set="method" line="176"><f a=""><x path="Void"/></f></clear>
		<id public="1"><x path="Int"/></id>
		<userData public="1"><d><d/></d></userData>
		<compound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></compound>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<active public="1"><x path="Bool"/></active>
		<stiff public="1"><x path="Bool"/></stiff>
		<frequency public="1"><x path="Float"/></frequency>
		<damping public="1"><x path="Float"/></damping>
		<maxForce public="1"><x path="Float"/></maxForce>
		<maxError public="1"><x path="Float"/></maxError>
		<breakUnderForce public="1"><x path="Bool"/></breakUnderForce>
		<breakUnderError public="1"><x path="Bool"/></breakUnderError>
		<removeOnBreak public="1"><x path="Bool"/></removeOnBreak>
		<component public="1"><c path="zpp_nape.space.ZPP_Component"/></component>
		<ignore public="1"><x path="Bool"/></ignore>
		<__velocity public="1"><x path="Bool"/></__velocity>
		<immutable_midstep public="1" set="method" line="208"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></immutable_midstep>
		<cbTypes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></cbTypes>
		<cbSet public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></cbSet>
		<wrap_cbTypes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_cbTypes>
		<setupcbTypes public="1" set="method" line="216"><f a=""><x path="Void"/></f></setupcbTypes>
		<immutable_cbTypes set="method" line="226"><f a=""><x path="Void"/></f></immutable_cbTypes>
		<wrap_cbTypes_subber set="method" line="230"><f a="pcb">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></wrap_cbTypes_subber>
		<wrap_cbTypes_adder set="method" line="244"><f a="cb">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></wrap_cbTypes_adder>
		<insert_cbtype public="1" set="method" line="248"><f a="cb">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></insert_cbtype>
		<alloc_cbSet public="1" set="method" line="275"><f a=""><x path="Void"/></f></alloc_cbSet>
		<dealloc_cbSet public="1" set="method" line="289"><f a=""><x path="Void"/></f></dealloc_cbSet>
		<activate public="1" set="method" line="323"><f a=""><x path="Void"/></f></activate>
		<deactivate public="1" set="method" line="326"><f a=""><x path="Void"/></f></deactivate>
		<addedToSpace public="1" set="method" line="329"><f a=""><x path="Void"/></f></addedToSpace>
		<removedFromSpace public="1" set="method" line="341"><f a=""><x path="Void"/></f></removedFromSpace>
		<activeInSpace public="1" set="method" line="353"><f a=""><x path="Void"/></f></activeInSpace>
		<inactiveOrOutSpace public="1" set="method" line="383"><f a=""><x path="Void"/></f></inactiveOrOutSpace>
		<activeBodies public="1" set="method" line="405"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveBodies public="1" set="method" line="416"><f a=""><x path="Void"/></f></inactiveBodies>
		<clearcache public="1" set="method" line="427"><f a=""><x path="Void"/></f></clearcache>
		<validate public="1" set="method" line="438"><f a=""><x path="Void"/></f></validate>
		<wake_connected public="1" set="method" line="449"><f a=""><x path="Void"/></f></wake_connected>
		<forest public="1" set="method" line="460"><f a=""><x path="Void"/></f></forest>
		<pair_exists public="1" set="method" line="471"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<broken public="1" set="method" line="483"><f a=""><x path="Void"/></f></broken>
		<warmStart public="1" set="method" line="485"><f a=""><x path="Void"/></f></warmStart>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<preStep public="1" set="method" line="497"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<applyImpulseVel public="1" set="method" line="509"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<applyImpulsePos public="1" set="method" line="521"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<wake public="1" set="method" line="532"><f a=""><x path="Void"/></f></wake>
		<draw public="1" set="method" line="535"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<copy public="1" set="method" line="536"><f a="?dict:?todo" v="null:null">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<copyto public="1" set="method" line="539"><f a="ret">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></copyto>
		<new public="1" set="method" line="193"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_AngleJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/AngleJoint.hx" module="zpp_nape.constraint.AngleJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<outer_zn public="1"><c path="nape.constraint.AngleJoint"/></outer_zn>
		<ratio public="1"><x path="Float"/></ratio>
		<jointMin public="1"><x path="Float"/></jointMin>
		<jointMax public="1"><x path="Float"/></jointMax>
		<slack public="1"><x path="Bool"/></slack>
		<equal public="1"><x path="Bool"/></equal>
		<scale public="1"><x path="Float"/></scale>
		<is_slack public="1" get="inline" set="null" line="184"><f a=""><x path="Bool"/></f></is_slack>
		<bodyImpulse public="1" set="method" line="214"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<activeBodies public="1" set="method" line="221" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveBodies public="1" set="method" line="229" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<kMass public="1"><x path="Float"/></kMass>
		<jAcc public="1"><x path="Float"/></jAcc>
		<jMax public="1"><x path="Float"/></jMax>
		<gamma public="1"><x path="Float"/></gamma>
		<bias public="1"><x path="Float"/></bias>
		<stepped public="1"><x path="Bool"/></stepped>
		<copy public="1" set="method" line="245" override="1"><f a="?dict:?todo" v="null:null">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<validate public="1" set="method" line="300" override="1"><f a=""><x path="Void"/></f></validate>
		<wake_connected public="1" set="method" line="307" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<forest public="1" set="method" line="311" override="1"><f a=""><x path="Void"/></f></forest>
		<pair_exists public="1" set="method" line="409" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<clearcache public="1" set="method" line="412" override="1"><f a=""><x path="Void"/></f></clearcache>
		<preStep public="1" set="method" line="417" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<warmStart public="1" set="method" line="481" override="1"><f a=""><x path="Void"/></f></warmStart>
		<applyImpulseVel public="1" set="method" line="493" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<applyImpulsePos public="1" set="method" line="532" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<draw public="1" set="method" line="579" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="292"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_AngleDraw" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/AngleJoint.hx" module="zpp_nape.constraint.AngleJoint">
		<indicator public="1" set="method" line="652" static="1"><f a="g:c:ang:rad:col">
	<c path="nape.util.Debug"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></indicator>
		<maxarc line="657" static="1"><x path="Float"/></maxarc>
		<drawSpiralSpring public="1" set="method" line="658" static="1"><f a="g:c:a0:a1:r0:r1:col:?coils" v=":::::::4">
	<c path="nape.util.Debug"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawSpiralSpring>
		<drawSpiral public="1" set="method" line="736" static="1"><f a="g:c:a0:a1:r0:r1:col">
	<c path="nape.util.Debug"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawSpiral>
	</class>
	<class path="zpp_nape.constraint.ZPP_CopyHelper" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/Constraint.hx" module="zpp_nape.constraint.Constraint">
		<dict public="1" set="method" line="560" static="1"><f a="id:bc">
	<x path="Int"/>
	<c path="nape.phys.Body"/>
	<c path="zpp_nape.constraint.ZPP_CopyHelper"/>
</f></dict>
		<todo public="1" set="method" line="566" static="1"><f a="id:cb">
	<x path="Int"/>
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.constraint.ZPP_CopyHelper"/>
</f></todo>
		<id public="1"><x path="Int"/></id>
		<bc public="1"><c path="nape.phys.Body"/></bc>
		<cb public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></cb>
		<new set="method" line="559"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_DistanceJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/DistanceJoint.hx" module="zpp_nape.constraint.DistanceJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<outer_zn public="1"><c path="nape.constraint.DistanceJoint"/></outer_zn>
		<jointMin public="1"><x path="Float"/></jointMin>
		<jointMax public="1"><x path="Float"/></jointMax>
		<slack public="1"><x path="Bool"/></slack>
		<equal public="1"><x path="Bool"/></equal>
		<is_slack public="1" get="inline" set="null" line="182"><f a=""><x path="Bool"/></f></is_slack>
		<nx public="1"><x path="Float"/></nx>
		<ny public="1"><x path="Float"/></ny>
		<cx1 public="1"><x path="Float"/></cx1>
		<cx2 public="1"><x path="Float"/></cx2>
		<bodyImpulse public="1" set="method" line="288"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<activeBodies public="1" set="method" line="295" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveBodies public="1" set="method" line="303" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<a1localx public="1"><x path="Float"/></a1localx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1rely public="1"><x path="Float"/></a1rely>
		<validate_a1 set="method" line="316"><f a=""><x path="Void"/></f></validate_a1>
		<invalidate_a1 set="method" line="338"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<setup_a1 public="1" set="method" line="362"><f a=""><x path="Void"/></f></setup_a1>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<a2localx public="1"><x path="Float"/></a2localx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2rely public="1"><x path="Float"/></a2rely>
		<validate_a2 set="method" line="374"><f a=""><x path="Void"/></f></validate_a2>
		<invalidate_a2 set="method" line="396"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<setup_a2 public="1" set="method" line="420"><f a=""><x path="Void"/></f></setup_a2>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<kMass public="1"><x path="Float"/></kMass>
		<jAcc public="1"><x path="Float"/></jAcc>
		<jMax public="1"><x path="Float"/></jMax>
		<gamma public="1"><x path="Float"/></gamma>
		<bias public="1"><x path="Float"/></bias>
		<stepped public="1"><x path="Bool"/></stepped>
		<copy public="1" set="method" line="433" override="1"><f a="?dict:?todo" v="null:null">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<validate public="1" set="method" line="571" override="1"><f a=""><x path="Void"/></f></validate>
		<wake_connected public="1" set="method" line="578" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<forest public="1" set="method" line="582" override="1"><f a=""><x path="Void"/></f></forest>
		<pair_exists public="1" set="method" line="680" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<clearcache public="1" set="method" line="683" override="1"><f a=""><x path="Void"/></f></clearcache>
		<preStep public="1" set="method" line="687" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<warmStart public="1" set="method" line="823" override="1"><f a=""><x path="Void"/></f></warmStart>
		<applyImpulseVel public="1" set="method" line="887" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<applyImpulsePos public="1" set="method" line="977" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<draw public="1" set="method" line="1288" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="480"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_LineJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/LineJoint.hx" module="zpp_nape.constraint.LineJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<outer_zn public="1"><c path="nape.constraint.LineJoint"/></outer_zn>
		<scale public="1"><x path="Float"/></scale>
		<jointMin public="1"><x path="Float"/></jointMin>
		<jointMax public="1"><x path="Float"/></jointMax>
		<equal public="1"><x path="Bool"/></equal>
		<dot1 public="1"><x path="Float"/></dot1>
		<dot2 public="1"><x path="Float"/></dot2>
		<cx1 public="1"><x path="Float"/></cx1>
		<cx2 public="1"><x path="Float"/></cx2>
		<bodyImpulse public="1" set="method" line="184"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<activeBodies public="1" set="method" line="209" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveBodies public="1" set="method" line="217" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<a1localx public="1"><x path="Float"/></a1localx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1rely public="1"><x path="Float"/></a1rely>
		<validate_a1 set="method" line="230"><f a=""><x path="Void"/></f></validate_a1>
		<invalidate_a1 set="method" line="252"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<setup_a1 public="1" set="method" line="276"><f a=""><x path="Void"/></f></setup_a1>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<a2localx public="1"><x path="Float"/></a2localx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2rely public="1"><x path="Float"/></a2rely>
		<validate_a2 set="method" line="288"><f a=""><x path="Void"/></f></validate_a2>
		<invalidate_a2 set="method" line="310"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<setup_a2 public="1" set="method" line="334"><f a=""><x path="Void"/></f></setup_a2>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<zip_n public="1"><x path="Bool"/></zip_n>
		<nlocalx public="1"><x path="Float"/></nlocalx>
		<nlocaly public="1"><x path="Float"/></nlocaly>
		<nrelx public="1"><x path="Float"/></nrelx>
		<nrely public="1"><x path="Float"/></nrely>
		<validate_n set="method" line="346"><f a=""><x path="Void"/></f></validate_n>
		<invalidate_n set="method" line="368"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_n>
		<setup_n public="1" set="method" line="395"><f a=""><x path="Void"/></f></setup_n>
		<wrap_n public="1"><c path="nape.geom.Vec2"/></wrap_n>
		<validate_norm public="1" set="method" line="402"><f a=""><x path="Void"/></f></validate_norm>
		<kMassa public="1"><x path="Float"/></kMassa>
		<kMassb public="1"><x path="Float"/></kMassb>
		<kMassc public="1"><x path="Float"/></kMassc>
		<jAccx public="1"><x path="Float"/></jAccx>
		<jAccy public="1"><x path="Float"/></jAccy>
		<jMax public="1"><x path="Float"/></jMax>
		<gamma public="1"><x path="Float"/></gamma>
		<biasx public="1"><x path="Float"/></biasx>
		<biasy public="1"><x path="Float"/></biasy>
		<stepped public="1"><x path="Bool"/></stepped>
		<copy public="1" set="method" line="442" override="1"><f a="?dict:?todo" v="null:null">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<validate public="1" set="method" line="642" override="1"><f a=""><x path="Void"/></f></validate>
		<wake_connected public="1" set="method" line="650" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<forest public="1" set="method" line="654" override="1"><f a=""><x path="Void"/></f></forest>
		<pair_exists public="1" set="method" line="752" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<clearcache public="1" set="method" line="755" override="1"><f a=""><x path="Void"/></f></clearcache>
		<preStep public="1" set="method" line="778" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<warmStart public="1" set="method" line="994" override="1"><f a=""><x path="Void"/></f></warmStart>
		<applyImpulseVel public="1" set="method" line="1076" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<applyImpulsePos public="1" set="method" line="1279" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<draw public="1" set="method" line="1571" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="489"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_MotorJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/MotorJoint.hx" module="zpp_nape.constraint.MotorJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<outer_zn public="1"><c path="nape.constraint.MotorJoint"/></outer_zn>
		<ratio public="1"><x path="Float"/></ratio>
		<rate public="1"><x path="Float"/></rate>
		<bodyImpulse public="1" set="method" line="178"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<activeBodies public="1" set="method" line="185" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveBodies public="1" set="method" line="193" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<kMass public="1"><x path="Float"/></kMass>
		<jAcc public="1"><x path="Float"/></jAcc>
		<jMax public="1"><x path="Float"/></jMax>
		<stepped public="1"><x path="Bool"/></stepped>
		<copy public="1" set="method" line="207" override="1"><f a="?dict:?todo" v="null:null">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<validate public="1" set="method" line="260" override="1"><f a=""><x path="Void"/></f></validate>
		<wake_connected public="1" set="method" line="266" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<forest public="1" set="method" line="270" override="1"><f a=""><x path="Void"/></f></forest>
		<pair_exists public="1" set="method" line="368" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<clearcache public="1" set="method" line="371" override="1"><f a=""><x path="Void"/></f></clearcache>
		<preStep public="1" set="method" line="375" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<warmStart public="1" set="method" line="396" override="1"><f a=""><x path="Void"/></f></warmStart>
		<applyImpulseVel public="1" set="method" line="402" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<applyImpulsePos public="1" set="method" line="435" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<new public="1" set="method" line="254"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_PivotJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/PivotJoint.hx" module="zpp_nape.constraint.PivotJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<outer_zn public="1"><c path="nape.constraint.PivotJoint"/></outer_zn>
		<bodyImpulse public="1" set="method" line="176"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<activeBodies public="1" set="method" line="183" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveBodies public="1" set="method" line="191" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<a1localx public="1"><x path="Float"/></a1localx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1rely public="1"><x path="Float"/></a1rely>
		<validate_a1 set="method" line="204"><f a=""><x path="Void"/></f></validate_a1>
		<invalidate_a1 set="method" line="226"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<setup_a1 public="1" set="method" line="250"><f a=""><x path="Void"/></f></setup_a1>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<a2localx public="1"><x path="Float"/></a2localx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2rely public="1"><x path="Float"/></a2rely>
		<validate_a2 set="method" line="262"><f a=""><x path="Void"/></f></validate_a2>
		<invalidate_a2 set="method" line="284"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<setup_a2 public="1" set="method" line="308"><f a=""><x path="Void"/></f></setup_a2>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<kMassa public="1"><x path="Float"/></kMassa>
		<kMassb public="1"><x path="Float"/></kMassb>
		<kMassc public="1"><x path="Float"/></kMassc>
		<jAccx public="1"><x path="Float"/></jAccx>
		<jAccy public="1"><x path="Float"/></jAccy>
		<jMax public="1"><x path="Float"/></jMax>
		<gamma public="1"><x path="Float"/></gamma>
		<biasx public="1"><x path="Float"/></biasx>
		<biasy public="1"><x path="Float"/></biasy>
		<stepped public="1"><x path="Bool"/></stepped>
		<copy public="1" set="method" line="325" override="1"><f a="?dict:?todo" v="null:null">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<validate public="1" set="method" line="481" override="1"><f a=""><x path="Void"/></f></validate>
		<wake_connected public="1" set="method" line="487" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<forest public="1" set="method" line="491" override="1"><f a=""><x path="Void"/></f></forest>
		<pair_exists public="1" set="method" line="589" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<clearcache public="1" set="method" line="592" override="1"><f a=""><x path="Void"/></f></clearcache>
		<preStep public="1" set="method" line="615" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<warmStart public="1" set="method" line="794" override="1"><f a=""><x path="Void"/></f></warmStart>
		<applyImpulseVel public="1" set="method" line="858" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<applyImpulsePos public="1" set="method" line="1034" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<draw public="1" set="method" line="1342" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="372"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_PulleyJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/PulleyJoint.hx" module="zpp_nape.constraint.PulleyJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<outer_zn public="1"><c path="nape.constraint.PulleyJoint"/></outer_zn>
		<ratio public="1"><x path="Float"/></ratio>
		<jointMin public="1"><x path="Float"/></jointMin>
		<jointMax public="1"><x path="Float"/></jointMax>
		<slack public="1"><x path="Bool"/></slack>
		<equal public="1"><x path="Bool"/></equal>
		<is_slack public="1" get="inline" set="null" line="183"><f a=""><x path="Bool"/></f></is_slack>
		<n12x public="1"><x path="Float"/></n12x>
		<n12y public="1"><x path="Float"/></n12y>
		<n34x public="1"><x path="Float"/></n34x>
		<n34y public="1"><x path="Float"/></n34y>
		<cx1 public="1"><x path="Float"/></cx1>
		<cx2 public="1"><x path="Float"/></cx2>
		<cx3 public="1"><x path="Float"/></cx3>
		<cx4 public="1"><x path="Float"/></cx4>
		<bodyImpulse public="1" set="method" line="353"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<activeBodies public="1" set="method" line="380" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveBodies public="1" set="method" line="394" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<a1localx public="1"><x path="Float"/></a1localx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1rely public="1"><x path="Float"/></a1rely>
		<validate_a1 set="method" line="413"><f a=""><x path="Void"/></f></validate_a1>
		<invalidate_a1 set="method" line="435"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<setup_a1 public="1" set="method" line="459"><f a=""><x path="Void"/></f></setup_a1>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<a2localx public="1"><x path="Float"/></a2localx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2rely public="1"><x path="Float"/></a2rely>
		<validate_a2 set="method" line="471"><f a=""><x path="Void"/></f></validate_a2>
		<invalidate_a2 set="method" line="493"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<setup_a2 public="1" set="method" line="517"><f a=""><x path="Void"/></f></setup_a2>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<b3 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b3>
		<a3localx public="1"><x path="Float"/></a3localx>
		<a3localy public="1"><x path="Float"/></a3localy>
		<a3relx public="1"><x path="Float"/></a3relx>
		<a3rely public="1"><x path="Float"/></a3rely>
		<validate_a3 set="method" line="529"><f a=""><x path="Void"/></f></validate_a3>
		<invalidate_a3 set="method" line="551"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a3>
		<setup_a3 public="1" set="method" line="575"><f a=""><x path="Void"/></f></setup_a3>
		<wrap_a3 public="1"><c path="nape.geom.Vec2"/></wrap_a3>
		<b4 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b4>
		<a4localx public="1"><x path="Float"/></a4localx>
		<a4localy public="1"><x path="Float"/></a4localy>
		<a4relx public="1"><x path="Float"/></a4relx>
		<a4rely public="1"><x path="Float"/></a4rely>
		<validate_a4 set="method" line="587"><f a=""><x path="Void"/></f></validate_a4>
		<invalidate_a4 set="method" line="609"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a4>
		<setup_a4 public="1" set="method" line="633"><f a=""><x path="Void"/></f></setup_a4>
		<wrap_a4 public="1"><c path="nape.geom.Vec2"/></wrap_a4>
		<kMass public="1"><x path="Float"/></kMass>
		<jAcc public="1"><x path="Float"/></jAcc>
		<jMax public="1"><x path="Float"/></jMax>
		<gamma public="1"><x path="Float"/></gamma>
		<bias public="1"><x path="Float"/></bias>
		<stepped public="1"><x path="Bool"/></stepped>
		<copy public="1" set="method" line="646" override="1"><f a="?dict:?todo" v="null:null">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<validate public="1" set="method" line="950" override="1"><f a=""><x path="Void"/></f></validate>
		<wake_connected public="1" set="method" line="958" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<forest public="1" set="method" line="964" override="1"><f a=""><x path="Void"/></f></forest>
		<pair_exists public="1" set="method" line="1158" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<clearcache public="1" set="method" line="1161" override="1"><f a=""><x path="Void"/></f></clearcache>
		<preStep public="1" set="method" line="1165" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<warmStart public="1" set="method" line="1367" override="1"><f a=""><x path="Void"/></f></warmStart>
		<applyImpulseVel public="1" set="method" line="1487" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<applyImpulsePos public="1" set="method" line="1633" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<draw public="1" set="method" line="2192" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<drawLink public="1" set="method" line="2216"><f a="g:a1:a2:n:nl:bias:scale:ca:cb">
	<c path="nape.util.Debug"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLink>
		<new public="1" set="method" line="735"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_UserConstraint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/UserConstraint.hx" module="zpp_nape.constraint.UserConstraint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<outer_zn public="1"><c path="nape.constraint.UserConstraint"/></outer_zn>
		<bindVec2_invalidate public="1" set="method" line="176"><f a="_">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></bindVec2_invalidate>
		<bodies public="1"><t path="nape.TArray"><c path="zpp_nape.constraint.ZPP_UserBody"/></t></bodies>
		<dim public="1"><x path="Int"/></dim>
		<jAcc public="1"><t path="nape.TArray"><x path="Float"/></t></jAcc>
		<bias public="1"><t path="nape.TArray"><x path="Float"/></t></bias>
		<addBody public="1" set="method" line="183"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></addBody>
		<remBody public="1" set="method" line="207"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></remBody>
		<bodyImpulse public="1" set="method" line="237"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<activeBodies public="1" set="method" line="243" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveBodies public="1" set="method" line="248" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<stepped public="1"><x path="Bool"/></stepped>
		<copy public="1" set="method" line="254" override="1"><f a="?dict:?todo" v="null:null">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<validate public="1" set="method" line="295" override="1"><f a=""><x path="Void"/></f></validate>
		<wake_connected public="1" set="method" line="299" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<forest public="1" set="method" line="304" override="1"><f a=""><x path="Void"/></f></forest>
		<pair_exists public="1" set="method" line="356" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<broken public="1" set="method" line="372" override="1"><f a=""><x path="Void"/></f></broken>
		<clearcache public="1" set="method" line="375" override="1"><f a=""><x path="Void"/></f></clearcache>
		<lsq public="1" set="method" line="379"><f a="v">
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Float"/>
</f></lsq>
		<_clamp public="1" set="method" line="384"><f a="v:max">
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Float"/>
	<x path="Void"/>
</f></_clamp>
		<L><t path="nape.TArray"><x path="Float"/></t></L>
		<solve public="1" set="method" line="392"><f a="m">
	<t path="nape.TArray"><x path="Float"/></t>
	<t path="nape.TArray"><x path="Float"/></t>
</f></solve>
		<y><t path="nape.TArray"><x path="Float"/></t></y>
		<transform public="1" set="method" line="415"><f a="L:x">
	<t path="nape.TArray"><x path="Float"/></t>
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Void"/>
</f></transform>
		<soft public="1"><x path="Float"/></soft>
		<gamma public="1"><x path="Float"/></gamma>
		<velonly public="1"><x path="Bool"/></velonly>
		<jMax public="1"><x path="Float"/></jMax>
		<Keff public="1"><t path="nape.TArray"><x path="Float"/></t></Keff>
		<preStep public="1" set="method" line="441" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<vec3><c path="nape.geom.Vec3"/></vec3>
		<warmStart public="1" set="method" line="477" override="1"><f a=""><x path="Void"/></f></warmStart>
		<J><t path="nape.TArray"><x path="Float"/></t></J>
		<jOld><t path="nape.TArray"><x path="Float"/></t></jOld>
		<applyImpulseVel public="1" set="method" line="499" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<applyImpulsePos public="1" set="method" line="533" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<draw public="1" set="method" line="564" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="260"><f a="dim:velonly">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_UserBody" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/UserConstraint.hx" module="zpp_nape.constraint.UserConstraint">
		<cnt public="1"><x path="Int"/></cnt>
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<new public="1" set="method" line="572"><f a="cnt:body">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_WeldJoint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/constraint/WeldJoint.hx" module="zpp_nape.constraint.WeldJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<outer_zn public="1"><c path="nape.constraint.WeldJoint"/></outer_zn>
		<bodyImpulse public="1" set="method" line="176"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<activeBodies public="1" set="method" line="183" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveBodies public="1" set="method" line="191" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<a1localx public="1"><x path="Float"/></a1localx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1rely public="1"><x path="Float"/></a1rely>
		<validate_a1 set="method" line="204"><f a=""><x path="Void"/></f></validate_a1>
		<invalidate_a1 set="method" line="226"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<setup_a1 public="1" set="method" line="250"><f a=""><x path="Void"/></f></setup_a1>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<a2localx public="1"><x path="Float"/></a2localx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2rely public="1"><x path="Float"/></a2rely>
		<validate_a2 set="method" line="262"><f a=""><x path="Void"/></f></validate_a2>
		<invalidate_a2 set="method" line="284"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<setup_a2 public="1" set="method" line="308"><f a=""><x path="Void"/></f></setup_a2>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<phase public="1"><x path="Float"/></phase>
		<kMassa public="1"><x path="Float"/></kMassa>
		<kMassb public="1"><x path="Float"/></kMassb>
		<kMassd public="1"><x path="Float"/></kMassd>
		<kMassc public="1"><x path="Float"/></kMassc>
		<kMasse public="1"><x path="Float"/></kMasse>
		<kMassf public="1"><x path="Float"/></kMassf>
		<jAccx public="1"><x path="Float"/></jAccx>
		<jAccy public="1"><x path="Float"/></jAccy>
		<jAccz public="1"><x path="Float"/></jAccz>
		<jMax public="1"><x path="Float"/></jMax>
		<gamma public="1"><x path="Float"/></gamma>
		<biasx public="1"><x path="Float"/></biasx>
		<biasy public="1"><x path="Float"/></biasy>
		<biasz public="1"><x path="Float"/></biasz>
		<stepped public="1"><x path="Bool"/></stepped>
		<copy public="1" set="method" line="331" override="1"><f a="?dict:?todo" v="null:null">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<validate public="1" set="method" line="491" override="1"><f a=""><x path="Void"/></f></validate>
		<wake_connected public="1" set="method" line="497" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<forest public="1" set="method" line="501" override="1"><f a=""><x path="Void"/></f></forest>
		<pair_exists public="1" set="method" line="599" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<clearcache public="1" set="method" line="602" override="1"><f a=""><x path="Void"/></f></clearcache>
		<preStep public="1" set="method" line="628" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<warmStart public="1" set="method" line="858" override="1"><f a=""><x path="Void"/></f></warmStart>
		<applyImpulseVel public="1" set="method" line="922" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<applyImpulsePos public="1" set="method" line="1143" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<draw public="1" set="method" line="1531" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="378"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_Arbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<internal public="1" line="179" static="1"><x path="Bool"/></internal>
		<COL public="1" line="261" static="1"><x path="Int"/></COL>
		<FLUID public="1" line="262" static="1"><x path="Int"/></FLUID>
		<SENSOR public="1" line="263" static="1"><x path="Int"/></SENSOR>
		<types public="1" line="264" static="1"><c path="Array"><c path="nape.dynamics.ArbiterType"/></c></types>
		<outer public="1"><c path="nape.dynamics.Arbiter"/></outer>
		<wrapper public="1" set="method" line="180"><f a=""><c path="nape.dynamics.Arbiter"/></f></wrapper>
		<inactiveme public="1" get="inline" set="null" line="199"><f a=""><x path="Bool"/></f></inactiveme>
		<hnext public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></hnext>
		<id public="1"><x path="Int"/></id>
		<di public="1"><x path="Int"/></di>
		<stamp public="1"><x path="Int"/></stamp>
		<up_stamp public="1"><x path="Int"/></up_stamp>
		<sleep_stamp public="1"><x path="Int"/></sleep_stamp>
		<endGenerated public="1"><x path="Int"/></endGenerated>
		<active public="1"><x path="Bool"/></active>
		<cleared public="1"><x path="Bool"/></cleared>
		<sleeping public="1"><x path="Bool"/></sleeping>
		<present public="1"><x path="Int"/></present>
		<intchange public="1"><x path="Bool"/></intchange>
		<presentable public="1"><x path="Bool"/></presentable>
		<continuous public="1"><x path="Bool"/></continuous>
		<fresh public="1"><x path="Bool"/></fresh>
		<immState public="1"><x path="Int"/></immState>
		<acting public="1" get="inline" set="null" line="224"><f a=""><x path="Bool"/></f></acting>
		<invalidated public="1"><x path="Bool"/></invalidated>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<ws1 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></ws1>
		<ws2 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></ws2>
		<pair public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></pair>
		<swap_features public="1" get="inline" set="null" line="235"><f a=""><x path="Void"/></f></swap_features>
		<type public="1"><x path="Int"/></type>
		<colarb public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></colarb>
		<fluidarb public="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></fluidarb>
		<sensorarb public="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></sensorarb>
		<lazyRetire public="1" get="inline" set="null" line="270"><f a="s:?b" v=":null">
	<c path="zpp_nape.space.ZPP_Space"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></lazyRetire>
		<sup_assign public="1" get="inline" set="null" line="291"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sup_assign>
		<sup_retire public="1" get="inline" set="null" line="309"><f a=""><x path="Void"/></f></sup_retire>
		<new public="1" set="method" line="203"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_SensorArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<extends path="zpp_nape.dynamics.ZPP_Arbiter"/>
		<zpp_pool public="1" line="358" static="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></zpp_pool>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></next>
		<alloc public="1" get="inline" set="null" line="384"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="396"><f a=""><x path="Void"/></f></free>
		<assign public="1" get="inline" set="null" line="413"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<retire public="1" get="inline" set="null" line="418"><f a=""><x path="Void"/></f></retire>
		<makemutable public="1" get="inline" set="null" line="440"><f a=""><x path="Void"/></f></makemutable>
		<makeimmutable public="1" get="inline" set="null" line="443"><f a=""><x path="Void"/></f></makeimmutable>
		<new public="1" set="method" line="406"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_FluidArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<extends path="zpp_nape.dynamics.ZPP_Arbiter"/>
		<zpp_pool public="1" line="449" static="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></zpp_pool>
		<outer_zn public="1"><c path="nape.dynamics.FluidArbiter"/></outer_zn>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></next>
		<alloc public="1" get="inline" set="null" line="475"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="487"><f a=""><x path="Void"/></f></free>
		<centroidx public="1"><x path="Float"/></centroidx>
		<centroidy public="1"><x path="Float"/></centroidy>
		<overlap public="1"><x path="Float"/></overlap>
		<r1x public="1"><x path="Float"/></r1x>
		<r1y public="1"><x path="Float"/></r1y>
		<r2x public="1"><x path="Float"/></r2x>
		<r2y public="1"><x path="Float"/></r2y>
		<nodrag public="1"><x path="Bool"/></nodrag>
		<wMass public="1"><x path="Float"/></wMass>
		<adamp public="1"><x path="Float"/></adamp>
		<agamma public="1"><x path="Float"/></agamma>
		<vMassa public="1"><x path="Float"/></vMassa>
		<vMassb public="1"><x path="Float"/></vMassb>
		<vMassc public="1"><x path="Float"/></vMassc>
		<dampx public="1"><x path="Float"/></dampx>
		<dampy public="1"><x path="Float"/></dampy>
		<lgamma public="1"><x path="Float"/></lgamma>
		<nx public="1"><x path="Float"/></nx>
		<ny public="1"><x path="Float"/></ny>
		<buoyx public="1"><x path="Float"/></buoyx>
		<buoyy public="1"><x path="Float"/></buoyy>
		<position_validate set="method" line="518"><f a=""><x path="Void"/></f></position_validate>
		<position_invalidate set="method" line="543"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></position_invalidate>
		<wrap_position public="1"><c path="nape.geom.Vec2"/></wrap_position>
		<getposition public="1" set="method" line="566"><f a=""><x path="Void"/></f></getposition>
		<assign public="1" get="inline" set="null" line="601"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<retire public="1" get="inline" set="null" line="647"><f a=""><x path="Void"/></f></retire>
		<mutable public="1"><x path="Bool"/></mutable>
		<makemutable public="1" get="inline" set="null" line="671"><f a=""><x path="Void"/></f></makemutable>
		<makeimmutable public="1" get="inline" set="null" line="677"><f a=""><x path="Void"/></f></makeimmutable>
		<inject public="1" get="inline" set="null" line="683"><f a="area:cx:cy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inject>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<preStep public="1" get="inline" set="null" line="709"><f a="s:dt">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Float"/>
	<x path="Void"/>
</f></preStep>
		<warmStart public="1" get="inline" set="null" line="1268"><f a=""><x path="Void"/></f></warmStart>
		<applyImpulseVel public="1" get="inline" set="null" line="1302"><f a=""><x path="Void"/></f></applyImpulseVel>
		<new public="1" set="method" line="573"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_ColArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<extends path="zpp_nape.dynamics.ZPP_Arbiter"/>
		<FACE1 public="1" get="inline" set="null" line="1466" static="1"><x path="Int"/></FACE1>
		<FACE2 public="1" get="inline" set="null" line="1467" static="1"><x path="Int"/></FACE2>
		<CIRCLE public="1" get="inline" set="null" line="1468" static="1"><x path="Int"/></CIRCLE>
		<zpp_pool public="1" line="1486" static="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></zpp_pool>
		<outer_zn public="1"><c path="nape.dynamics.CollisionArbiter"/></outer_zn>
		<dyn_fric public="1"><x path="Float"/></dyn_fric>
		<stat_fric public="1"><x path="Float"/></stat_fric>
		<restitution public="1"><x path="Float"/></restitution>
		<rfric public="1"><x path="Float"/></rfric>
		<userdef_dyn_fric public="1"><x path="Bool"/></userdef_dyn_fric>
		<userdef_stat_fric public="1"><x path="Bool"/></userdef_stat_fric>
		<userdef_restitution public="1"><x path="Bool"/></userdef_restitution>
		<userdef_rfric public="1"><x path="Bool"/></userdef_rfric>
		<s1 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s1>
		<s2 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s2>
		<contacts public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></contacts>
		<wrap_contacts public="1"><c path="nape.dynamics.ContactList"/></wrap_contacts>
		<innards public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></innards>
		<nx public="1"><x path="Float"/></nx>
		<ny public="1"><x path="Float"/></ny>
		<normal_validate set="method" line="1408"><f a=""><x path="Void"/></f></normal_validate>
		<wrap_normal public="1"><c path="nape.geom.Vec2"/></wrap_normal>
		<getnormal public="1" set="method" line="1438"><f a=""><x path="Void"/></f></getnormal>
		<kMassa><x path="Float"/></kMassa>
		<kMassb><x path="Float"/></kMassb>
		<kMassc><x path="Float"/></kMassc>
		<Ka><x path="Float"/></Ka>
		<Kb><x path="Float"/></Kb>
		<Kc><x path="Float"/></Kc>
		<rMass public="1"><x path="Float"/></rMass>
		<jrAcc public="1"><x path="Float"/></jrAcc>
		<rn1a><x path="Float"/></rn1a>
		<rt1a><x path="Float"/></rt1a>
		<rn1b><x path="Float"/></rn1b>
		<rt1b><x path="Float"/></rt1b>
		<rn2a><x path="Float"/></rn2a>
		<rt2a><x path="Float"/></rt2a>
		<rn2b><x path="Float"/></rn2b>
		<rt2b><x path="Float"/></rt2b>
		<k1x><x path="Float"/></k1x>
		<k1y><x path="Float"/></k1y>
		<k2x><x path="Float"/></k2x>
		<k2y><x path="Float"/></k2y>
		<surfacex public="1"><x path="Float"/></surfacex>
		<surfacey public="1"><x path="Float"/></surfacey>
		<ptype public="1"><x path="Int"/></ptype>
		<lnormx public="1"><x path="Float"/></lnormx>
		<lnormy public="1"><x path="Float"/></lnormy>
		<lproj public="1"><x path="Float"/></lproj>
		<radius public="1"><x path="Float"/></radius>
		<rev public="1"><x path="Bool"/></rev>
		<biasCoef><x path="Float"/></biasCoef>
		<__ref_edge1 public="1"><c path="zpp_nape.shape.ZPP_Edge"/></__ref_edge1>
		<__ref_edge2 public="1"><c path="zpp_nape.shape.ZPP_Edge"/></__ref_edge2>
		<__ref_vertex public="1"><x path="Int"/></__ref_vertex>
		<c1 public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></c1>
		<oc1 public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></oc1>
		<c2 public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></c2>
		<oc2 public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></oc2>
		<hc2 public="1"><x path="Bool"/></hc2>
		<hpc2 public="1"><x path="Bool"/></hpc2>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></next>
		<alloc public="1" get="inline" set="null" line="1520"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="1532"><f a=""><x path="Void"/></f></free>
		<stat public="1"><x path="Bool"/></stat>
		<injectContact public="1" get="inline" set="null" line="1558"><f a="px:py:nx:ny:dist:hash:?posOnly" v="::::::false">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></injectContact>
		<assign public="1" get="inline" set="null" line="1646"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<calcProperties public="1" get="inline" set="null" line="1654"><f a=""><x path="Void"/></f></calcProperties>
		<validate_props public="1" get="inline" set="null" line="1674"><f a=""><x path="Void"/></f></validate_props>
		<retire public="1" get="inline" set="null" line="1682"><f a=""><x path="Void"/></f></retire>
		<mutable public="1"><x path="Bool"/></mutable>
		<makemutable public="1" get="inline" set="null" line="1726"><f a=""><x path="Void"/></f></makemutable>
		<makeimmutable public="1" get="inline" set="null" line="1733"><f a=""><x path="Void"/></f></makeimmutable>
		<contacts_adder set="method" line="1738"><f a="x">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></contacts_adder>
		<contacts_subber set="method" line="1744"><f a="x">
	<c path="nape.dynamics.Contact"/>
	<x path="Void"/>
</f></contacts_subber>
		<setupcontacts public="1" set="method" line="1783"><f a=""><x path="Void"/></f></setupcontacts>
		<cleanupContacts public="1" get="inline" set="null" line="1792"><f a=""><x path="Bool"/></f></cleanupContacts>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<preStep public="1" get="inline" set="null" line="1882"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<warmStart public="1" get="inline" set="null" line="2127"><f a=""><x path="Void"/></f></warmStart>
		<applyImpulseVel public="1" get="inline" set="null" line="2197"><f a=""><x path="Void"/></f></applyImpulseVel>
		<applyImpulsePos public="1" get="inline" set="null" line="2342"><f a=""><x path="Void"/></f></applyImpulsePos>
		<new public="1" set="method" line="1510"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_Contact" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/dynamics/Contact.hx" module="zpp_nape.dynamics.Contact">
		<internal public="1" line="176" static="1"><x path="Bool"/></internal>
		<zpp_pool public="1" line="244" static="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></zpp_pool>
		<outer public="1"><c path="nape.dynamics.Contact"/></outer>
		<wrapper public="1" set="method" line="177"><f a=""><c path="nape.dynamics.Contact"/></f></wrapper>
		<px public="1"><x path="Float"/></px>
		<py public="1"><x path="Float"/></py>
		<position_validate set="method" line="188"><f a=""><x path="Void"/></f></position_validate>
		<wrap_position public="1"><c path="nape.geom.Vec2"/></wrap_position>
		<getposition public="1" set="method" line="214"><f a=""><x path="Void"/></f></getposition>
		<inactiveme public="1" set="method" line="221"><f a=""><x path="Bool"/></f></inactiveme>
		<arbiter public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></arbiter>
		<inner public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></inner>
		<active public="1"><x path="Bool"/></active>
		<posOnly public="1"><x path="Bool"/></posOnly>
		<stamp public="1"><x path="Int"/></stamp>
		<hash public="1"><x path="Int"/></hash>
		<fresh public="1"><x path="Bool"/></fresh>
		<dist public="1"><x path="Float"/></dist>
		<elasticity public="1"><x path="Float"/></elasticity>
		<free public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="243"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></next>
		<elem public="1" get="inline" set="null" line="271"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></elem>
		<begin public="1" get="inline" set="null" line="276"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></begin>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="285"><f a="i">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="290"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="295"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></inlined_add>
		<addAll public="1" set="method" line="314"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="332"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="337"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></inlined_insert>
		<pop public="1" set="method" line="362"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="367"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="386"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="391"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="404"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="415"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="440"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="453"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="476"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="481"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></inlined_erase>
		<splice public="1" set="method" line="513"><f a="pre:n">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></splice>
		<clear public="1" set="method" line="517"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="522"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="528"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="543"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="548"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="551"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="556"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="586"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></front>
		<back public="1" set="method" line="589"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></back>
		<iterator_at public="1" set="method" line="598"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></iterator_at>
		<at public="1" set="method" line="611"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></at>
		<new public="1" set="method" line="233"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_IContact" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/dynamics/Contact.hx" module="zpp_nape.dynamics.Contact">
		<r1x public="1"><x path="Float"/></r1x>
		<r1y public="1"><x path="Float"/></r1y>
		<r2x public="1"><x path="Float"/></r2x>
		<r2y public="1"><x path="Float"/></r2y>
		<nMass public="1"><x path="Float"/></nMass>
		<tMass public="1"><x path="Float"/></tMass>
		<bounce public="1"><x path="Float"/></bounce>
		<friction public="1"><x path="Float"/></friction>
		<jnAcc public="1"><x path="Float"/></jnAcc>
		<jtAcc public="1"><x path="Float"/></jtAcc>
		<lr1x public="1"><x path="Float"/></lr1x>
		<lr1y public="1"><x path="Float"/></lr1y>
		<lr2x public="1"><x path="Float"/></lr2x>
		<lr2y public="1"><x path="Float"/></lr2y>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></next>
		<elem public="1" get="inline" set="null" line="644"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></elem>
		<begin public="1" get="inline" set="null" line="649"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></begin>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="658"><f a="i">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="663"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="668"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></inlined_add>
		<addAll public="1" set="method" line="687"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="705"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="710"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></inlined_insert>
		<pop public="1" set="method" line="735"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="740"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="759"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="764"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="777"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="788"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="813"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="826"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="849"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="854"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></inlined_erase>
		<splice public="1" set="method" line="886"><f a="pre:n">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></splice>
		<clear public="1" set="method" line="890"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="895"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="901"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="916"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="921"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="924"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="929"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="959"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></front>
		<back public="1" set="method" line="962"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></back>
		<iterator_at public="1" set="method" line="971"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></iterator_at>
		<at public="1" set="method" line="984"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></at>
		<new public="1" set="method" line="640"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_InteractionFilter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/dynamics/InteractionFilter.hx" module="zpp_nape.dynamics.InteractionFilter">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></zpp_pool>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></next>
		<userData public="1"><d><d/></d></userData>
		<outer public="1"><c path="nape.dynamics.InteractionFilter"/></outer>
		<wrapper public="1" set="method" line="202"><f a=""><c path="nape.dynamics.InteractionFilter"/></f></wrapper>
		<free public="1" get="inline" set="null" line="228"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></alloc>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<feature_cons public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></feature_cons>
		<addShape public="1" get="inline" set="null" line="243"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></addShape>
		<remShape public="1" get="inline" set="null" line="248"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remShape>
		<copy public="1" set="method" line="256"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></f></copy>
		<collisionGroup public="1"><x path="Int"/></collisionGroup>
		<collisionMask public="1"><x path="Int"/></collisionMask>
		<shouldCollide public="1" get="inline" set="null" line="287"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Bool"/>
</f></shouldCollide>
		<sensorGroup public="1"><x path="Int"/></sensorGroup>
		<sensorMask public="1"><x path="Int"/></sensorMask>
		<shouldSense public="1" get="inline" set="null" line="294"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Bool"/>
</f></shouldSense>
		<fluidGroup public="1"><x path="Int"/></fluidGroup>
		<fluidMask public="1"><x path="Int"/></fluidMask>
		<shouldFlow public="1" get="inline" set="null" line="301"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Bool"/>
</f></shouldFlow>
		<invalidate public="1" set="method" line="304"><f a=""><x path="Void"/></f></invalidate>
		<new public="1" set="method" line="251"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_InteractionGroup" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/dynamics/InteractionGroup.hx" module="zpp_nape.dynamics.InteractionGroup">
		<SHAPE public="1" line="220" static="1"><x path="Int"/></SHAPE>
		<BODY public="1" line="221" static="1"><x path="Int"/></BODY>
		<outer public="1"><c path="nape.dynamics.InteractionGroup"/></outer>
		<ignore public="1"><x path="Bool"/></ignore>
		<group public="1"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></group>
		<setGroup public="1" set="method" line="178"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></setGroup>
		<groups public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/></groups>
		<wrap_groups public="1"><c path="nape.dynamics.InteractionGroupList"/></wrap_groups>
		<interactors public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></interactors>
		<wrap_interactors public="1"><c path="nape.phys.InteractorList"/></wrap_interactors>
		<depth public="1"><x path="Int"/></depth>
		<invalidate public="1" set="method" line="197"><f a="?force" v="false">
	<x path="Bool"/>
	<x path="Void"/>
</f></invalidate>
		<addGroup public="1" get="inline" set="null" line="229"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></addGroup>
		<remGroup public="1" get="inline" set="null" line="235"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></remGroup>
		<addInteractor public="1" get="inline" set="null" line="241"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></addInteractor>
		<remInteractor public="1" get="inline" set="null" line="246"><f a="intx:?flag" v=":-1">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Int"/>
	<x path="Void"/>
</f></remInteractor>
		<new public="1" set="method" line="222"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_SpaceArbiterList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/dynamics/SpaceArbiterList.hx" module="zpp_nape.dynamics.SpaceArbiterList">
		<extends path="nape.dynamics.ArbiterList"/>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<_length public="1"><x path="Int"/></_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<zpp_gl public="1" set="method" line="189" override="1"><f a=""><x path="Int"/></f></zpp_gl>
		<lengths public="1"><c path="Array"><x path="Int"/></c></lengths>
		<ite_0 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></ite_0>
		<ite_1 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></ite_1>
		<ite_2 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></ite_2>
		<ite_3 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></ite_3>
		<at_index_0 public="1"><x path="Int"/></at_index_0>
		<at_index_1 public="1"><x path="Int"/></at_index_1>
		<at_index_2 public="1"><x path="Int"/></at_index_2>
		<at_index_3 public="1"><x path="Int"/></at_index_3>
		<zpp_vm public="1" set="method" line="261" override="1"><f a=""><x path="Void"/></f></zpp_vm>
		<push public="1" set="method" line="290" override="1"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></push>
		<pop public="1" set="method" line="296" override="1"><f a=""><c path="nape.dynamics.Arbiter"/></f></pop>
		<unshift public="1" set="method" line="302" override="1"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></unshift>
		<shift public="1" set="method" line="308" override="1"><f a=""><c path="nape.dynamics.Arbiter"/></f></shift>
		<remove public="1" set="method" line="314" override="1"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></remove>
		<clear public="1" set="method" line="320" override="1"><f a=""><x path="Void"/></f></clear>
		<at public="1" set="method" line="325" override="1"><f a="index">
	<x path="Int"/>
	<c path="nape.dynamics.Arbiter"/>
</f></at>
		<new public="1" set="method" line="178"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_AABB" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/AABB.hx" module="zpp_nape.geom.AABB">
		<zpp_pool public="1" line="218" static="1"><c path="zpp_nape.geom.ZPP_AABB"/></zpp_pool>
		<get public="1" get="inline" set="null" line="258" static="1"><f a="minx:miny:maxx:maxy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_AABB"/>
</f></get>
		<_invalidate public="1"><t path="Null"><f a="">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></t></_invalidate>
		<_validate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_validate>
		<_immutable public="1"><x path="Bool"/></_immutable>
		<validate public="1" get="inline" set="null" line="180"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" get="inline" set="null" line="187"><f a=""><x path="Void"/></f></invalidate>
		<outer public="1"><t path="Null"><c path="nape.geom.AABB"/></t></outer>
		<wrapper public="1" set="method" line="193"><f a=""><c path="nape.geom.AABB"/></f></wrapper>
		<next public="1"><c path="zpp_nape.geom.ZPP_AABB"/></next>
		<alloc public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="247"><f a=""><x path="Void"/></f></free>
		<copy public="1" get="inline" set="null" line="321"><f a=""><c path="zpp_nape.geom.ZPP_AABB"/></f></copy>
		<width public="1" get="inline" set="null" line="326"><f a=""><x path="Float"/></f></width>
		<height public="1" get="inline" set="null" line="331"><f a=""><x path="Float"/></f></height>
		<perimeter public="1" get="inline" set="null" line="336"><f a=""><x path="Float"/></f></perimeter>
		<minx public="1"><x path="Float"/></minx>
		<miny public="1"><x path="Float"/></miny>
		<wrap_min public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></wrap_min>
		<getmin public="1" set="method" line="342"><f a=""><c path="nape.geom.Vec2"/></f></getmin>
		<dom_min public="1" set="method" line="356"><f a=""><x path="Void"/></f></dom_min>
		<mod_min public="1" set="method" line="379"><f a="min">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></mod_min>
		<maxx public="1"><x path="Float"/></maxx>
		<maxy public="1"><x path="Float"/></maxy>
		<wrap_max public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></wrap_max>
		<getmax public="1" set="method" line="407"><f a=""><c path="nape.geom.Vec2"/></f></getmax>
		<dom_max public="1" set="method" line="421"><f a=""><x path="Void"/></f></dom_max>
		<mod_max public="1" set="method" line="444"><f a="max">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></mod_max>
		<intersectX public="1" get="inline" set="null" line="471"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></intersectX>
		<intersectY public="1" get="inline" set="null" line="476"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></intersectY>
		<intersect public="1" get="inline" set="null" line="481"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></intersect>
		<combine public="1" get="inline" set="null" line="486"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></combine>
		<contains public="1" get="inline" set="null" line="494"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" get="inline" set="null" line="499"><f a="v">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></containsPoint>
		<setCombine public="1" get="inline" set="null" line="504"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></setCombine>
		<setExpand public="1" get="inline" set="null" line="512"><f a="a:fatten">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setExpand>
		<setExpandPoint public="1" get="inline" set="null" line="520"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setExpandPoint>
		<toString public="1" set="method" line="526"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="256"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Vec2" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></head>
		<begin public="1" get="inline" set="null" line="9354"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="9362"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="9367"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="9372"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_add>
		<addAll public="1" set="method" line="9409"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Vec2"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="9427"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="9432"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></inlined_insert>
		<pop public="1" set="method" line="9475"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="9480"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="9513"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="9518"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="9531"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="9542"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="9567"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="9580"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="9603"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="9608"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></inlined_erase>
		<splice public="1" set="method" line="9654"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></splice>
		<clear public="1" set="method" line="9658"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="9663"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="9669"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="9684"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="9689"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="9692"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="9697"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="9727"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></front>
		<back public="1" set="method" line="9730"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></back>
		<iterator_at public="1" set="method" line="9739"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></iterator_at>
		<at public="1" set="method" line="9752"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></at>
		<new public="1" set="method" line="9351"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Collide" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Collide.hx" module="zpp_nape.geom.Collide">
		<circleContains public="1" set="method" line="175" static="1"><f a="c:p">
	<c path="zpp_nape.shape.ZPP_Circle"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></circleContains>
		<polyContains public="1" set="method" line="184" static="1"><f a="s:p">
	<c path="zpp_nape.shape.ZPP_Polygon"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></polyContains>
		<shapeContains public="1" set="method" line="210" static="1"><f a="s:p">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></shapeContains>
		<bodyContains public="1" set="method" line="214" static="1"><f a="b:p">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></bodyContains>
		<containTest public="1" set="method" line="234" static="1"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></containTest>
		<contactCollide public="1" set="method" line="356" static="1"><f a="s1:s2:arb:rev">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></contactCollide>
		<testCollide_safe public="1" set="method" line="1034" static="1"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></testCollide_safe>
		<testCollide public="1" set="method" line="1042" static="1"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></testCollide>
		<flowCollide public="1" set="method" line="1171" static="1"><f a="s1:s2:arb">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></flowCollide>
		<flowpoly public="1" line="2910" static="1"><c path="zpp_nape.util.ZNPList_ZPP_Vec2"/></flowpoly>
		<flowsegs public="1" line="2911" static="1"><c path="zpp_nape.util.ZNPList_ZPP_Vec2"/></flowsegs>
	</class>
	<class path="zpp_nape.geom.ZPP_Convex" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Convex.hx" module="zpp_nape.geom.Convex">
		<isinner set="method" line="175" static="1"><f a="a:b:c">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></isinner>
		<optimise public="1" set="method" line="190" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></optimise>
	</class>
	<class path="zpp_nape.geom.ZPP_ConvexRayResult" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/ConvexRayResult.hx" module="zpp_nape.geom.ConvexRayResult">
		<convexPool line="177" static="1"><c path="zpp_nape.geom.ZPP_ConvexRayResult"/></convexPool>
		<rayPool line="180" static="1"><c path="zpp_nape.geom.ZPP_ConvexRayResult"/></rayPool>
		<internal public="1" line="186" static="1"><x path="Bool"/></internal>
		<getRay public="1" set="method" line="187" static="1"><f a="normal:time:inner:shape">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.shape.Shape"/>
	<c path="nape.geom.RayResult"/>
</f></getRay>
		<getConvex public="1" set="method" line="209" static="1"><f a="normal:position:toiDistance:shape">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<c path="nape.shape.Shape"/>
	<c path="nape.geom.ConvexResult"/>
</f></getConvex>
		<normal public="1"><c path="nape.geom.Vec2"/></normal>
		<shape public="1"><c path="nape.shape.Shape"/></shape>
		<convex public="1"><c path="nape.geom.ConvexResult"/></convex>
		<position public="1"><c path="nape.geom.Vec2"/></position>
		<ray public="1"><c path="nape.geom.RayResult"/></ray>
		<inner public="1"><x path="Bool"/></inner>
		<next public="1"><c path="zpp_nape.geom.ZPP_ConvexRayResult"/></next>
		<toiDistance public="1"><x path="Float"/></toiDistance>
		<disposed public="1" get="inline" set="null" line="234"><f a=""><x path="Void"/></f></disposed>
		<free public="1" set="method" line="239"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="185"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_CutVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Cutter.hx" module="zpp_nape.geom.Cutter">
		<zpp_pool public="1" line="175" static="1"><c path="zpp_nape.geom.ZPP_CutVert"/></zpp_pool>
		<path public="1" get="inline" set="null" line="220" static="1"><f a="poly">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></path>
		<prev public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></prev>
		<next public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></next>
		<posx public="1"><x path="Float"/></posx>
		<posy public="1"><x path="Float"/></posy>
		<vert public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></vert>
		<value public="1"><x path="Float"/></value>
		<positive public="1"><x path="Bool"/></positive>
		<parent public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></parent>
		<rank public="1"><x path="Int"/></rank>
		<used public="1"><x path="Bool"/></used>
		<alloc public="1" get="inline" set="null" line="212"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="215"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="209"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_CutInt" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Cutter.hx" module="zpp_nape.geom.Cutter">
		<zpp_pool public="1" line="249" static="1"><c path="zpp_nape.geom.ZPP_CutInt"/></zpp_pool>
		<get public="1" get="inline" set="null" line="291" static="1"><f a="time:?end:?start:?path0:?path1:?virtualint:?vertex" v=":null:null:null:null:false:false">
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></get>
		<next public="1"><c path="zpp_nape.geom.ZPP_CutInt"/></next>
		<time public="1"><x path="Float"/></time>
		<virtualint public="1"><x path="Bool"/></virtualint>
		<vertex public="1"><x path="Bool"/></vertex>
		<path0 public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></path0>
		<end public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></end>
		<start public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></start>
		<path1 public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></path1>
		<alloc public="1" get="inline" set="null" line="283"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="286"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="280"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Cutter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Cutter.hx" module="zpp_nape.geom.Cutter">
		<ints line="322" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CutInt"/></ints>
		<paths line="323" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CutVert"/></paths>
		<run public="1" set="method" line="324" static="1"><f a="P:_start:_end:bstart:bend:output">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
	<c path="nape.geom.GeomPolyList"/>
</f></run>
	</class>
	<class path="zpp_nape.geom.ZPP_Geom" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Geom.hx" module="zpp_nape.geom.Geom"><validateShape public="1" set="method" line="175" static="1"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></validateShape></class>
	<class path="zpp_nape.geom.ZPP_GeomVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/GeomPoly.hx" module="zpp_nape.geom.GeomPoly">
		<zpp_pool public="1" line="181" static="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></zpp_pool>
		<get public="1" get="inline" set="null" line="275" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></get>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<prev public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></prev>
		<next public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></next>
		<wrap public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></wrap>
		<forced public="1"><x path="Bool"/></forced>
		<free public="1" get="inline" set="null" line="206"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="215"><f a=""><x path="Void"/></f></alloc>
		<wrapper public="1" get="inline" set="null" line="219"><f a=""><c path="nape.geom.Vec2"/></f></wrapper>
		<modwrap public="1" get="inline" set="null" line="229"><f a="n">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></modwrap>
		<getwrap public="1" get="inline" set="null" line="252"><f a=""><x path="Void"/></f></getwrap>
		<new public="1" set="method" line="316"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_GeomPoly" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/GeomPoly.hx" module="zpp_nape.geom.GeomPoly">
		<outer public="1"><c path="nape.geom.GeomPoly"/></outer>
		<vertices public="1"><t path="Null"><c path="zpp_nape.geom.ZPP_GeomVert"/></t></vertices>
		<new public="1" set="method" line="322"><f a="outer">
	<c path="nape.geom.GeomPoly"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_GeomVertexIterator" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/GeomPoly.hx" module="zpp_nape.geom.GeomPoly">
		<zpp_pool public="1" line="334" static="1"><c path="zpp_nape.geom.ZPP_GeomVertexIterator"/></zpp_pool>
		<internal public="1" line="368" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="379" static="1"><f a="poly:forward">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomVertexIterator"/>
</f></get>
		<ptr public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></ptr>
		<start public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></start>
		<first public="1"><x path="Bool"/></first>
		<forward public="1"><x path="Bool"/></forward>
		<outer public="1"><c path="nape.geom.GeomVertexIterator"/></outer>
		<next public="1"><c path="zpp_nape.geom.ZPP_GeomVertexIterator"/></next>
		<free public="1" get="inline" set="null" line="360"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="366"><f a=""><x path="Void"/></f></alloc>
		<new set="method" line="370"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MarchSpan" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/MarchingSquares.hx" module="zpp_nape.geom.MarchingSquares">
		<zpp_pool public="1" line="179" static="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></zpp_pool>
		<parent public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></parent>
		<rank public="1"><x path="Int"/></rank>
		<out public="1"><x path="Bool"/></out>
		<next public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></next>
		<free public="1" get="inline" set="null" line="205"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="210"><f a=""><x path="Void"/></f></alloc>
		<new public="1" set="method" line="214"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MarchPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/MarchingSquares.hx" module="zpp_nape.geom.MarchingSquares">
		<zpp_pool public="1" line="234" static="1"><c path="zpp_nape.geom.ZPP_MarchPair"/></zpp_pool>
		<p1 public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></p1>
		<key1 public="1"><x path="Int"/></key1>
		<okey1 public="1"><x path="Int"/></okey1>
		<p2 public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></p2>
		<key2 public="1"><x path="Int"/></key2>
		<okey2 public="1"><x path="Int"/></okey2>
		<pr public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></pr>
		<keyr public="1"><x path="Int"/></keyr>
		<okeyr public="1"><x path="Int"/></okeyr>
		<pd public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></pd>
		<span1 public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></span1>
		<span2 public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></span2>
		<spanr public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></spanr>
		<next public="1"><c path="zpp_nape.geom.ZPP_MarchPair"/></next>
		<free public="1" get="inline" set="null" line="260"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="266"><f a=""><x path="Void"/></f></alloc>
		<new public="1" set="method" line="267"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MarchingSquares" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/MarchingSquares.hx" module="zpp_nape.geom.MarchingSquares">
		<me line="271" static="1"><c path="zpp_nape.geom.ZPP_MarchingSquares"/></me>
		<isos static="1"><c path="zpp_nape.util.ZNPArray2_Float"/></isos>
		<ints static="1"><c path="zpp_nape.util.ZNPArray2_ZPP_GeomVert"/></ints>
		<map static="1"><c path="zpp_nape.util.ZNPArray2_ZPP_MarchPair"/></map>
		<run public="1" set="method" line="276" static="1"><f a="iso:bx0:by0:bx1:by1:cell:quality:combine:ret">
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
	<x path="Void"/>
</f></run>
		<look_march public="1" line="953" static="1"><c path="Array"><x path="Int"/></c></look_march>
		<ISO get="inline" set="null" line="1928" static="1"><f a="iso:x:y">
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ISO>
		<output set="method" line="662"><f a="ret:poly">
	<c path="nape.geom.GeomPolyList"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></output>
		<linkright get="inline" set="null" line="750"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkright>
		<linkleft get="inline" set="null" line="758"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkleft>
		<linkdown get="inline" set="null" line="763"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkdown>
		<linkup get="inline" set="null" line="768"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkup>
		<combLR set="method" line="771"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></combLR>
		<combUD set="method" line="864"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></combUD>
		<combUD_virtual set="method" line="911"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></combUD_virtual>
		<combLeft get="inline" set="null" line="922"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combLeft>
		<combRight get="inline" set="null" line="928"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combRight>
		<combUp get="inline" set="null" line="934"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combUp>
		<combDown get="inline" set="null" line="940"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combDown>
		<comb get="inline" set="null" line="946"><f a="flag">
	<x path="Int"/>
	<x path="Bool"/>
</f></comb>
		<marchSquare set="method" line="954"><f a="iso:isos:ints:x0:y0:x1:y1:xn:yn:fstx:fsty:sndx:sndy:quality">
	<t path="nape.geom.IsoFunctionDef"/>
	<c path="zpp_nape.util.ZNPArray2_Float"/>
	<c path="zpp_nape.util.ZNPArray2_ZPP_GeomVert"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
</f></marchSquare>
		<lerp get="inline" set="null" line="1882"><f a="x0:x1:v0:v1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></lerp>
		<xlerp set="method" line="1893"><f a="x0:x1:y:v0:v1:iso:quality">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Int"/>
	<x path="Float"/>
</f></xlerp>
		<ylerp set="method" line="1910"><f a="y0:y1:x:v0:v1:iso:quality">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Int"/>
	<x path="Float"/>
</f></ylerp>
		<new set="method" line="272"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Mat23" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Mat23.hx" module="zpp_nape.geom.Mat23">
		<zpp_pool public="1" line="248" static="1"><c path="zpp_nape.geom.ZPP_Mat23"/></zpp_pool>
		<get public="1" set="method" line="279" static="1"><f a=""><c path="zpp_nape.geom.ZPP_Mat23"/></f></get>
		<identity public="1" set="method" line="300" static="1"><f a=""><c path="zpp_nape.geom.ZPP_Mat23"/></f></identity>
		<outer public="1"><t path="Null"><c path="nape.geom.Mat23"/></t></outer>
		<wrapper public="1" set="method" line="176"><f a=""><c path="nape.geom.Mat23"/></f></wrapper>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<_invalidate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_invalidate>
		<invalidate public="1" get="inline" set="null" line="209"><f a=""><x path="Void"/></f></invalidate>
		<set public="1" get="inline" set="null" line="216"><f a="m">
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Void"/>
</f></set>
		<setas public="1" set="method" line="219"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setas>
		<next public="1"><c path="zpp_nape.geom.ZPP_Mat23"/></next>
		<free public="1" get="inline" set="null" line="274"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="277"><f a=""><x path="Void"/></f></alloc>
		<new public="1" set="method" line="278"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MatMN" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/MatMN.hx" module="zpp_nape.geom.MatMN">
		<outer public="1"><c path="nape.geom.MatMN"/></outer>
		<m public="1"><x path="Int"/></m>
		<n public="1"><x path="Int"/></n>
		<x public="1"><t path="nape.TArray"><x path="Float"/></t></x>
		<new public="1" set="method" line="179"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Monotone" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Monotone.hx" module="zpp_nape.geom.Monotone">
		<bisector set="method" line="175" static="1"><f a="b">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></bisector>
		<below set="method" line="222" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></below>
		<above set="method" line="296" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></above>
		<left_vertex set="method" line="299" static="1"><f a="p">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></left_vertex>
		<isMonotone public="1" set="method" line="303" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></isMonotone>
		<sharedPPoly public="1" static="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></sharedPPoly>
		<getShared public="1" get="inline" set="null" line="378" static="1"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></getShared>
		<queue line="382" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></queue>
		<edges line="383" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></edges>
		<decompose public="1" set="method" line="384" static="1"><f a="P:?poly" v=":null">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></decompose>
	</class>
	<class path="zpp_nape.geom.ZPP_PartitionVertex" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/PartitionedPoly.hx" module="zpp_nape.geom.PartitionedPoly">
		<nextId line="176" static="1"><x path="Int"/></nextId>
		<zpp_pool public="1" line="185" static="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></zpp_pool>
		<get public="1" get="inline" set="null" line="230" static="1"><f a="x">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></get>
		<rightdistance set="method" line="493" static="1"><f a="edge:vert">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Float"/>
</f></rightdistance>
		<vert_lt public="1" set="method" line="509" static="1"><f a="edge:vert">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></vert_lt>
		<edge_swap public="1" set="method" line="518" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></edge_swap>
		<edge_lt public="1" set="method" line="523" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></edge_lt>
		<id public="1"><x path="Int"/></id>
		<mag public="1"><x path="Float"/></mag>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<forced public="1"><x path="Bool"/></forced>
		<diagonals public="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></diagonals>
		<type public="1"><x path="Int"/></type>
		<helper public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></helper>
		<rightchain public="1"><x path="Bool"/></rightchain>
		<next public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></next>
		<prev public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></prev>
		<alloc public="1" get="inline" set="null" line="216"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="218"><f a=""><x path="Void"/></f></free>
		<copy public="1" get="inline" set="null" line="272"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></copy>
		<sort public="1" set="method" line="314"><f a=""><x path="Void"/></f></sort>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></node>
		<new public="1" set="method" line="211"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_PartitionedPoly" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/PartitionedPoly.hx" module="zpp_nape.geom.PartitionedPoly">
		<zpp_pool public="1" line="596" static="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></zpp_pool>
		<sharedPPList public="1" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/></sharedPPList>
		<getSharedPP public="1" get="inline" set="null" line="891" static="1"><f a=""><c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/></f></getSharedPP>
		<sharedGVList public="1" static="1"><c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/></sharedGVList>
		<getShared public="1" get="inline" set="null" line="1134" static="1"><f a=""><c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/></f></getShared>
		<vertices public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></vertices>
		<eq set="method" line="589"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></eq>
		<next public="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></next>
		<alloc public="1" get="inline" set="null" line="621"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="623"><f a=""><x path="Void"/></f></free>
		<init public="1" set="method" line="633"><f a="?P" v="null">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></init>
		<remove_collinear_vertices public="1" set="method" line="712"><f a=""><x path="Bool"/></f></remove_collinear_vertices>
		<add_diagonal public="1" set="method" line="884"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></add_diagonal>
		<extract_partitions public="1" set="method" line="895"><f a="?ret" v="null">
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
</f></extract_partitions>
		<pull_partitions set="method" line="990"><f a="start:ret">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></pull_partitions>
		<extract public="1" set="method" line="1138"><f a="?ret" v="null">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
</f></extract>
		<pull set="method" line="1218"><f a="start:ret">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></pull>
		<new public="1" set="method" line="592"><f a="?P" v="null">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Ray" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Ray.hx" module="zpp_nape.geom.Ray">
		<internal public="1" line="176" static="1"><x path="Bool"/></internal>
		<origin public="1"><c path="nape.geom.Vec2"/></origin>
		<direction public="1"><c path="nape.geom.Vec2"/></direction>
		<maxdist public="1"><x path="Float"/></maxdist>
		<userData public="1"><d><d/></d></userData>
		<originx public="1"><x path="Float"/></originx>
		<originy public="1"><x path="Float"/></originy>
		<dirx public="1"><x path="Float"/></dirx>
		<diry public="1"><x path="Float"/></diry>
		<idirx public="1"><x path="Float"/></idirx>
		<idiry public="1"><x path="Float"/></idiry>
		<normalx public="1"><x path="Float"/></normalx>
		<normaly public="1"><x path="Float"/></normaly>
		<absnormalx public="1"><x path="Float"/></absnormalx>
		<absnormaly public="1"><x path="Float"/></absnormaly>
		<origin_invalidate set="method" line="192"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></origin_invalidate>
		<direction_invalidate set="method" line="214"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></direction_invalidate>
		<zip_dir public="1"><x path="Bool"/></zip_dir>
		<invalidate_dir public="1" get="inline" set="null" line="287"><f a=""><x path="Void"/></f></invalidate_dir>
		<validate_dir public="1" set="method" line="290"><f a=""><x path="Void"/></f></validate_dir>
		<rayAABB public="1" set="method" line="391"><f a=""><c path="zpp_nape.geom.ZPP_AABB"/></f></rayAABB>
		<aabbtest public="1" set="method" line="427"><f a="a">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></aabbtest>
		<aabbsect public="1" set="method" line="435"><f a="a">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Float"/>
</f></aabbsect>
		<circlesect public="1" set="method" line="491"><f a="c:inner:mint">
	<c path="zpp_nape.shape.ZPP_Circle"/>
	<x path="Bool"/>
	<x path="Float"/>
	<t path="Null"><c path="nape.geom.RayResult"/></t>
</f></circlesect>
		<circlesect2 public="1" set="method" line="761"><f a="c:inner:list">
	<c path="zpp_nape.shape.ZPP_Circle"/>
	<x path="Bool"/>
	<c path="nape.geom.RayResultList"/>
	<x path="Void"/>
</f></circlesect2>
		<polysect public="1" set="method" line="1068"><f a="p:inner:mint">
	<c path="zpp_nape.shape.ZPP_Polygon"/>
	<x path="Bool"/>
	<x path="Float"/>
	<t path="Null"><c path="nape.geom.RayResult"/></t>
</f></polysect>
		<polysect2 public="1" set="method" line="1185"><f a="p:inner:list">
	<c path="zpp_nape.shape.ZPP_Polygon"/>
	<x path="Bool"/>
	<c path="nape.geom.RayResultList"/>
	<x path="Void"/>
</f></polysect2>
		<new public="1" set="method" line="237"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<zpp_pool public="1" line="181" static="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></zpp_pool>
		<less_xy public="1" set="method" line="237" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></less_xy>
		<swap_nodes public="1" set="method" line="240" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></swap_nodes>
		<get public="1" get="inline" set="null" line="246" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></get>
		<forced public="1"><x path="Bool"/></forced>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<links public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></links>
		<id public="1"><x path="Int"/></id>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></next>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></node>
		<free public="1" get="inline" set="null" line="208"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="215"><f a=""><x path="Void"/></f></alloc>
		<new set="method" line="216"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleSeg" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<zpp_pool public="1" line="295" static="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></zpp_pool>
		<get public="1" set="method" line="356" static="1"><f a="left:right">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></get>
		<left public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></left>
		<right public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></right>
		<vertices public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></vertices>
		<id public="1"><x path="Int"/></id>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></next>
		<free public="1" get="inline" set="null" line="321"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="329"><f a=""><x path="Void"/></f></alloc>
		<prev public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></prev>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></node>
		<less_xy public="1" set="method" line="332"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></less_xy>
		<new set="method" line="335"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleEvent" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<swap_nodes public="1" set="method" line="389" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></swap_nodes>
		<less_xy public="1" set="method" line="394" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></less_xy>
		<zpp_pool public="1" line="404" static="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></zpp_pool>
		<get public="1" get="inline" set="null" line="440" static="1"><f a="v">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></get>
		<type public="1"><x path="Int"/></type>
		<vertex public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></vertex>
		<segment public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></segment>
		<segment2 public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></segment2>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></node>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></next>
		<free public="1" get="inline" set="null" line="430"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="437"><f a=""><x path="Void"/></f></alloc>
		<new set="method" line="438"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleSweep" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<sweepx public="1"><x path="Float"/></sweepx>
		<tree public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></tree>
		<swap_nodes public="1" set="method" line="488"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></swap_nodes>
		<edge_lt public="1" set="method" line="493"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></edge_lt>
		<clear public="1" set="method" line="693"><f a=""><x path="Void"/></f></clear>
		<add public="1" set="method" line="696"><f a="e">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></add>
		<remove public="1" set="method" line="710"><f a="e">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></remove>
		<intersect public="1" set="method" line="718"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></intersect>
		<intersection public="1" set="method" line="736"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></intersection>
		<new public="1" set="method" line="467"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Simple" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<sweep line="788" static="1"><c path="zpp_nape.geom.ZPP_SimpleSweep"/></sweep>
		<inthash line="789" static="1"><c path="zpp_nape.util.FastHash2_Hashable2_Boolfalse"/></inthash>
		<vertices line="790" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></vertices>
		<queue line="791" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></queue>
		<ints line="792" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></ints>
		<decompose public="1" set="method" line="793" static="1"><f a="poly:?rets" v=":null">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
</f></decompose>
		<clip_polygon public="1" set="method" line="1791" static="1"><f a="vertices:rets">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<x path="Void"/>
</f></clip_polygon>
		<list_vertices line="2048" static="1"><c path="zpp_nape.util.ZNPList_ZPP_SimpleVert"/></list_vertices>
		<list_queue line="2049" static="1"><c path="zpp_nape.util.ZNPList_ZPP_SimpleEvent"/></list_queue>
		<isSimple public="1" set="method" line="2050" static="1"><f a="poly">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></isSimple>
	</class>
	<class path="zpp_nape.geom.ZPP_SimplifyV" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Simplify.hx" module="zpp_nape.geom.Simplify">
		<zpp_pool public="1" line="178" static="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></zpp_pool>
		<get public="1" get="inline" set="null" line="213" static="1"><f a="v">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
</f></get>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></next>
		<prev public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></prev>
		<flag public="1"><x path="Bool"/></flag>
		<forced public="1"><x path="Bool"/></forced>
		<free public="1" get="inline" set="null" line="207"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="210"><f a=""><x path="Void"/></f></alloc>
		<new public="1" set="method" line="211"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimplifyP" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Simplify.hx" module="zpp_nape.geom.Simplify">
		<zpp_pool public="1" line="259" static="1"><c path="zpp_nape.geom.ZPP_SimplifyP"/></zpp_pool>
		<get public="1" get="inline" set="null" line="295" static="1"><f a="min:max">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></get>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimplifyP"/></next>
		<min public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></min>
		<max public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></max>
		<free public="1" get="inline" set="null" line="288"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="293"><f a=""><x path="Void"/></f></alloc>
		<new public="1" set="method" line="285"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Simplify" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Simplify.hx" module="zpp_nape.geom.Simplify">
		<lessval public="1" get="inline" set="null" line="322" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<x path="Float"/>
</f></lessval>
		<less public="1" get="inline" set="null" line="326" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<x path="Bool"/>
</f></less>
		<distance public="1" set="method" line="329" static="1"><f a="v:a:b">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<x path="Float"/>
</f></distance>
		<stack line="366" static="1"><c path="zpp_nape.util.ZNPList_ZPP_SimplifyP"/></stack>
		<simplify public="1" set="method" line="367" static="1"><f a="P:epsilon">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></simplify>
	</class>
	<class path="zpp_nape.geom.ZPP_ToiEvent" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/SweepDistance.hx" module="zpp_nape.geom.SweepDistance">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.geom.ZPP_ToiEvent"/></zpp_pool>
		<next public="1"><c path="zpp_nape.geom.ZPP_ToiEvent"/></next>
		<alloc public="1" get="inline" set="null" line="202"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="209"><f a=""><x path="Void"/></f></free>
		<toi public="1"><x path="Float"/></toi>
		<s1 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s1>
		<s2 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s2>
		<arbiter public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></arbiter>
		<frozen1 public="1"><x path="Bool"/></frozen1>
		<frozen2 public="1"><x path="Bool"/></frozen2>
		<c1 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></c1>
		<c2 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></c2>
		<axis public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></axis>
		<slipped public="1"><x path="Bool"/></slipped>
		<failed public="1"><x path="Bool"/></failed>
		<kinematic public="1"><x path="Bool"/></kinematic>
		<new public="1" set="method" line="222"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SweepDistance" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/SweepDistance.hx" module="zpp_nape.geom.SweepDistance">
		<dynamicSweep public="1" set="method" line="230" static="1"><f a="toi:timeStep:lowerBound:negRadius:?userAPI" v="::::false">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></dynamicSweep>
		<staticSweep public="1" set="method" line="339" static="1"><f a="toi:timeStep:lowerBound:negRadius">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></staticSweep>
		<distanceBody public="1" set="method" line="475" static="1"><f a="b1:b2:w1:w2">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Float"/>
</f></distanceBody>
		<distance public="1" get="inline" set="null" line="647" static="1"><f a="s1:s2:w1:w2:axis:?upperBound" v=":::::1e100f">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
</f></distance>
	</class>
	<class path="zpp_nape.geom.ZPP_PartitionPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Triangular.hx" module="zpp_nape.geom.Triangular">
		<zpp_pool public="1" line="175" static="1"><c path="zpp_nape.geom.ZPP_PartitionPair"/></zpp_pool>
		<get public="1" get="inline" set="null" line="569" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></get>
		<edge_swap public="1" set="method" line="601" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></edge_swap>
		<edge_lt public="1" set="method" line="608" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></edge_lt>
		<next public="1"><c path="zpp_nape.geom.ZPP_PartitionPair"/></next>
		<elem public="1" get="inline" set="null" line="202"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></elem>
		<begin public="1" get="inline" set="null" line="207"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></begin>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="216"><f a="i">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="221"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="226"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></inlined_add>
		<addAll public="1" set="method" line="245"><f a="x">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="263"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="268"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></inlined_insert>
		<pop public="1" set="method" line="293"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="298"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="317"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="322"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="335"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="346"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="371"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="384"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="407"><f a="pre">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="412"><f a="pre">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></inlined_erase>
		<splice public="1" set="method" line="444"><f a="pre:n">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></splice>
		<clear public="1" set="method" line="448"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="453"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="459"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="474"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="479"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="482"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="487"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="517"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></front>
		<back public="1" set="method" line="520"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></back>
		<iterator_at public="1" set="method" line="529"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></iterator_at>
		<at public="1" set="method" line="542"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></at>
		<free public="1" get="inline" set="null" line="556"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="562"><f a=""><x path="Void"/></f></alloc>
		<a public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></a>
		<b public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></b>
		<id public="1"><x path="Int"/></id>
		<di public="1"><x path="Int"/></di>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></node>
		<new public="1" set="method" line="567"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Triangular" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Triangular.hx" module="zpp_nape.geom.Triangular">
		<lt get="inline" set="null" line="615" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></lt>
		<right_turn get="inline" set="null" line="619" static="1"><f a="a:b:c">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Float"/>
</f></right_turn>
		<queue line="634" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></queue>
		<stack line="635" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></stack>
		<delaunay public="1" set="method" line="636" static="1"><f a="A:B:C:D">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></delaunay>
		<edgeSet line="687" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></edgeSet>
		<optimise public="1" set="method" line="688" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></optimise>
		<triangulate public="1" set="method" line="887" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></triangulate>
	</class>
	<class path="zpp_nape.geom.ZPP_Vec2" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Vec2.hx" module="zpp_nape.geom.Vec2">
		<zpp_pool public="1" line="233" static="1"><c path="zpp_nape.geom.ZPP_Vec2"/></zpp_pool>
		<get public="1" get="inline" set="null" line="632" static="1"><f a="x:y:?immutable" v="::false">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></get>
		<_invalidate public="1"><t path="Null"><f a="">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></t></_invalidate>
		<_validate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_validate>
		<validate public="1" get="inline" set="null" line="179"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" get="inline" set="null" line="186"><f a=""><x path="Void"/></f></invalidate>
		<_immutable public="1"><x path="Bool"/></_immutable>
		<_isimmutable public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_isimmutable>
		<immutable public="1" get="inline" set="null" line="195"><f a=""><x path="Void"/></f></immutable>
		<outer public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></outer>
		<wrapper public="1" get="inline" set="null" line="208"><f a=""><c path="nape.geom.Vec2"/></f></wrapper>
		<weak public="1"><x path="Bool"/></weak>
		<free public="1" get="inline" set="null" line="259"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="270"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></next>
		<elem public="1" get="inline" set="null" line="276"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></elem>
		<begin public="1" get="inline" set="null" line="281"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></begin>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="290"><f a="i">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="295"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="300"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_add>
		<addAll public="1" set="method" line="319"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="337"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="342"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_insert>
		<pop public="1" set="method" line="367"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="372"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="391"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="396"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="409"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="420"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="445"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="458"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="481"><f a="pre">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="486"><f a="pre">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_erase>
		<splice public="1" set="method" line="518"><f a="pre:n">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></splice>
		<clear public="1" set="method" line="522"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="527"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="533"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="548"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="553"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="556"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="561"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="591"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></front>
		<back public="1" set="method" line="594"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></back>
		<iterator_at public="1" set="method" line="603"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></iterator_at>
		<at public="1" set="method" line="616"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></at>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<copy public="1" get="inline" set="null" line="676"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></copy>
		<toString public="1" set="method" line="679"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="630"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Vec3" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/Vec3.hx" module="zpp_nape.geom.Vec3">
		<outer public="1"><c path="nape.geom.Vec3"/></outer>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<immutable public="1"><x path="Bool"/></immutable>
		<_validate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_validate>
		<validate public="1" get="inline" set="null" line="183"><f a=""><x path="Void"/></f></validate>
		<new public="1" set="method" line="188"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_VecMath" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/geom/VecMath.hx" module="zpp_nape.geom.VecMath">
		<vec_dsq public="1" get="inline" set="null" line="176" static="1"><f a="ax:ay:bx:by">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></vec_dsq>
		<vec_distance public="1" get="inline" set="null" line="186" static="1"><f a="ax:ay:bx:by">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></vec_distance>
	</class>
	<class path="zpp_nape.phys.ZPP_Interactor" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/phys/Interactor.hx" module="zpp_nape.phys.Interactor">
		<get public="1" set="method" line="235" static="1"><f a="i1:i2">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></get>
		<int_callback public="1" get="inline" set="null" line="426" static="1"><f a="set:x:cb">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<x path="Void"/>
</f></int_callback>
		<outer_i public="1"><c path="nape.phys.Interactor"/></outer_i>
		<id public="1"><x path="Int"/></id>
		<userData public="1"><d><d/></d></userData>
		<ishape public="1"><c path="zpp_nape.shape.ZPP_Shape"/></ishape>
		<ibody public="1"><c path="zpp_nape.phys.ZPP_Body"/></ibody>
		<icompound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></icompound>
		<isShape public="1" get="inline" set="null" line="183"><f a=""><x path="Bool"/></f></isShape>
		<isBody public="1" get="inline" set="null" line="188"><f a=""><x path="Bool"/></f></isBody>
		<isCompound public="1" get="inline" set="null" line="193"><f a=""><x path="Bool"/></f></isCompound>
		<__iaddedToSpace public="1" set="method" line="196"><f a=""><x path="Void"/></f></__iaddedToSpace>
		<__iremovedFromSpace public="1" set="method" line="208"><f a=""><x path="Void"/></f></__iremovedFromSpace>
		<wake public="1" set="method" line="220"><f a=""><x path="Void"/></f></wake>
		<cbsets public="1"><c path="zpp_nape.util.ZNPList_ZPP_CallbackSet"/></cbsets>
		<getSpace public="1" get="inline" set="null" line="281"><f a=""><t path="Null"><c path="zpp_nape.space.ZPP_Space"/></t></f></getSpace>
		<group public="1"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></group>
		<cbTypes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></cbTypes>
		<cbSet public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></cbSet>
		<wrap_cbTypes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_cbTypes>
		<setupcbTypes public="1" set="method" line="288"><f a=""><x path="Void"/></f></setupcbTypes>
		<immutable_cbTypes set="method" line="298"><f a=""><x path="Void"/></f></immutable_cbTypes>
		<wrap_cbTypes_subber set="method" line="302"><f a="pcb">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></wrap_cbTypes_subber>
		<wrap_cbTypes_adder set="method" line="317"><f a="cb">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></wrap_cbTypes_adder>
		<insert_cbtype public="1" set="method" line="321"><f a="cb">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></insert_cbtype>
		<alloc_cbSet public="1" set="method" line="349"><f a=""><x path="Void"/></f></alloc_cbSet>
		<dealloc_cbSet public="1" set="method" line="366"><f a=""><x path="Void"/></f></dealloc_cbSet>
		<setGroup public="1" set="method" line="402"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></setGroup>
		<immutable_midstep public="1" set="method" line="415"><f a="n">
	<c path="String"/>
	<x path="Void"/>
</f></immutable_midstep>
		<lookup_group public="1" get="inline" set="null" line="440"><f a=""><t path="Null"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></t></f></lookup_group>
		<copyto public="1" set="method" line="449"><f a="ret">
	<c path="nape.phys.Interactor"/>
	<x path="Void"/>
</f></copyto>
		<new public="1" set="method" line="420"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_Body" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/phys/Body.hx" module="zpp_nape.phys.Body">
		<extends path="zpp_nape.phys.ZPP_Interactor"/>
		<types public="1" line="193" static="1"><c path="Array"><c path="nape.phys.BodyType"/></c></types>
		<bodystack line="213" static="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></bodystack>
		<bodyset line="214" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></bodyset>
		<bodysetlt set="method" line="215" static="1"><f a="a:b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></bodysetlt>
		<cur_graph_depth line="243" static="1"><x path="Int"/></cur_graph_depth>
		<__static public="1" set="method" line="1376" static="1"><f a=""><c path="nape.phys.Body"/></f></__static>
		<outer public="1"><c path="nape.phys.Body"/></outer>
		<world public="1"><x path="Bool"/></world>
		<type public="1"><x path="Int"/></type>
		<isStatic public="1" get="inline" set="null" line="180"><f a=""><x path="Bool"/></f></isStatic>
		<isDynamic public="1" get="inline" set="null" line="185"><f a=""><x path="Bool"/></f></isDynamic>
		<isKinematic public="1" get="inline" set="null" line="190"><f a=""><x path="Bool"/></f></isKinematic>
		<invalidate_type public="1" set="method" line="194"><f a=""><x path="Void"/></f></invalidate_type>
		<compound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></compound>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<invalidate_shapes public="1" set="method" line="201"><f a=""><x path="Void"/></f></invalidate_shapes>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/></arbiters>
		<wrap_arbiters public="1"><c path="nape.dynamics.ArbiterList"/></wrap_arbiters>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<component public="1"><c path="zpp_nape.space.ZPP_Component"/></component>
		<graph_depth public="1"><x path="Int"/></graph_depth>
		<init_bodysetlist get="inline" set="null" line="220"><f a=""><x path="Void"/></f></init_bodysetlist>
		<connectedBodies_cont set="method" line="244"><f a="b">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></connectedBodies_cont>
		<connectedBodies public="1" set="method" line="250"><f a="depth:output">
	<x path="Int"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></connectedBodies>
		<interactingBodies public="1" set="method" line="274"><f a="arbiter_type:depth:output">
	<x path="Int"/>
	<x path="Int"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></interactingBodies>
		<atRest public="1" set="method" line="305"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></atRest>
		<refreshArbiters public="1" set="method" line="330"><f a=""><x path="Void"/></f></refreshArbiters>
		<sweepTime public="1"><x path="Float"/></sweepTime>
		<sweep_angvel public="1"><x path="Float"/></sweep_angvel>
		<sweepFrozen public="1"><x path="Bool"/></sweepFrozen>
		<sweepRadius public="1"><x path="Float"/></sweepRadius>
		<bullet public="1"><x path="Bool"/></bullet>
		<bulletEnabled public="1"><x path="Bool"/></bulletEnabled>
		<disableCCD public="1"><x path="Bool"/></disableCCD>
		<sweepIntegrate public="1" get="inline" set="null" line="349"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></sweepIntegrate>
		<sweepValidate public="1" get="inline" set="null" line="379"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></sweepValidate>
		<pre_posx public="1"><x path="Float"/></pre_posx>
		<pre_posy public="1"><x path="Float"/></pre_posy>
		<posx public="1"><x path="Float"/></posx>
		<posy public="1"><x path="Float"/></posy>
		<wrap_pos public="1"><c path="nape.geom.Vec2"/></wrap_pos>
		<velx public="1"><x path="Float"/></velx>
		<vely public="1"><x path="Float"/></vely>
		<wrap_vel public="1"><c path="nape.geom.Vec2"/></wrap_vel>
		<forcex public="1"><x path="Float"/></forcex>
		<forcey public="1"><x path="Float"/></forcey>
		<wrap_force public="1"><c path="nape.geom.Vec2"/></wrap_force>
		<kinvelx public="1"><x path="Float"/></kinvelx>
		<kinvely public="1"><x path="Float"/></kinvely>
		<wrap_kinvel public="1"><c path="nape.geom.Vec2"/></wrap_kinvel>
		<svelx public="1"><x path="Float"/></svelx>
		<svely public="1"><x path="Float"/></svely>
		<wrap_svel public="1"><c path="nape.geom.Vec2"/></wrap_svel>
		<invalidate_pos public="1" get="inline" set="null" line="467"><f a=""><x path="Void"/></f></invalidate_pos>
		<pos_invalidate set="method" line="484"><f a="pos">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></pos_invalidate>
		<pos_validate set="method" line="514"><f a=""><x path="Void"/></f></pos_validate>
		<vel_invalidate set="method" line="536"><f a="vel">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></vel_invalidate>
		<vel_validate set="method" line="562"><f a=""><x path="Void"/></f></vel_validate>
		<kinvel_invalidate set="method" line="584"><f a="vel">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></kinvel_invalidate>
		<kinvel_validate set="method" line="607"><f a=""><x path="Void"/></f></kinvel_validate>
		<svel_invalidate set="method" line="629"><f a="vel">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></svel_invalidate>
		<svel_validate set="method" line="652"><f a=""><x path="Void"/></f></svel_validate>
		<force_invalidate set="method" line="674"><f a="force">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></force_invalidate>
		<force_validate set="method" line="700"><f a=""><x path="Void"/></f></force_validate>
		<setupPosition public="1" set="method" line="720"><f a=""><x path="Void"/></f></setupPosition>
		<setupVelocity public="1" set="method" line="729"><f a=""><x path="Void"/></f></setupVelocity>
		<setupkinvel public="1" set="method" line="738"><f a=""><x path="Void"/></f></setupkinvel>
		<setupsvel public="1" set="method" line="747"><f a=""><x path="Void"/></f></setupsvel>
		<setupForce public="1" set="method" line="756"><f a=""><x path="Void"/></f></setupForce>
		<cvel_validate set="method" line="765"><f a=""><x path="Void"/></f></cvel_validate>
		<wrapcvel public="1"><c path="nape.geom.Vec3"/></wrapcvel>
		<setup_cvel public="1" set="method" line="771"><f a=""><x path="Void"/></f></setup_cvel>
		<angvel public="1"><x path="Float"/></angvel>
		<torque public="1"><x path="Float"/></torque>
		<kinangvel public="1"><x path="Float"/></kinangvel>
		<pre_rot public="1"><x path="Float"/></pre_rot>
		<rot public="1"><x path="Float"/></rot>
		<invalidate_rot public="1" get="inline" set="null" line="784"><f a=""><x path="Void"/></f></invalidate_rot>
		<axisx public="1"><x path="Float"/></axisx>
		<axisy public="1"><x path="Float"/></axisy>
		<zip_axis public="1"><x path="Bool"/></zip_axis>
		<validate_axis public="1" get="inline" set="null" line="806"><f a=""><x path="Void"/></f></validate_axis>
		<quick_validate_axis public="1" get="inline" set="null" line="814"><f a=""><x path="Void"/></f></quick_validate_axis>
		<delta_rot public="1" get="inline" set="null" line="838"><f a="dr">
	<x path="Float"/>
	<x path="Void"/>
</f></delta_rot>
		<kinematicDelaySleep public="1"><x path="Bool"/></kinematicDelaySleep>
		<mass public="1"><x path="Float"/></mass>
		<zip_mass public="1"><x path="Bool"/></zip_mass>
		<massMode public="1"><x path="Int"/></massMode>
		<imass public="1"><x path="Float"/></imass>
		<smass public="1"><x path="Float"/></smass>
		<cmass public="1"><x path="Float"/></cmass>
		<nomove public="1"><x path="Bool"/></nomove>
		<invalidate_mass public="1" set="method" line="858"><f a=""><x path="Void"/></f></invalidate_mass>
		<validate_mass public="1" set="method" line="862"><f a=""><x path="Void"/></f></validate_mass>
		<gravMass public="1"><x path="Float"/></gravMass>
		<zip_gravMass public="1"><x path="Bool"/></zip_gravMass>
		<gravMassMode public="1"><x path="Int"/></gravMassMode>
		<gravMassScale public="1"><x path="Float"/></gravMassScale>
		<zip_gravMassScale public="1"><x path="Bool"/></zip_gravMassScale>
		<invalidate_gravMass public="1" set="method" line="897"><f a=""><x path="Void"/></f></invalidate_gravMass>
		<validate_gravMass public="1" set="method" line="902"><f a=""><x path="Void"/></f></validate_gravMass>
		<invalidate_gravMassScale public="1" set="method" line="916"><f a=""><x path="Void"/></f></invalidate_gravMassScale>
		<validate_gravMassScale public="1" set="method" line="920"><f a=""><x path="Void"/></f></validate_gravMassScale>
		<inertiaMode public="1"><x path="Int"/></inertiaMode>
		<inertia public="1"><x path="Float"/></inertia>
		<zip_inertia public="1"><x path="Bool"/></zip_inertia>
		<cinertia public="1"><x path="Float"/></cinertia>
		<iinertia public="1"><x path="Float"/></iinertia>
		<sinertia public="1"><x path="Float"/></sinertia>
		<norotate public="1"><x path="Bool"/></norotate>
		<invalidate_inertia public="1" set="method" line="937"><f a=""><x path="Void"/></f></invalidate_inertia>
		<validate_inertia public="1" set="method" line="941"><f a=""><x path="Void"/></f></validate_inertia>
		<invalidate_wake public="1" get="inline" set="null" line="973"><f a=""><x path="Void"/></f></invalidate_wake>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<zip_aabb public="1"><x path="Bool"/></zip_aabb>
		<validate_aabb public="1" get="inline" set="null" line="979"><f a=""><x path="Void"/></f></validate_aabb>
		<invalidate_aabb public="1" get="inline" set="null" line="1040"><f a=""><x path="Void"/></f></invalidate_aabb>
		<localCOMx public="1"><x path="Float"/></localCOMx>
		<localCOMy public="1"><x path="Float"/></localCOMy>
		<zip_localCOM public="1"><x path="Bool"/></zip_localCOM>
		<worldCOMx public="1"><x path="Float"/></worldCOMx>
		<worldCOMy public="1"><x path="Float"/></worldCOMy>
		<zip_worldCOM public="1"><x path="Bool"/></zip_worldCOM>
		<wrap_localCOM public="1"><c path="nape.geom.Vec2"/></wrap_localCOM>
		<wrap_worldCOM public="1"><c path="nape.geom.Vec2"/></wrap_worldCOM>
		<invalidate_localCOM public="1" get="inline" set="null" line="1053"><f a=""><x path="Void"/></f></invalidate_localCOM>
		<invalidate_worldCOM public="1" get="inline" set="null" line="1059"><f a=""><x path="Void"/></f></invalidate_worldCOM>
		<validate_localCOM public="1" set="method" line="1062"><f a=""><x path="Void"/></f></validate_localCOM>
		<validate_worldCOM public="1" set="method" line="1158"><f a=""><x path="Void"/></f></validate_worldCOM>
		<getlocalCOM public="1" set="method" line="1189"><f a=""><x path="Void"/></f></getlocalCOM>
		<getworldCOM public="1" set="method" line="1195"><f a=""><x path="Void"/></f></getworldCOM>
		<__immutable_midstep public="1" get="inline" set="null" line="1203"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></__immutable_midstep>
		<clear public="1" set="method" line="1208"><f a=""><x path="Void"/></f></clear>
		<aabb_validate set="method" line="1386"><f a=""><x path="Void"/></f></aabb_validate>
		<shapes_adder set="method" line="1392"><f a="s">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></shapes_adder>
		<shapes_subber set="method" line="1406"><f a="s">
	<c path="nape.shape.Shape"/>
	<x path="Void"/>
</f></shapes_subber>
		<shapes_invalidate set="method" line="1411"><f a="_">
	<c path="zpp_nape.util.ZPP_ShapeList"/>
	<x path="Void"/>
</f></shapes_invalidate>
		<shapes_modifiable set="method" line="1415"><f a=""><x path="Void"/></f></shapes_modifiable>
		<addedToSpace public="1" set="method" line="1633"><f a=""><x path="Void"/></f></addedToSpace>
		<removedFromSpace public="1" set="method" line="1663"><f a=""><x path="Void"/></f></removedFromSpace>
		<copy public="1" set="method" line="1688"><f a=""><c path="nape.phys.Body"/></f></copy>
		<new public="1" set="method" line="1420"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_Compound" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/phys/Compound.hx" module="zpp_nape.phys.Compound">
		<extends path="zpp_nape.phys.ZPP_Interactor"/>
		<outer public="1"><c path="nape.phys.Compound"/></outer>
		<bodies public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></bodies>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<compounds public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></compounds>
		<wrap_bodies public="1"><c path="nape.phys.BodyList"/></wrap_bodies>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<wrap_compounds public="1"><c path="nape.phys.CompoundList"/></wrap_compounds>
		<depth public="1"><x path="Int"/></depth>
		<compound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></compound>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<__imutable_midstep public="1" set="method" line="185"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></__imutable_midstep>
		<addedToSpace public="1" set="method" line="190"><f a=""><x path="Void"/></f></addedToSpace>
		<removedFromSpace public="1" set="method" line="193"><f a=""><x path="Void"/></f></removedFromSpace>
		<breakApart public="1" set="method" line="196"><f a=""><x path="Void"/></f></breakApart>
		<bodies_adder set="method" line="236"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></bodies_adder>
		<bodies_subber set="method" line="248"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></bodies_subber>
		<bodies_modifiable set="method" line="254"><f a=""><x path="Void"/></f></bodies_modifiable>
		<constraints_adder set="method" line="258"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></constraints_adder>
		<constraints_subber set="method" line="270"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></constraints_subber>
		<constraints_modifiable set="method" line="276"><f a=""><x path="Void"/></f></constraints_modifiable>
		<compounds_adder set="method" line="280"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></compounds_adder>
		<compounds_subber set="method" line="299"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></compounds_subber>
		<compounds_modifiable set="method" line="305"><f a=""><x path="Void"/></f></compounds_modifiable>
		<copy public="1" set="method" line="336"><f a="?dict:?todo" v="null:null">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.phys.Compound"/>
</f></copy>
		<new public="1" set="method" line="309"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_FluidProperties" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/phys/FluidProperties.hx" module="zpp_nape.phys.FluidProperties">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.phys.ZPP_FluidProperties"/></zpp_pool>
		<next public="1"><c path="zpp_nape.phys.ZPP_FluidProperties"/></next>
		<userData public="1"><d><d/></d></userData>
		<outer public="1"><c path="nape.phys.FluidProperties"/></outer>
		<wrapper public="1" set="method" line="202"><f a=""><c path="nape.phys.FluidProperties"/></f></wrapper>
		<free public="1" get="inline" set="null" line="228"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></alloc>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<feature_cons public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></feature_cons>
		<addShape public="1" get="inline" set="null" line="243"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></addShape>
		<remShape public="1" get="inline" set="null" line="248"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remShape>
		<copy public="1" set="method" line="251"><f a=""><c path="zpp_nape.phys.ZPP_FluidProperties"/></f></copy>
		<viscosity public="1"><x path="Float"/></viscosity>
		<density public="1"><x path="Float"/></density>
		<gravityx public="1"><x path="Float"/></gravityx>
		<gravityy public="1"><x path="Float"/></gravityy>
		<wrap_gravity public="1"><c path="nape.geom.Vec2"/></wrap_gravity>
		<gravity_invalidate set="method" line="304"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></gravity_invalidate>
		<gravity_validate set="method" line="327"><f a=""><x path="Void"/></f></gravity_validate>
		<getgravity public="1" set="method" line="349"><f a=""><x path="Void"/></f></getgravity>
		<invalidate public="1" set="method" line="355"><f a=""><x path="Void"/></f></invalidate>
		<new public="1" set="method" line="274"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_Material" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/phys/Material.hx" module="zpp_nape.phys.Material">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.phys.ZPP_Material"/></zpp_pool>
		<WAKE public="1" line="280" static="1"><x path="Int"/></WAKE>
		<PROPS public="1" line="281" static="1"><x path="Int"/></PROPS>
		<ANGDRAG public="1" line="282" static="1"><x path="Int"/></ANGDRAG>
		<ARBITERS public="1" line="283" static="1"><x path="Int"/></ARBITERS>
		<next public="1"><c path="zpp_nape.phys.ZPP_Material"/></next>
		<userData public="1"><d><d/></d></userData>
		<outer public="1"><c path="nape.phys.Material"/></outer>
		<wrapper public="1" set="method" line="202"><f a=""><c path="nape.phys.Material"/></f></wrapper>
		<free public="1" get="inline" set="null" line="228"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></alloc>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<feature_cons public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></feature_cons>
		<addShape public="1" get="inline" set="null" line="243"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></addShape>
		<remShape public="1" get="inline" set="null" line="248"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remShape>
		<dynamicFriction public="1"><x path="Float"/></dynamicFriction>
		<staticFriction public="1"><x path="Float"/></staticFriction>
		<density public="1"><x path="Float"/></density>
		<elasticity public="1"><x path="Float"/></elasticity>
		<rollingFriction public="1"><x path="Float"/></rollingFriction>
		<copy public="1" set="method" line="264"><f a=""><c path="zpp_nape.phys.ZPP_Material"/></f></copy>
		<set public="1" set="method" line="273"><f a="x">
	<c path="zpp_nape.phys.ZPP_Material"/>
	<x path="Void"/>
</f></set>
		<invalidate public="1" set="method" line="284"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidate>
		<new public="1" set="method" line="256"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Shape" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/shape/Shape.hx" module="zpp_nape.shape.Shape">
		<extends path="zpp_nape.phys.ZPP_Interactor"/>
		<types public="1" line="178" static="1"><c path="Array"><c path="nape.shape.ShapeType"/></c></types>
		<outer public="1"><c path="nape.shape.Shape"/></outer>
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<type public="1"><x path="Int"/></type>
		<isCircle public="1" get="inline" set="null" line="180"><f a=""><x path="Bool"/></f></isCircle>
		<isPolygon public="1" get="inline" set="null" line="184"><f a=""><x path="Bool"/></f></isPolygon>
		<area public="1"><x path="Float"/></area>
		<zip_area_inertia public="1"><x path="Bool"/></zip_area_inertia>
		<inertia public="1"><x path="Float"/></inertia>
		<angDrag public="1"><x path="Float"/></angDrag>
		<zip_angDrag public="1"><x path="Bool"/></zip_angDrag>
		<localCOMx public="1"><x path="Float"/></localCOMx>
		<localCOMy public="1"><x path="Float"/></localCOMy>
		<zip_localCOM public="1"><x path="Bool"/></zip_localCOM>
		<worldCOMx public="1"><x path="Float"/></worldCOMx>
		<worldCOMy public="1"><x path="Float"/></worldCOMy>
		<zip_worldCOM public="1"><x path="Bool"/></zip_worldCOM>
		<wrap_localCOM public="1"><c path="nape.geom.Vec2"/></wrap_localCOM>
		<wrap_worldCOM public="1"><c path="nape.geom.Vec2"/></wrap_worldCOM>
		<sweepRadius public="1"><x path="Float"/></sweepRadius>
		<zip_sweepRadius public="1"><x path="Bool"/></zip_sweepRadius>
		<sweepCoef public="1"><x path="Float"/></sweepCoef>
		<invalidate_sweepRadius public="1" get="inline" set="null" line="205"><f a=""><x path="Void"/></f></invalidate_sweepRadius>
		<validate_sweepRadius public="1" set="method" line="208"><f a=""><x path="Void"/></f></validate_sweepRadius>
		<circle public="1"><c path="zpp_nape.shape.ZPP_Circle"/></circle>
		<polygon public="1"><c path="zpp_nape.shape.ZPP_Polygon"/></polygon>
		<refmaterial public="1"><c path="zpp_nape.phys.ZPP_Material"/></refmaterial>
		<material public="1"><c path="zpp_nape.phys.ZPP_Material"/></material>
		<filter public="1"><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></filter>
		<fluidProperties public="1"><c path="zpp_nape.phys.ZPP_FluidProperties"/></fluidProperties>
		<fluidEnabled public="1"><x path="Bool"/></fluidEnabled>
		<sensorEnabled public="1"><x path="Bool"/></sensorEnabled>
		<sweep public="1"><c path="zpp_nape.space.ZPP_SweepData"/></sweep>
		<node public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></node>
		<pairs public="1"><c path="zpp_nape.util.ZNPList_ZPP_AABBPair"/></pairs>
		<clear public="1" set="method" line="226"><f a=""><x path="Void"/></f></clear>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<zip_aabb public="1"><x path="Bool"/></zip_aabb>
		<validate_aabb public="1" get="inline" set="null" line="234"><f a=""><x path="Void"/></f></validate_aabb>
		<force_validate_aabb public="1" get="inline" set="null" line="245"><f a=""><x path="Void"/></f></force_validate_aabb>
		<invalidate_aabb public="1" get="inline" set="null" line="251"><f a=""><x path="Void"/></f></invalidate_aabb>
		<validate_area_inertia public="1" set="method" line="255"><f a=""><x path="Void"/></f></validate_area_inertia>
		<validate_angDrag public="1" set="method" line="262"><f a=""><x path="Void"/></f></validate_angDrag>
		<validate_localCOM public="1" get="inline" set="null" line="272"><f a=""><x path="Void"/></f></validate_localCOM>
		<validate_worldCOM public="1" get="inline" set="null" line="300"><f a=""><x path="Void"/></f></validate_worldCOM>
		<getworldCOM public="1" set="method" line="313"><f a=""><x path="Void"/></f></getworldCOM>
		<invalidate_area_inertia public="1" set="method" line="339"><f a=""><x path="Void"/></f></invalidate_area_inertia>
		<invalidate_angDrag public="1" set="method" line="347"><f a=""><x path="Void"/></f></invalidate_angDrag>
		<invalidate_localCOM public="1" set="method" line="350"><f a=""><x path="Void"/></f></invalidate_localCOM>
		<invalidate_worldCOM public="1" set="method" line="358"><f a=""><x path="Void"/></f></invalidate_worldCOM>
		<invalidate_material public="1" set="method" line="362"><f a="flags">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidate_material>
		<invalidate_filter public="1" set="method" line="379"><f a=""><x path="Void"/></f></invalidate_filter>
		<invalidate_fluidprops public="1" set="method" line="382"><f a=""><x path="Void"/></f></invalidate_fluidprops>
		<aabb_validate set="method" line="385"><f a=""><x path="Void"/></f></aabb_validate>
		<setMaterial public="1" set="method" line="448"><f a="material">
	<c path="zpp_nape.phys.ZPP_Material"/>
	<x path="Void"/>
</f></setMaterial>
		<setFilter public="1" set="method" line="459"><f a="filter">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Void"/>
</f></setFilter>
		<setFluid public="1" set="method" line="469"><f a="fluid">
	<c path="zpp_nape.phys.ZPP_FluidProperties"/>
	<x path="Void"/>
</f></setFluid>
		<__immutable_midstep public="1" set="method" line="479"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></__immutable_midstep>
		<addedToBody public="1" set="method" line="484"><f a=""><x path="Void"/></f></addedToBody>
		<removedFromBody public="1" set="method" line="488"><f a=""><x path="Void"/></f></removedFromBody>
		<addedToSpace public="1" set="method" line="489"><f a=""><x path="Void"/></f></addedToSpace>
		<removedFromSpace public="1" set="method" line="495"><f a=""><x path="Void"/></f></removedFromSpace>
		<copy public="1" set="method" line="501"><f a=""><c path="nape.shape.Shape"/></f></copy>
		<new set="method" line="391"><f a="type">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Circle" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/shape/Circle.hx" module="zpp_nape.shape.Circle">
		<extends path="zpp_nape.shape.ZPP_Shape"/>
		<outer_zn public="1"><c path="nape.shape.Circle"/></outer_zn>
		<radius public="1"><x path="Float"/></radius>
		<__clear public="1" set="method" line="182"><f a=""><x path="Void"/></f></__clear>
		<invalidate_radius public="1" set="method" line="183"><f a=""><x path="Void"/></f></invalidate_radius>
		<localCOM_validate set="method" line="189"><f a=""><x path="Void"/></f></localCOM_validate>
		<localCOM_invalidate set="method" line="209"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></localCOM_invalidate>
		<localCOM_immutable set="method" line="234"><f a=""><x path="Void"/></f></localCOM_immutable>
		<setupLocalCOM public="1" set="method" line="238"><f a=""><x path="Void"/></f></setupLocalCOM>
		<__validate_aabb public="1" get="inline" set="null" line="250"><f a=""><x path="Void"/></f></__validate_aabb>
		<_force_validate_aabb public="1" get="inline" set="null" line="281"><f a=""><x path="Void"/></f></_force_validate_aabb>
		<__validate_sweepRadius public="1" set="method" line="291"><f a=""><x path="Void"/></f></__validate_sweepRadius>
		<__validate_area_inertia public="1" set="method" line="295"><f a=""><x path="Void"/></f></__validate_area_inertia>
		<__validate_angDrag public="1" set="method" line="300"><f a=""><x path="Void"/></f></__validate_angDrag>
		<__scale public="1" set="method" line="307"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__scale>
		<__translate public="1" set="method" line="317"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__translate>
		<__rotate public="1" set="method" line="333"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__rotate>
		<__transform public="1" set="method" line="364"><f a="m">
	<c path="nape.geom.Mat23"/>
	<x path="Void"/>
</f></__transform>
		<__copy public="1" set="method" line="376"><f a=""><c path="zpp_nape.shape.ZPP_Circle"/></f></__copy>
		<new public="1" set="method" line="177"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Edge" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/shape/Edge.hx" module="zpp_nape.shape.Edge">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.shape.ZPP_Edge"/></zpp_pool>
		<internal public="1" line="209" static="1"><x path="Bool"/></internal>
		<next public="1"><c path="zpp_nape.shape.ZPP_Edge"/></next>
		<free public="1" get="inline" set="null" line="202"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="207"><f a=""><x path="Void"/></f></alloc>
		<polygon public="1"><c path="zpp_nape.shape.ZPP_Polygon"/></polygon>
		<outer public="1"><c path="nape.shape.Edge"/></outer>
		<wrapper public="1" set="method" line="211"><f a=""><c path="nape.shape.Edge"/></f></wrapper>
		<lnormx public="1"><x path="Float"/></lnormx>
		<lnormy public="1"><x path="Float"/></lnormy>
		<wrap_lnorm public="1"><c path="nape.geom.Vec2"/></wrap_lnorm>
		<gnormx public="1"><x path="Float"/></gnormx>
		<gnormy public="1"><x path="Float"/></gnormy>
		<wrap_gnorm public="1"><c path="nape.geom.Vec2"/></wrap_gnorm>
		<length public="1"><x path="Float"/></length>
		<lprojection public="1"><x path="Float"/></lprojection>
		<gprojection public="1"><x path="Float"/></gprojection>
		<lp0 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></lp0>
		<gp0 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></gp0>
		<lp1 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></lp1>
		<gp1 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></gp1>
		<tp0 public="1"><x path="Float"/></tp0>
		<tp1 public="1"><x path="Float"/></tp1>
		<lnorm_validate set="method" line="235"><f a=""><x path="Void"/></f></lnorm_validate>
		<gnorm_validate set="method" line="261"><f a=""><x path="Void"/></f></gnorm_validate>
		<getlnorm public="1" set="method" line="288"><f a=""><x path="Void"/></f></getlnorm>
		<getgnorm public="1" set="method" line="293"><f a=""><x path="Void"/></f></getgnorm>
		<new public="1" set="method" line="298"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Polygon" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/shape/Polygon.hx" module="zpp_nape.shape.Polygon">
		<extends path="zpp_nape.shape.ZPP_Shape"/>
		<outer_zn public="1"><c path="nape.shape.Polygon"/></outer_zn>
		<lverts public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></lverts>
		<wrap_lverts public="1"><c path="nape.geom.Vec2List"/></wrap_lverts>
		<gverts public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></gverts>
		<wrap_gverts public="1"><c path="nape.geom.Vec2List"/></wrap_gverts>
		<edges public="1"><c path="zpp_nape.util.ZNPList_ZPP_Edge"/></edges>
		<wrap_edges public="1"><c path="nape.shape.EdgeList"/></wrap_edges>
		<edgeCnt public="1"><x path="Int"/></edgeCnt>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<__clear public="1" set="method" line="184"><f a=""><x path="Void"/></f></__clear>
		<lverts_pa_invalidate set="method" line="185"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></lverts_pa_invalidate>
		<lverts_pa_immutable set="method" line="189"><f a=""><x path="Void"/></f></lverts_pa_immutable>
		<gverts_pa_validate set="method" line="193"><f a=""><x path="Void"/></f></gverts_pa_validate>
		<lverts_post_adder set="method" line="199"><f a="x">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></lverts_post_adder>
		<lverts_subber set="method" line="292"><f a="x">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></lverts_subber>
		<lverts_invalidate set="method" line="295"><f a="_">
	<c path="zpp_nape.util.ZPP_Vec2List"/>
	<x path="Void"/>
</f></lverts_invalidate>
		<lverts_validate set="method" line="298"><f a=""><x path="Void"/></f></lverts_validate>
		<lverts_modifiable set="method" line="302"><f a=""><x path="Void"/></f></lverts_modifiable>
		<gverts_validate set="method" line="309"><f a=""><x path="Void"/></f></gverts_validate>
		<edges_validate set="method" line="312"><f a=""><x path="Void"/></f></edges_validate>
		<getlverts public="1" set="method" line="316"><f a=""><x path="Void"/></f></getlverts>
		<getgverts public="1" set="method" line="328"><f a=""><x path="Void"/></f></getgverts>
		<getedges public="1" set="method" line="334"><f a=""><x path="Void"/></f></getedges>
		<zip_lverts public="1"><x path="Bool"/></zip_lverts>
		<invalidate_lverts public="1" set="method" line="341"><f a=""><x path="Void"/></f></invalidate_lverts>
		<zip_laxi public="1"><x path="Bool"/></zip_laxi>
		<invalidate_laxi public="1" set="method" line="353"><f a=""><x path="Void"/></f></invalidate_laxi>
		<zip_gverts public="1"><x path="Bool"/></zip_gverts>
		<invalidate_gverts public="1" set="method" line="359"><f a=""><x path="Void"/></f></invalidate_gverts>
		<zip_gaxi public="1"><x path="Bool"/></zip_gaxi>
		<invalidate_gaxi public="1" set="method" line="364"><f a=""><x path="Void"/></f></invalidate_gaxi>
		<zip_valid public="1"><x path="Bool"/></zip_valid>
		<validation public="1"><c path="nape.shape.ValidationResult"/></validation>
		<valid public="1" set="method" line="369"><f a=""><c path="nape.shape.ValidationResult"/></f></valid>
		<validate_lverts public="1" set="method" line="702"><f a=""><x path="Void"/></f></validate_lverts>
		<cleanup_lvert public="1" set="method" line="714"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></cleanup_lvert>
		<zip_sanitation public="1"><x path="Bool"/></zip_sanitation>
		<splice_collinear public="1" get="inline" set="null" line="815"><f a=""><x path="Void"/></f></splice_collinear>
		<splice_collinear_real public="1" set="method" line="821"><f a=""><x path="Void"/></f></splice_collinear_real>
		<reverse_vertices public="1" set="method" line="877"><f a=""><x path="Void"/></f></reverse_vertices>
		<validate_laxi public="1" set="method" line="889"><f a=""><x path="Void"/></f></validate_laxi>
		<validate_gverts public="1" get="inline" set="null" line="1055"><f a=""><x path="Void"/></f></validate_gverts>
		<validate_gaxi public="1" get="inline" set="null" line="1081"><f a=""><x path="Void"/></f></validate_gaxi>
		<__validate_aabb public="1" get="inline" set="null" line="1171"><f a=""><x path="Void"/></f></__validate_aabb>
		<_force_validate_aabb public="1" get="inline" set="null" line="1233"><f a=""><x path="Void"/></f></_force_validate_aabb>
		<__validate_sweepRadius public="1" set="method" line="1302"><f a=""><x path="Void"/></f></__validate_sweepRadius>
		<__validate_area_inertia public="1" set="method" line="1336"><f a=""><x path="Void"/></f></__validate_area_inertia>
		<__validate_angDrag public="1" set="method" line="1393"><f a=""><x path="Void"/></f></__validate_angDrag>
		<__validate_localCOM public="1" get="inline" set="null" line="1621"><f a=""><x path="Void"/></f></__validate_localCOM>
		<localCOM_validate set="method" line="1768"><f a=""><x path="Void"/></f></localCOM_validate>
		<localCOM_invalidate set="method" line="1774"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></localCOM_invalidate>
		<setupLocalCOM public="1" set="method" line="1820"><f a=""><x path="Void"/></f></setupLocalCOM>
		<__translate public="1" set="method" line="1834"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__translate>
		<__scale public="1" set="method" line="1857"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__scale>
		<__rotate public="1" set="method" line="1871"><f a="ax:ay">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__rotate>
		<__transform public="1" set="method" line="1909"><f a="mat">
	<c path="nape.geom.Mat23"/>
	<x path="Void"/>
</f></__transform>
		<__copy public="1" set="method" line="1926"><f a=""><c path="zpp_nape.shape.ZPP_Polygon"/></f></__copy>
		<new public="1" set="method" line="1826"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Broadphase" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/Broadphase.hx" module="zpp_nape.space.Broadphase">
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<is_sweep public="1"><x path="Bool"/></is_sweep>
		<sweep public="1"><c path="zpp_nape.space.ZPP_SweepPhase"/></sweep>
		<dynab public="1"><c path="zpp_nape.space.ZPP_DynAABBPhase"/></dynab>
		<insert public="1" set="method" line="179"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></insert>
		<remove public="1" set="method" line="183"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remove>
		<sync public="1" set="method" line="187"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></sync>
		<broadphase public="1" set="method" line="191"><f a="space:discrete">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></broadphase>
		<clear public="1" set="method" line="201"><f a=""><x path="Void"/></f></clear>
		<shapesUnderPoint public="1" set="method" line="202"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<bodiesUnderPoint public="1" set="method" line="205"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<aabbShape public="1"><c path="nape.shape.Shape"/></aabbShape>
		<matrix public="1"><c path="nape.geom.Mat23"/></matrix>
		<updateAABBShape public="1" set="method" line="210"><f a="aabb">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></updateAABBShape>
		<shapesInAABB public="1" set="method" line="230"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<bodiesInAABB public="1" set="method" line="233"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<circShape public="1"><c path="nape.shape.Shape"/></circShape>
		<updateCircShape public="1" set="method" line="237"><f a="x:y:r">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateCircShape>
		<shapesInCircle public="1" set="method" line="254"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInCircle public="1" set="method" line="257"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<validateShape public="1" set="method" line="260"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></validateShape>
		<shapesInShape public="1" set="method" line="265"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInShape public="1" set="method" line="268"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<rayCast public="1" set="method" line="271"><f a="ray:inner:filter">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<rayMultiCast public="1" set="method" line="274"><f a="ray:inner:filter:output">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<new public="1" set="method" line="174"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_AABBNode" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<zpp_pool public="1" line="187" static="1"><c path="zpp_nape.space.ZPP_AABBNode"/></zpp_pool>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<shape public="1"><c path="zpp_nape.shape.ZPP_Shape"/></shape>
		<dyn public="1"><x path="Bool"/></dyn>
		<parent public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></parent>
		<child1 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></child1>
		<child2 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></child2>
		<height public="1"><x path="Int"/></height>
		<rayt public="1"><x path="Float"/></rayt>
		<next public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></next>
		<alloc public="1" get="inline" set="null" line="213"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="237"><f a=""><x path="Void"/></f></free>
		<mnext public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></mnext>
		<moved public="1"><x path="Bool"/></moved>
		<snext public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></snext>
		<synced public="1"><x path="Bool"/></synced>
		<first_sync public="1"><x path="Bool"/></first_sync>
		<isLeaf public="1" get="inline" set="null" line="268"><f a=""><x path="Bool"/></f></isLeaf>
		<new public="1" set="method" line="183"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_AABBPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<zpp_pool public="1" line="282" static="1"><c path="zpp_nape.space.ZPP_AABBPair"/></zpp_pool>
		<n1 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></n1>
		<n2 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></n2>
		<first public="1"><x path="Bool"/></first>
		<sleeping public="1"><x path="Bool"/></sleeping>
		<id public="1"><x path="Int"/></id>
		<di public="1"><x path="Int"/></di>
		<arb public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></arb>
		<next public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></next>
		<alloc public="1" get="inline" set="null" line="309"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="321"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="306"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_AABBTree" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<tmpaabb public="1" line="419" static="1"><c path="zpp_nape.geom.ZPP_AABB"/></tmpaabb>
		<root public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></root>
		<clear public="1" set="method" line="338"><f a=""><x path="Void"/></f></clear>
		<insertLeaf set="method" line="420"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></insertLeaf>
		<inlined_insertLeaf public="1" get="inline" set="null" line="425"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></inlined_insertLeaf>
		<removeLeaf public="1" set="method" line="515"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></removeLeaf>
		<inlined_removeLeaf public="1" get="inline" set="null" line="520"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></inlined_removeLeaf>
		<balance public="1" get="inline" set="null" line="589"><f a="a">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></balance>
		<new public="1" set="method" line="337"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_DynAABBPhase" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<extends path="zpp_nape.space.ZPP_Broadphase"/>
		<FATTEN get="inline" set="null" line="696" static="1"><x path="Float"/></FATTEN>
		<VEL_STEPS get="inline" set="null" line="698" static="1"><x path="Float"/></VEL_STEPS>
		<stree public="1"><c path="zpp_nape.space.ZPP_AABBTree"/></stree>
		<dtree public="1"><c path="zpp_nape.space.ZPP_AABBTree"/></dtree>
		<pairs public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></pairs>
		<syncs public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></syncs>
		<moves public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></moves>
		<dyn public="1" get="inline" set="null" line="713"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></dyn>
		<__insert public="1" set="method" line="717"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__insert>
		<__remove public="1" set="method" line="777"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__remove>
		<__sync public="1" get="inline" set="null" line="944"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__sync>
		<sync_broadphase public="1" set="method" line="986"><f a=""><x path="Void"/></f></sync_broadphase>
		<broadphase public="1" set="method" line="1106" override="1"><f a="space:discrete">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></broadphase>
		<clear public="1" set="method" line="1882" override="1"><f a=""><x path="Void"/></f></clear>
		<treeStack><c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/></treeStack>
		<shapesUnderPoint public="1" set="method" line="1932" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<bodiesUnderPoint public="1" set="method" line="2029" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<treeStack2 public="1"><c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/></treeStack2>
		<shapesInAABB public="1" set="method" line="2133" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<failed public="1"><c path="nape.phys.BodyList"/></failed>
		<bodiesInAABB public="1" set="method" line="2277" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<shapesInCircle public="1" set="method" line="2468" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInCircle public="1" set="method" line="2545" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInShape public="1" set="method" line="2644" override="1"><f a="shp:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInShape public="1" set="method" line="2721" override="1"><f a="shp:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<openlist public="1"><c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/></openlist>
		<rayCast public="1" set="method" line="2821" override="1"><f a="ray:inner:filter">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<rayMultiCast public="1" set="method" line="2950" override="1"><f a="ray:inner:filter:output">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<new public="1" set="method" line="704"><f a="space">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Island" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<zpp_pool public="1" line="533" static="1"><c path="zpp_nape.space.ZPP_Island"/></zpp_pool>
		<next public="1"><c path="zpp_nape.space.ZPP_Island"/></next>
		<elem public="1" get="inline" set="null" line="178"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></elem>
		<begin public="1" get="inline" set="null" line="183"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></begin>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="192"><f a="i">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="197"><f a="o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="202"><f a="o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></inlined_add>
		<addAll public="1" set="method" line="221"><f a="x">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="239"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="244"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></inlined_insert>
		<pop public="1" set="method" line="269"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="274"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="293"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="298"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="311"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="322"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="347"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="360"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="383"><f a="pre">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="388"><f a="pre">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></inlined_erase>
		<splice public="1" set="method" line="420"><f a="pre:n">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></splice>
		<clear public="1" set="method" line="424"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="429"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="435"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="450"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="455"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="458"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="463"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="493"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></front>
		<back public="1" set="method" line="496"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></back>
		<iterator_at public="1" set="method" line="505"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></iterator_at>
		<at public="1" set="method" line="518"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></at>
		<comps public="1"><c path="zpp_nape.util.ZNPList_ZPP_Component"/></comps>
		<sleep public="1"><x path="Bool"/></sleep>
		<waket public="1"><x path="Int"/></waket>
		<free public="1" get="inline" set="null" line="559"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="571"><f a=""><x path="Void"/></f></alloc>
		<new public="1" set="method" line="574"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Component" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<zpp_pool public="1" line="581" static="1"><c path="zpp_nape.space.ZPP_Component"/></zpp_pool>
		<next public="1"><c path="zpp_nape.space.ZPP_Component"/></next>
		<parent public="1"><c path="zpp_nape.space.ZPP_Component"/></parent>
		<rank public="1"><x path="Int"/></rank>
		<isBody public="1"><x path="Bool"/></isBody>
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<constraint public="1"><c path="zpp_nape.constraint.ZPP_Constraint"/></constraint>
		<island public="1"><c path="zpp_nape.space.ZPP_Island"/></island>
		<sleeping public="1"><x path="Bool"/></sleeping>
		<waket public="1"><x path="Int"/></waket>
		<woken public="1"><x path="Bool"/></woken>
		<free public="1" get="inline" set="null" line="616"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="630"><f a=""><x path="Void"/></f></alloc>
		<reset public="1" get="inline" set="null" line="637"><f a=""><x path="Void"/></f></reset>
		<new public="1" set="method" line="631"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_CallbackSet" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<get public="1" set="method" line="650" static="1"><f a="i1:i2">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></get>
		<zpp_pool public="1" line="1059" static="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></zpp_pool>
		<id public="1"><x path="Int"/></id>
		<di public="1"><x path="Int"/></di>
		<int1 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int1>
		<int2 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int2>
		<arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/></arbiters>
		<COLLISIONstate public="1"><x path="Int"/></COLLISIONstate>
		<COLLISIONstamp public="1"><x path="Int"/></COLLISIONstamp>
		<SENSORstate public="1"><x path="Int"/></SENSORstate>
		<SENSORstamp public="1"><x path="Int"/></SENSORstamp>
		<FLUIDstate public="1"><x path="Int"/></FLUIDstate>
		<FLUIDstamp public="1"><x path="Int"/></FLUIDstamp>
		<next public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></next>
		<elem public="1" get="inline" set="null" line="707"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></elem>
		<begin public="1" get="inline" set="null" line="712"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></begin>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="721"><f a="i">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="726"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="731"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_add>
		<addAll public="1" set="method" line="750"><f a="x">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="768"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="773"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_insert>
		<pop public="1" set="method" line="798"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="803"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="822"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="827"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="840"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="851"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="876"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="889"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="912"><f a="pre">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="917"><f a="pre">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_erase>
		<splice public="1" set="method" line="949"><f a="pre:n">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></splice>
		<clear public="1" set="method" line="953"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="958"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="964"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="979"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="984"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="987"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="992"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="1022"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></front>
		<back public="1" set="method" line="1025"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></back>
		<iterator_at public="1" set="method" line="1034"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></iterator_at>
		<at public="1" set="method" line="1047"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></at>
		<freed public="1"><x path="Bool"/></freed>
		<lazydel public="1"><x path="Bool"/></lazydel>
		<free public="1" get="inline" set="null" line="1087"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="1102"><f a=""><x path="Void"/></f></alloc>
		<add_arb public="1" get="inline" set="null" line="1117"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></add_arb>
		<try_remove_arb public="1" set="method" line="1124"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></try_remove_arb>
		<remove_arb public="1" set="method" line="1127"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Void"/>
</f></remove_arb>
		<empty_arb public="1" set="method" line="1130"><f a="type">
	<x path="Int"/>
	<x path="Bool"/>
</f></empty_arb>
		<really_empty public="1" get="inline" set="null" line="1158"><f a=""><x path="Bool"/></f></really_empty>
		<sleeping public="1" get="inline" set="null" line="1163"><f a=""><x path="Bool"/></f></sleeping>
		<new public="1" set="method" line="1113"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_CbSetManager" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<cbsets public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></cbsets>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<get public="1" set="method" line="1194"><f a="cbTypes">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></get>
		<remove public="1" set="method" line="1253"><f a="set">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></remove>
		<clear public="1" set="method" line="1285"><f a=""><x path="Void"/></f></clear>
		<validate public="1" get="inline" set="null" line="1318"><f a=""><x path="Void"/></f></validate>
		<pair public="1" get="inline" set="null" line="1348"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></pair>
		<valid_listener public="1" get="inline" set="null" line="1374"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></valid_listener>
		<new public="1" set="method" line="1295"><f a="space">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Space" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<outer public="1"><c path="nape.space.Space"/></outer>
		<userData public="1"><d><d/></d></userData>
		<gravityx public="1"><x path="Float"/></gravityx>
		<gravityy public="1"><x path="Float"/></gravityy>
		<wrap_gravity public="1"><c path="nape.geom.Vec2"/></wrap_gravity>
		<getgravity public="1" set="method" line="1385"><f a=""><x path="Void"/></f></getgravity>
		<gravity_invalidate set="method" line="1391"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></gravity_invalidate>
		<gravity_validate set="method" line="1502"><f a=""><x path="Void"/></f></gravity_validate>
		<bodies public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></bodies>
		<wrap_bodies public="1"><c path="nape.phys.BodyList"/></wrap_bodies>
		<compounds public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></compounds>
		<wrap_compounds public="1"><c path="nape.phys.CompoundList"/></wrap_compounds>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<kinematics public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></kinematics>
		<bphase public="1"><c path="zpp_nape.space.ZPP_Broadphase"/></bphase>
		<__static public="1"><c path="nape.phys.Body"/></__static>
		<global_lin_drag public="1"><x path="Float"/></global_lin_drag>
		<global_ang_drag public="1"><x path="Float"/></global_ang_drag>
		<stamp public="1"><x path="Int"/></stamp>
		<midstep public="1"><x path="Bool"/></midstep>
		<time public="1"><x path="Float"/></time>
		<sortcontacts public="1"><x path="Bool"/></sortcontacts>
		<c_arbiters_true public="1"><c path="zpp_nape.util.ZNPList_ZPP_ColArbiter"/></c_arbiters_true>
		<c_arbiters_false public="1"><c path="zpp_nape.util.ZNPList_ZPP_ColArbiter"/></c_arbiters_false>
		<f_arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_FluidArbiter"/></f_arbiters>
		<s_arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_SensorArbiter"/></s_arbiters>
		<wrap_arbiters public="1"><c path="nape.dynamics.ArbiterList"/></wrap_arbiters>
		<live public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></live>
		<wrap_live public="1"><c path="nape.phys.BodyList"/></wrap_live>
		<live_constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></live_constraints>
		<wrap_livecon public="1"><c path="nape.constraint.ConstraintList"/></wrap_livecon>
		<staticsleep public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></staticsleep>
		<islands public="1"><c path="zpp_nape.space.ZPP_Island"/></islands>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_Listener"/></listeners>
		<wrap_listeners public="1"><c path="nape.callbacks.ListenerList"/></wrap_listeners>
		<callbacks public="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></callbacks>
		<callbackset_list public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></callbackset_list>
		<cbsets public="1"><c path="zpp_nape.space.ZPP_CbSetManager"/></cbsets>
		<clear public="1" set="method" line="1556"><f a=""><x path="Void"/></f></clear>
		<bodies_adder set="method" line="1815"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></bodies_adder>
		<bodies_subber set="method" line="1826"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></bodies_subber>
		<bodies_modifiable set="method" line="1830"><f a=""><x path="Void"/></f></bodies_modifiable>
		<compounds_adder set="method" line="1834"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></compounds_adder>
		<compounds_subber set="method" line="1845"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></compounds_subber>
		<compounds_modifiable set="method" line="1849"><f a=""><x path="Void"/></f></compounds_modifiable>
		<constraints_adder set="method" line="1853"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></constraints_adder>
		<constraints_subber set="method" line="1864"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></constraints_subber>
		<constraints_modifiable set="method" line="1868"><f a=""><x path="Void"/></f></constraints_modifiable>
		<listeners_adder set="method" line="1872"><f a="x">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></listeners_adder>
		<listeners_subber set="method" line="1880"><f a="x">
	<c path="nape.callbacks.Listener"/>
	<x path="Void"/>
</f></listeners_subber>
		<listeners_modifiable set="method" line="1884"><f a=""><x path="Void"/></f></listeners_modifiable>
		<revoke_listener public="1" get="inline" set="null" line="1997"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></revoke_listener>
		<unrevoke_listener public="1" get="inline" set="null" line="2000"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></unrevoke_listener>
		<addListener public="1" set="method" line="2001"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></addListener>
		<remListener public="1" set="method" line="2008"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></remListener>
		<add_callbackset public="1" set="method" line="2015"><f a="cb">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></add_callbackset>
		<remove_callbackset public="1" set="method" line="2028"><f a="cb">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></remove_callbackset>
		<transmitType public="1" set="method" line="2033"><f a="p:new_type">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
	<x path="Void"/>
</f></transmitType>
		<added_shape public="1" get="inline" set="null" line="2102"><f a="s:?dontwake" v=":false">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></added_shape>
		<removed_shape public="1" set="method" line="2134"><f a="s:?deleting" v=":false">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></removed_shape>
		<addConstraint public="1" set="method" line="2278"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></addConstraint>
		<remConstraint public="1" set="method" line="2294"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remConstraint>
		<addCompound public="1" set="method" line="2302"><f a="x">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></addCompound>
		<remCompound public="1" set="method" line="2330"><f a="x">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></remCompound>
		<addBody public="1" set="method" line="2358"><f a="body:?flag" v=":-1">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBody>
		<remBody public="1" set="method" line="2439"><f a="body:?flag" v=":-1">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
	<x path="Void"/>
</f></remBody>
		<shapesUnderPoint public="1" set="method" line="2581"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<bodiesUnderPoint public="1" set="method" line="2584"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesInAABB public="1" set="method" line="2587"><f a="aabb:strict:cont:filter:output">
	<c path="nape.geom.AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<bodiesInAABB public="1" set="method" line="2590"><f a="aabb:strict:cont:filter:output">
	<c path="nape.geom.AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<shapesInCircle public="1" set="method" line="2593"><f a="pos:rad:cont:filter:output">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInCircle public="1" set="method" line="2596"><f a="pos:rad:cont:filter:output">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInShape public="1" set="method" line="2599"><f a="shape:cont:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInShape public="1" set="method" line="2602"><f a="shape:cont:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<rayCast public="1" set="method" line="2605"><f a="ray:inner:filter">
	<c path="nape.geom.Ray"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<rayMultiCast public="1" set="method" line="2608"><f a="ray:inner:filter:output">
	<c path="nape.geom.Ray"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<convexShapeList><c path="nape.shape.ShapeList"/></convexShapeList>
		<convexCast public="1" set="method" line="2612"><f a="shape:deltaTime:filter:dynamics">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Float"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<x path="Bool"/>
	<c path="nape.geom.ConvexResult"/>
</f></convexCast>
		<prepareCast get="inline" set="null" line="2833"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></prepareCast>
		<convexMultiCast public="1" set="method" line="2837"><f a="shape:deltaTime:filter:dynamics:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Float"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<x path="Bool"/>
	<c path="nape.geom.ConvexResultList"/>
	<c path="nape.geom.ConvexResultList"/>
</f></convexMultiCast>
		<push_callback public="1" set="method" line="2982"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></push_callback>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<step public="1" set="method" line="3014"><f a="deltaTime:velocityIterations:positionIterations">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></step>
		<toiEvents public="1"><c path="zpp_nape.util.ZNPList_ZPP_ToiEvent"/></toiEvents>
		<continuousCollisions public="1" set="method" line="3355"><f a="deltaTime">
	<x path="Float"/>
	<x path="Void"/>
</f></continuousCollisions>
		<continuousEvent public="1" set="method" line="3565"><f a="s1:s2:stat:in_arb:_">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></continuousEvent>
		<bodyCbWake public="1" set="method" line="3651"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></bodyCbWake>
		<bodyCbSleep public="1" set="method" line="3674"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></bodyCbSleep>
		<constraintCbWake public="1" set="method" line="3694"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></constraintCbWake>
		<constraintCbSleep public="1" set="method" line="3717"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></constraintCbSleep>
		<constraintCbBreak public="1" set="method" line="3737"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></constraintCbBreak>
		<nullListenerType public="1" set="method" line="3757"><f a="cb1:cb2">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></nullListenerType>
		<nullInteractorType public="1" set="method" line="3866"><f a="intx:?me" v=":null">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></nullInteractorType>
		<freshListenerType public="1" set="method" line="3948"><f a="cb1:cb2">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></freshListenerType>
		<freshInteractorType public="1" set="method" line="4045"><f a="intx:?me" v=":null">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></freshInteractorType>
		<wakeCompound public="1" set="method" line="4133"><f a="x">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></wakeCompound>
		<wakeIsland public="1" set="method" line="4184"><f a="i">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></wakeIsland>
		<non_inlined_wake public="1" set="method" line="4287"><f a="o:?fst" v=":false">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></non_inlined_wake>
		<really_wake public="1" set="method" line="4315"><f a="o:?fst" v=":false">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></really_wake>
		<wake_constraint public="1" set="method" line="4424"><f a="con:?fst" v=":false">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></wake_constraint>
		<doForests public="1" set="method" line="4467"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></doForests>
		<sleepArbiters public="1" set="method" line="4757"><f a=""><x path="Void"/></f></sleepArbiters>
		<static_validation public="1" set="method" line="4906"><f a="body">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></static_validation>
		<validation public="1" set="method" line="4936"><f a=""><x path="Void"/></f></validation>
		<updateVel public="1" set="method" line="5128"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></updateVel>
		<updatePos public="1" set="method" line="5158"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></updatePos>
		<continuous public="1"><x path="Bool"/></continuous>
		<presteparb public="1" set="method" line="5346"><f a="arb:dt:?cont" v="::false">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></presteparb>
		<prestep public="1" set="method" line="5490"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></prestep>
		<warmStart public="1" set="method" line="5635"><f a=""><x path="Void"/></f></warmStart>
		<iterateVel public="1" set="method" line="5672"><f a="times">
	<x path="Int"/>
	<x path="Void"/>
</f></iterateVel>
		<iteratePos public="1" set="method" line="5729"><f a="times">
	<x path="Int"/>
	<x path="Void"/>
</f></iteratePos>
		<group_ignore public="1" get="inline" set="null" line="5786"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></group_ignore>
		<interactionType public="1" get="inline" set="null" line="5808"><f a="s1:s2:b1:b2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
</f></interactionType>
		<precb><c path="nape.callbacks.PreCallback"/></precb>
		<prelisteners><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></prelisteners>
		<narrowPhase public="1" set="method" line="5858"><f a="s1:s2:stat:in_arb:continuous">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></narrowPhase>
		<mrca1 public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></mrca1>
		<mrca2 public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></mrca2>
		<MRCA_chains public="1" set="method" line="7219"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></MRCA_chains>
		<inlined_MRCA_chains public="1" get="inline" set="null" line="7224"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></inlined_MRCA_chains>
		<new public="1" set="method" line="1888"><f a="gravity:broadphase">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="nape.space.Broadphase"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.space.ZPP_SweepData" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/SweepPhase.hx" module="zpp_nape.space.SweepPhase">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.space.ZPP_SweepData"/></zpp_pool>
		<next public="1"><c path="zpp_nape.space.ZPP_SweepData"/></next>
		<prev public="1"><c path="zpp_nape.space.ZPP_SweepData"/></prev>
		<shape public="1"><c path="zpp_nape.shape.ZPP_Shape"/></shape>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<free public="1" get="inline" set="null" line="205"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="212"><f a=""><x path="Void"/></f></alloc>
		<gt public="1" get="inline" set="null" line="216"><f a="x">
	<c path="zpp_nape.space.ZPP_SweepData"/>
	<x path="Bool"/>
</f></gt>
		<new public="1" set="method" line="213"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_SweepPhase" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/space/SweepPhase.hx" module="zpp_nape.space.SweepPhase">
		<extends path="zpp_nape.space.ZPP_Broadphase"/>
		<list public="1"><c path="zpp_nape.space.ZPP_SweepData"/></list>
		<__insert public="1" set="method" line="228"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__insert>
		<__remove public="1" set="method" line="262"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__remove>
		<__sync public="1" get="inline" set="null" line="296"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__sync>
		<sync_broadphase public="1" set="method" line="307"><f a=""><x path="Void"/></f></sync_broadphase>
		<sync_broadphase_fast public="1" get="inline" set="null" line="313"><f a=""><x path="Void"/></f></sync_broadphase_fast>
		<broadphase public="1" set="method" line="345" override="1"><f a="space:discrete">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></broadphase>
		<clear public="1" set="method" line="384" override="1"><f a=""><x path="Void"/></f></clear>
		<shapesUnderPoint public="1" set="method" line="390" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<bodiesUnderPoint public="1" set="method" line="429" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesInAABB public="1" set="method" line="471" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<failed public="1"><c path="nape.phys.BodyList"/></failed>
		<bodiesInAABB public="1" set="method" line="499" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<shapesInCircle public="1" set="method" line="549" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInCircle public="1" set="method" line="570" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInShape public="1" set="method" line="603" override="1"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInShape public="1" set="method" line="624" override="1"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<rayCast public="1" set="method" line="657" override="1"><f a="ray:inner:filter">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<rayMultiCast public="1" set="method" line="745" override="1"><f a="ray:inner:filter:output">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<new public="1" set="method" line="223"><f a="space">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPArray2_Float" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Array2.hx" module="zpp_nape.util.Array2">
		<list public="1"><t path="nape.TArray"><x path="Float"/></t></list>
		<width public="1"><x path="Int"/></width>
		<resize public="1" set="method" line="191"><f a="width:height:def">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<get public="1" get="inline" set="null" line="209"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<set public="1" get="inline" set="null" line="222"><f a="x:y:obj">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set>
		<new public="1" set="method" line="182"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPArray2_ZPP_GeomVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Array2.hx" module="zpp_nape.util.Array2">
		<list public="1"><t path="nape.TArray"><c path="zpp_nape.geom.ZPP_GeomVert"/></t></list>
		<width public="1"><x path="Int"/></width>
		<resize public="1" set="method" line="251"><f a="width:height:def">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></resize>
		<get public="1" get="inline" set="null" line="269"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></get>
		<set public="1" get="inline" set="null" line="282"><f a="x:y:obj">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></set>
		<new public="1" set="method" line="242"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPArray2_ZPP_MarchPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Array2.hx" module="zpp_nape.util.Array2">
		<list public="1"><t path="nape.TArray"><c path="zpp_nape.geom.ZPP_MarchPair"/></t></list>
		<width public="1"><x path="Int"/></width>
		<resize public="1" set="method" line="311"><f a="width:height:def">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></resize>
		<get public="1" get="inline" set="null" line="329"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
</f></get>
		<set public="1" get="inline" set="null" line="342"><f a="x:y:obj">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
</f></set>
		<new public="1" set="method" line="302"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Debug" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Debug.hx" module="zpp_nape.util.Debug">
		<internal public="1" line="175" static="1"><x path="Bool"/></internal>
		<outer public="1"><c path="nape.util.Debug"/></outer>
		<isbmp public="1"><x path="Bool"/></isbmp>
		<d_shape public="1"><c path="zpp_nape.util.ZPP_ShapeDebug"/></d_shape>
		<bg_r public="1"><x path="Float"/></bg_r>
		<bg_g public="1"><x path="Float"/></bg_g>
		<bg_b public="1"><x path="Float"/></bg_b>
		<bg_col public="1"><x path="Int"/></bg_col>
		<xform public="1"><c path="zpp_nape.geom.ZPP_Mat23"/></xform>
		<xnull public="1"><x path="Bool"/></xnull>
		<xdet public="1"><x path="Float"/></xdet>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<viewport public="1"><c path="zpp_nape.geom.ZPP_AABB"/></viewport>
		<iport public="1"><c path="zpp_nape.geom.ZPP_AABB"/></iport>
		<xform_invalidate set="method" line="201"><f a=""><x path="Void"/></f></xform_invalidate>
		<setform public="1" set="method" line="265"><f a=""><x path="Void"/></f></setform>
		<tmpab public="1"><c path="zpp_nape.geom.ZPP_AABB"/></tmpab>
		<cull public="1" set="method" line="270"><f a="aabb">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></cull>
		<sup_setbg public="1" set="method" line="422"><f a="bgcol">
	<x path="Int"/>
	<x path="Void"/>
</f></sup_setbg>
		<new public="1" set="method" line="192"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ShapeDebug" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Debug.hx" module="zpp_nape.util.Debug">
		<extends path="zpp_nape.util.ZPP_Debug"/>
		<outer_zn public="1"><c path="nape.util.ShapeDebug"/></outer_zn>
		<shape public="1"><c path="flash.display.Shape"/></shape>
		<graphics public="1"><c path="flash.display.Graphics"/></graphics>
		<setbg public="1" set="method" line="442"><f a="bgColor">
	<x path="Int"/>
	<x path="Void"/>
</f></setbg>
		<compoundstack public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></compoundstack>
		<draw_compound public="1" set="method" line="446"><f a="compound:xform:xdet:xnull">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_compound>
		<shapeList><c path="nape.shape.ShapeList"/></shapeList>
		<bodyList><c path="nape.phys.BodyList"/></bodyList>
		<draw_space public="1" set="method" line="474"><f a="space:xform:xdet:xnull">
	<c path="zpp_nape.space.ZPP_Space"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_space>
		<draw_body public="1" set="method" line="573"><f a="body:xform:xdet:xnull">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_body>
		<draw_shape public="1" set="method" line="775"><f a="shape:xform:xdet:xnull">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_shape>
		<draw_arbiter public="1" set="method" line="1033"><f a="arb:xform:xdet:xnull">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_arbiter>
		<new public="1" set="method" line="434"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.Hashable2_Boolfalse" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/FastHash.hx" module="zpp_nape.util.FastHash">
		<zpp_pool public="1" line="179" static="1"><c path="zpp_nape.util.Hashable2_Boolfalse"/></zpp_pool>
		<get public="1" get="inline" set="null" line="214" static="1"><f a="id:di:val">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></get>
		<getpersist public="1" get="inline" set="null" line="220" static="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></getpersist>
		<ordered_get public="1" get="inline" set="null" line="244" static="1"><f a="id:di:val">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></ordered_get>
		<ordered_get_persist public="1" get="inline" set="null" line="248" static="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></ordered_get_persist>
		<value public="1"><x path="Bool"/></value>
		<next public="1"><c path="zpp_nape.util.Hashable2_Boolfalse"/></next>
		<hnext public="1"><c path="zpp_nape.util.Hashable2_Boolfalse"/></hnext>
		<id public="1"><x path="Int"/></id>
		<di public="1"><x path="Int"/></di>
		<free public="1" get="inline" set="null" line="208"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="211"><f a=""><x path="Void"/></f></alloc>
		<new set="method" line="212"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.FastHash2_Hashable2_Boolfalse" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/FastHash.hx" module="zpp_nape.util.FastHash">
		<table public="1"><t path="nape.TArray"><c path="zpp_nape.util.Hashable2_Boolfalse"/></t></table>
		<cnt public="1"><x path="Int"/></cnt>
		<empty public="1" get="inline" set="null" line="268"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="271"><f a=""><x path="Void"/></f></clear>
		<get public="1" get="inline" set="null" line="288"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></get>
		<ordered_get public="1" get="inline" set="null" line="299"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="zpp_nape.util.Hashable2_Boolfalse"/></t>
</f></ordered_get>
		<has public="1" set="method" line="307"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></has>
		<maybeAdd public="1" set="method" line="316"><f a="arb">
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
	<x path="Void"/>
</f></maybeAdd>
		<add public="1" set="method" line="350"><f a="arb">
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="382"><f a="arb">
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
	<x path="Void"/>
</f></remove>
		<hash public="1" get="inline" set="null" line="416"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hash>
		<new public="1" set="method" line="259"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CallbackSet" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></head>
		<begin public="1" get="inline" set="null" line="597"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="605"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="610"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="615"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_add>
		<addAll public="1" set="method" line="652"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CallbackSet"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="670"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="675"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></inlined_insert>
		<pop public="1" set="method" line="718"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="723"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="756"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="761"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="774"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="785"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="810"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="823"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="846"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="851"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></inlined_erase>
		<splice public="1" set="method" line="897"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></splice>
		<clear public="1" set="method" line="901"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="906"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="912"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="927"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="932"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="935"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="940"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="970"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></front>
		<back public="1" set="method" line="973"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></back>
		<iterator_at public="1" set="method" line="982"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></iterator_at>
		<at public="1" set="method" line="995"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></at>
		<new public="1" set="method" line="594"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Shape" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></head>
		<begin public="1" get="inline" set="null" line="1014"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="1022"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="1027"><f a="o">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="1032"><f a="o">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
</f></inlined_add>
		<addAll public="1" set="method" line="1069"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Shape"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="1087"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="1092"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></inlined_insert>
		<pop public="1" set="method" line="1135"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="1140"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="1173"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="1178"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="1191"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="1202"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="1227"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="1240"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="1263"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="1268"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></inlined_erase>
		<splice public="1" set="method" line="1314"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></splice>
		<clear public="1" set="method" line="1318"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="1323"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="1329"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="1344"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="1349"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="1352"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="1357"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="1387"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></front>
		<back public="1" set="method" line="1390"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></back>
		<iterator_at public="1" set="method" line="1399"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></iterator_at>
		<at public="1" set="method" line="1412"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
</f></at>
		<new public="1" set="method" line="1011"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Body" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></head>
		<begin public="1" get="inline" set="null" line="1431"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="1439"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="1444"><f a="o">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="1449"><f a="o">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></inlined_add>
		<addAll public="1" set="method" line="1486"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Body"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="1504"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="1509"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></inlined_insert>
		<pop public="1" set="method" line="1552"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="1557"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="1590"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="1595"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="1608"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="1619"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="1644"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="1657"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="1680"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="1685"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></inlined_erase>
		<splice public="1" set="method" line="1731"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></splice>
		<clear public="1" set="method" line="1735"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="1740"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="1746"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="1761"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="1766"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="1769"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="1774"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="1804"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></front>
		<back public="1" set="method" line="1807"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></back>
		<iterator_at public="1" set="method" line="1816"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></iterator_at>
		<at public="1" set="method" line="1829"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></at>
		<new public="1" set="method" line="1428"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Compound" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></head>
		<begin public="1" get="inline" set="null" line="2265"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="2273"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="2278"><f a="o">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="2283"><f a="o">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
</f></inlined_add>
		<addAll public="1" set="method" line="2320"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Compound"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="2338"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="2343"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></inlined_insert>
		<pop public="1" set="method" line="2386"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="2391"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="2424"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="2429"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="2442"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="2453"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="2478"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="2491"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="2514"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="2519"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></inlined_erase>
		<splice public="1" set="method" line="2565"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></splice>
		<clear public="1" set="method" line="2569"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="2574"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="2580"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="2595"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="2600"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="2603"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="2608"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="2638"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></front>
		<back public="1" set="method" line="2641"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></back>
		<iterator_at public="1" set="method" line="2650"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></iterator_at>
		<at public="1" set="method" line="2663"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
</f></at>
		<new public="1" set="method" line="2262"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Arbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></head>
		<begin public="1" get="inline" set="null" line="2682"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="2690"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="2695"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="2700"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></inlined_add>
		<addAll public="1" set="method" line="2737"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="2755"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="2760"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></inlined_insert>
		<pop public="1" set="method" line="2803"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="2808"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="2841"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="2846"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="2859"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="2870"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="2895"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="2908"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="2931"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="2936"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></inlined_erase>
		<splice public="1" set="method" line="2982"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></splice>
		<clear public="1" set="method" line="2986"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="2991"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="2997"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="3012"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="3017"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="3020"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="3025"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="3055"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></front>
		<back public="1" set="method" line="3058"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></back>
		<iterator_at public="1" set="method" line="3067"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></iterator_at>
		<at public="1" set="method" line="3080"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></at>
		<new public="1" set="method" line="2679"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CbSetPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></head>
		<begin public="1" get="inline" set="null" line="4767"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="4775"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="4780"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="4785"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></inlined_add>
		<addAll public="1" set="method" line="4822"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="4840"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="4845"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></inlined_insert>
		<pop public="1" set="method" line="4888"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="4893"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="4926"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="4931"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="4944"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="4955"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="4980"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="4993"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="5016"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="5021"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></inlined_erase>
		<splice public="1" set="method" line="5067"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></splice>
		<clear public="1" set="method" line="5071"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="5076"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="5082"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="5097"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="5102"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="5105"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="5110"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="5140"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></front>
		<back public="1" set="method" line="5143"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></back>
		<iterator_at public="1" set="method" line="5152"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></iterator_at>
		<at public="1" set="method" line="5165"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></at>
		<new public="1" set="method" line="4764"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CutInt" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></head>
		<begin public="1" get="inline" set="null" line="5601"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="5609"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="5614"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="5619"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></inlined_add>
		<addAll public="1" set="method" line="5656"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CutInt"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="5674"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="5679"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></inlined_insert>
		<pop public="1" set="method" line="5722"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="5727"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="5760"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="5765"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="5778"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="5789"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="5814"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="5827"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="5850"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="5855"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></inlined_erase>
		<splice public="1" set="method" line="5901"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></splice>
		<clear public="1" set="method" line="5905"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="5910"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="5916"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="5931"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="5936"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="5939"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="5944"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="5974"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></front>
		<back public="1" set="method" line="5977"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></back>
		<iterator_at public="1" set="method" line="5986"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></iterator_at>
		<at public="1" set="method" line="5999"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></at>
		<new public="1" set="method" line="5598"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CutVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></head>
		<begin public="1" get="inline" set="null" line="6018"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="6026"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="6031"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="6036"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></inlined_add>
		<addAll public="1" set="method" line="6073"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CutVert"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="6091"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="6096"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></inlined_insert>
		<pop public="1" set="method" line="6139"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="6144"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="6177"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="6182"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="6195"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="6206"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="6231"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="6244"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="6267"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="6272"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></inlined_erase>
		<splice public="1" set="method" line="6318"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></splice>
		<clear public="1" set="method" line="6322"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="6327"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="6333"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="6348"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="6353"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="6356"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="6361"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="6391"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></front>
		<back public="1" set="method" line="6394"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></back>
		<iterator_at public="1" set="method" line="6403"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></iterator_at>
		<at public="1" set="method" line="6416"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></at>
		<new public="1" set="method" line="6015"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_PartitionVertex" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></head>
		<begin public="1" get="inline" set="null" line="6435"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="6443"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="6448"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="6453"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></inlined_add>
		<addAll public="1" set="method" line="6490"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="6508"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="6513"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></inlined_insert>
		<pop public="1" set="method" line="6556"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="6561"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="6594"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="6599"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="6612"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="6623"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="6648"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="6661"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="6684"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="6689"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></inlined_erase>
		<splice public="1" set="method" line="6735"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></splice>
		<clear public="1" set="method" line="6739"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="6744"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="6750"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="6765"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="6770"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="6773"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="6778"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="6808"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></front>
		<back public="1" set="method" line="6811"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></back>
		<iterator_at public="1" set="method" line="6820"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></iterator_at>
		<at public="1" set="method" line="6833"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></at>
		<new public="1" set="method" line="6432"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></head>
		<begin public="1" get="inline" set="null" line="6852"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="6860"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="6865"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="6870"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></inlined_add>
		<addAll public="1" set="method" line="6907"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="6925"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="6930"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></inlined_insert>
		<pop public="1" set="method" line="6973"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="6978"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="7011"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="7016"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="7029"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="7040"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="7065"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="7078"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="7101"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="7106"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></inlined_erase>
		<splice public="1" set="method" line="7152"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></splice>
		<clear public="1" set="method" line="7156"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="7161"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="7167"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="7182"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="7187"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="7190"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="7195"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="7225"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></front>
		<back public="1" set="method" line="7228"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></back>
		<iterator_at public="1" set="method" line="7237"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></iterator_at>
		<at public="1" set="method" line="7250"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></at>
		<new public="1" set="method" line="6849"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SimplifyP" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></head>
		<begin public="1" get="inline" set="null" line="7269"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="7277"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="7282"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="7287"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></inlined_add>
		<addAll public="1" set="method" line="7324"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SimplifyP"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="7342"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="7347"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></inlined_insert>
		<pop public="1" set="method" line="7390"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="7395"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="7428"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="7433"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="7446"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="7457"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="7482"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="7495"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="7518"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="7523"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></inlined_erase>
		<splice public="1" set="method" line="7569"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></splice>
		<clear public="1" set="method" line="7573"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="7578"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="7584"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="7599"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="7604"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="7607"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="7612"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="7642"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></front>
		<back public="1" set="method" line="7645"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></back>
		<iterator_at public="1" set="method" line="7654"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></iterator_at>
		<at public="1" set="method" line="7667"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></at>
		<new public="1" set="method" line="7266"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_GeomVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></head>
		<begin public="1" get="inline" set="null" line="7686"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="7694"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="7699"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="7704"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></inlined_add>
		<addAll public="1" set="method" line="7741"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="7759"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="7764"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></inlined_insert>
		<pop public="1" set="method" line="7807"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="7812"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="7845"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="7850"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="7863"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="7874"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="7899"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="7912"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="7935"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="7940"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></inlined_erase>
		<splice public="1" set="method" line="7986"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></splice>
		<clear public="1" set="method" line="7990"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="7995"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="8001"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="8016"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="8021"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="8024"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="8029"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="8059"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></front>
		<back public="1" set="method" line="8062"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></back>
		<iterator_at public="1" set="method" line="8071"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></iterator_at>
		<at public="1" set="method" line="8084"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></at>
		<new public="1" set="method" line="7683"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SimpleVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></head>
		<begin public="1" get="inline" set="null" line="8103"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="8111"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="8116"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="8121"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></inlined_add>
		<addAll public="1" set="method" line="8158"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="8176"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="8181"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></inlined_insert>
		<pop public="1" set="method" line="8224"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="8229"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="8262"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="8267"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="8280"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="8291"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="8316"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="8329"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="8352"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="8357"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></inlined_erase>
		<splice public="1" set="method" line="8403"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></splice>
		<clear public="1" set="method" line="8407"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="8412"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="8418"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="8433"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="8438"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="8441"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="8446"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="8476"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></front>
		<back public="1" set="method" line="8479"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></back>
		<iterator_at public="1" set="method" line="8488"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></iterator_at>
		<at public="1" set="method" line="8501"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></at>
		<new public="1" set="method" line="8100"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SimpleEvent" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></head>
		<begin public="1" get="inline" set="null" line="8520"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="8528"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="8533"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="8538"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></inlined_add>
		<addAll public="1" set="method" line="8575"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="8593"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="8598"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></inlined_insert>
		<pop public="1" set="method" line="8641"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="8646"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="8679"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="8684"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="8697"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="8708"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="8733"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="8746"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="8769"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="8774"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></inlined_erase>
		<splice public="1" set="method" line="8820"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></splice>
		<clear public="1" set="method" line="8824"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="8829"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="8835"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="8850"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="8855"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="8858"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="8863"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="8893"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></front>
		<back public="1" set="method" line="8896"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></back>
		<iterator_at public="1" set="method" line="8905"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></iterator_at>
		<at public="1" set="method" line="8918"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></at>
		<new public="1" set="method" line="8517"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_AABBPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></head>
		<begin public="1" get="inline" set="null" line="8937"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="8945"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="8950"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="8955"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
</f></inlined_add>
		<addAll public="1" set="method" line="8992"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_AABBPair"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="9010"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="9015"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></inlined_insert>
		<pop public="1" set="method" line="9058"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="9063"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="9096"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="9101"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="9114"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="9125"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="9150"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="9163"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="9186"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="9191"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></inlined_erase>
		<splice public="1" set="method" line="9237"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></splice>
		<clear public="1" set="method" line="9241"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="9246"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="9252"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="9267"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="9272"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="9275"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="9280"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="9310"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></front>
		<back public="1" set="method" line="9313"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></back>
		<iterator_at public="1" set="method" line="9322"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></iterator_at>
		<at public="1" set="method" line="9335"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
</f></at>
		<new public="1" set="method" line="8934"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Edge" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></head>
		<begin public="1" get="inline" set="null" line="9771"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="9779"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="9784"><f a="o">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="9789"><f a="o">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
</f></inlined_add>
		<addAll public="1" set="method" line="9826"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Edge"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="9844"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="9849"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></inlined_insert>
		<pop public="1" set="method" line="9892"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="9897"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="9930"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="9935"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="9948"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="9959"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="9984"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="9997"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="10020"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="10025"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></inlined_erase>
		<splice public="1" set="method" line="10071"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></splice>
		<clear public="1" set="method" line="10075"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="10080"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="10086"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="10101"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="10106"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="10109"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="10114"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="10144"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></front>
		<back public="1" set="method" line="10147"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></back>
		<iterator_at public="1" set="method" line="10156"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></iterator_at>
		<at public="1" set="method" line="10169"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
</f></at>
		<new public="1" set="method" line="9768"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_AABBNode" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></head>
		<begin public="1" get="inline" set="null" line="10188"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="10196"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="10201"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="10206"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></inlined_add>
		<addAll public="1" set="method" line="10243"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="10261"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="10266"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></inlined_insert>
		<pop public="1" set="method" line="10309"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="10314"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="10347"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="10352"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="10365"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="10376"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="10401"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="10414"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="10437"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="10442"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></inlined_erase>
		<splice public="1" set="method" line="10488"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></splice>
		<clear public="1" set="method" line="10492"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="10497"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="10503"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="10518"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="10523"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="10526"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="10531"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="10561"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></front>
		<back public="1" set="method" line="10564"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></back>
		<iterator_at public="1" set="method" line="10573"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></iterator_at>
		<at public="1" set="method" line="10586"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></at>
		<new public="1" set="method" line="10185"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Component" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></head>
		<begin public="1" get="inline" set="null" line="10605"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="10613"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="10618"><f a="o">
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="10623"><f a="o">
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
</f></inlined_add>
		<addAll public="1" set="method" line="10660"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Component"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="10678"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="10683"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></inlined_insert>
		<pop public="1" set="method" line="10726"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="10731"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="10764"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="10769"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="10782"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="10793"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="10818"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="10831"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="10854"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="10859"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></inlined_erase>
		<splice public="1" set="method" line="10905"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></splice>
		<clear public="1" set="method" line="10909"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="10914"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="10920"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="10935"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="10940"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="10943"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="10948"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="10978"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></front>
		<back public="1" set="method" line="10981"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></back>
		<iterator_at public="1" set="method" line="10990"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></iterator_at>
		<at public="1" set="method" line="11003"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Component"/>
</f></at>
		<new public="1" set="method" line="10602"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_InteractionGroup" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></head>
		<begin public="1" get="inline" set="null" line="11022"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="11030"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="11035"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="11040"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
</f></inlined_add>
		<addAll public="1" set="method" line="11077"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="11095"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="11100"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></inlined_insert>
		<pop public="1" set="method" line="11143"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="11148"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="11181"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="11186"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="11199"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="11210"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="11235"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="11248"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="11271"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="11276"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></inlined_erase>
		<splice public="1" set="method" line="11322"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></splice>
		<clear public="1" set="method" line="11326"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="11331"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="11337"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="11352"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="11357"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="11360"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="11365"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="11395"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></front>
		<back public="1" set="method" line="11398"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></back>
		<iterator_at public="1" set="method" line="11407"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></iterator_at>
		<at public="1" set="method" line="11420"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
</f></at>
		<new public="1" set="method" line="11019"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_ColArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></head>
		<begin public="1" get="inline" set="null" line="11439"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="11447"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="11452"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="11457"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
</f></inlined_add>
		<addAll public="1" set="method" line="11494"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_ColArbiter"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="11512"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="11517"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></inlined_insert>
		<pop public="1" set="method" line="11560"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="11565"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="11598"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="11603"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="11616"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="11627"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="11652"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="11665"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="11688"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="11693"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></inlined_erase>
		<splice public="1" set="method" line="11739"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></splice>
		<clear public="1" set="method" line="11743"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="11748"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="11754"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="11769"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="11774"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="11777"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="11782"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="11812"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></front>
		<back public="1" set="method" line="11815"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></back>
		<iterator_at public="1" set="method" line="11824"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></iterator_at>
		<at public="1" set="method" line="11837"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
</f></at>
		<new public="1" set="method" line="11436"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_FluidArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></head>
		<begin public="1" get="inline" set="null" line="11856"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="11864"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="11869"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="11874"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
</f></inlined_add>
		<addAll public="1" set="method" line="11911"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="11929"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="11934"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></inlined_insert>
		<pop public="1" set="method" line="11977"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="11982"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="12015"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="12020"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="12033"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="12044"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="12069"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="12082"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="12105"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="12110"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></inlined_erase>
		<splice public="1" set="method" line="12156"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></splice>
		<clear public="1" set="method" line="12160"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="12165"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="12171"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="12186"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="12191"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="12194"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="12199"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="12229"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></front>
		<back public="1" set="method" line="12232"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></back>
		<iterator_at public="1" set="method" line="12241"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></iterator_at>
		<at public="1" set="method" line="12254"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
</f></at>
		<new public="1" set="method" line="11853"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SensorArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></head>
		<begin public="1" get="inline" set="null" line="12273"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="12281"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="12286"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="12291"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
</f></inlined_add>
		<addAll public="1" set="method" line="12328"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="12346"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="12351"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></inlined_insert>
		<pop public="1" set="method" line="12394"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="12399"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="12432"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="12437"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="12450"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="12461"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="12486"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="12499"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="12522"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="12527"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></inlined_erase>
		<splice public="1" set="method" line="12573"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></splice>
		<clear public="1" set="method" line="12577"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="12582"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="12588"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="12603"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="12608"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="12611"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="12616"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="12646"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></front>
		<back public="1" set="method" line="12649"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></back>
		<iterator_at public="1" set="method" line="12658"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></iterator_at>
		<at public="1" set="method" line="12671"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
</f></at>
		<new public="1" set="method" line="12270"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Listener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></head>
		<begin public="1" get="inline" set="null" line="12690"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="12698"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="12703"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="12708"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
</f></inlined_add>
		<addAll public="1" set="method" line="12745"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Listener"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="12763"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="12768"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></inlined_insert>
		<pop public="1" set="method" line="12811"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="12816"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="12849"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="12854"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="12867"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="12878"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="12903"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="12916"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="12939"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="12944"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></inlined_erase>
		<splice public="1" set="method" line="12990"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></splice>
		<clear public="1" set="method" line="12994"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="12999"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="13005"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="13020"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="13025"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="13028"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="13033"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="13063"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></front>
		<back public="1" set="method" line="13066"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></back>
		<iterator_at public="1" set="method" line="13075"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></iterator_at>
		<at public="1" set="method" line="13088"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
</f></at>
		<new public="1" set="method" line="12687"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_ToiEvent" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></head>
		<begin public="1" get="inline" set="null" line="13107"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="13115"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="13120"><f a="o">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="13125"><f a="o">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
</f></inlined_add>
		<addAll public="1" set="method" line="13162"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_ToiEvent"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="13180"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="13185"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></inlined_insert>
		<pop public="1" set="method" line="13228"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="13233"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="13266"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="13271"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="13284"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="13295"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="13320"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="13333"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="13356"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="13361"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></inlined_erase>
		<splice public="1" set="method" line="13407"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></splice>
		<clear public="1" set="method" line="13411"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="13416"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="13422"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="13437"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="13442"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="13445"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="13450"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="13480"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></front>
		<back public="1" set="method" line="13483"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></back>
		<iterator_at public="1" set="method" line="13492"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></iterator_at>
		<at public="1" set="method" line="13505"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
</f></at>
		<new public="1" set="method" line="13104"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ConvexResult" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></head>
		<begin public="1" get="inline" set="null" line="13524"><f a=""><c path="zpp_nape.util.ZNPNode_ConvexResult"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="13532"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="13537"><f a="o">
	<c path="nape.geom.ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="13542"><f a="o">
	<c path="nape.geom.ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
</f></inlined_add>
		<addAll public="1" set="method" line="13579"><f a="x">
	<c path="zpp_nape.util.ZNPList_ConvexResult"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="13597"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="13602"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></inlined_insert>
		<pop public="1" set="method" line="13645"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="13650"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="13683"><f a=""><c path="nape.geom.ConvexResult"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="13688"><f a=""><c path="nape.geom.ConvexResult"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="13701"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="13712"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="13737"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="13750"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="13773"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="13778"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></inlined_erase>
		<splice public="1" set="method" line="13824"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></splice>
		<clear public="1" set="method" line="13828"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="13833"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="13839"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="13854"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="13859"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="13862"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="13867"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="13897"><f a=""><c path="nape.geom.ConvexResult"/></f></front>
		<back public="1" set="method" line="13900"><f a=""><c path="nape.geom.ConvexResult"/></f></back>
		<iterator_at public="1" set="method" line="13909"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></iterator_at>
		<at public="1" set="method" line="13922"><f a="ind">
	<x path="Int"/>
	<c path="nape.geom.ConvexResult"/>
</f></at>
		<new public="1" set="method" line="13521"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_GeomPoly" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></head>
		<begin public="1" get="inline" set="null" line="13941"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="13949"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="13954"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="13959"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
</f></inlined_add>
		<addAll public="1" set="method" line="13996"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomPoly"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="14014"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="14019"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></inlined_insert>
		<pop public="1" set="method" line="14062"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="14067"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="14100"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="14105"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="14118"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="14129"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="14154"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="14167"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="14190"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="14195"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></inlined_erase>
		<splice public="1" set="method" line="14241"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></splice>
		<clear public="1" set="method" line="14245"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="14250"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="14256"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="14271"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="14276"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="14279"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="14284"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="14314"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></front>
		<back public="1" set="method" line="14317"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></back>
		<iterator_at public="1" set="method" line="14326"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></iterator_at>
		<at public="1" set="method" line="14339"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
</f></at>
		<new public="1" set="method" line="13938"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_RayResult" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<head public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></head>
		<begin public="1" get="inline" set="null" line="14358"><f a=""><c path="zpp_nape.util.ZNPNode_RayResult"/></f></begin>
		<modified public="1"><x path="Bool"/></modified>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<length public="1"><x path="Int"/></length>
		<setbegin public="1" get="inline" set="null" line="14366"><f a="i">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<x path="Void"/>
</f></setbegin>
		<add public="1" set="method" line="14371"><f a="o">
	<c path="nape.geom.RayResult"/>
	<c path="nape.geom.RayResult"/>
</f></add>
		<inlined_add public="1" get="inline" set="null" line="14376"><f a="o">
	<c path="nape.geom.RayResult"/>
	<c path="nape.geom.RayResult"/>
</f></inlined_add>
		<addAll public="1" set="method" line="14413"><f a="x">
	<c path="zpp_nape.util.ZNPList_RayResult"/>
	<x path="Void"/>
</f></addAll>
		<insert public="1" set="method" line="14431"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="nape.geom.RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></insert>
		<inlined_insert public="1" get="inline" set="null" line="14436"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="nape.geom.RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></inlined_insert>
		<pop public="1" set="method" line="14479"><f a=""><x path="Void"/></f></pop>
		<inlined_pop public="1" get="inline" set="null" line="14484"><f a=""><x path="Void"/></f></inlined_pop>
		<pop_unsafe public="1" set="method" line="14517"><f a=""><c path="nape.geom.RayResult"/></f></pop_unsafe>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="14522"><f a=""><c path="nape.geom.RayResult"/></f></inlined_pop_unsafe>
		<remove public="1" set="method" line="14535"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></remove>
		<try_remove public="1" set="method" line="14546"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></try_remove>
		<inlined_remove public="1" get="inline" set="null" line="14571"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></inlined_remove>
		<inlined_try_remove public="1" get="inline" set="null" line="14584"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<erase public="1" set="method" line="14607"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></erase>
		<inlined_erase public="1" get="inline" set="null" line="14612"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></inlined_erase>
		<splice public="1" set="method" line="14658"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></splice>
		<clear public="1" set="method" line="14662"><f a=""><x path="Void"/></f></clear>
		<inlined_clear public="1" get="inline" set="null" line="14667"><f a=""><x path="Void"/></f></inlined_clear>
		<reverse public="1" set="method" line="14673"><f a=""><x path="Void"/></f></reverse>
		<empty public="1" get="inline" set="null" line="14688"><f a=""><x path="Bool"/></f></empty>
		<size public="1" get="inline" set="null" line="14693"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="14696"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></has>
		<inlined_has public="1" get="inline" set="null" line="14701"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></inlined_has>
		<front public="1" get="inline" set="null" line="14731"><f a=""><c path="nape.geom.RayResult"/></f></front>
		<back public="1" set="method" line="14734"><f a=""><c path="nape.geom.RayResult"/></f></back>
		<iterator_at public="1" set="method" line="14743"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></iterator_at>
		<at public="1" set="method" line="14756"><f a="ind">
	<x path="Int"/>
	<c path="nape.geom.RayResult"/>
</f></at>
		<new public="1" set="method" line="14355"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CbType" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14772" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></next>
		<alloc public="1" get="inline" set="null" line="14799"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="14802"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_CbType"/></elt>
		<elem public="1" get="inline" set="null" line="14809"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></elem>
		<new public="1" set="method" line="14806"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CallbackSet" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14815" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></next>
		<alloc public="1" get="inline" set="null" line="14842"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="14845"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></elt>
		<elem public="1" get="inline" set="null" line="14852"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></elem>
		<new public="1" set="method" line="14849"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Shape" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14858" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></next>
		<alloc public="1" get="inline" set="null" line="14885"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="14888"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.shape.ZPP_Shape"/></elt>
		<elem public="1" get="inline" set="null" line="14895"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></elem>
		<new public="1" set="method" line="14892"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Body" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14901" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></next>
		<alloc public="1" get="inline" set="null" line="14928"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="14931"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.phys.ZPP_Body"/></elt>
		<elem public="1" get="inline" set="null" line="14938"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></elem>
		<new public="1" set="method" line="14935"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Constraint" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14944" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></next>
		<alloc public="1" get="inline" set="null" line="14971"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="14974"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.constraint.ZPP_Constraint"/></elt>
		<elem public="1" get="inline" set="null" line="14981"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></elem>
		<new public="1" set="method" line="14978"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Compound" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14987" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></next>
		<alloc public="1" get="inline" set="null" line="15014"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15017"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.phys.ZPP_Compound"/></elt>
		<elem public="1" get="inline" set="null" line="15024"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></elem>
		<new public="1" set="method" line="15021"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Arbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15030" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></next>
		<alloc public="1" get="inline" set="null" line="15057"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15060"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></elt>
		<elem public="1" get="inline" set="null" line="15067"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></elem>
		<new public="1" set="method" line="15064"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_InteractionListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15073" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></next>
		<alloc public="1" get="inline" set="null" line="15100"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15103"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></elt>
		<elem public="1" get="inline" set="null" line="15110"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></elem>
		<new public="1" set="method" line="15107"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CbSet" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15116" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></next>
		<alloc public="1" get="inline" set="null" line="15143"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15146"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></elt>
		<elem public="1" get="inline" set="null" line="15153"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></elem>
		<new public="1" set="method" line="15150"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Interactor" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15159" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></next>
		<alloc public="1" get="inline" set="null" line="15186"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15189"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></elt>
		<elem public="1" get="inline" set="null" line="15196"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></elem>
		<new public="1" set="method" line="15193"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_BodyListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15202" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></next>
		<alloc public="1" get="inline" set="null" line="15229"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15232"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_BodyListener"/></elt>
		<elem public="1" get="inline" set="null" line="15239"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></elem>
		<new public="1" set="method" line="15236"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CbSetPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15245" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></next>
		<alloc public="1" get="inline" set="null" line="15272"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15275"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></elt>
		<elem public="1" get="inline" set="null" line="15282"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></elem>
		<new public="1" set="method" line="15279"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15288" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></next>
		<alloc public="1" get="inline" set="null" line="15315"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15318"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></elt>
		<elem public="1" get="inline" set="null" line="15325"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></elem>
		<new public="1" set="method" line="15322"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CutInt" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15331" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></next>
		<alloc public="1" get="inline" set="null" line="15358"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15361"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_CutInt"/></elt>
		<elem public="1" get="inline" set="null" line="15368"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></elem>
		<new public="1" set="method" line="15365"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CutVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15374" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></next>
		<alloc public="1" get="inline" set="null" line="15401"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15404"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></elt>
		<elem public="1" get="inline" set="null" line="15411"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></elem>
		<new public="1" set="method" line="15408"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15417" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></next>
		<alloc public="1" get="inline" set="null" line="15444"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15447"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></elt>
		<elem public="1" get="inline" set="null" line="15454"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></elem>
		<new public="1" set="method" line="15451"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15460" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></next>
		<alloc public="1" get="inline" set="null" line="15487"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15490"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></elt>
		<elem public="1" get="inline" set="null" line="15497"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></elem>
		<new public="1" set="method" line="15494"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SimplifyP" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15503" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></next>
		<alloc public="1" get="inline" set="null" line="15530"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15533"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_SimplifyP"/></elt>
		<elem public="1" get="inline" set="null" line="15540"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></elem>
		<new public="1" set="method" line="15537"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_GeomVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15546" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></next>
		<alloc public="1" get="inline" set="null" line="15573"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15576"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></elt>
		<elem public="1" get="inline" set="null" line="15583"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></elem>
		<new public="1" set="method" line="15580"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SimpleVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15589" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></next>
		<alloc public="1" get="inline" set="null" line="15616"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15619"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></elt>
		<elem public="1" get="inline" set="null" line="15626"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></elem>
		<new public="1" set="method" line="15623"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15632" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></next>
		<alloc public="1" get="inline" set="null" line="15659"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15662"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></elt>
		<elem public="1" get="inline" set="null" line="15669"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></elem>
		<new public="1" set="method" line="15666"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_AABBPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15675" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></next>
		<alloc public="1" get="inline" set="null" line="15702"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15705"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></elt>
		<elem public="1" get="inline" set="null" line="15712"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></elem>
		<new public="1" set="method" line="15709"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Vec2" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15718" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></next>
		<alloc public="1" get="inline" set="null" line="15745"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15748"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></elt>
		<elem public="1" get="inline" set="null" line="15755"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></elem>
		<new public="1" set="method" line="15752"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Edge" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15761" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></next>
		<alloc public="1" get="inline" set="null" line="15788"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15791"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.shape.ZPP_Edge"/></elt>
		<elem public="1" get="inline" set="null" line="15798"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></elem>
		<new public="1" set="method" line="15795"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_AABBNode" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15804" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></next>
		<alloc public="1" get="inline" set="null" line="15831"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15834"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></elt>
		<elem public="1" get="inline" set="null" line="15841"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></elem>
		<new public="1" set="method" line="15838"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Component" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15847" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></next>
		<alloc public="1" get="inline" set="null" line="15874"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15877"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.space.ZPP_Component"/></elt>
		<elem public="1" get="inline" set="null" line="15884"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></elem>
		<new public="1" set="method" line="15881"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15890" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></next>
		<alloc public="1" get="inline" set="null" line="15917"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15920"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></elt>
		<elem public="1" get="inline" set="null" line="15927"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></elem>
		<new public="1" set="method" line="15924"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_ColArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15933" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></next>
		<alloc public="1" get="inline" set="null" line="15960"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="15963"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></elt>
		<elem public="1" get="inline" set="null" line="15970"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></elem>
		<new public="1" set="method" line="15967"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15976" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></next>
		<alloc public="1" get="inline" set="null" line="16003"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="16006"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></elt>
		<elem public="1" get="inline" set="null" line="16013"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></elem>
		<new public="1" set="method" line="16010"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16019" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></next>
		<alloc public="1" get="inline" set="null" line="16046"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="16049"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></elt>
		<elem public="1" get="inline" set="null" line="16056"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></elem>
		<new public="1" set="method" line="16053"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Listener" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16062" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></next>
		<alloc public="1" get="inline" set="null" line="16089"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="16092"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_Listener"/></elt>
		<elem public="1" get="inline" set="null" line="16099"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></elem>
		<new public="1" set="method" line="16096"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_ToiEvent" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16105" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></next>
		<alloc public="1" get="inline" set="null" line="16132"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="16135"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_ToiEvent"/></elt>
		<elem public="1" get="inline" set="null" line="16142"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></elem>
		<new public="1" set="method" line="16139"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ConvexResult" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16148" static="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></next>
		<alloc public="1" get="inline" set="null" line="16175"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="16178"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="nape.geom.ConvexResult"/></elt>
		<elem public="1" get="inline" set="null" line="16185"><f a=""><c path="nape.geom.ConvexResult"/></f></elem>
		<new public="1" set="method" line="16182"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_GeomPoly" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16191" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></next>
		<alloc public="1" get="inline" set="null" line="16218"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="16221"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="zpp_nape.geom.ZPP_GeomPoly"/></elt>
		<elem public="1" get="inline" set="null" line="16228"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></elem>
		<new public="1" set="method" line="16225"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_RayResult" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16234" static="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></zpp_pool>
		<next public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></next>
		<alloc public="1" get="inline" set="null" line="16261"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="16264"><f a=""><x path="Void"/></f></free>
		<elt public="1"><c path="nape.geom.RayResult"/></elt>
		<elem public="1" get="inline" set="null" line="16271"><f a=""><c path="nape.geom.RayResult"/></f></elem>
		<new public="1" set="method" line="16268"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_MixVec2List" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<extends path="nape.geom.Vec2List"/>
		<get public="1" set="method" line="16283" static="1"><f a="list:?immutable" v=":false">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
	<c path="zpp_nape.util.ZPP_MixVec2List"/>
</f></get>
		<inner public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></inner>
		<_length public="1"><x path="Int"/></_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<at_ite public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<zpp_gl public="1" set="method" line="16296" override="1"><f a=""><x path="Int"/></f></zpp_gl>
		<zpp_vm public="1" set="method" line="16312" override="1"><f a=""><x path="Void"/></f></zpp_vm>
		<at public="1" set="method" line="16321" override="1"><f a="index">
	<x path="Int"/>
	<c path="nape.geom.Vec2"/>
</f></at>
		<push public="1" set="method" line="16348" override="1"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></push>
		<unshift public="1" set="method" line="16370" override="1"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></unshift>
		<pop public="1" set="method" line="16392" override="1"><f a=""><c path="nape.geom.Vec2"/></f></pop>
		<shift public="1" set="method" line="16421" override="1"><f a=""><c path="nape.geom.Vec2"/></f></shift>
		<remove public="1" set="method" line="16450" override="1"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></remove>
		<clear public="1" set="method" line="16481" override="1"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="16289"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ConstraintList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16503" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16509" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_Constraint"/>
	<x path="Bool"/>
	<c path="nape.constraint.ConstraintList"/>
</f></get>
		<outer public="1"><c path="nape.constraint.ConstraintList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ConstraintList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="16516"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="16526"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="16531"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="16536"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="16542"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="16551"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_BodyList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16565" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16571" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_Body"/>
	<x path="Bool"/>
	<c path="nape.phys.BodyList"/>
</f></get>
		<outer public="1"><c path="nape.phys.BodyList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_BodyList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="16578"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="16588"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="16593"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="16598"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="16604"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="16613"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_InteractorList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16627" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16633" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_Interactor"/>
	<x path="Bool"/>
	<c path="nape.phys.InteractorList"/>
</f></get>
		<outer public="1"><c path="nape.phys.InteractorList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_InteractorList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.phys.Interactor"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.phys.Interactor"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.phys.Interactor"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="16640"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="16650"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="16655"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="16660"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="16666"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="16675"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_CompoundList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16689" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16695" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_Compound"/>
	<x path="Bool"/>
	<c path="nape.phys.CompoundList"/>
</f></get>
		<outer public="1"><c path="nape.phys.CompoundList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_CompoundList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="16702"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="16712"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="16717"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="16722"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="16728"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="16737"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ListenerList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16751" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16757" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_Listener"/>
	<x path="Bool"/>
	<c path="nape.callbacks.ListenerList"/>
</f></get>
		<outer public="1"><c path="nape.callbacks.ListenerList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Listener"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ListenerList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.callbacks.Listener"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.callbacks.Listener"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="16764"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="16774"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="16779"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="16784"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="16790"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="16799"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_CbTypeList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16813" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16819" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
	<c path="nape.callbacks.CbTypeList"/>
</f></get>
		<outer public="1"><c path="nape.callbacks.CbTypeList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_CbTypeList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="16826"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="16836"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="16841"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="16846"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="16852"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="16861"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Vec2List" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16875" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16881" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_Vec2"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2List"/>
</f></get>
		<outer public="1"><c path="nape.geom.Vec2List"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Vec2"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_Vec2List"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="16888"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="16898"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="16903"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="16908"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="16914"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="16923"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_GeomPolyList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16937" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16943" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomPoly"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
</f></get>
		<outer public="1"><c path="nape.geom.GeomPolyList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_GeomPoly"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_GeomPolyList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.geom.GeomPoly"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.geom.GeomPoly"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.geom.GeomPoly"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="16950"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="16960"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="16965"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="16970"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="16976"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="16985"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_RayResultList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16999" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17005" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_RayResult"/>
	<x path="Bool"/>
	<c path="nape.geom.RayResultList"/>
</f></get>
		<outer public="1"><c path="nape.geom.RayResultList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_RayResult"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_RayResultList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="17012"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="17022"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="17027"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="17032"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="17038"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="17047"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ConvexResultList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17061" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17067" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ConvexResult"/>
	<x path="Bool"/>
	<c path="nape.geom.ConvexResultList"/>
</f></get>
		<outer public="1"><c path="nape.geom.ConvexResultList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ConvexResult"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ConvexResultList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="17074"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="17084"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="17089"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="17094"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="17100"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="17109"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_EdgeList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17123" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17129" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_Edge"/>
	<x path="Bool"/>
	<c path="nape.shape.EdgeList"/>
</f></get>
		<outer public="1"><c path="nape.shape.EdgeList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Edge"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_EdgeList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.shape.Edge"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.shape.Edge"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.shape.Edge"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="17136"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="17146"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="17151"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="17156"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="17162"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="17171"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ShapeList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17185" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17191" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_Shape"/>
	<x path="Bool"/>
	<c path="nape.shape.ShapeList"/>
</f></get>
		<outer public="1"><c path="nape.shape.ShapeList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ShapeList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.shape.Shape"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.shape.Shape"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="17198"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="17208"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="17213"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="17218"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="17224"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="17233"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_InteractionGroupList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17247" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17253" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionGroupList"/>
</f></get>
		<outer public="1"><c path="nape.dynamics.InteractionGroupList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_InteractionGroupList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="17260"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="17270"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="17275"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="17280"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="17286"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="17295"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ArbiterList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17309" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17315" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/>
	<x path="Bool"/>
	<c path="nape.dynamics.ArbiterList"/>
</f></get>
		<outer public="1"><c path="nape.dynamics.ArbiterList"/></outer>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ArbiterList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="17322"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="17332"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="17337"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="17342"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="17348"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="17357"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ContactList" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17371" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17377" static="1"><f a="list:?imm" v=":false">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
	<c path="nape.dynamics.ContactList"/>
</f></get>
		<outer public="1"><c path="nape.dynamics.ContactList"/></outer>
		<inner public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></inner>
		<immutable public="1"><x path="Bool"/></immutable>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ContactList"/>
	<x path="Void"/>
</f></_invalidate>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<adder public="1"><f a="">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></adder>
		<post_adder public="1"><f a="">
	<c path="nape.dynamics.Contact"/>
	<x path="Void"/>
</f></post_adder>
		<subber public="1"><f a="">
	<c path="nape.dynamics.Contact"/>
	<x path="Void"/>
</f></subber>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<valmod public="1" set="method" line="17384"><f a=""><x path="Void"/></f></valmod>
		<modified public="1" set="method" line="17394"><f a=""><x path="Void"/></f></modified>
		<modify_test public="1" set="method" line="17399"><f a=""><x path="Void"/></f></modify_test>
		<validate public="1" set="method" line="17404"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" set="method" line="17410"><f a=""><x path="Void"/></f></invalidate>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></at_ite>
		<push_ite public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></push_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<user_length public="1"><x path="Int"/></user_length>
		<new public="1" set="method" line="17419"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Math" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Math.hx" module="zpp_nape.util.Math">
		<sqrt public="1" get="inline" set="null" line="179" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<invsqrt public="1" get="inline" set="null" line="193" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></invsqrt>
		<sqr public="1" get="inline" set="null" line="210" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></sqr>
		<clamp2 public="1" get="inline" set="null" line="222" static="1"><f a="x:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp2>
		<clamp public="1" get="inline" set="null" line="234" static="1"><f a="x:a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp>
	</class>
	<class path="zpp_nape.util.ZPP_PubPool" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/Pool.hx" module="zpp_nape.util.Pool">
		<poolGeomPoly public="1" line="176" static="1"><c path="nape.geom.GeomPoly"/></poolGeomPoly>
		<nextGeomPoly public="1" line="178" static="1"><c path="nape.geom.GeomPoly"/></nextGeomPoly>
		<poolVec2 public="1" line="180" static="1"><c path="nape.geom.Vec2"/></poolVec2>
		<nextVec2 public="1" line="182" static="1"><c path="nape.geom.Vec2"/></nextVec2>
		<poolVec3 public="1" line="184" static="1"><c path="nape.geom.Vec3"/></poolVec3>
		<nextVec3 public="1" line="186" static="1"><c path="nape.geom.Vec3"/></nextVec3>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_Body" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></zpp_pool>
		<free public="1" get="inline" set="null" line="202"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="209"><f a=""><x path="Void"/></f></alloc>
		<lt public="1"><f a=":">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></lt>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></swapped>
		<data public="1"><c path="zpp_nape.phys.ZPP_Body"/></data>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></prev>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></next>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></parent>
		<colour public="1"><x path="Int"/></colour>
		<verify public="1" set="method" line="218"><f a=""><x path="Bool"/></f></verify>
		<empty public="1" set="method" line="283"><f a=""><x path="Bool"/></f></empty>
		<singular public="1" set="method" line="286"><f a=""><x path="Bool"/></f></singular>
		<size public="1" set="method" line="289"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="319"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></has>
		<find public="1" set="method" line="322"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></find>
		<has_weak public="1" set="method" line="330"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></has_weak>
		<find_weak public="1" set="method" line="333"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></find_weak>
		<lower_bound public="1" set="method" line="342"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></lower_bound>
		<first public="1" set="method" line="379"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></first>
		<pop_front public="1" set="method" line="392"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></pop_front>
		<remove public="1" set="method" line="407"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></remove>
		<successor_node public="1" set="method" line="419"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></successor_node>
		<predecessor_node public="1" set="method" line="442"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></predecessor_node>
		<successor public="1" set="method" line="465"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<t path="Null"><c path="zpp_nape.phys.ZPP_Body"/></t>
</f></successor>
		<predecessor public="1" set="method" line="477"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<t path="Null"><c path="zpp_nape.phys.ZPP_Body"/></t>
</f></predecessor>
		<remove_node public="1" set="method" line="489"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<x path="Void"/>
</f></remove_node>
		<clear public="1" set="method" line="609"><f a=""><x path="Void"/></f></clear>
		<clear_with public="1" get="inline" set="null" line="613"><f a="lambda">
	<f a="">
		<c path="zpp_nape.phys.ZPP_Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear_node get="inline" set="null" line="622"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<f a="">
		<c path="zpp_nape.phys.ZPP_Body"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></clear_node>
		<__fix_neg_red public="1" set="method" line="657"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<__fix_dbl_red public="1" set="method" line="724"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<try_insert_bool public="1" set="method" line="813"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<try_insert public="1" set="method" line="905"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></try_insert>
		<insert public="1" set="method" line="997"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></insert>
		<new public="1" set="method" line="217"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="1065" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></zpp_pool>
		<free public="1" get="inline" set="null" line="1091"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="1098"><f a=""><x path="Void"/></f></alloc>
		<lt public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></lt>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></swapped>
		<data public="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></data>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></prev>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></next>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></parent>
		<colour public="1"><x path="Int"/></colour>
		<verify public="1" set="method" line="1107"><f a=""><x path="Bool"/></f></verify>
		<empty public="1" set="method" line="1172"><f a=""><x path="Bool"/></f></empty>
		<singular public="1" set="method" line="1175"><f a=""><x path="Bool"/></f></singular>
		<size public="1" set="method" line="1178"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="1208"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></has>
		<find public="1" set="method" line="1211"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></find>
		<has_weak public="1" set="method" line="1219"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></has_weak>
		<find_weak public="1" set="method" line="1222"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></find_weak>
		<lower_bound public="1" set="method" line="1231"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></lower_bound>
		<first public="1" set="method" line="1268"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></first>
		<pop_front public="1" set="method" line="1281"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></pop_front>
		<remove public="1" set="method" line="1296"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></remove>
		<successor_node public="1" set="method" line="1308"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></successor_node>
		<predecessor_node public="1" set="method" line="1331"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></predecessor_node>
		<successor public="1" set="method" line="1354"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<t path="Null"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></t>
</f></successor>
		<predecessor public="1" set="method" line="1366"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<t path="Null"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></t>
</f></predecessor>
		<remove_node public="1" set="method" line="1378"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></remove_node>
		<clear public="1" set="method" line="1498"><f a=""><x path="Void"/></f></clear>
		<clear_with public="1" get="inline" set="null" line="1502"><f a="lambda">
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear_node get="inline" set="null" line="1511"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></clear_node>
		<__fix_neg_red public="1" set="method" line="1546"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<__fix_dbl_red public="1" set="method" line="1613"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<try_insert_bool public="1" set="method" line="1702"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<try_insert public="1" set="method" line="1794"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></try_insert>
		<insert public="1" set="method" line="1886"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></insert>
		<new public="1" set="method" line="1106"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="1954" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></zpp_pool>
		<free public="1" get="inline" set="null" line="1980"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="1987"><f a=""><x path="Void"/></f></alloc>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></lt>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></swapped>
		<data public="1"><c path="zpp_nape.geom.ZPP_PartitionPair"/></data>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></prev>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></next>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></parent>
		<colour public="1"><x path="Int"/></colour>
		<verify public="1" set="method" line="1996"><f a=""><x path="Bool"/></f></verify>
		<empty public="1" set="method" line="2061"><f a=""><x path="Bool"/></f></empty>
		<singular public="1" set="method" line="2064"><f a=""><x path="Bool"/></f></singular>
		<size public="1" set="method" line="2067"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="2097"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></has>
		<find public="1" set="method" line="2100"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></find>
		<has_weak public="1" set="method" line="2108"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></has_weak>
		<find_weak public="1" set="method" line="2111"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></find_weak>
		<lower_bound public="1" set="method" line="2120"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></lower_bound>
		<first public="1" set="method" line="2157"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></first>
		<pop_front public="1" set="method" line="2170"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></pop_front>
		<remove public="1" set="method" line="2185"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></remove>
		<successor_node public="1" set="method" line="2197"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></successor_node>
		<predecessor_node public="1" set="method" line="2220"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></predecessor_node>
		<successor public="1" set="method" line="2243"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_PartitionPair"/></t>
</f></successor>
		<predecessor public="1" set="method" line="2255"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_PartitionPair"/></t>
</f></predecessor>
		<remove_node public="1" set="method" line="2267"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<x path="Void"/>
</f></remove_node>
		<clear public="1" set="method" line="2387"><f a=""><x path="Void"/></f></clear>
		<clear_with public="1" get="inline" set="null" line="2391"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionPair"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear_node get="inline" set="null" line="2400"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionPair"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></clear_node>
		<__fix_neg_red public="1" set="method" line="2435"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<__fix_dbl_red public="1" set="method" line="2502"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<try_insert_bool public="1" set="method" line="2591"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<try_insert public="1" set="method" line="2683"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></try_insert>
		<insert public="1" set="method" line="2775"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></insert>
		<new public="1" set="method" line="1995"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="2843" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></zpp_pool>
		<free public="1" get="inline" set="null" line="2869"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="2876"><f a=""><x path="Void"/></f></alloc>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></lt>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></swapped>
		<data public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></data>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></prev>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></next>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></parent>
		<colour public="1"><x path="Int"/></colour>
		<verify public="1" set="method" line="2885"><f a=""><x path="Bool"/></f></verify>
		<empty public="1" set="method" line="2950"><f a=""><x path="Bool"/></f></empty>
		<singular public="1" set="method" line="2953"><f a=""><x path="Bool"/></f></singular>
		<size public="1" set="method" line="2956"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="2986"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></has>
		<find public="1" set="method" line="2989"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></find>
		<has_weak public="1" set="method" line="2997"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></has_weak>
		<find_weak public="1" set="method" line="3000"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></find_weak>
		<lower_bound public="1" set="method" line="3009"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></lower_bound>
		<first public="1" set="method" line="3046"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></first>
		<pop_front public="1" set="method" line="3059"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></pop_front>
		<remove public="1" set="method" line="3074"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></remove>
		<successor_node public="1" set="method" line="3086"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></successor_node>
		<predecessor_node public="1" set="method" line="3109"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></predecessor_node>
		<successor public="1" set="method" line="3132"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></t>
</f></successor>
		<predecessor public="1" set="method" line="3144"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></t>
</f></predecessor>
		<remove_node public="1" set="method" line="3156"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></remove_node>
		<clear public="1" set="method" line="3276"><f a=""><x path="Void"/></f></clear>
		<clear_with public="1" get="inline" set="null" line="3280"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear_node get="inline" set="null" line="3289"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></clear_node>
		<__fix_neg_red public="1" set="method" line="3324"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<__fix_dbl_red public="1" set="method" line="3391"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<try_insert_bool public="1" set="method" line="3480"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<try_insert public="1" set="method" line="3572"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></try_insert>
		<insert public="1" set="method" line="3664"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></insert>
		<new public="1" set="method" line="2884"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="3732" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></zpp_pool>
		<free public="1" get="inline" set="null" line="3758"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="3765"><f a=""><x path="Void"/></f></alloc>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></lt>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></swapped>
		<data public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></data>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></prev>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></next>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></parent>
		<colour public="1"><x path="Int"/></colour>
		<verify public="1" set="method" line="3774"><f a=""><x path="Bool"/></f></verify>
		<empty public="1" set="method" line="3839"><f a=""><x path="Bool"/></f></empty>
		<singular public="1" set="method" line="3842"><f a=""><x path="Bool"/></f></singular>
		<size public="1" set="method" line="3845"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="3875"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></has>
		<find public="1" set="method" line="3878"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></find>
		<has_weak public="1" set="method" line="3886"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></has_weak>
		<find_weak public="1" set="method" line="3889"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></find_weak>
		<lower_bound public="1" set="method" line="3898"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></lower_bound>
		<first public="1" set="method" line="3935"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></first>
		<pop_front public="1" set="method" line="3948"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></pop_front>
		<remove public="1" set="method" line="3963"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></remove>
		<successor_node public="1" set="method" line="3975"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></successor_node>
		<predecessor_node public="1" set="method" line="3998"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></predecessor_node>
		<successor public="1" set="method" line="4021"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleVert"/></t>
</f></successor>
		<predecessor public="1" set="method" line="4033"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleVert"/></t>
</f></predecessor>
		<remove_node public="1" set="method" line="4045"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></remove_node>
		<clear public="1" set="method" line="4165"><f a=""><x path="Void"/></f></clear>
		<clear_with public="1" get="inline" set="null" line="4169"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleVert"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear_node get="inline" set="null" line="4178"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleVert"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></clear_node>
		<__fix_neg_red public="1" set="method" line="4213"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<__fix_dbl_red public="1" set="method" line="4280"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<try_insert_bool public="1" set="method" line="4369"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<try_insert public="1" set="method" line="4461"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></try_insert>
		<insert public="1" set="method" line="4553"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></insert>
		<new public="1" set="method" line="3773"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="4621" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></zpp_pool>
		<free public="1" get="inline" set="null" line="4647"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="4654"><f a=""><x path="Void"/></f></alloc>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></lt>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></swapped>
		<data public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></data>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></prev>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></next>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></parent>
		<colour public="1"><x path="Int"/></colour>
		<verify public="1" set="method" line="4663"><f a=""><x path="Bool"/></f></verify>
		<empty public="1" set="method" line="4728"><f a=""><x path="Bool"/></f></empty>
		<singular public="1" set="method" line="4731"><f a=""><x path="Bool"/></f></singular>
		<size public="1" set="method" line="4734"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="4764"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></has>
		<find public="1" set="method" line="4767"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></find>
		<has_weak public="1" set="method" line="4775"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></has_weak>
		<find_weak public="1" set="method" line="4778"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></find_weak>
		<lower_bound public="1" set="method" line="4787"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></lower_bound>
		<first public="1" set="method" line="4824"><f a=""><c path="zpp_nape.geom.ZPP_SimpleSeg"/></f></first>
		<pop_front public="1" set="method" line="4837"><f a=""><c path="zpp_nape.geom.ZPP_SimpleSeg"/></f></pop_front>
		<remove public="1" set="method" line="4852"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></remove>
		<successor_node public="1" set="method" line="4864"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></successor_node>
		<predecessor_node public="1" set="method" line="4887"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></predecessor_node>
		<successor public="1" set="method" line="4910"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></t>
</f></successor>
		<predecessor public="1" set="method" line="4922"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></t>
</f></predecessor>
		<remove_node public="1" set="method" line="4934"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></remove_node>
		<clear public="1" set="method" line="5054"><f a=""><x path="Void"/></f></clear>
		<clear_with public="1" get="inline" set="null" line="5058"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear_node get="inline" set="null" line="5067"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></clear_node>
		<__fix_neg_red public="1" set="method" line="5102"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<__fix_dbl_red public="1" set="method" line="5169"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<try_insert_bool public="1" set="method" line="5258"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<try_insert public="1" set="method" line="5350"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></try_insert>
		<insert public="1" set="method" line="5442"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></insert>
		<new public="1" set="method" line="4662"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="5510" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></zpp_pool>
		<free public="1" get="inline" set="null" line="5536"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="5543"><f a=""><x path="Void"/></f></alloc>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></lt>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></swapped>
		<data public="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></data>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></prev>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></next>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></parent>
		<colour public="1"><x path="Int"/></colour>
		<verify public="1" set="method" line="5552"><f a=""><x path="Bool"/></f></verify>
		<empty public="1" set="method" line="5617"><f a=""><x path="Bool"/></f></empty>
		<singular public="1" set="method" line="5620"><f a=""><x path="Bool"/></f></singular>
		<size public="1" set="method" line="5623"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="5653"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></has>
		<find public="1" set="method" line="5656"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></find>
		<has_weak public="1" set="method" line="5664"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></has_weak>
		<find_weak public="1" set="method" line="5667"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></find_weak>
		<lower_bound public="1" set="method" line="5676"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></lower_bound>
		<first public="1" set="method" line="5713"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></first>
		<pop_front public="1" set="method" line="5726"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></pop_front>
		<remove public="1" set="method" line="5741"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></remove>
		<successor_node public="1" set="method" line="5753"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></successor_node>
		<predecessor_node public="1" set="method" line="5776"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></predecessor_node>
		<successor public="1" set="method" line="5799"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></t>
</f></successor>
		<predecessor public="1" set="method" line="5811"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></t>
</f></predecessor>
		<remove_node public="1" set="method" line="5823"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></remove_node>
		<clear public="1" set="method" line="5943"><f a=""><x path="Void"/></f></clear>
		<clear_with public="1" get="inline" set="null" line="5947"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear_node get="inline" set="null" line="5956"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></clear_node>
		<__fix_neg_red public="1" set="method" line="5991"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<__fix_dbl_red public="1" set="method" line="6058"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<try_insert_bool public="1" set="method" line="6147"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<try_insert public="1" set="method" line="6239"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></try_insert>
		<insert public="1" set="method" line="6331"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></insert>
		<new public="1" set="method" line="5551"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_CbSet" params="" file="C:\HaxeToolkit\haxe\lib/nape/2,0,16/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="6399" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></zpp_pool>
		<free public="1" get="inline" set="null" line="6425"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="6432"><f a=""><x path="Void"/></f></alloc>
		<lt public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></lt>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></swapped>
		<data public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></data>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></prev>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></next>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></parent>
		<colour public="1"><x path="Int"/></colour>
		<verify public="1" set="method" line="6441"><f a=""><x path="Bool"/></f></verify>
		<empty public="1" set="method" line="6506"><f a=""><x path="Bool"/></f></empty>
		<singular public="1" set="method" line="6509"><f a=""><x path="Bool"/></f></singular>
		<size public="1" set="method" line="6512"><f a=""><x path="Int"/></f></size>
		<has public="1" set="method" line="6542"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></has>
		<find public="1" set="method" line="6545"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></find>
		<has_weak public="1" set="method" line="6553"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></has_weak>
		<find_weak public="1" set="method" line="6556"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></find_weak>
		<lower_bound public="1" set="method" line="6565"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></lower_bound>
		<first public="1" set="method" line="6602"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></first>
		<pop_front public="1" set="method" line="6615"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></pop_front>
		<remove public="1" set="method" line="6630"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></remove>
		<successor_node public="1" set="method" line="6642"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></successor_node>
		<predecessor_node public="1" set="method" line="6665"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></predecessor_node>
		<successor public="1" set="method" line="6688"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<t path="Null"><c path="zpp_nape.callbacks.ZPP_CbSet"/></t>
</f></successor>
		<predecessor public="1" set="method" line="6700"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<t path="Null"><c path="zpp_nape.callbacks.ZPP_CbSet"/></t>
</f></predecessor>
		<remove_node public="1" set="method" line="6712"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<x path="Void"/>
</f></remove_node>
		<clear public="1" set="method" line="6832"><f a=""><x path="Void"/></f></clear>
		<clear_with public="1" get="inline" set="null" line="6836"><f a="lambda">
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear_node get="inline" set="null" line="6845"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></clear_node>
		<__fix_neg_red public="1" set="method" line="6880"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<__fix_dbl_red public="1" set="method" line="6947"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<try_insert_bool public="1" set="method" line="7036"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<try_insert public="1" set="method" line="7128"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></try_insert>
		<insert public="1" set="method" line="7220"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></insert>
		<new public="1" set="method" line="6440"><f a=""><x path="Void"/></f></new>
	</class>
</haxe>
<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../bootstrap-combined.min.css" rel="stylesheet" /><script type="text/javascript" src="../../jquery-1.9.1.min.js"></script><script type="text/javascript" src="../../bootstrap.min.js"></script><link href="../../styles.css" rel="stylesheet" /><link rel="icon" href="../../favicon.ico" type="image/x-icon"></link><script type="text/javascript" src="../../nav.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["flash"]};</script><title>Space</title></head><body><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><form class="navbar-search pull-left" id="searchForm"><input id="search" type="text" class="search-query" placeholder="Filter" autocomplete="off"/></form><ul class="nav"><li id="select-platform" class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Platform<b class="caret"></b></a><ul class="dropdown-menu"><li data="all"><a href="#">All Platforms</a></li><li data="flash"><a href="#">flash</a></li></ul></li></ul></div></div><div id="container"><div id="nav"></div><div id="content"><div class="header"><h1><code><span class="directive">class </span><span class="type">nape.space.Space</span></code></h1></div><div class="body"><p class="availability">Available on all platforms</p><div class="doc"><p>The heart of all Nape simulations.</p></div><h2>Instance Fields</h2><div class="platform platform-flash"><a name="arbiters"></a><h3><p><code><span class="keyword">var</span> <a href="#arbiters"><span class="identifier">arbiters</span></a>:<a class="type" href="../../nape/dynamics/ArbiterList.html">ArbiterList</a></code></p></h3><div class="doc"><p>List of all active arbiters in Space.
     * <br/><br/>
     * This list is immutable.</p></div></div><div class="platform platform-flash"><a name="bodies"></a><h3><p><code><span class="keyword">var</span> <a href="#bodies"><span class="identifier">bodies</span></a>:<a class="type" href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>List of all Bodys directly placed in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Body to this Space equivalent to: <code>body.space = space</code>
     * <br/><br/>
     * This list is only those bodies directly placed in the space, any
     * body that is a child of a Compound will not be in this list.</p></div></div><div class="platform platform-flash"><a name="broadphase"></a><h3><p><code><span class="keyword">var</span> <a href="#broadphase"><span class="identifier">broadphase</span></a>:<a class="type" href="../../nape/space/Broadphase.html">Broadphase</a></code></p></h3><div class="doc"><p>Broadphase type in use.</p></div></div><div class="platform platform-flash"><a name="compounds"></a><h3><p><code><span class="keyword">var</span> <a href="#compounds"><span class="identifier">compounds</span></a>:<a class="type" href="../../nape/phys/CompoundList.html">CompoundList</a></code></p></h3><div class="doc"><p>List of all Compounds directly placed in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Compound to this Space equivalent to: <code>compound.space = space</code>
     * <br/><br/>
     * This list is only those compounds directly placed in the space, any
     * compound that is a child of another compound will not be in this list.</p></div></div><div class="platform platform-flash"><a name="constraints"></a><h3><p><code><span class="keyword">var</span> <a href="#constraints"><span class="identifier">constraints</span></a>:<a class="type" href="../../nape/constraint/ConstraintList.html">ConstraintList</a></code></p></h3><div class="doc"><p>List of all Constraints directly placed in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Constraint to this Space equivalent to: <code>constraint.space = space</code>
     * <br/><br/>
     * This list is only those bodies directly placed in the space, any
     * constraint that is a child of a Compound will not be in this list.</p></div></div><div class="platform platform-flash"><a name="elapsedTime"></a><h3><p><code><span class="keyword">var</span> <a href="#elapsedTime"><span class="identifier">elapsedTime</span></a>:<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>The elapsed simulation time.
     * <br/><br/>
     * This is the total amount of 'time' that has elapsed in the Space simulation.</p></div></div><div class="platform platform-flash"><a name="gravity"></a><h3><p><code><span class="keyword">var</span> <a href="#gravity"><span class="identifier">gravity</span></a>:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Space gravity.
     * <br/><br/>
     * Units are of pixels/second/second
     * @default (0,0)</p></div></div><div class="platform platform-flash"><a name="listeners"></a><h3><p><code><span class="keyword">var</span> <a href="#listeners"><span class="identifier">listeners</span></a>:<a class="type" href="../../nape/callbacks/ListenerList.html">ListenerList</a></code></p></h3><div class="doc"><p>List of all Listeners in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Listener to this Space equivalent to: <code>listener.space = space</code></p></div></div><div class="platform platform-flash"><a name="liveBodies"></a><h3><p><code><span class="keyword">var</span> <a href="#liveBodies"><span class="identifier">liveBodies</span></a>:<a class="type" href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>List of all active dynamic Bodies in space.
     * <br/><br/>
     * This list contains all dynamic bodies that are awake regardless of their containment in a Compound.
     * <br/><br/>
     * This list is immutable.</p></div></div><div class="platform platform-flash"><a name="liveConstraints"></a><h3><p><code><span class="keyword">var</span> <a href="#liveConstraints"><span class="identifier">liveConstraints</span></a>:<a class="type" href="../../nape/constraint/ConstraintList.html">ConstraintList</a></code></p></h3><div class="doc"><p>List of all active Constraints in space.
     * <br/><br/>
     * This list contains all constraints regardless of their containment in a Compound.
     * <br/><br/>
     * This list is immutable.</p></div></div><div class="platform platform-flash"><a name="sortContacts"></a><h3><p><code><span class="keyword">var</span> <a href="#sortContacts"><span class="identifier">sortContacts</span></a>:<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Flag controlling sorting of contact points.
     * <br/><br/>
     * If true, then collisions will be resolved in an order defined by their
     * penetration depths. This can be shown to improve stability of the physics
     * as well as making simulations more consistent regardless of which broadphase
     * is used.
     * <br/><br/>
     * Having sorting enabled obviously incurs a cost, and you may consider
     * disabling it if you are having issues with performance (Though things
     * such as number of physics iterations will have much greater bearing on
     * performance than this, especcialy since enabling this may permit you
     * to use less iterations).
     *
     * @default true</p></div></div><div class="platform platform-flash"><a name="timeStamp"></a><h3><p><code><span class="keyword">var</span> <a href="#timeStamp"><span class="identifier">timeStamp</span></a>:<a class="type" href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>The time stamp of this Space object.
     * <br/><br/>
     * This is equal to the number of times that space.step(..) has been invoked.</p></div></div><div class="platform platform-flash"><a name="userData"></a><h3><p><code><span class="keyword">var</span> <a href="#userData"><span class="identifier">userData</span></a>:<a class="type" href="../../Dynamic.html">Dynamic</a><a class="type" href="../../Dynamic.html">Dynamic</a></code></p></h3><div class="doc"><p>Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &amp;#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}</p></div></div><div class="platform platform-flash"><a name="world"></a><h3><p><code><span class="keyword">var</span> <a href="#world"><span class="identifier">world</span></a>:<a class="type" href="../../nape/phys/Body.html">Body</a></code></p></h3><div class="doc"><p>Static, immutable Body for constraint purposes.
     * <br/><br/>
     * This is a completely static, uncollidable, uninteractable Body
     * with no Shapes, that cannot be modified in any way.
     * <br/><br/>
     * Its purpose is to provide a means for attaching Constraints
     * from one Body to the Space itself, for instance pinning a body
     * against a static point in space.</p></div></div><div class="platform platform-flash"><a name="worldAngularDrag"></a><h3><p><code><span class="keyword">var</span> <a href="#worldAngularDrag"><span class="identifier">worldAngularDrag</span></a>:<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>Angular drag applied to all bodies in Space.
     * <br/><br/>
     * This represents the fraction of a body's angular velocity which will be
     * removed per second. This value has no unit attached.
     *
     * @default 0.015</p></div></div><div class="platform platform-flash"><a name="worldLinearDrag"></a><h3><p><code><span class="keyword">var</span> <a href="#worldLinearDrag"><span class="identifier">worldLinearDrag</span></a>:<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>Linear drag applied to all bodies in Space.
     * <br/><br/>
     * This represents the fraction of a body's linear velocity which will be
     * removed per second. This value has no unit attached.
     *
     * @default 0.015</p></div></div><div class="platform platform-flash"><a name="zpp_inner"></a><h3><p><code><span class="keyword">var</span> <a href="#zpp_inner"><span class="identifier">zpp_inner</span></a>:<a class="type" href="../../zpp_nape/space/ZPP_Space.html">ZPP_Space</a></code></p></h3><div class="doc"><p>@private</p></div></div><div class="platform platform-flash"><a name="new"></a><h3><p><code><span class="keyword">function</span> <a href="#new"><span class="identifier">new</span></a>(?gravity:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a> = null, ?broadphase:<a class="type" href="../../nape/space/Broadphase.html">Broadphase</a> = null):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Construct a new Space object.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>gravity</td><td><p>The gravity of this space. (default &#40;0,0&#41;)
    * </p></td></tr><tr><td>broadphase</td><td><p>The broadphase type to use. (default DYNAMIC<em>AABB</em>TREE)
    * </p></td></tr><tr><td>returns</td><td><p>The constructed Space object.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="bodiesInAABB"></a><h3><p><code><span class="keyword">function</span> <a href="#bodiesInAABB"><span class="identifier">bodiesInAABB</span></a>(aabb:<a class="type" href="../../nape/geom/AABB.html">AABB</a>, ?containment:<a class="type" href="../../Bool.html">Bool</a> = false, ?strict:<a class="type" href="../../Bool.html">Bool</a> = true, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/phys/BodyList.html">BodyList</a> = null):<a class="type" href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>Evaluate all Bodies given an AABB.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the AABB, whose filter agrees to collide
     * will be considered.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>aabb</td><td><p>The bounding box to query bodies by,
    * </p></td></tr><tr><td>containment</td><td><p>If true, then only Bodies entirely contained (Rather
    *                    than simply intersecting) will be considered.
    *                    (default false)
    * </p></td></tr><tr><td>strict</td><td><p>If false, then the body's shape's bounding box will be used to
    *               classify the shapes of the body, instead of the Shape itself.
    *               (default true)
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>Optional list to append results to instead of creating a new list (default null).
    * </p></td></tr><tr><td>returns</td><td><p>A list of all the shapes for given AABB.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="bodiesInBody"></a><h3><p><code><span class="keyword">function</span> <a href="#bodiesInBody"><span class="identifier">bodiesInBody</span></a>(body:<a class="type" href="../../nape/phys/Body.html">Body</a>, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/phys/BodyList.html">BodyList</a> = null):<a class="type" href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>Evaluate all Bodies given a Body.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the input body, whose filter agrees to collide
     * will be considered. The input body is considered a purely geometric
     *
     * </p><table class="table table-condensed"><tbody><tr><td>body</td><td><p>The body to use in classifying other bodies.
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>Optional list to append results to instead of creating a new list (default null).
    * </p></td></tr><tr><td>returns</td><td><p>A list of all the bodies for given body.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="bodiesInCircle"></a><h3><p><code><span class="keyword">function</span> <a href="#bodiesInCircle"><span class="identifier">bodiesInCircle</span></a>(position:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>, radius:<a class="type" href="../../Float.html">Float</a>, ?containment:<a class="type" href="../../Bool.html">Bool</a> = false, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/phys/BodyList.html">BodyList</a> = null):<a class="type" href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>Evaluate all Bodies given a circle.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the circle, whose filter agrees to collide
     * will be considered.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>position</td><td><p>The position of the centre of the circle.
    * </p></td></tr><tr><td>radius</td><td><p>The radius of the circle.
    * </p></td></tr><tr><td>containment</td><td><p>If true, then only Bodies entirely contained (Rather
    *                    than simply intersecting) will be considered. If a
    *                    filter is supplied, only shapes that agree to collide
    *                    will be used in this containment check.
    *                    (default false)
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>Optional list to append results to instead of creating a new list (default null).
    * </p></td></tr><tr><td>returns</td><td><p>A list of all the shapes for given circle.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="bodiesInShape"></a><h3><p><code><span class="keyword">function</span> <a href="#bodiesInShape"><span class="identifier">bodiesInShape</span></a>(shape:<a class="type" href="../../nape/shape/Shape.html">Shape</a>, ?containment:<a class="type" href="../../Bool.html">Bool</a> = false, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/phys/BodyList.html">BodyList</a> = null):<a class="type" href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>Evaluate all Bodies given a shape.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the input shape, whose filter agrees to collide
     * will be considered. The input shape is considered a purely geometric
     * <br/><br/>
     * The input shape must be part of a Body so as to be well defined.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>shape</td><td><p>The shape to use in classifying other shapes.
    * </p></td></tr><tr><td>containment</td><td><p>If true, then only Bodies entirely contained (Rather
    *                    than simply intersecting) will be considered.
    *                    (default false)
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>Optional list to append results to instead of creating a new list (default null).
    * </p></td></tr><tr><td>returns</td><td><p>A list of all the bodies for given shape.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="bodiesUnderPoint"></a><h3><p><code><span class="keyword">function</span> <a href="#bodiesUnderPoint"><span class="identifier">bodiesUnderPoint</span></a>(point:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/phys/BodyList.html">BodyList</a> = null):<a class="type" href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>Evaluate all Bodies under a given Point.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape containing
     * the given point whose filter agrees to 'collide' will be considered.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>point</td><td><p>The point to evaluate bodies.
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>Optional list to append results to instead of creating a new list (default null).
    * </p></td></tr><tr><td>returns</td><td><p>A list of all the Bodies containing the given point.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="clear"></a><h3><p><code><span class="keyword">function</span> <a href="#clear"><span class="identifier">clear</span></a>():<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Clear the Space of all objects.
     * <br/><br/>
     * Things such as the elapsed simulation time, and time step will too be
     * reset to 0.
     * <br/><br/>
     * Parameters such as gravity, and worldLinearDrag will be untouched by
     * this operation.</p></div></div><div class="platform platform-flash"><a name="convexCast"></a><h3><p><code><span class="keyword">function</span> <a href="#convexCast"><span class="identifier">convexCast</span></a>(shape:<a class="type" href="../../nape/shape/Shape.html">Shape</a>, deltaTime:<a class="type" href="../../Float.html">Float</a>, ?liveSweep:<a class="type" href="../../Bool.html">Bool</a> = false, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null):<a class="type" href="../../Null.html">Null</a>&lt;<a class="type" href="../../nape/geom/ConvexResult.html">ConvexResult</a>&gt;</code></p></h3><div class="doc"><p>Perform a convex cast for soonest collision.
     * <br/><br/>
     * This method will return only the soonest collision result (if any), to find
     * more than this, use the convexMultiCast method. The shape will not be
     * swept further than the time delta provided.
     * Shapes already intersecting
     * the sweep shape at t = 0 are ignored.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be collidable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>shape</td><td><p>The Shape to be cast through space. This shape must belong
    *              to a body whose velocity is used to define the sweep.
    * </p></td></tr><tr><td>deltaTime</td><td><p>The amount of time to sweep the shape forward.
    * </p></td></tr><tr><td>liveSweep</td><td><p>If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>returns</td><td><p>The soonest result (if any) of convex intersection.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="convexMultiCast"></a><h3><p><code><span class="keyword">function</span> <a href="#convexMultiCast"><span class="identifier">convexMultiCast</span></a>(shape:<a class="type" href="../../nape/shape/Shape.html">Shape</a>, deltaTime:<a class="type" href="../../Float.html">Float</a>, ?liveSweep:<a class="type" href="../../Bool.html">Bool</a> = false, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, output:<a class="type" href="../../nape/geom/ConvexResultList.html">ConvexResultList</a>):<a class="type" href="../../nape/geom/ConvexResultList.html">ConvexResultList</a></code></p></h3><div class="doc"><p>Perform a convex cast for all collisions in time order.
     * <br/><br/>
     * This method will return all collisions, or an empty list if there are none.
     * The shape will not be
     * swept further than the time delta provided. Shapes already intersecting
     * the sweep shape at t = 0 are ignored.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be collidable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>shape</td><td><p>The Shape to be cast through space. This shape must belong
    *              to a body whose velocity is used to define the sweep.
    * </p></td></tr><tr><td>deltaTime</td><td><p>The amount of time to sweep the shape forward.
    * </p></td></tr><tr><td>liveSweep</td><td><p>If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>A list to append results to instead of allocating a new one (default null)
    * </p></td></tr><tr><td>returns</td><td><p>The collision results in time order.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="interactionType"></a><h3><p><code><span class="keyword">function</span> <a href="#interactionType"><span class="identifier">interactionType</span></a>(shape1:<a class="type" href="../../nape/shape/Shape.html">Shape</a>, shape2:<a class="type" href="../../nape/shape/Shape.html">Shape</a>):<a class="type" href="../../Null.html">Null</a>&lt;<a class="type" href="../../nape/callbacks/InteractionType.html">InteractionType</a>&gt;</code></p></h3><div class="doc"><p>Determine the interaction type that would occur between a pair of Shapes.
     * <br/><br/>
     * This function takes into account everything possible, and ignoring the
     * callback system will tell you precisely the type of interaction (if any
     * at all) which will occur between these Shapes.
     * <br/><br/>
     * This function can only work if the Shapes belong to a Body.
     * <br/><br/>
     * This function can only make use of any constraints 'ignore' property
     * to determine if 'null' should be returned if the constraints being used
     * are inside of a Space.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>shape1</td><td><p>The first Shape to test.
    * </p></td></tr><tr><td>shape2</td><td><p>The second Shape to test.
    * </p></td></tr><tr><td>returns</td><td><p>The interaction type that will occur between these shapes, or null
<em>         if no interaction will occur.
</em> </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="rayCast"></a><h3><p><code><span class="keyword">function</span> <a href="#rayCast"><span class="identifier">rayCast</span></a>(ray:<a class="type" href="../../nape/geom/Ray.html">Ray</a>, ?inner:<a class="type" href="../../Bool.html">Bool</a> = false, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null):<a class="type" href="../../Null.html">Null</a>&lt;<a class="type" href="../../nape/geom/RayResult.html">RayResult</a>&gt;</code></p></h3><div class="doc"><p>Perform a ray cast for closest result.
     * <br/><br/>
     * This method will return only the closest result (if any), to find more
     * the first result, use the rayMultiCast method. The ray will not be
     * cast beyond its maxDistance.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be intersectable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>ray</td><td><p>The ray to cast through space.
    * </p></td></tr><tr><td>inner</td><td><p>If true then inner surfaces of shapes will also be intersected.
    *              otherwise only the outer surfaces. (default false)
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>returns</td><td><p>The closest result (if any) of ray intersection.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="rayMultiCast"></a><h3><p><code><span class="keyword">function</span> <a href="#rayMultiCast"><span class="identifier">rayMultiCast</span></a>(ray:<a class="type" href="../../nape/geom/Ray.html">Ray</a>, ?inner:<a class="type" href="../../Bool.html">Bool</a> = false, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/geom/RayResultList.html">RayResultList</a> = null):<a class="type" href="../../nape/geom/RayResultList.html">RayResultList</a></code></p></h3><div class="doc"><p>Perform a ray cast for all valid results.
     * <br/><br/>
     * This method will return all intersections (in distance order) of ray
     * with shapes in the space up to the ray's maxDistance.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be intersectable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>ray</td><td><p>The ray to cast through space.
    * </p></td></tr><tr><td>inner</td><td><p>If true then inner surfaces of shapes will also be intersected.
    *              otherwise only the outer surfaces. (default false)
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>A list to append results to instead of allocating a new one (default null)
    * </p></td></tr><tr><td>returns</td><td><p>All valid results of ray cast in distance order from closest to furthest.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="shapesInAABB"></a><h3><p><code><span class="keyword">function</span> <a href="#shapesInAABB"><span class="identifier">shapesInAABB</span></a>(aabb:<a class="type" href="../../nape/geom/AABB.html">AABB</a>, ?containment:<a class="type" href="../../Bool.html">Bool</a> = false, ?strict:<a class="type" href="../../Bool.html">Bool</a> = true, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/shape/ShapeList.html">ShapeList</a> = null):<a class="type" href="../../nape/shape/ShapeList.html">ShapeList</a></code></p></h3><div class="doc"><p>Evaluate all Shapes given an AABB.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>aabb</td><td><p>The bounding box to query shapes by,
    * </p></td></tr><tr><td>containment</td><td><p>If true, then only Shapes entirely contained (Rather
    *                    than simply intersected) will be considered.
    *                    (default false)
    * </p></td></tr><tr><td>strict</td><td><p>If false, then the Shape's bounding box will be used to
    *               classify the Shape, instead of the Shape itself.
    *               (default true)
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>Optional list to append results to instead of creating a new list (default null).
    * </p></td></tr><tr><td>returns</td><td><p>A list of all the shapes for given AABB.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="shapesInBody"></a><h3><p><code><span class="keyword">function</span> <a href="#shapesInBody"><span class="identifier">shapesInBody</span></a>(body:<a class="type" href="../../nape/phys/Body.html">Body</a>, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/shape/ShapeList.html">ShapeList</a> = null):<a class="type" href="../../nape/shape/ShapeList.html">ShapeList</a></code></p></h3><div class="doc"><p>Evaluate all Shapes given a Body.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered. The input body's shape's own filters
     * are never used in this method. The input body is considered a purely
     * geometric object.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>body</td><td><p>The body to use in classifying other shapes.
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>Optional list to append results to instead of creating a new list (default null).
    * </p></td></tr><tr><td>returns</td><td><p>A list of all the shapes for given body.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="shapesInCircle"></a><h3><p><code><span class="keyword">function</span> <a href="#shapesInCircle"><span class="identifier">shapesInCircle</span></a>(position:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>, radius:<a class="type" href="../../Float.html">Float</a>, ?containment:<a class="type" href="../../Bool.html">Bool</a> = false, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/shape/ShapeList.html">ShapeList</a> = null):<a class="type" href="../../nape/shape/ShapeList.html">ShapeList</a></code></p></h3><div class="doc"><p>Evaluate all Shapes given a circle.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>position</td><td><p>The position of the centre of the circle.
    * </p></td></tr><tr><td>radius</td><td><p>The radius of the circle.
    * </p></td></tr><tr><td>containment</td><td><p>If true, then only Shapes entirely contained (Rather
    *                    than simply intersected) will be considered.
    *                    (default false)
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>Optional list to append results to instead of creating a new list (default null).
    * </p></td></tr><tr><td>returns</td><td><p>A list of all the shapes for given circle.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="shapesInShape"></a><h3><p><code><span class="keyword">function</span> <a href="#shapesInShape"><span class="identifier">shapesInShape</span></a>(shape:<a class="type" href="../../nape/shape/Shape.html">Shape</a>, ?containment:<a class="type" href="../../Bool.html">Bool</a> = false, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/shape/ShapeList.html">ShapeList</a> = null):<a class="type" href="../../nape/shape/ShapeList.html">ShapeList</a></code></p></h3><div class="doc"><p>Evaluate all Shapes given another shape.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered. The input shape's own filter
     * is never used in this method. The input shape is considered a purely
     * geometric object.
     * <br/><br/>
     * The input shape must be part of a Body so as to be well defined.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>shape</td><td><p>The shape to use in classifying other shapes.
    * </p></td></tr><tr><td>containment</td><td><p>If true, then only Shapes entirely contained (Rather
    *                    than simply intersected) will be considered.
    *                    (default false)
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>Optional list to append results to instead of creating a new list (default null).
    * </p></td></tr><tr><td>returns</td><td><p>A list of all the shapes for given shape.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="shapesUnderPoint"></a><h3><p><code><span class="keyword">function</span> <a href="#shapesUnderPoint"><span class="identifier">shapesUnderPoint</span></a>(point:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>, ?filter:<a class="type" href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a> = null, ?output:<a class="type" href="../../nape/shape/ShapeList.html">ShapeList</a> = null):<a class="type" href="../../nape/shape/ShapeList.html">ShapeList</a></code></p></h3><div class="doc"><p>Evaluate all Shapes under a given Point.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>point</td><td><p>The point to evaluate shapes.
    * </p></td></tr><tr><td>filter</td><td><p>Optional filter to pick and choose shapes, based on whether
    *               the filters agree to collide. (default null)
    * </p></td></tr><tr><td>output</td><td><p>Optional list to append results to instead of creating a new list (default null).
    * </p></td></tr><tr><td>returns</td><td><p>A list of all the Shapes containing the given point.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="step"></a><h3><p><code><span class="keyword">function</span> <a href="#step"><span class="identifier">step</span></a>(deltaTime:<a class="type" href="../../Float.html">Float</a>, ?velocityIterations:<a class="type" href="../../Int.html">Int</a> = 10, ?positionIterations:<a class="type" href="../../Int.html">Int</a> = 10):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Step simulation forward in time.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>deltaTime</td><td><p>The number of seconds to simulate. For 60fps physics
    *                  you would use a value of 1/60.
    * </p></td></tr><tr><td>velocityIterations</td><td><p>The number of iterations to use in resolving
    *                           errors in the velocities of objects. This is
    *                           together with collision detection the most
    *                           expensive phase of a simulation update, as well
    *                           as the most important for stable results.
    *                           (default 10)
    * </p></td></tr><tr><td>positionIterations</td><td><p>The number of iterations to use in resolving
    *                           errors in the positions of objects. This is
    *                           far more lightweight than velocity iterations,
    *                           as well as being less important for the
    *                           stability of results. (default 10)
    * </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="visitBodies"></a><h3><p><code><span class="keyword">function</span> <a href="#visitBodies"><span class="identifier">visitBodies</span></a>(lambda:<a class="type" href="../../nape/phys/Body.html">Body</a> -&gt;<a class="type" href="../../Void.html">Void</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Apply given function to all bodies in space.
     * <br/><br/>
     * This method is a way to iterate over 'every' Body in the Space
     * regardless of containment in a Compound.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>lambda</td><td><p>The function to apply to each Body.
    * </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="visitCompounds"></a><h3><p><code><span class="keyword">function</span> <a href="#visitCompounds"><span class="identifier">visitCompounds</span></a>(lambda:<a class="type" href="../../nape/phys/Compound.html">Compound</a> -&gt;<a class="type" href="../../Void.html">Void</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Apply given function to all compounds in space.
     * <br/><br/>
     * This method is a way to iterate over 'every' Compound in the Space
     * regardless of containment in another Compound.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>lambda</td><td><p>The function to apply to each Compound.
    * </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="visitConstraints"></a><h3><p><code><span class="keyword">function</span> <a href="#visitConstraints"><span class="identifier">visitConstraints</span></a>(lambda:<a class="type" href="../../nape/constraint/Constraint.html">Constraint</a> -&gt;<a class="type" href="../../Void.html">Void</a>):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Apply given function to all constraints in space.
     * <br/><br/>
     * This method is a way to iterate over 'every' Constraint in the Space
     * regardless of containment in a Compound.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>lambda</td><td><p>The function to apply to each Constraint.
    * </p></td></tr></tbody></table></div></div></div></div></div></body></html>
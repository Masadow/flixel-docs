<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../bootstrap-combined.min.css" rel="stylesheet" /><script type="text/javascript" src="../../jquery-1.9.1.min.js"></script><script type="text/javascript" src="../../bootstrap.min.js"></script><link href="../../styles.css" rel="stylesheet" /><link rel="icon" href="../../favicon.ico" type="image/x-icon"></link><script type="text/javascript" src="../../nav.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["flash"]};</script><title>Mat23</title></head><body><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><form class="navbar-search pull-left" id="searchForm"><input id="search" type="text" class="search-query" placeholder="Filter" autocomplete="off"/></form><ul class="nav"><li id="select-platform" class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Platform<b class="caret"></b></a><ul class="dropdown-menu"><li data="all"><a href="#">All Platforms</a></li><li data="flash"><a href="#">flash</a></li></ul></li></ul></div></div><div id="container"><div id="nav"></div><div id="content"><div class="header"><h1><code><span class="directive">class </span><span class="type">nape.geom.Mat23</span></code></h1></div><div class="body"><p class="availability">Available on all platforms</p><div class="doc"><p>2D Matrix class representing affine transformations:
 * <pre>
 * [ a  b  tx ]
 * [ c  d  ty ]
 * [ 0  0  1  ]
 * </pre>
 *
 * Note that in AS3, flash.geom.Matrix has 'b' and 'c' swapped! so if you are
 * converting between flash.geom.Matrix and nape.geom.Mat23 you should use the
 * methods provided to avoid any mistakes with this.</p></div><h2>Class Fields</h2><div class="platform platform-flash"><a name="fromMatrix"></a><h3><p><code><span class="keyword">static </span><span class="keyword">function</span> <a href="#fromMatrix"><span class="identifier">fromMatrix</span></a>(matrix:<a class="type" href="../../flash/geom/Matrix.html">Matrix</a>):<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Create a Mat23 matrix from a given AS3 flash.geom.Matrix.
     * <br/><br/>
     * This method should be used in preference to doing so manually
     * as the allocation of matrix entries to name is different and
     * it is easy to make this mistake!
     * <br/><br/>
     * This method is only available on <code>flash</code> and
     * <code>openfl||nme</code> targets.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>matrix</td><td><p>The AS3 Matrix to create Mat23 from. This value must
    *               not be null.
    * </p></td></tr><tr><td>returns</td><td><p>The constructed Mat23 matching AS3 Matrix.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="rotation"></a><h3><p><code><span class="keyword">static </span><span class="keyword">function</span> <a href="#rotation"><span class="identifier">rotation</span></a>(angle:<a class="type" href="../../Float.html">Float</a>):<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Construct a Mat23 representing a clockwise rotation.
     <em>
     * <pre>
     * [ cos angle  -sin angle  0 ]
     * [ sin angle   cos angle  0 ]
     * </pre>
     </em>
     * </p><table class="table table-condensed"><tbody><tr><td>angle</td><td><p>The clockwise rotation in radians
    * </p></td></tr><tr><td>returns</td><td><p>The rotation matrix.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="scale"></a><h3><p><code><span class="keyword">static </span><span class="keyword">function</span> <a href="#scale"><span class="identifier">scale</span></a>(sx:<a class="type" href="../../Float.html">Float</a>, sy:<a class="type" href="../../Float.html">Float</a>):<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Construct a Mat23 representing a scaling
     <em>
     * <pre>
     * [ sx  0  0 ]
     * [ 0  sy  0 ]
     * </pre>
     </em>
     * </p><table class="table table-condensed"><tbody><tr><td>sx</td><td><p>The x factor of scaling.
    * </p></td></tr><tr><td>sy</td><td><p>The y factor of scaling.
    * </p></td></tr><tr><td>returns</td><td><p>The scaling matrix.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="translation"></a><h3><p><code><span class="keyword">static </span><span class="keyword">function</span> <a href="#translation"><span class="identifier">translation</span></a>(tx:<a class="type" href="../../Float.html">Float</a>, ty:<a class="type" href="../../Float.html">Float</a>):<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Construct a Mat23 representing a translation
     <em>
     * <pre>
     * [ 1  0  tx ]
     * [ 0  1  ty ]
     * </pre>
     </em>
     * </p><table class="table table-condensed"><tbody><tr><td>tx</td><td><p>The x translation.
    * </p></td></tr><tr><td>ty</td><td><p>The y translation.
    * </p></td></tr><tr><td>returns</td><td><p>The translation matrix.</p></td></tr></tbody></table></div></div><h2>Instance Fields</h2><div class="platform platform-flash"><a name="a"></a><h3><p><code><span class="keyword">var</span> <a href="#a"><span class="identifier">a</span></a>:<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>The (1,1) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ a  .  . ]
     * [ .  .  . ]
     * </pre>
     *
     * @default 1</p></div></div><div class="platform platform-flash"><a name="b"></a><h3><p><code><span class="keyword">var</span> <a href="#b"><span class="identifier">b</span></a>:<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>The (1,2) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ .  b  . ]
     * [ .  .  . ]
     * </pre>
     *
     * @default 0</p></div></div><div class="platform platform-flash"><a name="c"></a><h3><p><code><span class="keyword">var</span> <a href="#c"><span class="identifier">c</span></a>:<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>The (2,1) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ .  .  . ]
     * [ c  .  . ]
     * </pre>
     *
     * @default 0</p></div></div><div class="platform platform-flash"><a name="d"></a><h3><p><code><span class="keyword">var</span> <a href="#d"><span class="identifier">d</span></a>:<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>The (2,2) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ .  .  . ]
     * [ .  d  . ]
     * </pre>
     *
     * @default 1</p></div></div><div class="platform platform-flash"><a name="determinant"></a><h3><p><code><span class="keyword">var</span> <a href="#determinant"><span class="identifier">determinant</span></a>:<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>(readonly) The determinant of this matrix.
     * <br/><br/>
     * This represents the factor of change in area
     * for a region of the plane after transformation by matrix.
     * <br/><br/>
     * A determinant of 0 signifies that the matrix is not invertible.
     * <br/><br/>
     * A negative determinant signifies that for example, a clockwise wound
     * polygon would be transformed into a counter-clockwise polygon.
     *
     * @default 1</p></div></div><div class="platform platform-flash"><a name="tx"></a><h3><p><code><span class="keyword">var</span> <a href="#tx"><span class="identifier">tx</span></a>:<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>The (1,3) entry in Mat23 which represents x translation
     * <br/><br/>
     * <pre>
     * [ .  .  tx ]
     * [ .  .  .  ]
     * </pre>
     *
     * @default 0</p></div></div><div class="platform platform-flash"><a name="ty"></a><h3><p><code><span class="keyword">var</span> <a href="#ty"><span class="identifier">ty</span></a>:<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>The (2,3) entry in Mat23 which represents y translation
     * <br/><br/>
     * <pre>
     * [ .  .  .  ]
     * [ .  .  ty ]
     * </pre>
     *
     * @default 0</p></div></div><div class="platform platform-flash"><a name="zpp_inner"></a><h3><p><code><span class="keyword">var</span> <a href="#zpp_inner"><span class="identifier">zpp_inner</span></a>:<a class="type" href="../../zpp_nape/geom/ZPP_Mat23.html">ZPP_Mat23</a></code></p></h3><div class="doc"><p>@private</p></div></div><div class="platform platform-flash"><a name="new"></a><h3><p><code><span class="keyword">function</span> <a href="#new"><span class="identifier">new</span></a>(?a:<a class="type" href="../../Float.html">Float</a> = 1.0f, ?b:<a class="type" href="../../Float.html">Float</a> = 0.0f, ?c:<a class="type" href="../../Float.html">Float</a> = 0.0f, ?d:<a class="type" href="../../Float.html">Float</a> = 1.0f, ?tx:<a class="type" href="../../Float.html">Float</a> = 0.0f, ?ty:<a class="type" href="../../Float.html">Float</a> = 0.0f):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Construct new Mat23.
     * <br/><br/>
     * <pre>
     * [ a  b  tx ]
     * [ c  d  ty ]
     * </pre>
     *
     * </p><table class="table table-condensed"><tbody><tr><td>a</td><td><p>The (1,1) entry in matrix (default 1)
   * </p></td></tr><tr><td>b</td><td><p>The (1,2) entry in matrix (default 0)
   * </p></td></tr><tr><td>c</td><td><p>The (2,1) entry in matrix (default 0)
   * </p></td></tr><tr><td>d</td><td><p>The (2,2) entry in matrix (default 1)
   * </p></td></tr><tr><td>tx</td><td><p>The (1,3) entry in matrix (default 0)
    * </p></td></tr><tr><td>ty</td><td><p>The (2,3) entry in matrix (default 0)
    * </p></td></tr><tr><td>returns</td><td><p>The newly constructed Mat23.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="concat"></a><h3><p><code><span class="keyword">function</span> <a href="#concat"><span class="identifier">concat</span></a>(matrix:<a class="type" href="../../nape/geom/Mat23.html">Mat23</a>):<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Concatenate matrices (left-multiplication), returning new Mat23.
     * <br/><br/>
     * <code>mat1.concat(mat2)</code> is the transformation that first
     * performs transformation represented by mat1, followed by transformation
     * represented by mat2.
     * <br/>
     *
     * </p><table class="table table-condensed"><tbody><tr><td>matrix</td><td><p>Matrix to concatenate with.
    * </p></td></tr><tr><td>returns</td><td><p>The result of the concatenation.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="copy"></a><h3><p><code><span class="keyword">function</span> <a href="#copy"><span class="identifier">copy</span></a>():<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Produce copy of this Mat23
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>The new Mat23 representing copy of this.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="equiorthogonal"></a><h3><p><code><span class="keyword">function</span> <a href="#equiorthogonal"><span class="identifier">equiorthogonal</span></a>():<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if matrix is equiorthogonal
     * <br/><br/>
     * This is a term I invented after
     * failing to find an existing name. It describes that this matrix maps
     * circles into other circles (of not necessarigly the same radius). In
     * otherwords the matrix can be decomposed into a rotation, translation
     * and scaling of equal x/y factors.
     * <br/><br/>
     * This property is required for any Mat23 that is used to transform a
     * Circle, or any Body containing a Circle, or to transform a Debug view.
     * <br/><br/>
     * This is a weaker property than orthogonality which describes a mapping
     * to a circle of equal radius.
     * <br/><br/>
     * Mathematically speaking a matrix is equiorthogonal iff.
     * <code>transpose(M) * M = kI</code> for some non-zero scalar k.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>True if matrix is equiorthogonal.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="equiorthogonalise"></a><h3><p><code><span class="keyword">function</span> <a href="#equiorthogonalise"><span class="identifier">equiorthogonalise</span></a>():<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Equiorthogonalise matrix.
     * <br/><br/>
     * We do this by finding the 'nearest' orthogonal matrix;
     * scaling the basis vectors of matrix to their mean length
     * and applying an equal and opposite rotation to each basis vector to
     * make them perpendicular.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A reference to this Mat23.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="inverse"></a><h3><p><code><span class="keyword">function</span> <a href="#inverse"><span class="identifier">inverse</span></a>():<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Compute the inverse of this matrix, returning the inverse in a new
     * Mat23 object.
     * <br/><br/>
     * The inverse is such that mat.concat(mat.inverse()) is the identity
     * matrix, as well as mat.inverse().concat(mat)
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>The inverse matrix.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="inverseTransform"></a><h3><p><code><span class="keyword">function</span> <a href="#inverseTransform"><span class="identifier">inverseTransform</span></a>(point:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>, ?noTranslation:<a class="type" href="../../Bool.html">Bool</a> = false, ?weak:<a class="type" href="../../Bool.html">Bool</a> = false):<a class="type" href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Perform inverse transformation with Vec2, returning new Vec2.
     * <br/><br/>
     * The matrix inverse will be performed implicitly and should this
     * method be called many times for the same Mat23, it would be better
     * to instead compute the matrix inverse only once.
     * <br/><br/>
     * The new Vec2 will be allocated from the global object pool.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>point</td><td><p>The Vec2 to transform.
     * </p></td></tr><tr><td>noTranslation</td><td><p>If true then the input Vec2 will be treat as a
    *                      vector instead of a point, treating the tx/ty
    *                      values of this Mat23 as though they were 0.
    *                      (default false)
    * </p></td></tr><tr><td>weak</td><td><p>If true, then the allocated Vec2 will be
     *                      automatically released to global object pool when
     *                      used as an argument to a Nape function.
     * </p></td></tr><tr><td>returns</td><td><p>The result of the transformation as a newly
<em>                      allocated (possibly weak) Vec2. (default false)
</em> </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="orthogonal"></a><h3><p><code><span class="keyword">function</span> <a href="#orthogonal"><span class="identifier">orthogonal</span></a>():<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if matrix is orthogonal
     * <br/><br/>
     * This property describes a matrix
     * which maps circles into other circles of equal radius. In otherwords
     * the matrix can be decomposed into a rotation and a translation.
     * <br/><br/>
     * Mathematically speaking a matrix is orthogonal iff.
     * <code>transpose(M) * M = I</code>.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>True if matrix is orthogonal.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="orthogonalise"></a><h3><p><code><span class="keyword">function</span> <a href="#orthogonalise"><span class="identifier">orthogonalise</span></a>():<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Orthogonalise matrix.
     * <br/><br/>
     * We do this by finding the 'nearest' orthogonal matrix;
     * normalising the basis vectors of matrix
     * and applying an equal and opposite rotation to each basis vector to
     * make them perpendicular.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A reference to this Mat23.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="reset"></a><h3><p><code><span class="keyword">function</span> <a href="#reset"><span class="identifier">reset</span></a>():<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Reset matrix to identity.
     * <br/><br/>
     * Equivalent to calling setAs with default argument values.
     * <br/><br/>
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A reference to this Mat23.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="set"></a><h3><p><code><span class="keyword">function</span> <a href="#set"><span class="identifier">set</span></a>(matrix:<a class="type" href="../../nape/geom/Mat23.html">Mat23</a>):<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Set values of matrix from another.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>matrix</td><td><p>The matrix to copy values from.
    * </p></td></tr><tr><td>returns</td><td><p>A reference to this Mat23.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="setAs"></a><h3><p><code><span class="keyword">function</span> <a href="#setAs"><span class="identifier">setAs</span></a>(?a:<a class="type" href="../../Float.html">Float</a> = 1.0f, ?b:<a class="type" href="../../Float.html">Float</a> = 0.0f, ?c:<a class="type" href="../../Float.html">Float</a> = 0.0f, ?d:<a class="type" href="../../Float.html">Float</a> = 1.0f, ?tx:<a class="type" href="../../Float.html">Float</a> = 0.0f, ?ty:<a class="type" href="../../Float.html">Float</a> = 0.0f):<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Set values of matrix from numbers.
     * <br/><br/>
     * So that: <code>mat.setAs(...)</code> is
     * semantically equivalent to: <code>mat.set(new Mat23(...))</code>
     * <br/><br/>
     * </p><table class="table table-condensed"><tbody><tr><td>a</td><td><p>The value to which the (1,1) entry will be set (default 1)
   * </p></td></tr><tr><td>b</td><td><p>The value to which the (1,2) entry will be set (default 0)
   * </p></td></tr><tr><td>c</td><td><p>The value to which the (2,1) entry will be set (default 0)
   * </p></td></tr><tr><td>d</td><td><p>The value to which the (2,2) entry will be set (default 1)
   * </p></td></tr><tr><td>tx</td><td><p>The value to which the (1,3) entry will be set (default 0)
    * </p></td></tr><tr><td>ty</td><td><p>The value to which the (2,3) entry will be set (default 0)
    * </p></td></tr><tr><td>returns</td><td><p>A reference to this Mat23.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="singular"></a><h3><p><code><span class="keyword">function</span> <a href="#singular"><span class="identifier">singular</span></a>():<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if the matrix is singular.
     * This check is based on computing the condition number of the matrix
     * by the Frobenius norm, and comparing against 2 / epsilon.
     * <br/><br/>
     * If matrix is singular, then inversion of the matrix cannot be performed
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>True, if matrix is singular.</p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="toMatrix"></a><h3><p><code><span class="keyword">function</span> <a href="#toMatrix"><span class="identifier">toMatrix</span></a>(?output:<a class="type" href="../../flash/geom/Matrix.html">Matrix</a> = null):<a class="type" href="../../flash/geom/Matrix.html">Matrix</a></code></p></h3><div class="doc"><p>Create an AS3 flash.geom.Matrix from this Mat23.
     * <br/><br/>
     * This method should be used in preference to doing so manually
     * as the allocation of matrix entries to name is different and
     * it is easy to make this mistake!
     *
     * @preturn The constructed AS3 Matrix.</p><table class="table table-condensed"><tbody><tr><td>output</td><td><p>If supplied, this Matrix will have its properties
    *               populated insteaad of creating a new Matrix.
    * </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="toString"></a><h3><p><code><span class="keyword">function</span> <a href="#toString"><span class="identifier">toString</span></a>():<a class="type" href="../../String.html">String</a></code></p></h3><div class="doc"><p>@private</p></div></div><div class="platform platform-flash"><a name="transform"></a><h3><p><code><span class="keyword">function</span> <a href="#transform"><span class="identifier">transform</span></a>(point:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>, ?noTranslation:<a class="type" href="../../Bool.html">Bool</a> = false, ?weak:<a class="type" href="../../Bool.html">Bool</a> = false):<a class="type" href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Transform a Vec2 by this matrix in new Vec2.
     * <br/><br/>
     * The Vec2 object will be allocated form the global object pool.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>point</td><td><p>The Vec2 to transform by this matrix.
     * </p></td></tr><tr><td>noTranslation</td><td><p>If true, then the input Vec2 will be treat as a
    *                      vector, rather than a point with the tx/ty values
    *                      treat as 0. (default false)
    * </p></td></tr><tr><td>weak</td><td><p>If true, then the allocated Vec2 will be
     *                      automatically released to global object pool when
     *                      used as an argument to a Nape function.
     * </p></td></tr><tr><td>returns</td><td><p>The result of the transformation as a newly
<em>                      allocated (possibly weak) Vec2. (default false)
</em> </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="transpose"></a><h3><p><code><span class="keyword">function</span> <a href="#transpose"><span class="identifier">transpose</span></a>():<a class="type" href="../../nape/geom/Mat23.html">Mat23</a></code></p></h3><div class="doc"><p>Compute the transpose of this matrix, returning the transpose in a new
     * Mat23 object.
     * <br/><br/>
     * Technically speaking, we cannot transpose a matrix if the tx/ty values
     * are non-zero as the implicit bottom row of matrix must be (0, 0, 1)
     * so the tx/ty values of output matrix are set so that should the main
     * 2x2 block of the matrix be orthogonal (Representing a rotation), then
     * the transpose will be able to act as the matrix inverse.
     * <pre>
     * var mat = Mat23.rotation(..).concat(Mat23.translation(...));
     * trace(mat.concat(mat.transpose())); // Identity matrix
     * trace(mat.concat(mat.inverse())); // Identity matrix
     * </pre>
     * If the main 2x2 block of matrix is 'not' orthogonal, then the transpose
     * will not be equal to the inverse.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>The transposed matrix.</p></td></tr></tbody></table></div></div></div></div></div></body></html>
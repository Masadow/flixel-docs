<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../bootstrap-combined.min.css" rel="stylesheet" /><script type="text/javascript" src="../../jquery-1.9.1.min.js"></script><script type="text/javascript" src="../../bootstrap.min.js"></script><link href="../../styles.css" rel="stylesheet" /><link rel="icon" href="../../favicon.ico" type="image/x-icon"></link><script type="text/javascript" src="../../nav.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["flash"]};</script><title>package geom</title></head><body><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><form class="navbar-search pull-left" id="searchForm"><input id="search" type="text" class="search-query" placeholder="Filter" autocomplete="off"/></form><ul class="nav"><li id="select-platform" class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Platform<b class="caret"></b></a><ul class="dropdown-menu"><li data="all"><a href="#">All Platforms</a></li><li data="flash"><a href="#">flash</a></li></ul></li></ul></div></div><div id="container"><div id="nav"></div><div id="content"><h1><span class="directive">package</span> nape.geom</h1><table class="table table-condensed"><tbody><tr><td width="200"><a href="../../nape/geom/AABB.html">AABB</a></td><td><p>Axis Aligned Bounding Box (AABB)
 * <br/><br/>
 * Note that in many cases of an AABB object being returned by a Nape function
 * the AABB object will be marked internally as an 'immutable' AABB. This will
 * always be documented and trying to mutate such an AABB will result in an
 * error being thrown.</p></td></tr><tr><td width="200"><a href="../../nape/geom/ConvexResult.html">ConvexResult</a></td><td><p>Class representing the results of a convex cast operation.
 * <br/><br/>
 * These objects are allocated from an object pool and can
 * be released back to that pool by calling its dispose method.</p></td></tr><tr><td width="200"><a href="../../nape/geom/ConvexResultIterator.html">ConvexResultIterator</a></td><td><p>Haxe Iterator<T> compatible iterator over Nape list.</p></td></tr><tr><td width="200"><a href="../../nape/geom/ConvexResultList.html">ConvexResultList</a></td><td><p>Nape list of ConvexResult type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i &lt; list.length; i++) {
 *     var obj:ConvexResult = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i &lt; list.length) {
 *     var obj:ConvexResult = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:ConvexResult = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre></p></td></tr><tr><td width="200"><a href="../../nape/geom/Geom.html">Geom</a></td><td><p>Geom class provides interface to collision detection routines in nape.</p></td></tr><tr><td width="200"><a href="../../nape/geom/GeomPoly.html">GeomPoly</a></td><td><p>Polygon class with various geometric methods
 * <br/><br/>
 * This class represents a general Polygon, rather than the Polygon class
 * which is physics shape.
 * <br/><br/>
 * Internally this polygon is stored as a circularly linked list of special
 * vertex types that are exposed via a Vec2 that is lazily constructed whenever
 * necessary to the API.</p></td></tr><tr><td width="200"><a href="../../nape/geom/GeomPolyIterator.html">GeomPolyIterator</a></td><td><p>Haxe Iterator<T> compatible iterator over Nape list.</p></td></tr><tr><td width="200"><a href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></td><td><p>Nape list of GeomPoly type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i &lt; list.length; i++) {
 *     var obj:GeomPoly = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i &lt; list.length) {
 *     var obj:GeomPoly = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:GeomPoly = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre></p></td></tr><tr><td width="200"><a href="../../nape/geom/GeomVertexIterator.html">GeomVertexIterator</a></td><td><p>Haxe compatible iterator over vertices of GeomPoly.
 * <br/><br/>
 * Vec2's intrinsically tied to the vertices are exposed through
 * the iterator which does not modify the state of the polygon.</p></td></tr><tr><td width="200"><a href="../../nape/geom/IsoFunction.html">IsoFunction</a></td><td><p>For 'flash' targets only.
 * <br/><br/>
 * Iso-functions for MarchingSquares must be given
 * as an object implementing this IsoFunction interface. This is for
 * reasons of avoiding excessive memory allocations that occur through
 * automatic boxing of arguments/return values when using function values.
 * <br/>
 * Since iso-functions may be called 10,000's of times per-invocation of
 * marching-squares, this can quickly accumulate into a lot of GC activity.</p></td></tr><tr><td width="200"><a href="../../nape/geom/IsoFunctionDef.html">IsoFunctionDef</a></td><td><p>Typedef defining iso-function type for MarchingSquares.
 * <code>
 * typedef IsoFunctionDef = #if flash IsoFunction #else Float-&gt;Float-&gt;Float #end;
 * </code></p></td></tr><tr><td width="200"><a href="../../nape/geom/MarchingSquares.html">MarchingSquares</a></td><td><p>Iso-surface extraction into polygons.
 * <br/><br/>
 * This class, with only one static method provides an interface to
 * an algorithm which will, when given a function mapping each point
 * in a given AABB to a scalar value extract approximated polygons
 * which represent the region of the AABB where the function returns
 * a negative value.
 * <br/><br/>
 * This function could be a mathematical function like the equation of
 * a circle: <code> function (x, y) return (x<em>x + y</em>y) - r<em>r </code>
 * <br/>
 * Or something more practical like the biased alpha value interpolated
 * from a Bitmap:
 * <pre>
 * function (x, y) {
 *    var ix = if (x &lt; 0) 0 else if (x >= bitmap.width - 1) bitmap.width - 2 else Std.int(x);
 *    var iy = if (y &lt; 0) 0 else if (y >= bitmap.height - 1) bitmap.height - 2 else Std.int(y);
 *    var fx = x - ix;
 *    var fy = y - iy;
 *    var gx = 1 - fx;
 *    var gy = 1 - fy;
 </em>
 *    var a00 = bitmap.getPixel32(ix, iy) >>> 24;
 *    var a01 = bitmap.getPixel32(ix, iy + 1) >>> 24;
 *    var a10 = bitmap.getPixel32(ix + 1, iy) >>> 24;
 *    var a11 = bitmap.getPixel32(ix + 1, iy + 1) >>> 24;
 <em>
 *    return 0x80 - (gx</em>gy<em>a00 + fx</em>gy<em>a10 + gx</em>fy<em>a01 + fx</em>fy*a11);
 * }
 * </pre>
 * For 'flash', we must wrap this in an IsoFunction interface to be used
 * by MarchingSquares for performance reasons:
 * <pre>
 * class BitmapIsoFunction implements nape.geom.IsoFunction {
 *     public function iso(x:Float, y:Float):Float {
 *         ...
 *     }
 * }
 * </pre>
 * This function is converted into a set of polygons by sampling along regular
 * grid points, and then recursively interpolating along cell edges based on
 * the function provided to find the point in space along that edge where the
 * function is approximately 0.
 * <br/><br/>
 * From this we generate polygons in each grid cell, which are then by default
 * combined into larger, weakly simply polygons suitable for use in the
 * decomposition routines of GeomPoly like convexDecomposition!
 * <br/><br/>
 * The runtime of the algorithm is O(N+K) for N number of cells and K number
 * of output vertices (A final pass is made to remove unnecessary vertices).</p></td></tr><tr><td width="200"><a href="../../nape/geom/Mat23.html">Mat23</a></td><td><p>2D Matrix class representing affine transformations:
 * <pre>
 * [ a  b  tx ]
 * [ c  d  ty ]
 * [ 0  0  1  ]
 * </pre>
 *
 * Note that in AS3, flash.geom.Matrix has 'b' and 'c' swapped! so if you are
 * converting between flash.geom.Matrix and nape.geom.Mat23 you should use the
 * methods provided to avoid any mistakes with this.</p></td></tr><tr><td width="200"><a href="../../nape/geom/MatMN.html">MatMN</a></td><td><p>A general MxN dimensional matrix.
 * <br/><br/>
 * This object is not often used in Nape :)</p></td></tr><tr><td width="200"><a href="../../nape/geom/Ray.html">Ray</a></td><td><p>Parametrically defined ray used in ray casting functions.</p></td></tr><tr><td width="200"><a href="../../nape/geom/RayResult.html">RayResult</a></td><td><p>Class representing the results of a ray cast operation.
 * <br/><br/>
 * These objects are allocated from an object pool and can
 * be released back to that pool by calling its dispose method.</p></td></tr><tr><td width="200"><a href="../../nape/geom/RayResultIterator.html">RayResultIterator</a></td><td><p>Haxe Iterator<T> compatible iterator over Nape list.</p></td></tr><tr><td width="200"><a href="../../nape/geom/RayResultList.html">RayResultList</a></td><td><p>Nape list of RayResult type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i &lt; list.length; i++) {
 *     var obj:RayResult = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i &lt; list.length) {
 *     var obj:RayResult = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:RayResult = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre></p></td></tr><tr><td width="200"><a href="../../nape/geom/Vec2.html">Vec2</a></td><td><p>2 Dimensional vector.
 * <br/><br/>
 * Note that in many cases of a Vec2 object being returned by a Nape function
 * the Vec2 object will be marked internally as an 'immutable' Vec2. This will
 * always be documented and trying to mutate such a Vec2 will result in an
 * error being thrown.
 * <br/><br/>
 * Vec2 objects can make use of a global object pool, attempting to make use
 * of a disposed Vec2 will also result in an error with the object pool
 * working in a FILO order to increase the likelihood of such misuse being
 * caught.
 * <br/><br/>
 * Additionally Vec2 objects can be created as 'weak'. Passing a weak Vec2 to
 * any Nape function as an argument will result in the automatic disposal of
 * the Vec2 once the method has finished with it. There may be exceptions to
 * this rule which will also be documented; a notable case being the appending
 * of a weak Vec2 to a Nape Vec2List in which case the disposal of the weak
 * Vec2 is performed when that Vec2List is handed to a Nape function instead.
 * <br/><br/>
 * Example:
 * <pre>
 * var vertices = Polygon.box(20, 20, true);
 * var polygon = new Polygon(vertices);
 * </pre>
 * In this example, passing <code>true</code> to the Polygon.box method means
 * that we will be returned a Vec2List containing only 'weak' Vec2s. Upon
 * passing this Vec2List to the Polygon constructor, all of the Vec2s from
 * that list will be automatically disposed.</p></td></tr><tr><td width="200"><a href="../../nape/geom/Vec2Iterator.html">Vec2Iterator</a></td><td><p>Haxe Iterator<T> compatible iterator over Nape list.</p></td></tr><tr><td width="200"><a href="../../nape/geom/Vec2List.html">Vec2List</a></td><td><p>Nape list of Vec2 type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i &lt; list.length; i++) {
 *     var obj:Vec2 = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i &lt; list.length) {
 *     var obj:Vec2 = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Vec2 = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre></p></td></tr><tr><td width="200"><a href="../../nape/geom/Vec3.html">Vec3</a></td><td><p>A 3 dimensional vector object.
 * <br/><br/>
 * In many instances a Vec3 will be accessible from Nape which is marked
 * as immutable, these cases will be documented and modifying such a Vec3
 * will result in an error.</p></td></tr><tr><td width="200"><a href="../../nape/geom/Winding.html">Winding</a></td><td><p>Enumeration represents the winding of a Polygon.
 * <br/><br/>
 * To appreciate what the winding of a polygon means, think of a polygon who's
 * vertices are the numbers on a clock face.
 *
 * If the vertices are ordered <code>12 -&gt; 1 -&gt; 2 ... -&gt; 12</code>
 * then this polygon is clockwise wound. The reverse order would mean the
 * polygon is wound anticlockwise.</p></td></tr></tbody></table></div></div></body></html>
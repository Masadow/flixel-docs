<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../bootstrap-combined.min.css" rel="stylesheet" /><script type="text/javascript" src="../../jquery-1.9.1.min.js"></script><script type="text/javascript" src="../../bootstrap.min.js"></script><link href="../../styles.css" rel="stylesheet" /><link rel="icon" href="../../favicon.ico" type="image/x-icon"></link><script type="text/javascript" src="../../nav.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["flash"]};</script><title>GeomPoly</title></head><body><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><form class="navbar-search pull-left" id="searchForm"><input id="search" type="text" class="search-query" placeholder="Filter" autocomplete="off"/></form><ul class="nav"><li id="select-platform" class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Platform<b class="caret"></b></a><ul class="dropdown-menu"><li data="all"><a href="#">All Platforms</a></li><li data="flash"><a href="#">flash</a></li></ul></li></ul></div></div><div id="container"><div id="nav"></div><div id="content"><div class="header"><h1><code><span class="directive">class </span><span class="type">nape.geom.GeomPoly</span></code></h1></div><div class="body"><p class="availability">Available on all platforms</p><div class="doc"><p>Polygon class with various geometric methods
 * <br/><br/>
 * This class represents a general Polygon, rather than the Polygon class
 * which is physics shape.
 * <br/><br/>
 * Internally this polygon is stored as a circularly linked list of special
 * vertex types that are exposed via a Vec2 that is lazily constructed whenever
 * necessary to the API.</p></div><h2>Class Fields</h2><div class="platform platform-flash"><a name="get"></a><h3><p><code><span class="keyword">static </span><span class="keyword">function</span> <a href="#get"><span class="identifier">get</span></a>(?vertices:<a class="type" href="../../Dynamic.html">Dynamic</a> = null):<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Allocate GeomPoly from object pool.
     * <br/><br/>
     * The vertices argument is typed Dynamic (<em> in AS3), and is permitted
     * to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
     * <br/><br/>
     * The input will be used to initialise the vertices of the polygon with
     * the head of the polygon pointing to the first vertex in input with vertices
     * inserted in forward order.
     </em>
     * </p><table class="table table-condensed"><tbody><tr><td>vertices</td><td><p>Vertex data to initialise polygon, or null for empty polygon.
    * </p></td></tr><tr><td>returns</td><td><p>New GeomPoly representing input vertex data, allocated from object pool.
* </p></td></tr></tbody></table></div></div><h2>Instance Fields</h2><div class="platform platform-flash"><a name="zpp_disp"></a><h3><p><code><span class="keyword">var</span> <a href="#zpp_disp"><span class="identifier">zpp_disp</span></a>:<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>@private</p></div></div><div class="platform platform-flash"><a name="zpp_inner"></a><h3><p><code><span class="keyword">var</span> <a href="#zpp_inner"><span class="identifier">zpp_inner</span></a>:<a class="type" href="../../zpp_nape/geom/ZPP_GeomPoly.html">ZPP_GeomPoly</a></code></p></h3><div class="doc"><p>@private</p></div></div><div class="platform platform-flash"><a name="zpp_pool"></a><h3><p><code><span class="keyword">var</span> <a href="#zpp_pool"><span class="identifier">zpp_pool</span></a>:<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>@private</p></div></div><div class="platform platform-flash"><a name="new"></a><h3><p><code><span class="keyword">function</span> <a href="#new"><span class="identifier">new</span></a>(?vertices:<a class="type" href="../../Dynamic.html">Dynamic</a> = null):<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Create a new GeomPoly polygon.
     * <br/><br/>
     * The vertices argument is typed Dynamic (<em> in AS3), and is permitted
     * to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
     * <br/><br/>
     * The input will be used to initialise the vertices of the polygon with
     * the head of the polygon pointing to the first vertex in input with vertices
     * inserted in forward order.
     * <br/><br/>
     * You should use the static 'get' method in preference to make use of object pool.
     </em>
     * </p><table class="table table-condensed"><tbody><tr><td>vertices</td><td><p>Vertex data to initialise polygon, or null for empty polygon.
    * </p></td></tr><tr><td>returns</td><td><p>New GeomPoly representing input vertex data.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="area"></a><h3><p><code><span class="keyword">function</span> <a href="#area"><span class="identifier">area</span></a>():<a class="type" href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>Compute area of weakly-simple polygon.
     * <br/><br/>
     * For complex polygons, this function will return an underestimate
     * to the true area.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>The area of the polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="backwardsIterator"></a><h3><p><code><span class="keyword">function</span> <a href="#backwardsIterator"><span class="identifier">backwardsIterator</span></a>():<a class="type" href="../../nape/geom/GeomVertexIterator.html">GeomVertexIterator</a></code></p></h3><div class="doc"><p>Haxe iterator over vertices of polygon.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A Haxe iterator over the vertices of the polygon.
<em>         Iterating in a backwards direction.
</em> </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="bottom"></a><h3><p><code><span class="keyword">function</span> <a href="#bottom"><span class="identifier">bottom</span></a>():<a class="type" href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Find bottom most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A Vec2 representing the bottom most vertex.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="bounds"></a><h3><p><code><span class="keyword">function</span> <a href="#bounds"><span class="identifier">bounds</span></a>():<a class="type" href="../../nape/geom/AABB.html">AABB</a></code></p></h3><div class="doc"><p>Determine bounds of polygon.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A new AABB representing bounds of polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="clear"></a><h3><p><code><span class="keyword">function</span> <a href="#clear"><span class="identifier">clear</span></a>():<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Clear all vertices from polygon.
     * <br/><br/>
     * All of the vertices will be released to the global object pool.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A reference to this polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="contains"></a><h3><p><code><span class="keyword">function</span> <a href="#contains"><span class="identifier">contains</span></a>(point:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>):<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if point is contained in polygon.
     * <br/><br/>
     * Polygon containment is performed with a ray cast through polygon
     * from the vertex and counting the number of intersections. In this
     * way containment will be defined for self-intersecting polygons based
     * on how such a polygon would be rendered with areas of self-intersection
     * treat as being 'outside' the polygon.
     * <br/><br/>
     * This algorithm operates in O(n) time.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>point</td><td><p>The point to test for containment.
    * </p></td></tr><tr><td>returns</td><td><p>True if point is contained in the polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="convexDecomposition"></a><h3><p><code><span class="keyword">function</span> <a href="#convexDecomposition"><span class="identifier">convexDecomposition</span></a>(?delaunay:<a class="type" href="../../Bool.html">Bool</a> = false, ?output:<a class="type" href="../../nape/geom/GeomPolyList.html">GeomPolyList</a> = null):<a class="type" href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></code></p></h3><div class="doc"><p>Produce a decomposition of weakly-simple polygon into convex components.
     * <br/><br/>
     * This algorithm 'should' be 100% robust and has been well test on for
     * example, the output of the Marching Squars utility which produces many
     * degenerate cases of weakly-simple polygons that have not yet broken this
     * algorithm!.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time and will produce no more than
     * 4 times the number of convex poylgons in a minimal decomposition in the
     * worst case scenario.
     * <br/><br/>
     * Vertices may be stripped from the polygon that are found to not be
     * necessary as part of making this algorithm robust.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>delaunay</td><td><p>This algorithm first performs a triangulation, if this field
    *                 is true, then this triangulation will be made delaunay and may
    *                 produce better convex polygons resultanly (default false).
    * </p></td></tr><tr><td>output</td><td><p>If supplied, polygons will be appended to this list via 'add'
    *        instead of a new list being constructed.
    * </p></td></tr><tr><td>returns</td><td><p>A Nape list of GeomPoly's defining the decomposition.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="copy"></a><h3><p><code><span class="keyword">function</span> <a href="#copy"><span class="identifier">copy</span></a>():<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Copy this polygon.
     * <br/><br/>
     * The copy will have its vertices in the same order as 'this' polygon.
     * It will also have its current vertex at head, as the same vertex
     * this polygon has.
     * <br/><br/>
     * This polygon will not be modified in any way.
     * <pre>
     * poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                (head)
     <em>
     * poly2 = poly.copy();
     </em>
     * poly2 := -> A' &lt;-> B' &lt;-> C' &lt;-> D' &lt;-> E' &lt;-
     *                  (head)
     * </pre>
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>The new GeomPoly representing the copy.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="current"></a><h3><p><code><span class="keyword">function</span> <a href="#current"><span class="identifier">current</span></a>():<a class="type" href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Current vertex at head of polygon.
     * <br/><br/>
     * The current vertex will not be changed by this access.
     * <br/><br/>
     * This function returns a Vec2 which will be intrinsically tied
     * to the values of the internal vertex so that modifications to
     * this Vec2 will be reflected in the vertex of the polygon.
     * <br/><br/>
     * If invoked again with the head of the polygon pointing to the
     * same vertex, then the same Vec2 will be returned; this Vec2 is
     * not able to be disposed of.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A Vec2 representing the current vertex of polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="cut"></a><h3><p><code><span class="keyword">function</span> <a href="#cut"><span class="identifier">cut</span></a>(start:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>, end:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>, ?boundedStart:<a class="type" href="../../Bool.html">Bool</a> = false, ?boundedEnd:<a class="type" href="../../Bool.html">Bool</a> = false, ?output:<a class="type" href="../../nape/geom/GeomPolyList.html">GeomPolyList</a> = null):<a class="type" href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></code></p></h3><div class="doc"><p>Cut simple polygon with line.
     * <br/><br/>
     * The result of this operation will be a list of new GeomPoly representing
     * the connected regions of the polygon after an imaginary cut is made.
     * <pre>
     * (Result of cut assuming
     *  boundedStart = true)       <em>
     *   /&#92;    _             /&#92;   / &#92;
     *  /  &#92;  / &#92;           /  &#92; '---'
     * / o--&#92;/---&#92;-->  =>  /    &#92;,---,
     * &#92;</em><strong></strong><strong></strong>/         &#92;<strong></strong><strong></strong>_/
     * </pre>
     * This algorithm runs in average case O(n.log(n)) time and worst case O(n^2).
     * For convex polygons, this algorithm runs in guaranteed O(n) time.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>start</td><td><p>The start point for line segment
    * </p></td></tr><tr><td>end</td><td><p>The end point for line segment.
    * </p></td></tr><tr><td>boundedStart</td><td><p>If true, then the cut will not extend
    *                     beyond the start of the line segment.
    *                     (default false)
    * </p></td></tr><tr><td>boundedEnd</td><td><p>If true, then the cut will not extend
  *                     beyond the end of the line segment.
  *                     (default false)
  * </p></td></tr><tr><td>output</td><td><p>A GeomPolyList to append results to if supplied,
    *               otherwise a new list is created (default null)
    * </p></td></tr><tr><td>returns</td><td><p>A list of GeomPoly representing the result of the cut.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="dispose"></a><h3><p><code><span class="keyword">function</span> <a href="#dispose"><span class="identifier">dispose</span></a>():<a class="type" href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Release this GeomPoly to global object pool.
     * <br/><br/>
     * Once disposed this GeomPoly will be accessible to Nape internals for re-allocation
     * and should not be touched (Good practice would be to set any references to this
     * GeomPoly to null to help ensure this).
     * <br/><br/>
     * In debug mode, should you attempt to access this GeomPoly after disposal
     * and the GeomPoly is still in the object pool, you will be given an Error.
     * The object pool operates on a First-In-Last-Out principal in debug mode to help
     * catch these sort of errors.
     * </p></div></div><div class="platform platform-flash"><a name="empty"></a><h3><p><code><span class="keyword">function</span> <a href="#empty"><span class="identifier">empty</span></a>():<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if polygon is empty.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>True if polygon is empty.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="erase"></a><h3><p><code><span class="keyword">function</span> <a href="#erase"><span class="identifier">erase</span></a>(count:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Erase count number of elements
     * <br/><br/>
     * For positive values of count, this is equivalent to successive
     * unshift operations.
     * <br/><br/>
     * For negative values of count, this is equivalent to successive
     * pop operations.
     * <pre>
     * poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-> F &lt;-> G &lt;-
     *                (head)
     <em>
     * poly.erase(2);
     </em>
     * poly := -> A &lt;-> D &lt;-> E &lt;-> F &lt;-> G &lt;-
     *                (head)
     <em>
     * poly.erase(-3);
     </em>
     * poly := -> E &lt;-> F &lt;-
     *                (head)
     * </pre>
     * In this case that the specified number of elements to erase is
     * greater than the size of the polygon, the method will simply
     * terminate with the polygon being empty.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>count</td><td><p>The number of vertices to erase, with sign indicating
    *              the direction for erasing.
    * </p></td></tr><tr><td>returns</td><td><p>A reference to this polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="forwardIterator"></a><h3><p><code><span class="keyword">function</span> <a href="#forwardIterator"><span class="identifier">forwardIterator</span></a>():<a class="type" href="../../nape/geom/GeomVertexIterator.html">GeomVertexIterator</a></code></p></h3><div class="doc"><p>Haxe iterator over vertices of polygon.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A Haxe iterator over the vertices of the polygon.
<em>         Iterating in a forward direction.
</em> </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="inflate"></a><h3><p><code><span class="keyword">function</span> <a href="#inflate"><span class="identifier">inflate</span></a>(inflation:<a class="type" href="../../Float.html">Float</a>):<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Inflate/Deflate polygon.
     * <br/><br/>
     * This algorithm does not attempt to deal with any self-intersections which may
     * result from the process. Gaps are joined with a miter joint.
     * <br/><br/>
     * This algorithm will work for self-intersecting polygons, though the results
     * may not be what you expect; some parts will be inflated, and some deflated
     * depending on the local winding. You should probably avoid using this on
     * self-intersecting polygons.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>inflation</td><td><p>The number of pixels to inflate polygon by. To deflate
    *                  use a negative value.
    * </p></td></tr><tr><td>returns</td><td><p>The inflated polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="isClockwise"></a><h3><p><code><span class="keyword">function</span> <a href="#isClockwise"><span class="identifier">isClockwise</span></a>():<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if polygon is clockwise wound.
     * <br/><br/>
     * This is equivalent to <code>poly.winding() == Winding.CLOCKWISE</code>.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>True if polygon is clockwise wound.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="isConvex"></a><h3><p><code><span class="keyword">function</span> <a href="#isConvex"><span class="identifier">isConvex</span></a>():<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if weakly-simple polygon is convex.
     * <br/><br/>
     * This algorithm assumes that the polygon is weakly-simple. Otherwise it may
     * fail (It is very easy to construct a self intersecting polygon which
     * will return True for isConvex()).
     * <br/><br/>
     * You may wish to instead use <code>isSimple() &amp;&amp; isConvex()</code> if
     * you cannot be sure of the polygon being simple, noting that this will
     * of course return false in the case of a weakly-simple polygon.
     * <pre>
     *  <strong></strong><em>
     * |     |
     * |     |  &lt;-- convex
     * |</em><strong><em>/
     *  </em><em>
     * |  &#92;</em></strong>
     * |     /  &lt;-- concave
     * |<strong></strong>/
     * </pre>
     * This algorithm operates in O(n) time.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>True if polygon is found to be convex.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="isDegenerate"></a><h3><p><code><span class="keyword">function</span> <a href="#isDegenerate"><span class="identifier">isDegenerate</span></a>():<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if weakly-simple polygon is degenerate.
     * <br/><br/>
     * Degeneracy is determined by having a zero area, if polygon is complex,
     * then this function may report degeneracy erroneously.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>True if polygon is degenerate.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="isMonotone"></a><h3><p><code><span class="keyword">function</span> <a href="#isMonotone"><span class="identifier">isMonotone</span></a>():<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if polygon is y-monotone.
     * <br/><br/>
     * To be classed as y-monotone, the polygon must be such that any horizontal
     * line intersects the polygon in at most 2 intersections.
     * <pre>
     *  <strong><em>
     * |   |
     * |   |  &lt;-- y-monotone
     * |</em></strong>|
     <em>
     * |&#92;
     * | &#92;/|  &lt;-- not y-monotone, offending vertex at bottom of the V.
     * |___|
     * </pre>
     * This algorithm operates in O(n) time.
     </em>
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>True if polygon is y-monotone.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="isSimple"></a><h3><p><code><span class="keyword">function</span> <a href="#isSimple"><span class="identifier">isSimple</span></a>():<a class="type" href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if polygon is strictly simple.
     * <br/><br/>
     * By strict simplicity, we refer to not permitting 'glancing'
     * self intersections (where boundary of polygon 'touches' but does not
     * pass through another area of the polygon's boundary). This property
     * is instead referred to as being 'weakly simple' for which there is no
     * easy test!
     * <pre>
     *  <strong></strong><strong><em>
     * |   </em><em>  |  &lt;-- strictly simple polygon.
     * |   &#92; &#92;</em>|
     *  &#92;</strong>/
     *  <strong></strong><strong><em>
     * |   |   |
     * |  /</em>&#92;  | &lt;-- weakly simple polygon.
     *  &#92;</strong><strong><em>/
     *  </em></strong><em>
     * | </em><em>/
     *  X</em>  <strong>   &lt;-- complex polygon.
     * |  &#92;/  &#92;
     * &#92;</strong>/&#92;__|
     * </pre>
     * This algorithm operates in O(n.log(n)) time.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>True if polygon is strictly simple.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="iterator"></a><h3><p><code><span class="keyword">function</span> <a href="#iterator"><span class="identifier">iterator</span></a>():<a class="type" href="../../nape/geom/GeomVertexIterator.html">GeomVertexIterator</a></code></p></h3><div class="doc"><p>Haxe iterator over vertices of polygon.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A Haxe iterator over the vertices of the polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="left"></a><h3><p><code><span class="keyword">function</span> <a href="#left"><span class="identifier">left</span></a>():<a class="type" href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Find left most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A Vec2 representing the left most vertex.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="monotoneDecomposition"></a><h3><p><code><span class="keyword">function</span> <a href="#monotoneDecomposition"><span class="identifier">monotoneDecomposition</span></a>(?output:<a class="type" href="../../nape/geom/GeomPolyList.html">GeomPolyList</a> = null):<a class="type" href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></code></p></h3><div class="doc"><p>Produce a decomposition of weakly-simple polygon into monotone components.
     * <br/><br/>
     * This algorithm 'should' be 100% robust and has been well tested on for
     * example, the output of the Marching Squares utility which produces many
     * degenerate cases of weakly-simple polygons that have not yet broken this
     * algorithm!.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time and may strip vertices from
     * the polygon in degenerate cases where vertex is not needed to define the
     * polygon.
     * <br/><br/>
     * This algorithm is an improved version of the one presented in: Mark de
     * Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf.
     * Computational Geometry: Algorithms and Applications. Springer-Verlag,
     * Berlin, 1997.
    
     * </p><table class="table table-condensed"><tbody><tr><td>output</td><td><p>If supplied, polygons will be appended to this list via 'add'
    *        instead of a new list being constructed.
    * </p></td></tr><tr><td>returns</td><td><p>A Nape list of GeomPoly's defining the decomposition.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="pop"></a><h3><p><code><span class="keyword">function</span> <a href="#pop"><span class="identifier">pop</span></a>():<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Pop vertex from polygon.
     * <br/><br/>
     * Pop the current vertex at head of polygon, retreating the 'current'
     * vertex to point to the previous vertex in polygon. This inner vertex
     * will be released to the global object pool.
     * <br/><br/>
     * In this way a pop which follows a push will act to reset the push.
     * <pre>
     * poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                (head)
     <em>
     * poly.pop();
     </em>
     * poly := -> A &lt;-> C &lt;-> D &lt;-> E &lt;-
     *          (head)
     * </pre>
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A reference to this polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="push"></a><h3><p><code><span class="keyword">function</span> <a href="#push"><span class="identifier">push</span></a>(vertex:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>):<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Push vertex to polygon.
     * <br/><br/>
     * A vertex will be allocated from a global object pool, and initialised
     * with the values of the given Vec2.
     * <br/><br/>
     * This vertex will be inserted after the current head, and the head
     * advanced to the newly inserted vertex, in this way successive pushes
     * will insert elements in order.
     * <br/><br/>
     * Note that the Vec2 supplied as argument is only used to initialise the
     * inner Vertex.
     * <pre>
     * poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                (head)
     <em>
     * poly.push(X);
     </em>
     * poly := -> A &lt;-> B &lt;-> X &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                      (head)
     * </pre>
     *
     * </p><table class="table table-condensed"><tbody><tr><td>vertex</td><td><p>The Vec2 to be used in initialising the inner vertex.
    * </p></td></tr><tr><td>returns</td><td><p>A reference to this polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="right"></a><h3><p><code><span class="keyword">function</span> <a href="#right"><span class="identifier">right</span></a>():<a class="type" href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Find right most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A Vec2 representing the right most vertex.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="shift"></a><h3><p><code><span class="keyword">function</span> <a href="#shift"><span class="identifier">shift</span></a>():<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Shift vertex from polygon.
     * <br/><br/>
     * Shift the current vertex at head of polygon, advancing the 'current'
     * vertex to point to the next vertex in polygon. This inner vertex
     * will be released to the global object pool.
     * <br/><br/>
     * In this way a shift which follows an unshift will act to reset the
     * unshift operation.
     * <pre>
     * poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                (head)
     <em>
     * poly.shift();
     </em>
     * poly := -> A &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                (head)
     * </pre>
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A reference to this polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="simpleDecomposition"></a><h3><p><code><span class="keyword">function</span> <a href="#simpleDecomposition"><span class="identifier">simpleDecomposition</span></a>(?output:<a class="type" href="../../nape/geom/GeomPolyList.html">GeomPolyList</a> = null):<a class="type" href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></code></p></h3><div class="doc"><p>Produce a decomposition of complex polygon into simple components.
     * <br/><br/>
     * WARNING: This method is 'not' 100% robust. It may fail!
     * <br/><br/>
     * Produce a decomposition of a self intersecting, complex polygon into
     * a set of weakly-simple components.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time and is based on the
     * Bentley-Ottmann algorithm.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>output</td><td><p>If supplied, polygons will be appended to this list via 'add'
    *        instead of a new list being constructed.
    * </p></td></tr><tr><td>returns</td><td><p>A Nape list of GeomPoly's representing the decomposition.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="simplify"></a><h3><p><code><span class="keyword">function</span> <a href="#simplify"><span class="identifier">simplify</span></a>(epsilon:<a class="type" href="../../Float.html">Float</a>):<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Simplify polygon.
     * <br/><br/>
     * Simplification is performed with an implementation of the Ramer-Douglas-Peucker
     * algorithm. The output polygon is formed via subset of the vertices in
     * the input polygon such that any discarded vertex is at most 'epsilon' pixels
     * away from the local output polygon.
     * <br/><br/>
     * This algorithm works on both simple and complex polygons, but please note
     * that this algorithm makes no guarantees on a simple polygon remaining simple
     * after simplification. This should not generally be a problem unless the epsilon
     * value is large with respect to the size of the features on the polygon.
     * <br/><br/>
     * Many of the geometric algorithms will mark vertices as important, such that
     * they will be guaranteed to exist after simplification (Such as preventing
     * gaps from opening up in marching squares when simplifying output polygons).
     * <br/><br/>
     * The average runtime of this algorithm is O(n.log(n)). This algorithm is
     * not stable in the sense that adding a new vertex to the polygon may drastically
     * change the result of simplifying the polygon.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>epsilon</td><td><p>The distance from polygon at which vertices are ignored.
    * </p></td></tr><tr><td>returns</td><td><p>A new GeomPoly representing the result of the simplification.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="size"></a><h3><p><code><span class="keyword">function</span> <a href="#size"><span class="identifier">size</span></a>():<a class="type" href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>Determine number of vertices in polygon
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>The number of vertices.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="skipBackwards"></a><h3><p><code><span class="keyword">function</span> <a href="#skipBackwards"><span class="identifier">skipBackwards</span></a>(times:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Advance head of polygon backwards.
     * <br/><br/>
     * The current head of polygon will be moved backwards
     * the given number of times, with a negative value
     * being equivalent to performing a forwards advance.
     * <br/><br/>
     * <code>poly.skip<em>backwards(times)</code> is equivalent to
     * <code>poly.skip</em>forwards(-times)</code>
     * <pre>
     * poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                (head)
     <em>
     * poly.skipBackwards(2);
     </em>
     * poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                                  (head)
     * </pre>
     *
     * @params times The number of times to advance head backwards.
     *               This value can be negative indicating a forwards
     *               advance.
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A reference to this polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="skipForward"></a><h3><p><code><span class="keyword">function</span> <a href="#skipForward"><span class="identifier">skipForward</span></a>(times:<a class="type" href="../../Int.html">Int</a>):<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Advance head of polygon forward.
     * <br/><br/>
     * The current head of polygon will be moved forwards
     * the given number of times, with a negative value
     * being equivalent to performing a backwards advance.
     * <br/><br/>
     * <code>poly.skip<em>forwards(times)</code> is equivalent to
     * <code>poly.skip</em>backwards(-times)</code>
     * <pre>
     * poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                (head)
     <em>
     * poly.skipForwards(2);
     </em>
     * poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                            (head)
     * </pre>
     *
     * @params times The number of times to advance head forward.
     *               This value can be negative indicating a backwards
     *               advance.
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A reference to this polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="toString"></a><h3><p><code><span class="keyword">function</span> <a href="#toString"><span class="identifier">toString</span></a>():<a class="type" href="../../String.html">String</a></code></p></h3><div class="doc"><p>@private</p></div></div><div class="platform platform-flash"><a name="top"></a><h3><p><code><span class="keyword">function</span> <a href="#top"><span class="identifier">top</span></a>():<a class="type" href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Find top most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>A Vec2 representing the top most vertex.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="transform"></a><h3><p><code><span class="keyword">function</span> <a href="#transform"><span class="identifier">transform</span></a>(matrix:<a class="type" href="../../nape/geom/Mat23.html">Mat23</a>):<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Transform polygon by given matrix.
     * <br/><br/>
     * Any transformation (not just equiorthogonal ones) are permitted, though
     * a transformation that causes polygon to be come degenerate is a bit
     * pointless.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>matrix</td><td><p>The matrix to transform polygon by.
    * </p></td></tr><tr><td>returns</td><td><p>A reference to this polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="triangularDecomposition"></a><h3><p><code><span class="keyword">function</span> <a href="#triangularDecomposition"><span class="identifier">triangularDecomposition</span></a>(?delaunay:<a class="type" href="../../Bool.html">Bool</a> = false, ?output:<a class="type" href="../../nape/geom/GeomPolyList.html">GeomPolyList</a> = null):<a class="type" href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></code></p></h3><div class="doc"><p>Produce a decomposition of weakly-simple polygon into triangles.
     * <br/><br/>
     * This algorithm 'should' be 100% robust and has been well test on for
     * example, the output of the Marching Squars utility which produces many
     * degenerate cases of weakly-simple polygons that have not yet broken this
     * algorithm!.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time.
     * <br/><br/>
     * Vertices may be stripped from the polygon that are found to not be
     * necessary as part of making this algorithm robust.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>delaunay</td><td><p>If true, then an O(n^2) pass will be made to mutate the original
    *                 triangulation to push it into a delanuay triangulation. (default false)
    * </p></td></tr><tr><td>output</td><td><p>If supplied, polygons will be appended to this list via 'add'
    *        instead of a new list being constructed.
    * </p></td></tr><tr><td>returns</td><td><p>A Nape list of GeomPoly's defining the decomposition.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="unshift"></a><h3><p><code><span class="keyword">function</span> <a href="#unshift"><span class="identifier">unshift</span></a>(vertex:<a class="type" href="../../nape/geom/Vec2.html">Vec2</a>):<a class="type" href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Unshift vertex to polygon.
     * <br/><br/>
     * A vertex will be allocated from a global object pool, and initialised
     * with the values of the given Vec2.
     * <br/><br/>
     * This vertex will be inserted before the current head, and the head
     * retreated to the newly inserted vertex, in this way successive unshifts
     * will insert elements in the expected reverse order.
     * <br/><br/>
     * Note that the Vec2 supplied as argument is only used to initialise the
     * inner Vertex.
     * <pre>
     * poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                (head)
     <em>
     * poly.unshift(X);
     </em>
     * poly := -> A &lt;-> X &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-
     *                (head)
     * </pre>
     *
     * </p><table class="table table-condensed"><tbody><tr><td>vertex</td><td><p>The Vec2 to be used in initialising the inner vertex.
    * </p></td></tr><tr><td>returns</td><td><p>A reference to this polygon.
* </p></td></tr></tbody></table></div></div><div class="platform platform-flash"><a name="winding"></a><h3><p><code><span class="keyword">function</span> <a href="#winding"><span class="identifier">winding</span></a>():<a class="type" href="../../nape/geom/Winding.html">Winding</a></code></p></h3><div class="doc"><p>Compute the winding order for this polygon.
     * <br/><br/>
     * The winding order can be conceptualised by thinking of an analog
     * clock face, if your polygon is the numbers on the clock then a
     * clockwise winding would have your polygon's vertices in numerical
     * order.
     * <br/><br/>
     * In the case of a non-simple polygon with self intersections then the
     * winding order is decided by how 'much' of the polygon is locally
     * clockwise wound, and how much is locally anti-clockwise wound.
     * <br/>
     * (Think of a figure 8 style polygon where one loop is larger than the
     * other. This larger loop will dictate the winding of the polygon.)
     * <br/><br/>
     * If no winding can be computed, then <code>Winding.UNDEFINED</code>
     * will be returned.
     *
     * </p><table class="table table-condensed"><tbody><tr><td>returns</td><td><p>The winding of the polygon.
* </p></td></tr></tbody></table></div></div></div></div></div></body></html>